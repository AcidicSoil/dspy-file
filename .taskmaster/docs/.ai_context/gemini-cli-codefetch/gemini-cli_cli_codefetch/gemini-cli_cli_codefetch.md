Project Structure:
├── index.ts
├── package.json
├── src
│   ├── commands
│   │   ├── extensions
│   │   │   ├── disable.ts
│   │   │   ├── enable.ts
│   │   │   ├── examples
│   │   │   ├── install.test.ts
│   │   │   ├── install.ts
│   │   │   ├── link.ts
│   │   │   ├── list.ts
│   │   │   ├── new.test.ts
│   │   │   ├── new.ts
│   │   │   ├── uninstall.test.ts
│   │   │   ├── uninstall.ts
│   │   │   └── update.ts
│   │   ├── extensions.tsx
│   │   ├── mcp
│   │   │   ├── add.test.ts
│   │   │   ├── add.ts
│   │   │   ├── list.test.ts
│   │   │   ├── list.ts
│   │   │   ├── remove.test.ts
│   │   │   └── remove.ts
│   │   ├── mcp.test.ts
│   │   └── mcp.ts
│   ├── config
│   │   ├── auth.test.ts
│   │   ├── auth.ts
│   │   ├── config.integration.test.ts
│   │   ├── config.test.ts
│   │   ├── config.ts
│   │   ├── extension.test.ts
│   │   ├── extension.ts
│   │   ├── extensions
│   │   │   ├── extensionEnablement.test.ts
│   │   │   ├── extensionEnablement.ts
│   │   │   ├── github.test.ts
│   │   │   ├── github.ts
│   │   │   ├── github_fetch.ts
│   │   │   ├── update.test.ts
│   │   │   ├── update.ts
│   │   │   ├── variableSchema.ts
│   │   │   ├── variables.test.ts
│   │   │   └── variables.ts
│   │   ├── keyBindings.test.ts
│   │   ├── keyBindings.ts
│   │   ├── policy-engine.integration.test.ts
│   │   ├── policy.test.ts
│   │   ├── policy.ts
│   │   ├── sandboxConfig.ts
│   │   ├── settings.test.ts
│   │   ├── settings.ts
│   │   ├── settingsSchema.test.ts
│   │   ├── settingsSchema.ts
│   │   ├── trustedFolders.test.ts
│   │   └── trustedFolders.ts
│   ├── core
│   │   ├── auth.ts
│   │   ├── initializer.ts
│   │   └── theme.ts
│   ├── gemini.test.tsx
│   ├── gemini.tsx
│   ├── nonInteractiveCli.test.ts
│   ├── nonInteractiveCli.ts
│   ├── nonInteractiveCliCommands.ts
│   ├── patches
│   │   └── is-in-ci.ts
│   ├── services
│   │   ├── BuiltinCommandLoader.test.ts
│   │   ├── BuiltinCommandLoader.ts
│   │   ├── CommandService.test.ts
│   │   ├── CommandService.ts
│   │   ├── FileCommandLoader.test.ts
│   │   ├── FileCommandLoader.ts
│   │   ├── McpPromptLoader.test.ts
│   │   ├── McpPromptLoader.ts
│   │   ├── prompt-processors
│   │   │   ├── argumentProcessor.test.ts
│   │   │   ├── argumentProcessor.ts
│   │   │   ├── atFileProcessor.test.ts
│   │   │   ├── atFileProcessor.ts
│   │   │   ├── injectionParser.test.ts
│   │   │   ├── injectionParser.ts
│   │   │   ├── shellProcessor.test.ts
│   │   │   ├── shellProcessor.ts
│   │   │   └── types.ts
│   │   └── types.ts
│   ├── test-utils
│   │   ├── createExtension.ts
│   │   ├── customMatchers.ts
│   │   ├── mockCommandContext.test.ts
│   │   ├── mockCommandContext.ts
│   │   └── render.tsx
│   ├── ui
│   │   ├── App.test.tsx
│   │   ├── App.tsx
│   │   ├── AppContainer.test.tsx
│   │   ├── AppContainer.tsx
│   │   ├── IdeIntegrationNudge.tsx
│   │   ├── auth
│   │   │   ├── AuthDialog.test.tsx
│   │   │   ├── AuthDialog.tsx
│   │   │   ├── AuthInProgress.tsx
│   │   │   └── useAuth.ts
│   │   ├── colors.ts
│   │   ├── commands
│   │   │   ├── aboutCommand.test.ts
│   │   │   ├── aboutCommand.ts
│   │   │   ├── authCommand.test.ts
│   │   │   ├── authCommand.ts
│   │   │   ├── bugCommand.test.ts
│   │   │   ├── bugCommand.ts
│   │   │   ├── chatCommand.test.ts
│   │   │   ├── chatCommand.ts
│   │   │   ├── clearCommand.test.ts
│   │   │   ├── clearCommand.ts
│   │   │   ├── compressCommand.test.ts
│   │   │   ├── compressCommand.ts
│   │   │   ├── copyCommand.test.ts
│   │   │   ├── copyCommand.ts
│   │   │   ├── corgiCommand.test.ts
│   │   │   ├── corgiCommand.ts
│   │   │   ├── directoryCommand.test.tsx
│   │   │   ├── directoryCommand.tsx
│   │   │   ├── docsCommand.test.ts
│   │   │   ├── docsCommand.ts
│   │   │   ├── editorCommand.test.ts
│   │   │   ├── editorCommand.ts
│   │   │   ├── extensionsCommand.test.ts
│   │   │   ├── extensionsCommand.ts
│   │   │   ├── helpCommand.test.ts
│   │   │   ├── helpCommand.ts
│   │   │   ├── ideCommand.test.ts
│   │   │   ├── ideCommand.ts
│   │   │   ├── initCommand.test.ts
│   │   │   ├── initCommand.ts
│   │   │   ├── mcpCommand.test.ts
│   │   │   ├── mcpCommand.ts
│   │   │   ├── memoryCommand.test.ts
│   │   │   ├── memoryCommand.ts
│   │   │   ├── modelCommand.test.ts
│   │   │   ├── modelCommand.ts
│   │   │   ├── permissionsCommand.test.ts
│   │   │   ├── permissionsCommand.ts
│   │   │   ├── privacyCommand.test.ts
│   │   │   ├── privacyCommand.ts
│   │   │   ├── profileCommand.ts
│   │   │   ├── quitCommand.test.ts
│   │   │   ├── quitCommand.ts
│   │   │   ├── restoreCommand.test.ts
│   │   │   ├── restoreCommand.ts
│   │   │   ├── settingsCommand.test.ts
│   │   │   ├── settingsCommand.ts
│   │   │   ├── setupGithubCommand.test.ts
│   │   │   ├── setupGithubCommand.ts
│   │   │   ├── statsCommand.test.ts
│   │   │   ├── statsCommand.ts
│   │   │   ├── terminalSetupCommand.test.ts
│   │   │   ├── terminalSetupCommand.ts
│   │   │   ├── themeCommand.test.ts
│   │   │   ├── themeCommand.ts
│   │   │   ├── toolsCommand.test.ts
│   │   │   ├── toolsCommand.ts
│   │   │   ├── types.ts
│   │   │   └── vimCommand.ts
│   │   ├── components
│   │   │   ├── AboutBox.tsx
│   │   │   ├── AnsiOutput.test.tsx
│   │   │   ├── AnsiOutput.tsx
│   │   │   ├── AppHeader.tsx
│   │   │   ├── AsciiArt.ts
│   │   │   ├── AutoAcceptIndicator.tsx
│   │   │   ├── CliSpinner.tsx
│   │   │   ├── Composer.test.tsx
│   │   │   ├── Composer.tsx
│   │   │   ├── ConfigInitDisplay.tsx
│   │   │   ├── ConsentPrompt.test.tsx
│   │   │   ├── ConsentPrompt.tsx
│   │   │   ├── ConsoleSummaryDisplay.tsx
│   │   │   ├── ContextSummaryDisplay.test.tsx
│   │   │   ├── ContextSummaryDisplay.tsx
│   │   │   ├── ContextUsageDisplay.tsx
│   │   │   ├── DebugProfiler.test.tsx
│   │   │   ├── DebugProfiler.tsx
│   │   │   ├── DetailedMessagesDisplay.tsx
│   │   │   ├── DialogManager.tsx
│   │   │   ├── EditorSettingsDialog.tsx
│   │   │   ├── ExitWarning.tsx
│   │   │   ├── FolderTrustDialog.test.tsx
│   │   │   ├── FolderTrustDialog.tsx
│   │   │   ├── Footer.test.tsx
│   │   │   ├── Footer.tsx
│   │   │   ├── GeminiRespondingSpinner.tsx
│   │   │   ├── Header.test.tsx
│   │   │   ├── Header.tsx
│   │   │   ├── Help.test.tsx
│   │   │   ├── Help.tsx
│   │   │   ├── HistoryItemDisplay.test.tsx
│   │   │   ├── HistoryItemDisplay.tsx
│   │   │   ├── IdeTrustChangeDialog.test.tsx
│   │   │   ├── IdeTrustChangeDialog.tsx
│   │   │   ├── InputPrompt.test.tsx
│   │   │   ├── InputPrompt.tsx
│   │   │   ├── LoadingIndicator.test.tsx
│   │   │   ├── LoadingIndicator.tsx
│   │   │   ├── LoopDetectionConfirmation.test.tsx
│   │   │   ├── LoopDetectionConfirmation.tsx
│   │   │   ├── MainContent.tsx
│   │   │   ├── MemoryUsageDisplay.tsx
│   │   │   ├── ModelDialog.test.tsx
│   │   │   ├── ModelDialog.tsx
│   │   │   ├── ModelStatsDisplay.test.tsx
│   │   │   ├── ModelStatsDisplay.tsx
│   │   │   ├── Notifications.tsx
│   │   │   ├── PermissionsModifyTrustDialog.test.tsx
│   │   │   ├── PermissionsModifyTrustDialog.tsx
│   │   │   ├── PrepareLabel.test.tsx
│   │   │   ├── PrepareLabel.tsx
│   │   │   ├── ProQuotaDialog.test.tsx
│   │   │   ├── ProQuotaDialog.tsx
│   │   │   ├── QueuedMessageDisplay.test.tsx
│   │   │   ├── QueuedMessageDisplay.tsx
│   │   │   ├── QuittingDisplay.tsx
│   │   │   ├── SessionSummaryDisplay.test.tsx
│   │   │   ├── SessionSummaryDisplay.tsx
│   │   │   ├── SettingsDialog.test.tsx
│   │   │   ├── SettingsDialog.tsx
│   │   │   ├── ShellConfirmationDialog.test.tsx
│   │   │   ├── ShellConfirmationDialog.tsx
│   │   │   ├── ShellInputPrompt.tsx
│   │   │   ├── ShellModeIndicator.tsx
│   │   │   ├── ShowMoreLines.tsx
│   │   │   ├── StatsDisplay.test.tsx
│   │   │   ├── StatsDisplay.tsx
│   │   │   ├── SuggestionsDisplay.tsx
│   │   │   ├── ThemeDialog.test.tsx
│   │   │   ├── ThemeDialog.tsx
│   │   │   ├── Tips.tsx
│   │   │   ├── ToolStatsDisplay.test.tsx
│   │   │   ├── ToolStatsDisplay.tsx
│   │   │   ├── UpdateNotification.tsx
│   │   │   ├── WorkspaceMigrationDialog.tsx
│   │   │   ├── __snapshots__
│   │   │   │   ├── Footer.test.tsx.snap
│   │   │   │   ├── HistoryItemDisplay.test.tsx.snap
│   │   │   │   ├── IDEContextDetailDisplay.test.tsx.snap
│   │   │   │   ├── InputPrompt.test.tsx.snap
│   │   │   │   ├── LoadingIndicator.test.tsx.snap
│   │   │   │   ├── LoopDetectionConfirmation.test.tsx.snap
│   │   │   │   ├── ModelStatsDisplay.test.tsx.snap
│   │   │   │   ├── PrepareLabel.test.tsx.snap
│   │   │   │   ├── SessionSummaryDisplay.test.tsx.snap
│   │   │   │   ├── SettingsDialog.test.tsx.snap
│   │   │   │   ├── ShellConfirmationDialog.test.tsx.snap
│   │   │   │   ├── StatsDisplay.test.tsx.snap
│   │   │   │   ├── ThemeDialog.test.tsx.snap
│   │   │   │   └── ToolStatsDisplay.test.tsx.snap
│   │   │   ├── messages
│   │   │   │   ├── CompressionMessage.test.tsx
│   │   │   │   ├── CompressionMessage.tsx
│   │   │   │   ├── DiffRenderer.test.tsx
│   │   │   │   ├── DiffRenderer.tsx
│   │   │   │   ├── ErrorMessage.tsx
│   │   │   │   ├── GeminiMessage.tsx
│   │   │   │   ├── GeminiMessageContent.tsx
│   │   │   │   ├── InfoMessage.tsx
│   │   │   │   ├── ToolConfirmationMessage.test.tsx
│   │   │   │   ├── ToolConfirmationMessage.tsx
│   │   │   │   ├── ToolGroupMessage.test.tsx
│   │   │   │   ├── ToolGroupMessage.tsx
│   │   │   │   ├── ToolMessage.test.tsx
│   │   │   │   ├── ToolMessage.tsx
│   │   │   │   ├── UserMessage.tsx
│   │   │   │   ├── UserShellMessage.tsx
│   │   │   │   ├── WarningMessage.tsx
│   │   │   ├── shared
│   │   │   │   ├── BaseSelectionList.test.tsx
│   │   │   │   ├── BaseSelectionList.tsx
│   │   │   │   ├── DescriptiveRadioButtonSelect.test.tsx
│   │   │   │   ├── DescriptiveRadioButtonSelect.tsx
│   │   │   │   ├── EnumSelector.test.tsx
│   │   │   │   ├── EnumSelector.tsx
│   │   │   │   ├── MaxSizedBox.test.tsx
│   │   │   │   ├── MaxSizedBox.tsx
│   │   │   │   ├── RadioButtonSelect.test.tsx
│   │   │   │   ├── RadioButtonSelect.tsx
│   │   │   │   ├── ScopeSelector.tsx
│   │   │   │   ├── text-buffer.test.ts
│   │   │   │   ├── text-buffer.ts
│   │   │   │   ├── vim-buffer-actions.test.ts
│   │   │   │   └── vim-buffer-actions.ts
│   │   │   └── views
│   │   │       ├── ChatList.test.tsx
│   │   │       ├── ChatList.tsx
│   │   │       ├── ExtensionsList.test.tsx
│   │   │       ├── ExtensionsList.tsx
│   │   │       ├── McpStatus.test.tsx
│   │   │       ├── McpStatus.tsx
│   │   │       ├── ToolsList.test.tsx
│   │   │       ├── ToolsList.tsx
│   │   ├── constants.ts
│   │   ├── contexts
│   │   │   ├── AppContext.tsx
│   │   │   ├── ConfigContext.tsx
│   │   │   ├── KeypressContext.test.tsx
│   │   │   ├── KeypressContext.tsx
│   │   │   ├── OverflowContext.tsx
│   │   │   ├── SessionContext.test.tsx
│   │   │   ├── SessionContext.tsx
│   │   │   ├── SettingsContext.tsx
│   │   │   ├── ShellFocusContext.tsx
│   │   │   ├── StreamingContext.tsx
│   │   │   ├── UIActionsContext.tsx
│   │   │   ├── UIStateContext.tsx
│   │   │   └── VimModeContext.tsx
│   │   ├── editors
│   │   │   └── editorSettingsManager.ts
│   │   ├── hooks
│   │   │   ├── atCommandProcessor.test.ts
│   │   │   ├── atCommandProcessor.ts
│   │   │   ├── keyToAnsi.ts
│   │   │   ├── shellCommandProcessor.test.ts
│   │   │   ├── shellCommandProcessor.ts
│   │   │   ├── slashCommandProcessor.test.ts
│   │   │   ├── slashCommandProcessor.ts
│   │   │   ├── useAtCompletion.test.ts
│   │   │   ├── useAtCompletion.ts
│   │   │   ├── useAutoAcceptIndicator.test.ts
│   │   │   ├── useAutoAcceptIndicator.ts
│   │   │   ├── useBracketedPaste.ts
│   │   │   ├── useCommandCompletion.test.ts
│   │   │   ├── useCommandCompletion.tsx
│   │   │   ├── useCompletion.ts
│   │   │   ├── useConsoleMessages.test.ts
│   │   │   ├── useConsoleMessages.ts
│   │   │   ├── useEditorSettings.test.ts
│   │   │   ├── useEditorSettings.ts
│   │   │   ├── useExtensionUpdates.test.ts
│   │   │   ├── useExtensionUpdates.ts
│   │   │   ├── useFlickerDetector.test.ts
│   │   │   ├── useFlickerDetector.ts
│   │   │   ├── useFocus.test.ts
│   │   │   ├── useFocus.ts
│   │   │   ├── useFolderTrust.test.ts
│   │   │   ├── useFolderTrust.ts
│   │   │   ├── useGeminiStream.test.tsx
│   │   │   ├── useGeminiStream.ts
│   │   │   ├── useGitBranchName.test.ts
│   │   │   ├── useGitBranchName.ts
│   │   │   ├── useHistoryManager.test.ts
│   │   │   ├── useHistoryManager.ts
│   │   │   ├── useIdeTrustListener.test.ts
│   │   │   ├── useIdeTrustListener.ts
│   │   │   ├── useInputHistory.test.ts
│   │   │   ├── useInputHistory.ts
│   │   │   ├── useInputHistoryStore.test.ts
│   │   │   ├── useInputHistoryStore.ts
│   │   │   ├── useKeypress.test.ts
│   │   │   ├── useKeypress.ts
│   │   │   ├── useKittyKeyboardProtocol.ts
│   │   │   ├── useLoadingIndicator.test.ts
│   │   │   ├── useLoadingIndicator.ts
│   │   │   ├── useLogger.ts
│   │   │   ├── useMemoryMonitor.test.ts
│   │   │   ├── useMemoryMonitor.ts
│   │   │   ├── useMessageQueue.test.ts
│   │   │   ├── useMessageQueue.ts
│   │   │   ├── useModelCommand.test.ts
│   │   │   ├── useModelCommand.ts
│   │   │   ├── usePermissionsModifyTrust.test.ts
│   │   │   ├── usePermissionsModifyTrust.ts
│   │   │   ├── usePhraseCycler.test.ts
│   │   │   ├── usePhraseCycler.ts
│   │   │   ├── usePrivacySettings.test.ts
│   │   │   ├── usePrivacySettings.ts
│   │   │   ├── usePromptCompletion.ts
│   │   │   ├── useQuotaAndFallback.test.ts
│   │   │   ├── useQuotaAndFallback.ts
│   │   │   ├── useReactToolScheduler.ts
│   │   │   ├── useRefreshMemoryCommand.ts
│   │   │   ├── useReverseSearchCompletion.test.tsx
│   │   │   ├── useReverseSearchCompletion.tsx
│   │   │   ├── useSelectionList.test.ts
│   │   │   ├── useSelectionList.ts
│   │   │   ├── useSettingsCommand.ts
│   │   │   ├── useShellHistory.test.ts
│   │   │   ├── useShellHistory.ts
│   │   │   ├── useShowMemoryCommand.ts
│   │   │   ├── useSlashCompletion.test.ts
│   │   │   ├── useSlashCompletion.ts
│   │   │   ├── useStateAndRef.ts
│   │   │   ├── useTerminalSize.ts
│   │   │   ├── useThemeCommand.ts
│   │   │   ├── useTimer.test.ts
│   │   │   ├── useTimer.ts
│   │   │   ├── useToolScheduler.test.ts
│   │   │   ├── useWorkspaceMigration.ts
│   │   │   ├── vim.test.ts
│   │   │   └── vim.ts
│   │   ├── keyMatchers.test.ts
│   │   ├── keyMatchers.ts
│   │   ├── layouts
│   │   │   ├── DefaultAppLayout.tsx
│   │   │   └── ScreenReaderAppLayout.tsx
│   │   ├── noninteractive
│   │   │   └── nonInteractiveUi.ts
│   │   ├── privacy
│   │   │   ├── CloudFreePrivacyNotice.tsx
│   │   │   ├── CloudPaidPrivacyNotice.tsx
│   │   │   ├── GeminiPrivacyNotice.tsx
│   │   │   └── PrivacyNotice.tsx
│   │   ├── semantic-colors.ts
│   │   ├── state
│   │   │   └── extensions.ts
│   │   ├── textConstants.ts
│   │   ├── themes
│   │   │   ├── ansi-light.ts
│   │   │   ├── ansi.ts
│   │   │   ├── atom-one-dark.ts
│   │   │   ├── ayu-light.ts
│   │   │   ├── ayu.ts
│   │   │   ├── color-utils.test.ts
│   │   │   ├── color-utils.ts
│   │   │   ├── default-light.ts
│   │   │   ├── default.ts
│   │   │   ├── dracula.ts
│   │   │   ├── github-dark.ts
│   │   │   ├── github-light.ts
│   │   │   ├── googlecode.ts
│   │   │   ├── no-color.ts
│   │   │   ├── semantic-tokens.ts
│   │   │   ├── shades-of-purple.ts
│   │   │   ├── theme-manager.test.ts
│   │   │   ├── theme-manager.ts
│   │   │   ├── theme.test.ts
│   │   │   ├── theme.ts
│   │   │   └── xcode.ts
│   │   ├── types.ts
│   │   └── utils
│   │       ├── CodeColorizer.tsx
│   │       ├── ConsolePatcher.ts
│   │       ├── InlineMarkdownRenderer.tsx
│   │       ├── MarkdownDisplay.test.tsx
│   │       ├── MarkdownDisplay.tsx
│   │       ├── TableRenderer.tsx
│   │       ├── __snapshots__
│   │       │   └── MarkdownDisplay.test.tsx.snap
│   │       ├── clipboardUtils.test.ts
│   │       ├── clipboardUtils.ts
│   │       ├── commandUtils.test.ts
│   │       ├── commandUtils.ts
│   │       ├── computeStats.test.ts
│   │       ├── computeStats.ts
│   │       ├── displayUtils.test.ts
│   │       ├── displayUtils.ts
│   │       ├── formatters.test.ts
│   │       ├── formatters.ts
│   │       ├── highlight.test.ts
│   │       ├── highlight.ts
│   │       ├── isNarrowWidth.ts
│   │       ├── kittyProtocolDetector.ts
│   │       ├── markdownUtilities.test.ts
│   │       ├── markdownUtilities.ts
│   │       ├── platformConstants.ts
│   │       ├── terminalSetup.ts
│   │       ├── textUtils.test.ts
│   │       ├── textUtils.ts
│   │       ├── ui-sizing.ts
│   │       ├── updateCheck.test.ts
│   │       └── updateCheck.ts
│   ├── utils
│   │   ├── checks.ts
│   │   ├── cleanup.test.ts
│   │   ├── cleanup.ts
│   │   ├── commands.test.ts
│   │   ├── commands.ts
│   │   ├── commentJson.test.ts
│   │   ├── commentJson.ts
│   │   ├── deepMerge.test.ts
│   │   ├── deepMerge.ts
│   │   ├── dialogScopeUtils.ts
│   │   ├── envVarResolver.test.ts
│   │   ├── envVarResolver.ts
│   │   ├── errors.test.ts
│   │   ├── errors.ts
│   │   ├── events.ts
│   │   ├── gitUtils.test.ts
│   │   ├── gitUtils.ts
│   │   ├── handleAutoUpdate.test.ts
│   │   ├── handleAutoUpdate.ts
│   │   ├── installationInfo.test.ts
│   │   ├── installationInfo.ts
│   │   ├── math.ts
│   │   ├── package.ts
│   │   ├── processUtils.test.ts
│   │   ├── processUtils.ts
│   │   ├── readStdin.test.ts
│   │   ├── readStdin.ts
│   │   ├── relaunch.test.ts
│   │   ├── relaunch.ts
│   │   ├── resolvePath.ts
│   │   ├── sandbox-macos-permissive-closed.sb
│   │   ├── sandbox-macos-permissive-open.sb
│   │   ├── sandbox-macos-permissive-proxied.sb
│   │   ├── sandbox-macos-restrictive-closed.sb
│   │   ├── sandbox-macos-restrictive-open.sb
│   │   ├── sandbox-macos-restrictive-proxied.sb
│   │   ├── sandbox.ts
│   │   ├── sessionCleanup.integration.test.ts
│   │   ├── sessionCleanup.test.ts
│   │   ├── sessionCleanup.ts
│   │   ├── sessionUtils.ts
│   │   ├── settingsUtils.test.ts
│   │   ├── settingsUtils.ts
│   │   ├── spawnWrapper.ts
│   │   ├── startupWarnings.test.ts
│   │   ├── startupWarnings.ts
│   │   ├── updateEventEmitter.ts
│   │   ├── userStartupWarnings.test.ts
│   │   ├── userStartupWarnings.ts
│   │   ├── version.ts
│   │   ├── windowTitle.test.ts
│   │   └── windowTitle.ts
│   ├── validateNonInterActiveAuth.test.ts
│   ├── validateNonInterActiveAuth.ts
│   └── zed-integration
│       ├── acp.ts
│       ├── fileSystemService.ts
│       ├── schema.ts
│       └── zedIntegration.ts
├── test-setup.ts
├── tsconfig.json
└── vitest.config.ts


index.ts
```
1 | #!/usr/bin/env node
2 | 
3 | /**
4 |  * @license
5 |  * Copyright 2025 Google LLC
6 |  * SPDX-License-Identifier: Apache-2.0
7 |  */
8 | 
9 | import './src/gemini.js';
10 | import { main } from './src/gemini.js';
11 | import { FatalError } from '@google/gemini-cli-core';
12 | 
13 | // --- Global Entry Point ---
14 | main().catch((error) => {
15 |   if (error instanceof FatalError) {
16 |     let errorMessage = error.message;
17 |     if (!process.env['NO_COLOR']) {
18 |       errorMessage = `\x1b[31m${errorMessage}\x1b[0m`;
19 |     }
20 |     console.error(errorMessage);
21 |     process.exit(error.exitCode);
22 |   }
23 |   console.error('An unexpected critical error occurred:');
24 |   if (error instanceof Error) {
25 |     console.error(error.stack);
26 |   } else {
27 |     console.error(String(error));
28 |   }
29 |   process.exit(1);
30 | });
```

package.json
```
1 | {
2 |   "name": "@google/gemini-cli",
3 |   "version": "0.10.0-nightly.20251007.c195a9aa",
4 |   "description": "Gemini CLI",
5 |   "repository": {
6 |     "type": "git",
7 |     "url": "git+https://github.com/google-gemini/gemini-cli.git"
8 |   },
9 |   "type": "module",
10 |   "main": "dist/index.js",
11 |   "bin": {
12 |     "gemini": "dist/index.js"
13 |   },
14 |   "scripts": {
15 |     "build": "node ../../scripts/build_package.js",
16 |     "start": "node dist/index.js",
17 |     "debug": "node --inspect-brk dist/index.js",
18 |     "lint": "eslint . --ext .ts,.tsx",
19 |     "format": "prettier --write .",
20 |     "test": "vitest run",
21 |     "test:ci": "vitest run",
22 |     "typecheck": "tsc --noEmit"
23 |   },
24 |   "files": [
25 |     "dist"
26 |   ],
27 |   "config": {
28 |     "sandboxImageUri": "us-docker.pkg.dev/gemini-code-dev/gemini-cli/sandbox:0.10.0-nightly.20251007.c195a9aa"
29 |   },
30 |   "dependencies": {
31 |     "@google/gemini-cli-core": "file:../core",
32 |     "@google/genai": "1.16.0",
33 |     "@iarna/toml": "^2.2.5",
34 |     "@modelcontextprotocol/sdk": "^1.15.1",
35 |     "@types/update-notifier": "^6.0.8",
36 |     "ansi-regex": "^6.2.2",
37 |     "command-exists": "^1.2.9",
38 |     "comment-json": "^4.2.5",
39 |     "diff": "^7.0.0",
40 |     "dotenv": "^17.1.0",
41 |     "fzf": "^0.5.2",
42 |     "glob": "^10.4.5",
43 |     "highlight.js": "^11.11.1",
44 |     "ink": "^6.2.3",
45 |     "ink-gradient": "^3.0.0",
46 |     "ink-spinner": "^5.0.0",
47 |     "lowlight": "^3.3.0",
48 |     "mnemonist": "^0.40.3",
49 |     "open": "^10.1.2",
50 |     "react": "^19.1.0",
51 |     "read-package-up": "^11.0.0",
52 |     "shell-quote": "^1.8.3",
53 |     "simple-git": "^3.28.0",
54 |     "string-width": "^7.1.0",
55 |     "strip-ansi": "^7.1.0",
56 |     "strip-json-comments": "^3.1.1",
57 |     "tar": "^7.5.1",
58 |     "undici": "^7.10.0",
59 |     "extract-zip": "^2.0.1",
60 |     "update-notifier": "^7.3.1",
61 |     "wrap-ansi": "9.0.2",
62 |     "yargs": "^17.7.2",
63 |     "zod": "^3.23.8"
64 |   },
65 |   "devDependencies": {
66 |     "@babel/runtime": "^7.27.6",
67 |     "@google/gemini-cli-test-utils": "file:../test-utils",
68 |     "@testing-library/react": "^16.3.0",
69 |     "@types/archiver": "^6.0.3",
70 |     "@types/command-exists": "^1.2.3",
71 |     "@types/diff": "^7.0.2",
72 |     "@types/dotenv": "^6.1.1",
73 |     "@types/node": "^20.11.24",
74 |     "@types/react": "^19.1.8",
75 |     "@types/react-dom": "^19.1.6",
76 |     "@types/semver": "^7.7.0",
77 |     "@types/shell-quote": "^1.7.5",
78 |     "@types/tar": "^6.1.13",
79 |     "@types/yargs": "^17.0.32",
80 |     "archiver": "^7.0.1",
81 |     "ink-testing-library": "^4.0.0",
82 |     "jsdom": "^26.1.0",
83 |     "pretty-format": "^30.0.2",
84 |     "react-dom": "^19.1.0",
85 |     "typescript": "^5.3.3",
86 |     "vitest": "^3.1.1"
87 |   },
88 |   "engines": {
89 |     "node": ">=20"
90 |   }
91 | }
```

test-setup.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | // Unset NO_COLOR environment variable to ensure consistent theme behavior between local and CI test runs
8 | if (process.env.NO_COLOR !== undefined) {
9 |   delete process.env.NO_COLOR;
10 | }
11 | 
12 | import './src/test-utils/customMatchers.js';
```

tsconfig.json
```
1 | {
2 |   "extends": "../../tsconfig.json",
3 |   "compilerOptions": {
4 |     "outDir": "dist",
5 |     "jsx": "react-jsx",
6 |     "lib": ["DOM", "DOM.Iterable", "ES2023"],
7 |     "types": ["node", "vitest/globals"]
8 |   },
9 |   "include": [
10 |     "index.ts",
11 |     "src/**/*.ts",
12 |     "src/**/*.tsx",
13 |     "src/**/*.json",
14 |     "./package.json"
15 |   ],
16 |   "exclude": [
17 |     "node_modules",
18 |     "dist",
19 |     // TODO(5691): Fix type errors and remove excludes.
20 |     "src/commands/mcp.test.ts",
21 |     "src/commands/mcp/add.test.ts",
22 |     "src/commands/mcp/list.test.ts",
23 |     "src/commands/mcp/remove.test.ts",
24 |     "src/config/config.integration.test.ts",
25 |     "src/config/config.test.ts",
26 |     "src/config/extension.test.ts",
27 |     "src/config/settings.test.ts",
28 |     "src/nonInteractiveCli.test.ts",
29 |     "src/services/FileCommandLoader.test.ts",
30 |     "src/services/prompt-processors/argumentProcessor.test.ts",
31 |     "src/utils/cleanup.test.ts",
32 |     "src/utils/handleAutoUpdate.test.ts",
33 |     "src/utils/startupWarnings.test.ts",
34 |     "src/ui/App.test.tsx",
35 |     "src/ui/commands/aboutCommand.test.ts",
36 |     "src/ui/commands/authCommand.test.ts",
37 |     "src/ui/commands/bugCommand.test.ts",
38 |     "src/ui/commands/clearCommand.test.ts",
39 |     "src/ui/commands/compressCommand.test.ts",
40 |     "src/ui/commands/copyCommand.test.ts",
41 |     "src/ui/commands/corgiCommand.test.ts",
42 |     "src/ui/commands/docsCommand.test.ts",
43 |     "src/ui/commands/editorCommand.test.ts",
44 |     "src/ui/commands/extensionsCommand.test.ts",
45 |     "src/ui/commands/helpCommand.test.ts",
46 |     "src/ui/commands/restoreCommand.test.ts",
47 |     "src/ui/commands/settingsCommand.test.ts",
48 |     "src/ui/commands/themeCommand.test.ts",
49 |     "src/ui/commands/chatCommand.test.ts",
50 |     "src/ui/commands/directoryCommand.test.tsx",
51 |     "src/ui/commands/ideCommand.test.ts",
52 |     "src/ui/commands/initCommand.test.ts",
53 |     "src/ui/commands/privacyCommand.test.ts",
54 |     "src/ui/commands/quitCommand.test.ts",
55 |     "src/ui/commands/mcpCommand.test.ts",
56 |     "src/ui/commands/memoryCommand.test.ts",
57 |     "src/ui/commands/statsCommand.test.ts",
58 |     "src/ui/commands/terminalSetupCommand.test.ts",
59 |     "src/ui/commands/toolsCommand.test.ts",
60 |     "src/ui/components/ContextSummaryDisplay.test.tsx",
61 |     "src/ui/components/Footer.test.tsx",
62 |     "src/ui/components/InputPrompt.test.tsx",
63 |     "src/ui/components/ModelStatsDisplay.test.tsx",
64 |     "src/ui/components/SessionSummaryDisplay.test.tsx",
65 |     "src/ui/components/shared/text-buffer.test.ts",
66 |     "src/ui/components/shared/vim-buffer-actions.test.ts",
67 |     "src/ui/components/StatsDisplay.test.tsx",
68 |     "src/ui/components/ToolStatsDisplay.test.tsx",
69 |     "src/ui/components/WarningMessage.test.tsx",
70 |     "src/ui/contexts/SessionContext.test.tsx",
71 |     "src/ui/hooks/slashCommandProcessor.test.ts",
72 |     "src/ui/hooks/useAtCompletion.test.ts",
73 |     "src/ui/hooks/useConsoleMessages.test.ts",
74 |     "src/ui/hooks/useCommandCompletion.test.ts",
75 |     "src/ui/hooks/useFocus.test.ts",
76 |     "src/ui/hooks/useFolderTrust.test.ts",
77 |     "src/ui/hooks/useGeminiStream.test.tsx",
78 |     "src/ui/hooks/useKeypress.test.ts",
79 |     "src/ui/hooks/usePhraseCycler.test.ts",
80 |     "src/ui/hooks/vim.test.ts",
81 |     "src/ui/utils/computeStats.test.ts",
82 |     "src/ui/themes/theme.test.ts",
83 |     "src/validateNonInterActiveAuth.test.ts",
84 |     "src/services/prompt-processors/shellProcessor.test.ts",
85 |     "src/commands/extensions/examples/**"
86 |   ],
87 |   "references": [{ "path": "../core" }]
88 | }
```

vitest.config.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | /// <reference types="vitest" />
8 | import { defineConfig } from 'vitest/config';
9 | 
10 | export default defineConfig({
11 |   test: {
12 |     include: ['**/*.{test,spec}.?(c|m)[jt]s?(x)', 'config.test.ts'],
13 |     exclude: ['**/node_modules/**', '**/dist/**', '**/cypress/**'],
14 |     environment: 'jsdom',
15 |     globals: true,
16 |     reporters: ['default', 'junit'],
17 |     silent: true,
18 |     outputFile: {
19 |       junit: 'junit.xml',
20 |     },
21 |     setupFiles: ['./test-setup.ts'],
22 |     coverage: {
23 |       enabled: true,
24 |       provider: 'v8',
25 |       reportsDirectory: './coverage',
26 |       include: ['src/**/*'],
27 |       reporter: [
28 |         ['text', { file: 'full-text-summary.txt' }],
29 |         'html',
30 |         'json',
31 |         'lcov',
32 |         'cobertura',
33 |         ['json-summary', { outputFile: 'coverage-summary.json' }],
34 |       ],
35 |     },
36 |     poolOptions: {
37 |       threads: {
38 |         minThreads: 8,
39 |         maxThreads: 16,
40 |       },
41 |     },
42 |     server: {
43 |       deps: {
44 |         inline: [/@google\/gemini-cli-core/],
45 |       },
46 |     },
47 |   },
48 | });
```

src/gemini.test.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import {
8 |   describe,
9 |   it,
10 |   expect,
11 |   vi,
12 |   beforeEach,
13 |   afterEach,
14 |   type MockInstance,
15 | } from 'vitest';
16 | import {
17 |   main,
18 |   setupUnhandledRejectionHandler,
19 |   validateDnsResolutionOrder,
20 |   startInteractiveUI,
21 | } from './gemini.js';
22 | import { type LoadedSettings } from './config/settings.js';
23 | import { appEvents, AppEvent } from './utils/events.js';
24 | import type { Config } from '@google/gemini-cli-core';
25 | 
26 | // Custom error to identify mock process.exit calls
27 | class MockProcessExitError extends Error {
28 |   constructor(readonly code?: string | number | null | undefined) {
29 |     super('PROCESS_EXIT_MOCKED');
30 |     this.name = 'MockProcessExitError';
31 |   }
32 | }
33 | 
34 | // Mock dependencies
35 | vi.mock('./config/settings.js', () => ({
36 |   loadSettings: vi.fn().mockReturnValue({
37 |     merged: {
38 |       advanced: {},
39 |       security: { auth: {} },
40 |       ui: {},
41 |     },
42 |     setValue: vi.fn(),
43 |     forScope: () => ({ settings: {}, originalSettings: {}, path: '' }),
44 |     errors: [],
45 |   }),
46 |   migrateDeprecatedSettings: vi.fn(),
47 |   SettingScope: {
48 |     User: 'user',
49 |     Workspace: 'workspace',
50 |     System: 'system',
51 |     SystemDefaults: 'system-defaults',
52 |   },
53 | }));
54 | 
55 | vi.mock('./config/config.js', () => ({
56 |   loadCliConfig: vi.fn().mockResolvedValue({
57 |     getSandbox: vi.fn(() => false),
58 |     getQuestion: vi.fn(() => ''),
59 |     isInteractive: () => false,
60 |   } as unknown as Config),
61 |   parseArguments: vi.fn().mockResolvedValue({}),
62 |   isDebugMode: vi.fn(() => false),
63 | }));
64 | 
65 | vi.mock('read-package-up', () => ({
66 |   readPackageUp: vi.fn().mockResolvedValue({
67 |     packageJson: { name: 'test-pkg', version: 'test-version' },
68 |     path: '/fake/path/package.json',
69 |   }),
70 | }));
71 | 
72 | vi.mock('update-notifier', () => ({
73 |   default: vi.fn(() => ({
74 |     notify: vi.fn(),
75 |   })),
76 | }));
77 | 
78 | vi.mock('./utils/events.js', async (importOriginal) => {
79 |   const actual = await importOriginal<typeof import('./utils/events.js')>();
80 |   return {
81 |     ...actual,
82 |     appEvents: {
83 |       emit: vi.fn(),
84 |     },
85 |   };
86 | });
87 | 
88 | vi.mock('./utils/sandbox.js', () => ({
89 |   sandbox_command: vi.fn(() => ''), // Default to no sandbox command
90 |   start_sandbox: vi.fn(() => Promise.resolve()), // Mock as an async function that resolves
91 | }));
92 | 
93 | vi.mock('./utils/relaunch.js', () => ({
94 |   relaunchAppInChildProcess: vi.fn(),
95 | }));
96 | 
97 | vi.mock('./config/sandboxConfig.js', () => ({
98 |   loadSandboxConfig: vi.fn(),
99 | }));
100 | 
101 | describe('gemini.tsx main function', () => {
102 |   let originalEnvGeminiSandbox: string | undefined;
103 |   let originalEnvSandbox: string | undefined;
104 |   let initialUnhandledRejectionListeners: NodeJS.UnhandledRejectionListener[] =
105 |     [];
106 | 
107 |   beforeEach(() => {
108 |     // Store and clear sandbox-related env variables to ensure a consistent test environment
109 |     originalEnvGeminiSandbox = process.env['GEMINI_SANDBOX'];
110 |     originalEnvSandbox = process.env['SANDBOX'];
111 |     delete process.env['GEMINI_SANDBOX'];
112 |     delete process.env['SANDBOX'];
113 | 
114 |     initialUnhandledRejectionListeners =
115 |       process.listeners('unhandledRejection');
116 |   });
117 | 
118 |   afterEach(() => {
119 |     // Restore original env variables
120 |     if (originalEnvGeminiSandbox !== undefined) {
121 |       process.env['GEMINI_SANDBOX'] = originalEnvGeminiSandbox;
122 |     } else {
123 |       delete process.env['GEMINI_SANDBOX'];
124 |     }
125 |     if (originalEnvSandbox !== undefined) {
126 |       process.env['SANDBOX'] = originalEnvSandbox;
127 |     } else {
128 |       delete process.env['SANDBOX'];
129 |     }
130 | 
131 |     const currentListeners = process.listeners('unhandledRejection');
132 |     const addedListener = currentListeners.find(
133 |       (listener) => !initialUnhandledRejectionListeners.includes(listener),
134 |     );
135 | 
136 |     if (addedListener) {
137 |       process.removeListener('unhandledRejection', addedListener);
138 |     }
139 |     vi.restoreAllMocks();
140 |   });
141 | 
142 |   it('verifies that we dont load the config before relaunchAppInChildProcess', async () => {
143 |     const processExitSpy = vi
144 |       .spyOn(process, 'exit')
145 |       .mockImplementation((code) => {
146 |         throw new MockProcessExitError(code);
147 |       });
148 |     const { relaunchAppInChildProcess } = await import('./utils/relaunch.js');
149 |     const { loadCliConfig } = await import('./config/config.js');
150 |     const { loadSettings } = await import('./config/settings.js');
151 |     const { loadSandboxConfig } = await import('./config/sandboxConfig.js');
152 |     vi.mocked(loadSandboxConfig).mockResolvedValue(undefined);
153 | 
154 |     const callOrder: string[] = [];
155 |     vi.mocked(relaunchAppInChildProcess).mockImplementation(async () => {
156 |       callOrder.push('relaunch');
157 |     });
158 |     vi.mocked(loadCliConfig).mockImplementation(async () => {
159 |       callOrder.push('loadCliConfig');
160 |       return {
161 |         isInteractive: () => false,
162 |         getQuestion: () => '',
163 |         getSandbox: () => false,
164 |         getDebugMode: () => false,
165 |         getListExtensions: () => false,
166 |         getMcpServers: () => ({}),
167 |         initialize: vi.fn(),
168 |         getIdeMode: () => false,
169 |         getExperimentalZedIntegration: () => false,
170 |         getScreenReader: () => false,
171 |         getGeminiMdFileCount: () => 0,
172 |         getProjectRoot: () => '/',
173 |       } as unknown as Config;
174 |     });
175 |     vi.mocked(loadSettings).mockReturnValue({
176 |       errors: [],
177 |       merged: {
178 |         advanced: { autoConfigureMemory: true },
179 |         security: { auth: {} },
180 |         ui: {},
181 |       },
182 |       setValue: vi.fn(),
183 |       forScope: () => ({ settings: {}, originalSettings: {}, path: '' }),
184 |     } as never);
185 |     try {
186 |       await main();
187 |     } catch (e) {
188 |       // Mocked process exit throws an error.
189 |       if (!(e instanceof MockProcessExitError)) throw e;
190 |     }
191 | 
192 |     // It is critical that we call relaunch before loadCliConfig to avoid
193 |     // loading config in the outer process when we are going to relaunch.
194 |     // By ensuring we don't load the config we also ensure we don't trigger any
195 |     // operations that might require loading the config such as such as
196 |     // initializing mcp servers.
197 |     // For the sandbox case we still have to load a partial cli config.
198 |     // we can authorize outside the sandbox.
199 |     expect(callOrder).toEqual(['relaunch', 'loadCliConfig']);
200 |     processExitSpy.mockRestore();
201 |   });
202 | 
203 |   it('should log unhandled promise rejections and open debug console on first error', async () => {
204 |     const processExitSpy = vi
205 |       .spyOn(process, 'exit')
206 |       .mockImplementation((code) => {
207 |         throw new MockProcessExitError(code);
208 |       });
209 |     const appEventsMock = vi.mocked(appEvents);
210 |     const rejectionError = new Error('Test unhandled rejection');
211 | 
212 |     setupUnhandledRejectionHandler();
213 |     // Simulate an unhandled rejection.
214 |     // We are not using Promise.reject here as vitest will catch it.
215 |     // Instead we will dispatch the event manually.
216 |     process.emit('unhandledRejection', rejectionError, Promise.resolve());
217 | 
218 |     // We need to wait for the rejection handler to be called.
219 |     await new Promise(process.nextTick);
220 | 
221 |     expect(appEventsMock.emit).toHaveBeenCalledWith(AppEvent.OpenDebugConsole);
222 |     expect(appEventsMock.emit).toHaveBeenCalledWith(
223 |       AppEvent.LogError,
224 |       expect.stringContaining('Unhandled Promise Rejection'),
225 |     );
226 |     expect(appEventsMock.emit).toHaveBeenCalledWith(
227 |       AppEvent.LogError,
228 |       expect.stringContaining('Please file a bug report using the /bug tool.'),
229 |     );
230 | 
231 |     // Simulate a second rejection
232 |     const secondRejectionError = new Error('Second test unhandled rejection');
233 |     process.emit('unhandledRejection', secondRejectionError, Promise.resolve());
234 |     await new Promise(process.nextTick);
235 | 
236 |     // Ensure emit was only called once for OpenDebugConsole
237 |     const openDebugConsoleCalls = appEventsMock.emit.mock.calls.filter(
238 |       (call) => call[0] === AppEvent.OpenDebugConsole,
239 |     );
240 |     expect(openDebugConsoleCalls.length).toBe(1);
241 | 
242 |     // Avoid the process.exit error from being thrown.
243 |     processExitSpy.mockRestore();
244 |   });
245 | });
246 | 
247 | describe('gemini.tsx main function kitty protocol', () => {
248 |   let originalEnvNoRelaunch: string | undefined;
249 |   let setRawModeSpy: MockInstance<
250 |     (mode: boolean) => NodeJS.ReadStream & { fd: 0 }
251 |   >;
252 | 
253 |   beforeEach(() => {
254 |     // Set no relaunch in tests since process spawning causing issues in tests
255 |     originalEnvNoRelaunch = process.env['GEMINI_CLI_NO_RELAUNCH'];
256 |     process.env['GEMINI_CLI_NO_RELAUNCH'] = 'true';
257 | 
258 |     // eslint-disable-next-line @typescript-eslint/no-explicit-any
259 |     if (!(process.stdin as any).setRawMode) {
260 |       // eslint-disable-next-line @typescript-eslint/no-explicit-any
261 |       (process.stdin as any).setRawMode = vi.fn();
262 |     }
263 |     setRawModeSpy = vi.spyOn(process.stdin, 'setRawMode');
264 | 
265 |     Object.defineProperty(process.stdin, 'isTTY', {
266 |       value: true,
267 |       configurable: true,
268 |     });
269 |     Object.defineProperty(process.stdin, 'isRaw', {
270 |       value: false,
271 |       configurable: true,
272 |     });
273 |   });
274 | 
275 |   afterEach(() => {
276 |     // Restore original env variables
277 |     if (originalEnvNoRelaunch !== undefined) {
278 |       process.env['GEMINI_CLI_NO_RELAUNCH'] = originalEnvNoRelaunch;
279 |     } else {
280 |       delete process.env['GEMINI_CLI_NO_RELAUNCH'];
281 |     }
282 |   });
283 | 
284 |   it('should call setRawMode and detectAndEnableKittyProtocol when isInteractive is true', async () => {
285 |     const { detectAndEnableKittyProtocol } = await import(
286 |       './ui/utils/kittyProtocolDetector.js'
287 |     );
288 |     const { loadCliConfig, parseArguments } = await import(
289 |       './config/config.js'
290 |     );
291 |     const { loadSettings } = await import('./config/settings.js');
292 |     vi.mocked(loadCliConfig).mockResolvedValue({
293 |       isInteractive: () => true,
294 |       getQuestion: () => '',
295 |       getSandbox: () => false,
296 |       getDebugMode: () => false,
297 |       getListExtensions: () => false,
298 |       getMcpServers: () => ({}),
299 |       initialize: vi.fn(),
300 |       getIdeMode: () => false,
301 |       getExperimentalZedIntegration: () => false,
302 |       getScreenReader: () => false,
303 |       getGeminiMdFileCount: () => 0,
304 |     } as unknown as Config);
305 |     vi.mocked(loadSettings).mockReturnValue({
306 |       errors: [],
307 |       merged: {
308 |         advanced: {},
309 |         security: { auth: {} },
310 |         ui: {},
311 |       },
312 |       setValue: vi.fn(),
313 |       forScope: () => ({ settings: {}, originalSettings: {}, path: '' }),
314 |     } as never);
315 |     vi.mocked(parseArguments).mockResolvedValue({
316 |       model: undefined,
317 |       sandbox: undefined,
318 |       sandboxImage: undefined,
319 |       debug: undefined,
320 |       prompt: undefined,
321 |       promptInteractive: undefined,
322 |       query: undefined,
323 |       allFiles: undefined,
324 |       showMemoryUsage: undefined,
325 |       yolo: undefined,
326 |       approvalMode: undefined,
327 |       telemetry: undefined,
328 |       checkpointing: undefined,
329 |       telemetryTarget: undefined,
330 |       telemetryOtlpEndpoint: undefined,
331 |       telemetryOtlpProtocol: undefined,
332 |       telemetryLogPrompts: undefined,
333 |       telemetryOutfile: undefined,
334 |       allowedMcpServerNames: undefined,
335 |       allowedTools: undefined,
336 |       experimentalAcp: undefined,
337 |       extensions: undefined,
338 |       listExtensions: undefined,
339 |       proxy: undefined,
340 |       includeDirectories: undefined,
341 |       screenReader: undefined,
342 |       useSmartEdit: undefined,
343 |       useWriteTodos: undefined,
344 |       outputFormat: undefined,
345 |     });
346 | 
347 |     await main();
348 | 
349 |     expect(setRawModeSpy).toHaveBeenCalledWith(true);
350 |     expect(detectAndEnableKittyProtocol).toHaveBeenCalledTimes(1);
351 |   });
352 | });
353 | 
354 | describe('validateDnsResolutionOrder', () => {
355 |   let consoleWarnSpy: ReturnType<typeof vi.spyOn>;
356 | 
357 |   beforeEach(() => {
358 |     consoleWarnSpy = vi.spyOn(console, 'warn').mockImplementation(() => {});
359 |   });
360 | 
361 |   afterEach(() => {
362 |     consoleWarnSpy.mockRestore();
363 |   });
364 | 
365 |   it('should return "ipv4first" when the input is "ipv4first"', () => {
366 |     expect(validateDnsResolutionOrder('ipv4first')).toBe('ipv4first');
367 |     expect(consoleWarnSpy).not.toHaveBeenCalled();
368 |   });
369 | 
370 |   it('should return "verbatim" when the input is "verbatim"', () => {
371 |     expect(validateDnsResolutionOrder('verbatim')).toBe('verbatim');
[TRUNCATED]
```

src/gemini.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import React from 'react';
8 | import { render } from 'ink';
9 | import { AppContainer } from './ui/AppContainer.js';
10 | import { loadCliConfig, parseArguments } from './config/config.js';
11 | import * as cliConfig from './config/config.js';
12 | import { readStdin } from './utils/readStdin.js';
13 | import { basename } from 'node:path';
14 | import v8 from 'node:v8';
15 | import os from 'node:os';
16 | import dns from 'node:dns';
17 | import { start_sandbox } from './utils/sandbox.js';
18 | import type { DnsResolutionOrder, LoadedSettings } from './config/settings.js';
19 | import {
20 |   loadSettings,
21 |   migrateDeprecatedSettings,
22 |   SettingScope,
23 | } from './config/settings.js';
24 | import { themeManager } from './ui/themes/theme-manager.js';
25 | import { getStartupWarnings } from './utils/startupWarnings.js';
26 | import { getUserStartupWarnings } from './utils/userStartupWarnings.js';
27 | import { ConsolePatcher } from './ui/utils/ConsolePatcher.js';
28 | import { runNonInteractive } from './nonInteractiveCli.js';
29 | import { ExtensionStorage, loadExtensions } from './config/extension.js';
30 | import {
31 |   cleanupCheckpoints,
32 |   registerCleanup,
33 |   runExitCleanup,
34 | } from './utils/cleanup.js';
35 | import { getCliVersion } from './utils/version.js';
36 | import type { Config } from '@google/gemini-cli-core';
37 | import {
38 |   sessionId,
39 |   logUserPrompt,
40 |   AuthType,
41 |   getOauthClient,
42 |   UserPromptEvent,
43 | } from '@google/gemini-cli-core';
44 | import {
45 |   initializeApp,
46 |   type InitializationResult,
47 | } from './core/initializer.js';
48 | import { validateAuthMethod } from './config/auth.js';
49 | import { setMaxSizedBoxDebugging } from './ui/components/shared/MaxSizedBox.js';
50 | import { runZedIntegration } from './zed-integration/zedIntegration.js';
51 | import { cleanupExpiredSessions } from './utils/sessionCleanup.js';
52 | import { validateNonInteractiveAuth } from './validateNonInterActiveAuth.js';
53 | import { detectAndEnableKittyProtocol } from './ui/utils/kittyProtocolDetector.js';
54 | import { checkForUpdates } from './ui/utils/updateCheck.js';
55 | import { handleAutoUpdate } from './utils/handleAutoUpdate.js';
56 | import { appEvents, AppEvent } from './utils/events.js';
57 | import { computeWindowTitle } from './utils/windowTitle.js';
58 | import { SettingsContext } from './ui/contexts/SettingsContext.js';
59 | 
60 | import { SessionStatsProvider } from './ui/contexts/SessionContext.js';
61 | import { VimModeProvider } from './ui/contexts/VimModeContext.js';
62 | import { KeypressProvider } from './ui/contexts/KeypressContext.js';
63 | import { useKittyKeyboardProtocol } from './ui/hooks/useKittyKeyboardProtocol.js';
64 | import {
65 |   relaunchAppInChildProcess,
66 |   relaunchOnExitCode,
67 | } from './utils/relaunch.js';
68 | import { loadSandboxConfig } from './config/sandboxConfig.js';
69 | import { ExtensionEnablementManager } from './config/extensions/extensionEnablement.js';
70 | 
71 | export function validateDnsResolutionOrder(
72 |   order: string | undefined,
73 | ): DnsResolutionOrder {
74 |   const defaultValue: DnsResolutionOrder = 'ipv4first';
75 |   if (order === undefined) {
76 |     return defaultValue;
77 |   }
78 |   if (order === 'ipv4first' || order === 'verbatim') {
79 |     return order;
80 |   }
81 |   // We don't want to throw here, just warn and use the default.
82 |   console.warn(
83 |     `Invalid value for dnsResolutionOrder in settings: "${order}". Using default "${defaultValue}".`,
84 |   );
85 |   return defaultValue;
86 | }
87 | 
88 | function getNodeMemoryArgs(isDebugMode: boolean): string[] {
89 |   const totalMemoryMB = os.totalmem() / (1024 * 1024);
90 |   const heapStats = v8.getHeapStatistics();
91 |   const currentMaxOldSpaceSizeMb = Math.floor(
92 |     heapStats.heap_size_limit / 1024 / 1024,
93 |   );
94 | 
95 |   // Set target to 50% of total memory
96 |   const targetMaxOldSpaceSizeInMB = Math.floor(totalMemoryMB * 0.5);
97 |   if (isDebugMode) {
98 |     console.debug(
99 |       `Current heap size ${currentMaxOldSpaceSizeMb.toFixed(2)} MB`,
100 |     );
101 |   }
102 | 
103 |   if (process.env['GEMINI_CLI_NO_RELAUNCH']) {
104 |     return [];
105 |   }
106 | 
107 |   if (targetMaxOldSpaceSizeInMB > currentMaxOldSpaceSizeMb) {
108 |     if (isDebugMode) {
109 |       console.debug(
110 |         `Need to relaunch with more memory: ${targetMaxOldSpaceSizeInMB.toFixed(2)} MB`,
111 |       );
112 |     }
113 |     return [`--max-old-space-size=${targetMaxOldSpaceSizeInMB}`];
114 |   }
115 | 
116 |   return [];
117 | }
118 | 
119 | export function setupUnhandledRejectionHandler() {
120 |   let unhandledRejectionOccurred = false;
121 |   process.on('unhandledRejection', (reason, _promise) => {
122 |     const errorMessage = `=========================================
123 | This is an unexpected error. Please file a bug report using the /bug tool.
124 | CRITICAL: Unhandled Promise Rejection!
125 | =========================================
126 | Reason: ${reason}${
127 |       reason instanceof Error && reason.stack
128 |         ? `
129 | Stack trace:
130 | ${reason.stack}`
131 |         : ''
132 |     }`;
133 |     appEvents.emit(AppEvent.LogError, errorMessage);
134 |     if (!unhandledRejectionOccurred) {
135 |       unhandledRejectionOccurred = true;
136 |       appEvents.emit(AppEvent.OpenDebugConsole);
137 |     }
138 |   });
139 | }
140 | 
141 | export async function startInteractiveUI(
142 |   config: Config,
143 |   settings: LoadedSettings,
144 |   startupWarnings: string[],
145 |   workspaceRoot: string = process.cwd(),
146 |   initializationResult: InitializationResult,
147 | ) {
148 |   // Disable line wrapping.
149 |   // We rely on Ink to manage all line wrapping by forcing all content to be
150 |   // narrower than the terminal width so there is no need for the terminal to
151 |   // also attempt line wrapping.
152 |   // Disabling line wrapping reduces Ink rendering artifacts particularly when
153 |   // the terminal is resized on terminals that full respect this escape code
154 |   // such as Ghostty. Some terminals such as Iterm2 only respect line wrapping
155 |   // when using the alternate buffer, which Gemini CLI does not use because we
156 |   // do not yet have support for scrolling in that mode.
157 |   process.stdout.write('\x1b[?7l');
158 | 
159 |   registerCleanup(() => {
160 |     // Re-enable line wrapping on exit.
161 |     process.stdout.write('\x1b[?7h');
162 |   });
163 | 
164 |   const version = await getCliVersion();
165 |   setWindowTitle(basename(workspaceRoot), settings);
166 | 
167 |   // Create wrapper component to use hooks inside render
168 |   const AppWrapper = () => {
169 |     const kittyProtocolStatus = useKittyKeyboardProtocol();
170 |     return (
171 |       <SettingsContext.Provider value={settings}>
172 |         <KeypressProvider
173 |           kittyProtocolEnabled={kittyProtocolStatus.enabled}
174 |           config={config}
175 |           debugKeystrokeLogging={settings.merged.general?.debugKeystrokeLogging}
176 |         >
177 |           <SessionStatsProvider>
178 |             <VimModeProvider settings={settings}>
179 |               <AppContainer
180 |                 config={config}
181 |                 settings={settings}
182 |                 startupWarnings={startupWarnings}
183 |                 version={version}
184 |                 initializationResult={initializationResult}
185 |               />
186 |             </VimModeProvider>
187 |           </SessionStatsProvider>
188 |         </KeypressProvider>
189 |       </SettingsContext.Provider>
190 |     );
191 |   };
192 | 
193 |   const instance = render(
194 |     process.env['DEBUG'] ? (
195 |       <React.StrictMode>
196 |         <AppWrapper />
197 |       </React.StrictMode>
198 |     ) : (
199 |       <AppWrapper />
200 |     ),
201 |     {
202 |       exitOnCtrlC: false,
203 |       isScreenReaderEnabled: config.getScreenReader(),
204 |     },
205 |   );
206 | 
207 |   checkForUpdates()
208 |     .then((info) => {
209 |       handleAutoUpdate(info, settings, config.getProjectRoot());
210 |     })
211 |     .catch((err) => {
212 |       // Silently ignore update check errors.
213 |       if (config.getDebugMode()) {
214 |         console.error('Update check failed:', err);
215 |       }
216 |     });
217 | 
218 |   registerCleanup(() => instance.unmount());
219 | }
220 | 
221 | export async function main() {
222 |   setupUnhandledRejectionHandler();
223 |   const settings = loadSettings();
224 |   migrateDeprecatedSettings(settings);
225 |   await cleanupCheckpoints();
226 | 
227 |   const argv = await parseArguments(settings.merged);
228 | 
229 |   // Check for invalid input combinations early to prevent crashes
230 |   if (argv.promptInteractive && !process.stdin.isTTY) {
231 |     console.error(
232 |       'Error: The --prompt-interactive flag cannot be used when input is piped from stdin.',
233 |     );
234 |     process.exit(1);
235 |   }
236 | 
237 |   const isDebugMode = cliConfig.isDebugMode(argv);
238 |   const consolePatcher = new ConsolePatcher({
239 |     stderr: true,
240 |     debugMode: isDebugMode,
241 |   });
242 |   consolePatcher.patch();
243 |   registerCleanup(consolePatcher.cleanup);
244 | 
245 |   dns.setDefaultResultOrder(
246 |     validateDnsResolutionOrder(settings.merged.advanced?.dnsResolutionOrder),
247 |   );
248 | 
249 |   // Set a default auth type if one isn't set.
250 |   if (!settings.merged.security?.auth?.selectedType) {
251 |     if (process.env['CLOUD_SHELL'] === 'true') {
252 |       settings.setValue(
253 |         SettingScope.User,
254 |         'selectedAuthType',
255 |         AuthType.CLOUD_SHELL,
256 |       );
257 |     }
258 |   }
259 | 
260 |   // Load custom themes from settings
261 |   themeManager.loadCustomThemes(settings.merged.ui?.customThemes);
262 | 
263 |   if (settings.merged.ui?.theme) {
264 |     if (!themeManager.setActiveTheme(settings.merged.ui?.theme)) {
265 |       // If the theme is not found during initial load, log a warning and continue.
266 |       // The useThemeCommand hook in AppContainer.tsx will handle opening the dialog.
267 |       console.warn(`Warning: Theme "${settings.merged.ui?.theme}" not found.`);
268 |     }
269 |   }
270 | 
271 |   // hop into sandbox if we are outside and sandboxing is enabled
272 |   if (!process.env['SANDBOX']) {
273 |     const memoryArgs = settings.merged.advanced?.autoConfigureMemory
274 |       ? getNodeMemoryArgs(isDebugMode)
275 |       : [];
276 |     const sandboxConfig = await loadSandboxConfig(settings.merged, argv);
277 |     // We intentially omit the list of extensions here because extensions
278 |     // should not impact auth or setting up the sandbox.
279 |     // TODO(jacobr): refactor loadCliConfig so there is a minimal version
280 |     // that only initializes enough config to enable refreshAuth or find
281 |     // another way to decouple refreshAuth from requiring a config.
282 | 
283 |     if (sandboxConfig) {
284 |       const partialConfig = await loadCliConfig(
285 |         settings.merged,
286 |         [],
287 |         new ExtensionEnablementManager(ExtensionStorage.getUserExtensionsDir()),
288 |         sessionId,
289 |         argv,
290 |       );
291 | 
292 |       if (
293 |         settings.merged.security?.auth?.selectedType &&
294 |         !settings.merged.security?.auth?.useExternal
295 |       ) {
296 |         // Validate authentication here because the sandbox will interfere with the Oauth2 web redirect.
297 |         try {
298 |           const err = validateAuthMethod(
299 |             settings.merged.security.auth.selectedType,
300 |           );
301 |           if (err) {
302 |             throw new Error(err);
303 |           }
304 | 
305 |           await partialConfig.refreshAuth(
306 |             settings.merged.security.auth.selectedType,
307 |           );
308 |         } catch (err) {
309 |           console.error('Error authenticating:', err);
310 |           process.exit(1);
311 |         }
312 |       }
313 |       let stdinData = '';
314 |       if (!process.stdin.isTTY) {
315 |         stdinData = await readStdin();
316 |       }
317 | 
318 |       // This function is a copy of the one from sandbox.ts
319 |       // It is moved here to decouple sandbox.ts from the CLI's argument structure.
320 |       const injectStdinIntoArgs = (
321 |         args: string[],
322 |         stdinData?: string,
323 |       ): string[] => {
324 |         const finalArgs = [...args];
325 |         if (stdinData) {
326 |           const promptIndex = finalArgs.findIndex(
327 |             (arg) => arg === '--prompt' || arg === '-p',
328 |           );
329 |           if (promptIndex > -1 && finalArgs.length > promptIndex + 1) {
330 |             // If there's a prompt argument, prepend stdin to it
331 |             finalArgs[promptIndex + 1] =
332 |               `${stdinData}\n\n${finalArgs[promptIndex + 1]}`;
333 |           } else {
334 |             // If there's no prompt argument, add stdin as the prompt
335 |             finalArgs.push('--prompt', stdinData);
336 |           }
337 |         }
338 |         return finalArgs;
339 |       };
340 | 
341 |       const sandboxArgs = injectStdinIntoArgs(process.argv, stdinData);
342 | 
343 |       await relaunchOnExitCode(() =>
344 |         start_sandbox(sandboxConfig, memoryArgs, partialConfig, sandboxArgs),
345 |       );
346 |       process.exit(0);
347 |     } else {
[TRUNCATED]
```

src/nonInteractiveCli.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type {
8 |   Config,
9 |   ToolRegistry,
10 |   ServerGeminiStreamEvent,
11 |   SessionMetrics,
12 | } from '@google/gemini-cli-core';
13 | import {
14 |   executeToolCall,
15 |   ToolErrorType,
16 |   shutdownTelemetry,
17 |   GeminiEventType,
18 |   OutputFormat,
19 |   uiTelemetryService,
20 |   FatalInputError,
21 | } from '@google/gemini-cli-core';
22 | import type { Part } from '@google/genai';
23 | import { runNonInteractive } from './nonInteractiveCli.js';
24 | import { vi } from 'vitest';
25 | import type { LoadedSettings } from './config/settings.js';
26 | 
27 | // Mock core modules
28 | vi.mock('./ui/hooks/atCommandProcessor.js');
29 | vi.mock('@google/gemini-cli-core', async (importOriginal) => {
30 |   const original =
31 |     await importOriginal<typeof import('@google/gemini-cli-core')>();
32 | 
33 |   class MockChatRecordingService {
34 |     initialize = vi.fn();
35 |     recordMessage = vi.fn();
36 |     recordMessageTokens = vi.fn();
37 |     recordToolCalls = vi.fn();
38 |   }
39 | 
40 |   return {
41 |     ...original,
42 |     executeToolCall: vi.fn(),
43 |     shutdownTelemetry: vi.fn(),
44 |     isTelemetrySdkInitialized: vi.fn().mockReturnValue(true),
45 |     ChatRecordingService: MockChatRecordingService,
46 |     uiTelemetryService: {
47 |       getMetrics: vi.fn(),
48 |     },
49 |   };
50 | });
51 | 
52 | const mockGetCommands = vi.hoisted(() => vi.fn());
53 | const mockCommandServiceCreate = vi.hoisted(() => vi.fn());
54 | vi.mock('./services/CommandService.js', () => ({
55 |   CommandService: {
56 |     create: mockCommandServiceCreate,
57 |   },
58 | }));
59 | 
60 | describe('runNonInteractive', () => {
61 |   let mockConfig: Config;
62 |   let mockSettings: LoadedSettings;
63 |   let mockToolRegistry: ToolRegistry;
64 |   let mockCoreExecuteToolCall: vi.Mock;
65 |   let mockShutdownTelemetry: vi.Mock;
66 |   let consoleErrorSpy: vi.SpyInstance;
67 |   let processStdoutSpy: vi.SpyInstance;
68 |   let mockGeminiClient: {
69 |     sendMessageStream: vi.Mock;
70 |     getChatRecordingService: vi.Mock;
71 |   };
72 | 
73 |   beforeEach(async () => {
74 |     mockCoreExecuteToolCall = vi.mocked(executeToolCall);
75 |     mockShutdownTelemetry = vi.mocked(shutdownTelemetry);
76 | 
77 |     mockCommandServiceCreate.mockResolvedValue({
78 |       getCommands: mockGetCommands,
79 |     });
80 | 
81 |     consoleErrorSpy = vi.spyOn(console, 'error').mockImplementation(() => {});
82 |     processStdoutSpy = vi
83 |       .spyOn(process.stdout, 'write')
84 |       .mockImplementation(() => true);
85 |     vi.spyOn(process, 'exit').mockImplementation((code) => {
86 |       throw new Error(`process.exit(${code}) called`);
87 |     });
88 | 
89 |     mockToolRegistry = {
90 |       getTool: vi.fn(),
91 |       getFunctionDeclarations: vi.fn().mockReturnValue([]),
92 |     } as unknown as ToolRegistry;
93 | 
94 |     mockGeminiClient = {
95 |       sendMessageStream: vi.fn(),
96 |       getChatRecordingService: vi.fn(() => ({
97 |         initialize: vi.fn(),
98 |         recordMessage: vi.fn(),
99 |         recordMessageTokens: vi.fn(),
100 |         recordToolCalls: vi.fn(),
101 |       })),
102 |     };
103 | 
104 |     mockConfig = {
105 |       initialize: vi.fn().mockResolvedValue(undefined),
106 |       getGeminiClient: vi.fn().mockReturnValue(mockGeminiClient),
107 |       getToolRegistry: vi.fn().mockReturnValue(mockToolRegistry),
108 |       getMaxSessionTurns: vi.fn().mockReturnValue(10),
109 |       getSessionId: vi.fn().mockReturnValue('test-session-id'),
110 |       getProjectRoot: vi.fn().mockReturnValue('/test/project'),
111 |       storage: {
112 |         getProjectTempDir: vi.fn().mockReturnValue('/test/project/.gemini/tmp'),
113 |       },
114 |       getIdeMode: vi.fn().mockReturnValue(false),
115 |       getFullContext: vi.fn().mockReturnValue(false),
116 |       getContentGeneratorConfig: vi.fn().mockReturnValue({}),
117 |       getDebugMode: vi.fn().mockReturnValue(false),
118 |       getOutputFormat: vi.fn().mockReturnValue('text'),
119 |       getFolderTrust: vi.fn().mockReturnValue(false),
120 |       isTrustedFolder: vi.fn().mockReturnValue(false),
121 |     } as unknown as Config;
122 | 
123 |     mockSettings = {
124 |       system: { path: '', settings: {} },
125 |       systemDefaults: { path: '', settings: {} },
126 |       user: { path: '', settings: {} },
127 |       workspace: { path: '', settings: {} },
128 |       errors: [],
129 |       setValue: vi.fn(),
130 |       merged: {
131 |         security: {
132 |           auth: {
133 |             enforcedType: undefined,
134 |           },
135 |         },
136 |       },
137 |       isTrusted: true,
138 |       migratedInMemorScopes: new Set(),
139 |       forScope: vi.fn(),
140 |       computeMergedSettings: vi.fn(),
141 |     } as unknown as LoadedSettings;
142 | 
143 |     const { handleAtCommand } = await import(
144 |       './ui/hooks/atCommandProcessor.js'
145 |     );
146 |     vi.mocked(handleAtCommand).mockImplementation(async ({ query }) => ({
147 |       processedQuery: [{ text: query }],
148 |       shouldProceed: true,
149 |     }));
150 |   });
151 | 
152 |   afterEach(() => {
153 |     vi.restoreAllMocks();
154 |   });
155 | 
156 |   async function* createStreamFromEvents(
157 |     events: ServerGeminiStreamEvent[],
158 |   ): AsyncGenerator<ServerGeminiStreamEvent> {
159 |     for (const event of events) {
160 |       yield event;
161 |     }
162 |   }
163 | 
164 |   it('should process input and write text output', async () => {
165 |     const events: ServerGeminiStreamEvent[] = [
166 |       { type: GeminiEventType.Content, value: 'Hello' },
167 |       { type: GeminiEventType.Content, value: ' World' },
168 |       {
169 |         type: GeminiEventType.Finished,
170 |         value: { reason: undefined, usageMetadata: { totalTokenCount: 10 } },
171 |       },
172 |     ];
173 |     mockGeminiClient.sendMessageStream.mockReturnValue(
174 |       createStreamFromEvents(events),
175 |     );
176 | 
177 |     await runNonInteractive(
178 |       mockConfig,
179 |       mockSettings,
180 |       'Test input',
181 |       'prompt-id-1',
182 |     );
183 | 
184 |     expect(mockGeminiClient.sendMessageStream).toHaveBeenCalledWith(
185 |       [{ text: 'Test input' }],
186 |       expect.any(AbortSignal),
187 |       'prompt-id-1',
188 |     );
189 |     expect(processStdoutSpy).toHaveBeenCalledWith('Hello');
190 |     expect(processStdoutSpy).toHaveBeenCalledWith(' World');
191 |     expect(processStdoutSpy).toHaveBeenCalledWith('\n');
192 |     expect(mockShutdownTelemetry).toHaveBeenCalled();
193 |   });
194 | 
195 |   it('should handle a single tool call and respond', async () => {
196 |     const toolCallEvent: ServerGeminiStreamEvent = {
197 |       type: GeminiEventType.ToolCallRequest,
198 |       value: {
199 |         callId: 'tool-1',
200 |         name: 'testTool',
201 |         args: { arg1: 'value1' },
202 |         isClientInitiated: false,
203 |         prompt_id: 'prompt-id-2',
204 |       },
205 |     };
206 |     const toolResponse: Part[] = [{ text: 'Tool response' }];
207 |     mockCoreExecuteToolCall.mockResolvedValue({ responseParts: toolResponse });
208 | 
209 |     const firstCallEvents: ServerGeminiStreamEvent[] = [toolCallEvent];
210 |     const secondCallEvents: ServerGeminiStreamEvent[] = [
211 |       { type: GeminiEventType.Content, value: 'Final answer' },
212 |       {
213 |         type: GeminiEventType.Finished,
214 |         value: { reason: undefined, usageMetadata: { totalTokenCount: 10 } },
215 |       },
216 |     ];
217 | 
218 |     mockGeminiClient.sendMessageStream
219 |       .mockReturnValueOnce(createStreamFromEvents(firstCallEvents))
220 |       .mockReturnValueOnce(createStreamFromEvents(secondCallEvents));
221 | 
222 |     await runNonInteractive(
223 |       mockConfig,
224 |       mockSettings,
225 |       'Use a tool',
226 |       'prompt-id-2',
227 |     );
228 | 
229 |     expect(mockGeminiClient.sendMessageStream).toHaveBeenCalledTimes(2);
230 |     expect(mockCoreExecuteToolCall).toHaveBeenCalledWith(
231 |       mockConfig,
232 |       expect.objectContaining({ name: 'testTool' }),
233 |       expect.any(AbortSignal),
234 |     );
235 |     expect(mockGeminiClient.sendMessageStream).toHaveBeenNthCalledWith(
236 |       2,
237 |       [{ text: 'Tool response' }],
238 |       expect.any(AbortSignal),
239 |       'prompt-id-2',
240 |     );
241 |     expect(processStdoutSpy).toHaveBeenCalledWith('Final answer');
242 |     expect(processStdoutSpy).toHaveBeenCalledWith('\n');
243 |   });
244 | 
245 |   it('should handle error during tool execution and should send error back to the model', async () => {
246 |     const toolCallEvent: ServerGeminiStreamEvent = {
247 |       type: GeminiEventType.ToolCallRequest,
248 |       value: {
249 |         callId: 'tool-1',
250 |         name: 'errorTool',
251 |         args: {},
252 |         isClientInitiated: false,
253 |         prompt_id: 'prompt-id-3',
254 |       },
255 |     };
256 |     mockCoreExecuteToolCall.mockResolvedValue({
257 |       error: new Error('Execution failed'),
258 |       errorType: ToolErrorType.EXECUTION_FAILED,
259 |       responseParts: [
260 |         {
261 |           functionResponse: {
262 |             name: 'errorTool',
263 |             response: {
264 |               output: 'Error: Execution failed',
265 |             },
266 |           },
267 |         },
268 |       ],
269 |       resultDisplay: 'Execution failed',
270 |     });
271 |     const finalResponse: ServerGeminiStreamEvent[] = [
272 |       {
273 |         type: GeminiEventType.Content,
274 |         value: 'Sorry, let me try again.',
275 |       },
276 |       {
277 |         type: GeminiEventType.Finished,
278 |         value: { reason: undefined, usageMetadata: { totalTokenCount: 10 } },
279 |       },
280 |     ];
281 |     mockGeminiClient.sendMessageStream
282 |       .mockReturnValueOnce(createStreamFromEvents([toolCallEvent]))
283 |       .mockReturnValueOnce(createStreamFromEvents(finalResponse));
284 | 
285 |     await runNonInteractive(
286 |       mockConfig,
287 |       mockSettings,
288 |       'Trigger tool error',
289 |       'prompt-id-3',
290 |     );
291 | 
292 |     expect(mockCoreExecuteToolCall).toHaveBeenCalled();
293 |     expect(consoleErrorSpy).toHaveBeenCalledWith(
294 |       'Error executing tool errorTool: Execution failed',
295 |     );
296 |     expect(mockGeminiClient.sendMessageStream).toHaveBeenCalledTimes(2);
297 |     expect(mockGeminiClient.sendMessageStream).toHaveBeenNthCalledWith(
298 |       2,
299 |       [
300 |         {
301 |           functionResponse: {
302 |             name: 'errorTool',
303 |             response: {
304 |               output: 'Error: Execution failed',
305 |             },
306 |           },
307 |         },
308 |       ],
309 |       expect.any(AbortSignal),
310 |       'prompt-id-3',
311 |     );
312 |     expect(processStdoutSpy).toHaveBeenCalledWith('Sorry, let me try again.');
313 |   });
314 | 
315 |   it('should exit with error if sendMessageStream throws initially', async () => {
316 |     const apiError = new Error('API connection failed');
317 |     mockGeminiClient.sendMessageStream.mockImplementation(() => {
318 |       throw apiError;
319 |     });
320 | 
321 |     await expect(
322 |       runNonInteractive(
323 |         mockConfig,
324 |         mockSettings,
325 |         'Initial fail',
326 |         'prompt-id-4',
327 |       ),
328 |     ).rejects.toThrow(apiError);
329 |   });
330 | 
331 |   it('should not exit if a tool is not found, and should send error back to model', async () => {
332 |     const toolCallEvent: ServerGeminiStreamEvent = {
333 |       type: GeminiEventType.ToolCallRequest,
334 |       value: {
335 |         callId: 'tool-1',
336 |         name: 'nonexistentTool',
337 |         args: {},
338 |         isClientInitiated: false,
339 |         prompt_id: 'prompt-id-5',
340 |       },
341 |     };
342 |     mockCoreExecuteToolCall.mockResolvedValue({
343 |       error: new Error('Tool "nonexistentTool" not found in registry.'),
344 |       resultDisplay: 'Tool "nonexistentTool" not found in registry.',
345 |       responseParts: [],
346 |     });
347 |     const finalResponse: ServerGeminiStreamEvent[] = [
348 |       {
349 |         type: GeminiEventType.Content,
350 |         value: "Sorry, I can't find that tool.",
351 |       },
352 |       {
353 |         type: GeminiEventType.Finished,
354 |         value: { reason: undefined, usageMetadata: { totalTokenCount: 10 } },
355 |       },
356 |     ];
357 | 
358 |     mockGeminiClient.sendMessageStream
359 |       .mockReturnValueOnce(createStreamFromEvents([toolCallEvent]))
360 |       .mockReturnValueOnce(createStreamFromEvents(finalResponse));
361 | 
362 |     await runNonInteractive(
363 |       mockConfig,
364 |       mockSettings,
365 |       'Trigger tool not found',
366 |       'prompt-id-5',
367 |     );
368 | 
369 |     expect(mockCoreExecuteToolCall).toHaveBeenCalled();
370 |     expect(consoleErrorSpy).toHaveBeenCalledWith(
371 |       'Error executing tool nonexistentTool: Tool "nonexistentTool" not found in registry.',
372 |     );
373 |     expect(mockGeminiClient.sendMessageStream).toHaveBeenCalledTimes(2);
374 |     expect(processStdoutSpy).toHaveBeenCalledWith(
375 |       "Sorry, I can't find that tool.",
376 |     );
377 |   });
378 | 
379 |   it('should exit when max session turns are exceeded', async () => {
380 |     vi.mocked(mockConfig.getMaxSessionTurns).mockReturnValue(0);
381 |     await expect(
382 |       runNonInteractive(
383 |         mockConfig,
384 |         mockSettings,
385 |         'Trigger loop',
386 |         'prompt-id-6',
387 |       ),
388 |     ).rejects.toThrow('process.exit(53) called');
389 |   });
390 | 
391 |   it('should preprocess @include commands before sending to the model', async () => {
392 |     // 1. Mock the imported atCommandProcessor
393 |     const { handleAtCommand } = await import(
394 |       './ui/hooks/atCommandProcessor.js'
395 |     );
396 |     const mockHandleAtCommand = vi.mocked(handleAtCommand);
397 | 
398 |     // 2. Define the raw input and the expected processed output
399 |     const rawInput = 'Summarize @file.txt';
400 |     const processedParts: Part[] = [
401 |       { text: 'Summarize @file.txt' },
402 |       { text: '\n--- Content from referenced files ---\n' },
403 |       { text: 'This is the content of the file.' },
404 |       { text: '\n--- End of content ---' },
405 |     ];
406 | 
407 |     // 3. Setup the mock to return the processed parts
408 |     mockHandleAtCommand.mockResolvedValue({
409 |       processedQuery: processedParts,
410 |       shouldProceed: true,
411 |     });
412 | 
413 |     // Mock a simple stream response from the Gemini client
414 |     const events: ServerGeminiStreamEvent[] = [
415 |       { type: GeminiEventType.Content, value: 'Summary complete.' },
416 |       {
[TRUNCATED]
```

src/nonInteractiveCli.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type { Config, ToolCallRequestInfo } from '@google/gemini-cli-core';
8 | import { isSlashCommand } from './ui/utils/commandUtils.js';
9 | import type { LoadedSettings } from './config/settings.js';
10 | import {
11 |   executeToolCall,
12 |   shutdownTelemetry,
13 |   isTelemetrySdkInitialized,
14 |   GeminiEventType,
15 |   FatalInputError,
16 |   promptIdContext,
17 |   OutputFormat,
18 |   JsonFormatter,
19 |   uiTelemetryService,
20 | } from '@google/gemini-cli-core';
21 | 
22 | import type { Content, Part } from '@google/genai';
23 | 
24 | import { handleSlashCommand } from './nonInteractiveCliCommands.js';
25 | import { ConsolePatcher } from './ui/utils/ConsolePatcher.js';
26 | import { handleAtCommand } from './ui/hooks/atCommandProcessor.js';
27 | import {
28 |   handleError,
29 |   handleToolError,
30 |   handleCancellationError,
31 |   handleMaxTurnsExceededError,
32 | } from './utils/errors.js';
33 | 
34 | export async function runNonInteractive(
35 |   config: Config,
36 |   settings: LoadedSettings,
37 |   input: string,
38 |   prompt_id: string,
39 | ): Promise<void> {
40 |   return promptIdContext.run(prompt_id, async () => {
41 |     const consolePatcher = new ConsolePatcher({
42 |       stderr: true,
43 |       debugMode: config.getDebugMode(),
44 |     });
45 | 
46 |     try {
47 |       consolePatcher.patch();
48 |       // Handle EPIPE errors when the output is piped to a command that closes early.
49 |       process.stdout.on('error', (err: NodeJS.ErrnoException) => {
50 |         if (err.code === 'EPIPE') {
51 |           // Exit gracefully if the pipe is closed.
52 |           process.exit(0);
53 |         }
54 |       });
55 | 
56 |       const geminiClient = config.getGeminiClient();
57 | 
58 |       const abortController = new AbortController();
59 | 
60 |       let query: Part[] | undefined;
61 | 
62 |       if (isSlashCommand(input)) {
63 |         const slashCommandResult = await handleSlashCommand(
64 |           input,
65 |           abortController,
66 |           config,
67 |           settings,
68 |         );
69 |         // If a slash command is found and returns a prompt, use it.
70 |         // Otherwise, slashCommandResult fall through to the default prompt
71 |         // handling.
72 |         if (slashCommandResult) {
73 |           query = slashCommandResult as Part[];
74 |         }
75 |       }
76 | 
77 |       if (!query) {
78 |         const { processedQuery, shouldProceed } = await handleAtCommand({
79 |           query: input,
80 |           config,
81 |           addItem: (_item, _timestamp) => 0,
82 |           onDebugMessage: () => {},
83 |           messageId: Date.now(),
84 |           signal: abortController.signal,
85 |         });
86 | 
87 |         if (!shouldProceed || !processedQuery) {
88 |           // An error occurred during @include processing (e.g., file not found).
89 |           // The error message is already logged by handleAtCommand.
90 |           throw new FatalInputError(
91 |             'Exiting due to an error processing the @ command.',
92 |           );
93 |         }
94 |         query = processedQuery as Part[];
95 |       }
96 | 
97 |       let currentMessages: Content[] = [{ role: 'user', parts: query }];
98 | 
99 |       let turnCount = 0;
100 |       while (true) {
101 |         turnCount++;
102 |         if (
103 |           config.getMaxSessionTurns() >= 0 &&
104 |           turnCount > config.getMaxSessionTurns()
105 |         ) {
106 |           handleMaxTurnsExceededError(config);
107 |         }
108 |         const toolCallRequests: ToolCallRequestInfo[] = [];
109 | 
110 |         const responseStream = geminiClient.sendMessageStream(
111 |           currentMessages[0]?.parts || [],
112 |           abortController.signal,
113 |           prompt_id,
114 |         );
115 | 
116 |         let responseText = '';
117 |         for await (const event of responseStream) {
118 |           if (abortController.signal.aborted) {
119 |             handleCancellationError(config);
120 |           }
121 | 
122 |           if (event.type === GeminiEventType.Content) {
123 |             if (config.getOutputFormat() === OutputFormat.JSON) {
124 |               responseText += event.value;
125 |             } else {
126 |               process.stdout.write(event.value);
127 |             }
128 |           } else if (event.type === GeminiEventType.ToolCallRequest) {
129 |             toolCallRequests.push(event.value);
130 |           }
131 |         }
132 | 
133 |         if (toolCallRequests.length > 0) {
134 |           const toolResponseParts: Part[] = [];
135 |           for (const requestInfo of toolCallRequests) {
136 |             const toolResponse = await executeToolCall(
137 |               config,
138 |               requestInfo,
139 |               abortController.signal,
140 |             );
141 | 
142 |             if (toolResponse.error) {
143 |               handleToolError(
144 |                 requestInfo.name,
145 |                 toolResponse.error,
146 |                 config,
147 |                 toolResponse.errorType || 'TOOL_EXECUTION_ERROR',
148 |                 typeof toolResponse.resultDisplay === 'string'
149 |                   ? toolResponse.resultDisplay
150 |                   : undefined,
151 |               );
152 |             }
153 | 
154 |             if (toolResponse.responseParts) {
155 |               toolResponseParts.push(...toolResponse.responseParts);
156 |             }
157 |           }
158 |           currentMessages = [{ role: 'user', parts: toolResponseParts }];
159 |         } else {
160 |           if (config.getOutputFormat() === OutputFormat.JSON) {
161 |             const formatter = new JsonFormatter();
162 |             const stats = uiTelemetryService.getMetrics();
163 |             process.stdout.write(formatter.format(responseText, stats));
164 |           } else {
165 |             process.stdout.write('\n'); // Ensure a final newline
166 |           }
167 |           return;
168 |         }
169 |       }
170 |     } catch (error) {
171 |       handleError(error, config);
172 |     } finally {
173 |       consolePatcher.cleanup();
174 |       if (isTelemetrySdkInitialized()) {
175 |         await shutdownTelemetry(config);
176 |       }
177 |     }
178 |   });
179 | }
```

src/nonInteractiveCliCommands.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type { PartListUnion } from '@google/genai';
8 | import { parseSlashCommand } from './utils/commands.js';
9 | import {
10 |   FatalInputError,
11 |   Logger,
12 |   uiTelemetryService,
13 |   type Config,
14 | } from '@google/gemini-cli-core';
15 | import { CommandService } from './services/CommandService.js';
16 | import { FileCommandLoader } from './services/FileCommandLoader.js';
17 | import type { CommandContext } from './ui/commands/types.js';
18 | import { createNonInteractiveUI } from './ui/noninteractive/nonInteractiveUi.js';
19 | import type { LoadedSettings } from './config/settings.js';
20 | import type { SessionStatsState } from './ui/contexts/SessionContext.js';
21 | 
22 | /**
23 |  * Processes a slash command in a non-interactive environment.
24 |  *
25 |  * @returns A Promise that resolves to `PartListUnion` if a valid command is
26 |  *   found and results in a prompt, or `undefined` otherwise.
27 |  * @throws {FatalInputError} if the command result is not supported in
28 |  *   non-interactive mode.
29 |  */
30 | export const handleSlashCommand = async (
31 |   rawQuery: string,
32 |   abortController: AbortController,
33 |   config: Config,
34 |   settings: LoadedSettings,
35 | ): Promise<PartListUnion | undefined> => {
36 |   const trimmed = rawQuery.trim();
37 |   if (!trimmed.startsWith('/')) {
38 |     return;
39 |   }
40 | 
41 |   // Only custom commands are supported for now.
42 |   const loaders = [new FileCommandLoader(config)];
43 |   const commandService = await CommandService.create(
44 |     loaders,
45 |     abortController.signal,
46 |   );
47 |   const commands = commandService.getCommands();
48 | 
49 |   const { commandToExecute, args } = parseSlashCommand(rawQuery, commands);
50 | 
51 |   if (commandToExecute) {
52 |     if (commandToExecute.action) {
53 |       // Not used by custom commands but may be in the future.
54 |       const sessionStats: SessionStatsState = {
55 |         sessionId: config?.getSessionId(),
56 |         sessionStartTime: new Date(),
57 |         metrics: uiTelemetryService.getMetrics(),
58 |         lastPromptTokenCount: 0,
59 |         promptCount: 1,
60 |       };
61 | 
62 |       const logger = new Logger(config?.getSessionId() || '', config?.storage);
63 | 
64 |       const context: CommandContext = {
65 |         services: {
66 |           config,
67 |           settings,
68 |           git: undefined,
69 |           logger,
70 |         },
71 |         ui: createNonInteractiveUI(),
72 |         session: {
73 |           stats: sessionStats,
74 |           sessionShellAllowlist: new Set(),
75 |         },
76 |         invocation: {
77 |           raw: trimmed,
78 |           name: commandToExecute.name,
79 |           args,
80 |         },
81 |       };
82 | 
83 |       const result = await commandToExecute.action(context, args);
84 | 
85 |       if (result) {
86 |         switch (result.type) {
87 |           case 'submit_prompt':
88 |             return result.content;
89 |           case 'confirm_shell_commands':
90 |             // This result indicates a command attempted to confirm shell commands.
91 |             // However note that currently, ShellTool is excluded in non-interactive
92 |             // mode unless 'YOLO mode' is active, so confirmation actually won't
93 |             // occur because of YOLO mode.
94 |             // This ensures that if a command *does* request confirmation (e.g.
95 |             // in the future with more granular permissions), it's handled appropriately.
96 |             throw new FatalInputError(
97 |               'Exiting due to a confirmation prompt requested by the command.',
98 |             );
99 |           default:
100 |             throw new FatalInputError(
101 |               'Exiting due to command result that is not supported in non-interactive mode.',
102 |             );
103 |         }
104 |       }
105 |     }
106 |   }
107 | 
108 |   return;
109 | };
```

src/validateNonInterActiveAuth.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
8 | import { validateNonInteractiveAuth } from './validateNonInterActiveAuth.js';
9 | import { AuthType, OutputFormat } from '@google/gemini-cli-core';
10 | import type { Config } from '@google/gemini-cli-core';
11 | import * as auth from './config/auth.js';
12 | import { type LoadedSettings } from './config/settings.js';
13 | 
14 | describe('validateNonInterActiveAuth', () => {
15 |   let originalEnvGeminiApiKey: string | undefined;
16 |   let originalEnvVertexAi: string | undefined;
17 |   let originalEnvGcp: string | undefined;
18 |   let consoleErrorSpy: ReturnType<typeof vi.spyOn>;
19 |   let processExitSpy: ReturnType<typeof vi.spyOn>;
20 |   let refreshAuthMock: vi.Mock;
21 |   let mockSettings: LoadedSettings;
22 | 
23 |   beforeEach(() => {
24 |     originalEnvGeminiApiKey = process.env['GEMINI_API_KEY'];
25 |     originalEnvVertexAi = process.env['GOOGLE_GENAI_USE_VERTEXAI'];
26 |     originalEnvGcp = process.env['GOOGLE_GENAI_USE_GCA'];
27 |     delete process.env['GEMINI_API_KEY'];
28 |     delete process.env['GOOGLE_GENAI_USE_VERTEXAI'];
29 |     delete process.env['GOOGLE_GENAI_USE_GCA'];
30 |     consoleErrorSpy = vi.spyOn(console, 'error').mockImplementation(() => {});
31 |     processExitSpy = vi.spyOn(process, 'exit').mockImplementation((code) => {
32 |       throw new Error(`process.exit(${code}) called`);
33 |     });
34 |     vi.spyOn(auth, 'validateAuthMethod').mockReturnValue(null);
35 |     refreshAuthMock = vi.fn().mockResolvedValue('refreshed');
36 |     mockSettings = {
37 |       system: { path: '', settings: {} },
38 |       systemDefaults: { path: '', settings: {} },
39 |       user: { path: '', settings: {} },
40 |       workspace: { path: '', settings: {} },
41 |       errors: [],
42 |       setValue: vi.fn(),
43 |       merged: {
44 |         security: {
45 |           auth: {
46 |             enforcedType: undefined,
47 |           },
48 |         },
49 |       },
50 |       isTrusted: true,
51 |       migratedInMemorScopes: new Set(),
52 |       forScope: vi.fn(),
53 |       computeMergedSettings: vi.fn(),
54 |     } as unknown as LoadedSettings;
55 |   });
56 | 
57 |   afterEach(() => {
58 |     if (originalEnvGeminiApiKey !== undefined) {
59 |       process.env['GEMINI_API_KEY'] = originalEnvGeminiApiKey;
60 |     } else {
61 |       delete process.env['GEMINI_API_KEY'];
62 |     }
63 |     if (originalEnvVertexAi !== undefined) {
64 |       process.env['GOOGLE_GENAI_USE_VERTEXAI'] = originalEnvVertexAi;
65 |     } else {
66 |       delete process.env['GOOGLE_GENAI_USE_VERTEXAI'];
67 |     }
68 |     if (originalEnvGcp !== undefined) {
69 |       process.env['GOOGLE_GENAI_USE_GCA'] = originalEnvGcp;
70 |     } else {
71 |       delete process.env['GOOGLE_GENAI_USE_GCA'];
72 |     }
73 |     vi.restoreAllMocks();
74 |   });
75 | 
76 |   it('exits if no auth type is configured or env vars set', async () => {
77 |     const nonInteractiveConfig = {
78 |       refreshAuth: refreshAuthMock,
79 |       getOutputFormat: vi.fn().mockReturnValue(OutputFormat.TEXT),
80 |       getContentGeneratorConfig: vi
81 |         .fn()
82 |         .mockReturnValue({ authType: undefined }),
83 |     };
84 |     try {
85 |       await validateNonInteractiveAuth(
86 |         undefined,
87 |         undefined,
88 |         nonInteractiveConfig,
89 |         mockSettings,
90 |       );
91 |       expect.fail('Should have exited');
92 |     } catch (e) {
93 |       expect((e as Error).message).toContain('process.exit(1) called');
94 |     }
95 |     expect(consoleErrorSpy).toHaveBeenCalledWith(
96 |       expect.stringContaining('Please set an Auth method'),
97 |     );
98 |     expect(processExitSpy).toHaveBeenCalledWith(1);
99 |   });
100 | 
101 |   it('uses LOGIN_WITH_GOOGLE if GOOGLE_GENAI_USE_GCA is set', async () => {
102 |     process.env['GOOGLE_GENAI_USE_GCA'] = 'true';
103 |     const nonInteractiveConfig = {
104 |       refreshAuth: refreshAuthMock,
105 |     };
106 |     await validateNonInteractiveAuth(
107 |       undefined,
108 |       undefined,
109 |       nonInteractiveConfig,
110 |       mockSettings,
111 |     );
112 |     expect(refreshAuthMock).toHaveBeenCalledWith(AuthType.LOGIN_WITH_GOOGLE);
113 |   });
114 | 
115 |   it('uses USE_GEMINI if GEMINI_API_KEY is set', async () => {
116 |     process.env['GEMINI_API_KEY'] = 'fake-key';
117 |     const nonInteractiveConfig = {
118 |       refreshAuth: refreshAuthMock,
119 |     };
120 |     await validateNonInteractiveAuth(
121 |       undefined,
122 |       undefined,
123 |       nonInteractiveConfig,
124 |       mockSettings,
125 |     );
126 |     expect(refreshAuthMock).toHaveBeenCalledWith(AuthType.USE_GEMINI);
127 |   });
128 | 
129 |   it('uses USE_VERTEX_AI if GOOGLE_GENAI_USE_VERTEXAI is true (with GOOGLE_CLOUD_PROJECT and GOOGLE_CLOUD_LOCATION)', async () => {
130 |     process.env['GOOGLE_GENAI_USE_VERTEXAI'] = 'true';
131 |     process.env['GOOGLE_CLOUD_PROJECT'] = 'test-project';
132 |     process.env['GOOGLE_CLOUD_LOCATION'] = 'us-central1';
133 |     const nonInteractiveConfig = {
134 |       refreshAuth: refreshAuthMock,
135 |     };
136 |     await validateNonInteractiveAuth(
137 |       undefined,
138 |       undefined,
139 |       nonInteractiveConfig,
140 |       mockSettings,
141 |     );
142 |     expect(refreshAuthMock).toHaveBeenCalledWith(AuthType.USE_VERTEX_AI);
143 |   });
144 | 
145 |   it('uses USE_VERTEX_AI if GOOGLE_GENAI_USE_VERTEXAI is true and GOOGLE_API_KEY is set', async () => {
146 |     process.env['GOOGLE_GENAI_USE_VERTEXAI'] = 'true';
147 |     process.env['GOOGLE_API_KEY'] = 'vertex-api-key';
148 |     const nonInteractiveConfig = {
149 |       refreshAuth: refreshAuthMock,
150 |     };
151 |     await validateNonInteractiveAuth(
152 |       undefined,
153 |       undefined,
154 |       nonInteractiveConfig,
155 |       mockSettings,
156 |     );
157 |     expect(refreshAuthMock).toHaveBeenCalledWith(AuthType.USE_VERTEX_AI);
158 |   });
159 | 
160 |   it('uses LOGIN_WITH_GOOGLE if GOOGLE_GENAI_USE_GCA is set, even with other env vars', async () => {
161 |     process.env['GOOGLE_GENAI_USE_GCA'] = 'true';
162 |     process.env['GEMINI_API_KEY'] = 'fake-key';
163 |     process.env['GOOGLE_GENAI_USE_VERTEXAI'] = 'true';
164 |     process.env['GOOGLE_CLOUD_PROJECT'] = 'test-project';
165 |     process.env['GOOGLE_CLOUD_LOCATION'] = 'us-central1';
166 |     const nonInteractiveConfig = {
167 |       refreshAuth: refreshAuthMock,
168 |     };
169 |     await validateNonInteractiveAuth(
170 |       undefined,
171 |       undefined,
172 |       nonInteractiveConfig,
173 |       mockSettings,
174 |     );
175 |     expect(refreshAuthMock).toHaveBeenCalledWith(AuthType.LOGIN_WITH_GOOGLE);
176 |   });
177 | 
178 |   it('uses USE_VERTEX_AI if both GEMINI_API_KEY and GOOGLE_GENAI_USE_VERTEXAI are set', async () => {
179 |     process.env['GEMINI_API_KEY'] = 'fake-key';
180 |     process.env['GOOGLE_GENAI_USE_VERTEXAI'] = 'true';
181 |     process.env['GOOGLE_CLOUD_PROJECT'] = 'test-project';
182 |     process.env['GOOGLE_CLOUD_LOCATION'] = 'us-central1';
183 |     const nonInteractiveConfig = {
184 |       refreshAuth: refreshAuthMock,
185 |     };
186 |     await validateNonInteractiveAuth(
187 |       undefined,
188 |       undefined,
189 |       nonInteractiveConfig,
190 |       mockSettings,
191 |     );
192 |     expect(refreshAuthMock).toHaveBeenCalledWith(AuthType.USE_VERTEX_AI);
193 |   });
194 | 
195 |   it('uses USE_GEMINI if GOOGLE_GENAI_USE_VERTEXAI is false, GEMINI_API_KEY is set, and project/location are available', async () => {
196 |     process.env['GOOGLE_GENAI_USE_VERTEXAI'] = 'false';
197 |     process.env['GEMINI_API_KEY'] = 'fake-key';
198 |     process.env['GOOGLE_CLOUD_PROJECT'] = 'test-project';
199 |     process.env['GOOGLE_CLOUD_LOCATION'] = 'us-central1';
200 |     const nonInteractiveConfig = {
201 |       refreshAuth: refreshAuthMock,
202 |     };
203 |     await validateNonInteractiveAuth(
204 |       undefined,
205 |       undefined,
206 |       nonInteractiveConfig,
207 |       mockSettings,
208 |     );
209 |     expect(refreshAuthMock).toHaveBeenCalledWith(AuthType.USE_GEMINI);
210 |   });
211 | 
212 |   it('uses configuredAuthType over environment variables', async () => {
213 |     process.env['GEMINI_API_KEY'] = 'fake-key';
214 |     const nonInteractiveConfig = {
215 |       refreshAuth: refreshAuthMock,
216 |     };
217 |     await validateNonInteractiveAuth(
218 |       AuthType.LOGIN_WITH_GOOGLE,
219 |       undefined,
220 |       nonInteractiveConfig,
221 |       mockSettings,
222 |     );
223 |     expect(refreshAuthMock).toHaveBeenCalledWith(AuthType.LOGIN_WITH_GOOGLE);
224 |   });
225 | 
226 |   it('exits if validateAuthMethod returns error', async () => {
227 |     // Mock validateAuthMethod to return error
228 |     vi.spyOn(auth, 'validateAuthMethod').mockReturnValue('Auth error!');
229 |     const nonInteractiveConfig = {
230 |       refreshAuth: refreshAuthMock,
231 |       getOutputFormat: vi.fn().mockReturnValue(OutputFormat.TEXT),
232 |       getContentGeneratorConfig: vi
233 |         .fn()
234 |         .mockReturnValue({ authType: undefined }),
235 |     };
236 |     try {
237 |       await validateNonInteractiveAuth(
238 |         AuthType.USE_GEMINI,
239 |         undefined,
240 |         nonInteractiveConfig,
241 |         mockSettings,
242 |       );
243 |       expect.fail('Should have exited');
244 |     } catch (e) {
245 |       expect((e as Error).message).toContain('process.exit(1) called');
246 |     }
247 |     expect(consoleErrorSpy).toHaveBeenCalledWith('Auth error!');
248 |     expect(processExitSpy).toHaveBeenCalledWith(1);
249 |   });
250 | 
251 |   it('skips validation if useExternalAuth is true', async () => {
252 |     // Mock validateAuthMethod to return error to ensure it's not being called
253 |     const validateAuthMethodSpy = vi
254 |       .spyOn(auth, 'validateAuthMethod')
255 |       .mockReturnValue('Auth error!');
256 |     const nonInteractiveConfig = {
257 |       refreshAuth: refreshAuthMock,
258 |     };
259 | 
260 |     // Even with an invalid auth type, it should not exit
261 |     // because validation is skipped.
262 |     await validateNonInteractiveAuth(
263 |       'invalid-auth-type' as AuthType,
264 |       true, // useExternalAuth = true
265 |       nonInteractiveConfig,
266 |       mockSettings,
267 |     );
268 | 
269 |     expect(validateAuthMethodSpy).not.toHaveBeenCalled();
270 |     expect(consoleErrorSpy).not.toHaveBeenCalled();
271 |     expect(processExitSpy).not.toHaveBeenCalled();
272 |     // We still expect refreshAuth to be called with the (invalid) type
273 |     expect(refreshAuthMock).toHaveBeenCalledWith('invalid-auth-type');
274 |   });
275 | 
276 |   it('succeeds if effectiveAuthType matches enforcedAuthType', async () => {
277 |     mockSettings.merged.security.auth.enforcedType = AuthType.USE_GEMINI;
278 |     process.env['GEMINI_API_KEY'] = 'fake-key';
279 |     const nonInteractiveConfig = {
280 |       refreshAuth: refreshAuthMock,
281 |     };
282 |     await validateNonInteractiveAuth(
283 |       undefined,
284 |       undefined,
285 |       nonInteractiveConfig,
286 |       mockSettings,
287 |     );
288 |     expect(refreshAuthMock).toHaveBeenCalledWith(AuthType.USE_GEMINI);
289 |   });
290 | 
291 |   it('exits if configuredAuthType does not match enforcedAuthType', async () => {
292 |     mockSettings.merged.security.auth.enforcedType = AuthType.LOGIN_WITH_GOOGLE;
293 |     const nonInteractiveConfig = {
294 |       refreshAuth: refreshAuthMock,
295 |       getOutputFormat: vi.fn().mockReturnValue(OutputFormat.TEXT),
296 |     };
297 |     try {
298 |       await validateNonInteractiveAuth(
299 |         AuthType.USE_GEMINI,
300 |         undefined,
301 |         nonInteractiveConfig,
302 |         mockSettings,
303 |       );
304 |       expect.fail('Should have exited');
305 |     } catch (e) {
306 |       expect((e as Error).message).toContain('process.exit(1) called');
307 |     }
308 |     expect(consoleErrorSpy).toHaveBeenCalledWith(
309 |       "The enforced authentication type is 'oauth-personal', but the current type is 'gemini-api-key'. Please re-authenticate with the correct type.",
310 |     );
311 |     expect(processExitSpy).toHaveBeenCalledWith(1);
312 |   });
313 | 
314 |   it('exits if auth from env var does not match enforcedAuthType', async () => {
315 |     mockSettings.merged.security.auth.enforcedType = AuthType.LOGIN_WITH_GOOGLE;
316 |     process.env['GEMINI_API_KEY'] = 'fake-key';
317 |     const nonInteractiveConfig = {
318 |       refreshAuth: refreshAuthMock,
319 |       getOutputFormat: vi.fn().mockReturnValue(OutputFormat.TEXT),
320 |     };
321 |     try {
322 |       await validateNonInteractiveAuth(
323 |         undefined,
324 |         undefined,
325 |         nonInteractiveConfig,
326 |         mockSettings,
327 |       );
328 |       expect.fail('Should have exited');
329 |     } catch (e) {
330 |       expect((e as Error).message).toContain('process.exit(1) called');
331 |     }
332 |     expect(consoleErrorSpy).toHaveBeenCalledWith(
333 |       "The enforced authentication type is 'oauth-personal', but the current type is 'gemini-api-key'. Please re-authenticate with the correct type.",
334 |     );
335 |     expect(processExitSpy).toHaveBeenCalledWith(1);
336 |   });
337 | 
338 |   describe('JSON output mode', () => {
339 |     it('prints JSON error when no auth is configured and exits with code 1', async () => {
340 |       const nonInteractiveConfig = {
341 |         refreshAuth: refreshAuthMock,
342 |         getOutputFormat: vi.fn().mockReturnValue(OutputFormat.JSON),
343 |         getContentGeneratorConfig: vi
344 |           .fn()
345 |           .mockReturnValue({ authType: undefined }),
346 |       };
347 | 
348 |       let thrown: Error | undefined;
[TRUNCATED]
```

src/validateNonInterActiveAuth.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type { Config } from '@google/gemini-cli-core';
8 | import { AuthType, OutputFormat } from '@google/gemini-cli-core';
9 | import { USER_SETTINGS_PATH } from './config/settings.js';
10 | import { validateAuthMethod } from './config/auth.js';
11 | import { type LoadedSettings } from './config/settings.js';
12 | import { handleError } from './utils/errors.js';
13 | 
14 | function getAuthTypeFromEnv(): AuthType | undefined {
15 |   if (process.env['GOOGLE_GENAI_USE_GCA'] === 'true') {
16 |     return AuthType.LOGIN_WITH_GOOGLE;
17 |   }
18 |   if (process.env['GOOGLE_GENAI_USE_VERTEXAI'] === 'true') {
19 |     return AuthType.USE_VERTEX_AI;
20 |   }
21 |   if (process.env['GEMINI_API_KEY']) {
22 |     return AuthType.USE_GEMINI;
23 |   }
24 |   return undefined;
25 | }
26 | 
27 | export async function validateNonInteractiveAuth(
28 |   configuredAuthType: AuthType | undefined,
29 |   useExternalAuth: boolean | undefined,
30 |   nonInteractiveConfig: Config,
31 |   settings: LoadedSettings,
32 | ) {
33 |   try {
34 |     const effectiveAuthType = configuredAuthType || getAuthTypeFromEnv();
35 | 
36 |     const enforcedType = settings.merged.security?.auth?.enforcedType;
37 |     if (enforcedType && effectiveAuthType !== enforcedType) {
38 |       const message = effectiveAuthType
39 |         ? `The enforced authentication type is '${enforcedType}', but the current type is '${effectiveAuthType}'. Please re-authenticate with the correct type.`
40 |         : `The auth type '${enforcedType}' is enforced, but no authentication is configured.`;
41 |       throw new Error(message);
42 |     }
43 | 
44 |     if (!effectiveAuthType) {
45 |       const message = `Please set an Auth method in your ${USER_SETTINGS_PATH} or specify one of the following environment variables before running: GEMINI_API_KEY, GOOGLE_GENAI_USE_VERTEXAI, GOOGLE_GENAI_USE_GCA`;
46 |       throw new Error(message);
47 |     }
48 | 
49 |     const authType: AuthType = effectiveAuthType as AuthType;
50 | 
51 |     if (!useExternalAuth) {
52 |       const err = validateAuthMethod(String(authType));
53 |       if (err != null) {
54 |         throw new Error(err);
55 |       }
56 |     }
57 | 
58 |     await nonInteractiveConfig.refreshAuth(authType);
59 |     return nonInteractiveConfig;
60 |   } catch (error) {
61 |     if (nonInteractiveConfig.getOutputFormat() === OutputFormat.JSON) {
62 |       handleError(
63 |         error instanceof Error ? error : new Error(String(error)),
64 |         nonInteractiveConfig,
65 |         1,
66 |       );
67 |     } else {
68 |       console.error(error instanceof Error ? error.message : String(error));
69 |       process.exit(1);
70 |     }
71 |   }
72 | }
```

src/patches/is-in-ci.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | // This is a replacement for the `is-in-ci` package that always returns false.
8 | // We are doing this to avoid the issue where `ink` does not render the UI
9 | // when it detects that it is running in a CI environment.
10 | // This is safe because `ink` (and thus `is-in-ci`) is only used in the
11 | // interactive code path of the CLI.
12 | // See issue #1563 for more details.
13 | 
14 | const isInCi = false;
15 | 
16 | // eslint-disable-next-line import/no-default-export
17 | export default isInCi;
```

src/commands/extensions.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type { CommandModule } from 'yargs';
8 | import { installCommand } from './extensions/install.js';
9 | import { uninstallCommand } from './extensions/uninstall.js';
10 | import { listCommand } from './extensions/list.js';
11 | import { updateCommand } from './extensions/update.js';
12 | import { disableCommand } from './extensions/disable.js';
13 | import { enableCommand } from './extensions/enable.js';
14 | import { linkCommand } from './extensions/link.js';
15 | import { newCommand } from './extensions/new.js';
16 | 
17 | export const extensionsCommand: CommandModule = {
18 |   command: 'extensions <command>',
19 |   describe: 'Manage Gemini CLI extensions.',
20 |   builder: (yargs) =>
21 |     yargs
22 |       .command(installCommand)
23 |       .command(uninstallCommand)
24 |       .command(listCommand)
25 |       .command(updateCommand)
26 |       .command(disableCommand)
27 |       .command(enableCommand)
28 |       .command(linkCommand)
29 |       .command(newCommand)
30 |       .demandCommand(1, 'You need at least one command before continuing.')
31 |       .version(false),
32 |   handler: () => {
33 |     // This handler is not called when a subcommand is provided.
34 |     // Yargs will show the help menu.
35 |   },
36 | };
```

src/commands/mcp.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect, vi } from 'vitest';
8 | import { mcpCommand } from './mcp.js';
9 | import { type Argv } from 'yargs';
10 | import yargs from 'yargs';
11 | 
12 | describe('mcp command', () => {
13 |   it('should have correct command definition', () => {
14 |     expect(mcpCommand.command).toBe('mcp');
15 |     expect(mcpCommand.describe).toBe('Manage MCP servers');
16 |     expect(typeof mcpCommand.builder).toBe('function');
17 |     expect(typeof mcpCommand.handler).toBe('function');
18 |   });
19 | 
20 |   it('should have exactly one option (help flag)', () => {
21 |     // Test to ensure that the global 'gemini' flags are not added to the mcp command
22 |     const yargsInstance = yargs();
23 |     const builtYargs = mcpCommand.builder(yargsInstance);
24 |     const options = builtYargs.getOptions();
25 | 
26 |     // Should have exactly 1 option (help flag)
27 |     expect(Object.keys(options.key).length).toBe(1);
28 |     expect(options.key).toHaveProperty('help');
29 |   });
30 | 
31 |   it('should register add, remove, and list subcommands', () => {
32 |     const mockYargs = {
33 |       command: vi.fn().mockReturnThis(),
34 |       demandCommand: vi.fn().mockReturnThis(),
35 |       version: vi.fn().mockReturnThis(),
36 |     };
37 | 
38 |     mcpCommand.builder(mockYargs as unknown as Argv);
39 | 
40 |     expect(mockYargs.command).toHaveBeenCalledTimes(3);
41 | 
42 |     // Verify that the specific subcommands are registered
43 |     const commandCalls = mockYargs.command.mock.calls;
44 |     const commandNames = commandCalls.map((call) => call[0].command);
45 | 
46 |     expect(commandNames).toContain('add <name> <commandOrUrl> [args...]');
47 |     expect(commandNames).toContain('remove <name>');
48 |     expect(commandNames).toContain('list');
49 | 
50 |     expect(mockYargs.demandCommand).toHaveBeenCalledWith(
51 |       1,
52 |       'You need at least one command before continuing.',
53 |     );
54 |   });
55 | });
```

src/commands/mcp.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | // File for 'gemini mcp' command
8 | import type { CommandModule, Argv } from 'yargs';
9 | import { addCommand } from './mcp/add.js';
10 | import { removeCommand } from './mcp/remove.js';
11 | import { listCommand } from './mcp/list.js';
12 | 
13 | export const mcpCommand: CommandModule = {
14 |   command: 'mcp',
15 |   describe: 'Manage MCP servers',
16 |   builder: (yargs: Argv) =>
17 |     yargs
18 |       .command(addCommand)
19 |       .command(removeCommand)
20 |       .command(listCommand)
21 |       .demandCommand(1, 'You need at least one command before continuing.')
22 |       .version(false),
23 |   handler: () => {
24 |     // yargs will automatically show help if no subcommand is provided
25 |     // thanks to demandCommand(1) in the builder.
26 |   },
27 | };
```

src/core/auth.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import {
8 |   type AuthType,
9 |   type Config,
10 |   getErrorMessage,
11 | } from '@google/gemini-cli-core';
12 | 
13 | /**
14 |  * Handles the initial authentication flow.
15 |  * @param config The application config.
16 |  * @param authType The selected auth type.
17 |  * @returns An error message if authentication fails, otherwise null.
18 |  */
19 | export async function performInitialAuth(
20 |   config: Config,
21 |   authType: AuthType | undefined,
22 | ): Promise<string | null> {
23 |   if (!authType) {
24 |     return null;
25 |   }
26 | 
27 |   try {
28 |     await config.refreshAuth(authType);
29 |     // The console.log is intentionally left out here.
30 |     // We can add a dedicated startup message later if needed.
31 |   } catch (e) {
32 |     return `Failed to login. Message: ${getErrorMessage(e)}`;
33 |   }
34 | 
35 |   return null;
36 | }
```

src/core/initializer.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import {
8 |   IdeClient,
9 |   IdeConnectionEvent,
10 |   IdeConnectionType,
11 |   logIdeConnection,
12 |   type Config,
13 | } from '@google/gemini-cli-core';
14 | import { type LoadedSettings } from '../config/settings.js';
15 | import { performInitialAuth } from './auth.js';
16 | import { validateTheme } from './theme.js';
17 | 
18 | export interface InitializationResult {
19 |   authError: string | null;
20 |   themeError: string | null;
21 |   shouldOpenAuthDialog: boolean;
22 |   geminiMdFileCount: number;
23 | }
24 | 
25 | /**
26 |  * Orchestrates the application's startup initialization.
27 |  * This runs BEFORE the React UI is rendered.
28 |  * @param config The application config.
29 |  * @param settings The loaded application settings.
30 |  * @returns The results of the initialization.
31 |  */
32 | export async function initializeApp(
33 |   config: Config,
34 |   settings: LoadedSettings,
35 | ): Promise<InitializationResult> {
36 |   const authError = await performInitialAuth(
37 |     config,
38 |     settings.merged.security?.auth?.selectedType,
39 |   );
40 |   const themeError = validateTheme(settings);
41 | 
42 |   const shouldOpenAuthDialog =
43 |     settings.merged.security?.auth?.selectedType === undefined || !!authError;
44 | 
45 |   if (config.getIdeMode()) {
46 |     const ideClient = await IdeClient.getInstance();
47 |     await ideClient.connect();
48 |     logIdeConnection(config, new IdeConnectionEvent(IdeConnectionType.START));
49 |   }
50 | 
51 |   return {
52 |     authError,
53 |     themeError,
54 |     shouldOpenAuthDialog,
55 |     geminiMdFileCount: config.getGeminiMdFileCount(),
56 |   };
57 | }
```

src/core/theme.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { themeManager } from '../ui/themes/theme-manager.js';
8 | import { type LoadedSettings } from '../config/settings.js';
9 | 
10 | /**
11 |  * Validates the configured theme.
12 |  * @param settings The loaded application settings.
13 |  * @returns An error message if the theme is not found, otherwise null.
14 |  */
15 | export function validateTheme(settings: LoadedSettings): string | null {
16 |   const effectiveTheme = settings.merged.ui?.theme;
17 |   if (effectiveTheme && !themeManager.findThemeByName(effectiveTheme)) {
18 |     return `Theme "${effectiveTheme}" not found.`;
19 |   }
20 |   return null;
21 | }
```

src/config/auth.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { AuthType } from '@google/gemini-cli-core';
8 | import { vi } from 'vitest';
9 | import { validateAuthMethod } from './auth.js';
10 | 
11 | vi.mock('./settings.js', () => ({
12 |   loadEnvironment: vi.fn(),
13 |   loadSettings: vi.fn().mockReturnValue({
14 |     merged: vi.fn().mockReturnValue({}),
15 |   }),
16 | }));
17 | 
18 | describe('validateAuthMethod', () => {
19 |   beforeEach(() => {
20 |     vi.resetModules();
21 |     vi.stubEnv('GEMINI_API_KEY', undefined);
22 |     vi.stubEnv('GOOGLE_CLOUD_PROJECT', undefined);
23 |     vi.stubEnv('GOOGLE_CLOUD_LOCATION', undefined);
24 |     vi.stubEnv('GOOGLE_API_KEY', undefined);
25 |   });
26 | 
27 |   afterEach(() => {
28 |     vi.unstubAllEnvs();
29 |   });
30 | 
31 |   it('should return null for LOGIN_WITH_GOOGLE', () => {
32 |     expect(validateAuthMethod(AuthType.LOGIN_WITH_GOOGLE)).toBeNull();
33 |   });
34 | 
35 |   it('should return null for CLOUD_SHELL', () => {
36 |     expect(validateAuthMethod(AuthType.CLOUD_SHELL)).toBeNull();
37 |   });
38 | 
39 |   describe('USE_GEMINI', () => {
40 |     it('should return null if GEMINI_API_KEY is set', () => {
41 |       vi.stubEnv('GEMINI_API_KEY', 'test-key');
42 |       expect(validateAuthMethod(AuthType.USE_GEMINI)).toBeNull();
43 |     });
44 | 
45 |     it('should return an error message if GEMINI_API_KEY is not set', () => {
46 |       vi.stubEnv('GEMINI_API_KEY', undefined);
47 |       expect(validateAuthMethod(AuthType.USE_GEMINI)).toBe(
48 |         'GEMINI_API_KEY environment variable not found. Add that to your environment and try again (no reload needed if using .env)!',
49 |       );
50 |     });
51 |   });
52 | 
53 |   describe('USE_VERTEX_AI', () => {
54 |     it('should return null if GOOGLE_CLOUD_PROJECT and GOOGLE_CLOUD_LOCATION are set', () => {
55 |       vi.stubEnv('GOOGLE_CLOUD_PROJECT', 'test-project');
56 |       vi.stubEnv('GOOGLE_CLOUD_LOCATION', 'test-location');
57 |       expect(validateAuthMethod(AuthType.USE_VERTEX_AI)).toBeNull();
58 |     });
59 | 
60 |     it('should return null if GOOGLE_API_KEY is set', () => {
61 |       vi.stubEnv('GOOGLE_API_KEY', 'test-api-key');
62 |       expect(validateAuthMethod(AuthType.USE_VERTEX_AI)).toBeNull();
63 |     });
64 | 
65 |     it('should return an error message if no required environment variables are set', () => {
66 |       vi.stubEnv('GOOGLE_CLOUD_PROJECT', undefined);
67 |       vi.stubEnv('GOOGLE_CLOUD_LOCATION', undefined);
68 |       expect(validateAuthMethod(AuthType.USE_VERTEX_AI)).toBe(
69 |         'When using Vertex AI, you must specify either:\n' +
70 |           '• GOOGLE_CLOUD_PROJECT and GOOGLE_CLOUD_LOCATION environment variables.\n' +
71 |           '• GOOGLE_API_KEY environment variable (if using express mode).\n' +
72 |           'Update your environment and try again (no reload needed if using .env)!',
73 |       );
74 |     });
75 |   });
76 | 
77 |   it('should return an error message for an invalid auth method', () => {
78 |     expect(validateAuthMethod('invalid-method')).toBe(
79 |       'Invalid auth method selected.',
80 |     );
81 |   });
82 | });
```

src/config/auth.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { AuthType } from '@google/gemini-cli-core';
8 | import { loadEnvironment, loadSettings } from './settings.js';
9 | 
10 | export function validateAuthMethod(authMethod: string): string | null {
11 |   loadEnvironment(loadSettings().merged);
12 |   if (
13 |     authMethod === AuthType.LOGIN_WITH_GOOGLE ||
14 |     authMethod === AuthType.CLOUD_SHELL
15 |   ) {
16 |     return null;
17 |   }
18 | 
19 |   if (authMethod === AuthType.USE_GEMINI) {
20 |     if (!process.env['GEMINI_API_KEY']) {
21 |       return 'GEMINI_API_KEY environment variable not found. Add that to your environment and try again (no reload needed if using .env)!';
22 |     }
23 |     return null;
24 |   }
25 | 
26 |   if (authMethod === AuthType.USE_VERTEX_AI) {
27 |     const hasVertexProjectLocationConfig =
28 |       !!process.env['GOOGLE_CLOUD_PROJECT'] &&
29 |       !!process.env['GOOGLE_CLOUD_LOCATION'];
30 |     const hasGoogleApiKey = !!process.env['GOOGLE_API_KEY'];
31 |     if (!hasVertexProjectLocationConfig && !hasGoogleApiKey) {
32 |       return (
33 |         'When using Vertex AI, you must specify either:\n' +
34 |         '• GOOGLE_CLOUD_PROJECT and GOOGLE_CLOUD_LOCATION environment variables.\n' +
35 |         '• GOOGLE_API_KEY environment variable (if using express mode).\n' +
36 |         'Update your environment and try again (no reload needed if using .env)!'
37 |       );
38 |     }
39 |     return null;
40 |   }
41 | 
42 |   return 'Invalid auth method selected.';
43 | }
```

src/config/config.integration.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect, beforeEach, vi, afterEach } from 'vitest';
8 | import * as fs from 'node:fs';
9 | import * as path from 'node:path';
10 | import { tmpdir } from 'node:os';
11 | import type {
12 |   ConfigParameters,
13 |   ContentGeneratorConfig,
14 | } from '@google/gemini-cli-core';
15 | import {
16 |   Config,
17 |   DEFAULT_FILE_FILTERING_OPTIONS,
18 | } from '@google/gemini-cli-core';
19 | import { http, HttpResponse } from 'msw';
20 | import { setupServer } from 'msw/node';
21 | 
22 | export const server = setupServer();
23 | 
24 | // TODO(richieforeman): Consider moving this to test setup globally.
25 | beforeAll(() => {
26 |   server.listen({});
27 | });
28 | 
29 | afterEach(() => {
30 |   server.resetHandlers();
31 | });
32 | 
33 | afterAll(() => {
34 |   server.close();
35 | });
36 | 
37 | const CLEARCUT_URL = 'https://play.googleapis.com/log';
38 | 
39 | const TEST_CONTENT_GENERATOR_CONFIG: ContentGeneratorConfig = {
40 |   apiKey: 'test-key',
41 |   model: 'test-model',
42 |   userAgent: 'test-agent',
43 | };
44 | 
45 | // Mock file discovery service and tool registry
46 | vi.mock('@google/gemini-cli-core', async () => {
47 |   const actual = await vi.importActual('@google/gemini-cli-core');
48 |   return {
49 |     ...actual,
50 |     FileDiscoveryService: vi.fn().mockImplementation(() => ({
51 |       initialize: vi.fn(),
52 |     })),
53 |     createToolRegistry: vi.fn().mockResolvedValue({}),
54 |   };
55 | });
56 | 
57 | describe('Configuration Integration Tests', () => {
58 |   let tempDir: string;
59 | 
60 |   beforeEach(() => {
61 |     server.resetHandlers(http.post(CLEARCUT_URL, () => HttpResponse.text()));
62 | 
63 |     tempDir = fs.mkdtempSync(path.join(tmpdir(), 'gemini-cli-test-'));
64 |     vi.stubEnv('GEMINI_API_KEY', 'test-api-key');
65 |     vi.clearAllMocks();
66 |   });
67 | 
68 |   afterEach(() => {
69 |     vi.unstubAllEnvs();
70 |     if (fs.existsSync(tempDir)) {
71 |       fs.rmSync(tempDir, { recursive: true });
72 |     }
73 |   });
74 | 
75 |   describe('File Filtering Configuration', () => {
76 |     it('should load default file filtering settings', async () => {
77 |       const configParams: ConfigParameters = {
78 |         cwd: '/tmp',
79 |         contentGeneratorConfig: TEST_CONTENT_GENERATOR_CONFIG,
80 |         embeddingModel: 'test-embedding-model',
81 |         sandbox: false,
82 |         targetDir: tempDir,
83 |         debugMode: false,
84 |         fileFilteringRespectGitIgnore: undefined, // Should default to  DEFAULT_FILE_FILTERING_OPTIONS
85 |       };
86 | 
87 |       const config = new Config(configParams);
88 | 
89 |       expect(config.getFileFilteringRespectGitIgnore()).toBe(
90 |         DEFAULT_FILE_FILTERING_OPTIONS.respectGitIgnore,
91 |       );
92 |     });
93 | 
94 |     it('should load custom file filtering settings from configuration', async () => {
95 |       const configParams: ConfigParameters = {
96 |         cwd: '/tmp',
97 |         contentGeneratorConfig: TEST_CONTENT_GENERATOR_CONFIG,
98 |         embeddingModel: 'test-embedding-model',
99 |         sandbox: false,
100 |         targetDir: tempDir,
101 |         debugMode: false,
102 |         fileFiltering: {
103 |           respectGitIgnore: false,
104 |         },
105 |       };
106 | 
107 |       const config = new Config(configParams);
108 | 
109 |       expect(config.getFileFilteringRespectGitIgnore()).toBe(false);
110 |     });
111 | 
112 |     it('should merge user and workspace file filtering settings', async () => {
113 |       const configParams: ConfigParameters = {
114 |         cwd: '/tmp',
115 |         contentGeneratorConfig: TEST_CONTENT_GENERATOR_CONFIG,
116 |         embeddingModel: 'test-embedding-model',
117 |         sandbox: false,
118 |         targetDir: tempDir,
119 |         debugMode: false,
120 |         fileFiltering: {
121 |           respectGitIgnore: true,
122 |         },
123 |       };
124 | 
125 |       const config = new Config(configParams);
126 | 
127 |       expect(config.getFileFilteringRespectGitIgnore()).toBe(true);
128 |     });
129 |   });
130 | 
131 |   describe('Configuration Integration', () => {
132 |     it('should handle partial configuration objects gracefully', async () => {
133 |       const configParams: ConfigParameters = {
134 |         cwd: '/tmp',
135 |         contentGeneratorConfig: TEST_CONTENT_GENERATOR_CONFIG,
136 |         embeddingModel: 'test-embedding-model',
137 |         sandbox: false,
138 |         targetDir: tempDir,
139 |         debugMode: false,
140 |         fileFiltering: {
141 |           respectGitIgnore: false,
142 |         },
143 |       };
144 | 
145 |       const config = new Config(configParams);
146 | 
147 |       // Specified settings should be applied
148 |       expect(config.getFileFilteringRespectGitIgnore()).toBe(false);
149 |     });
150 | 
151 |     it('should handle empty configuration objects gracefully', async () => {
152 |       const configParams: ConfigParameters = {
153 |         cwd: '/tmp',
154 |         contentGeneratorConfig: TEST_CONTENT_GENERATOR_CONFIG,
155 |         embeddingModel: 'test-embedding-model',
156 |         sandbox: false,
157 |         targetDir: tempDir,
158 |         debugMode: false,
159 |         fileFiltering: {},
160 |       };
161 | 
162 |       const config = new Config(configParams);
163 | 
164 |       // All settings should use defaults
165 |       expect(config.getFileFilteringRespectGitIgnore()).toBe(
166 |         DEFAULT_FILE_FILTERING_OPTIONS.respectGitIgnore,
167 |       );
168 |     });
169 | 
170 |     it('should handle missing configuration sections gracefully', async () => {
171 |       const configParams: ConfigParameters = {
172 |         cwd: '/tmp',
173 |         contentGeneratorConfig: TEST_CONTENT_GENERATOR_CONFIG,
174 |         embeddingModel: 'test-embedding-model',
175 |         sandbox: false,
176 |         targetDir: tempDir,
177 |         debugMode: false,
178 |         // Missing fileFiltering configuration
179 |       };
180 | 
181 |       const config = new Config(configParams);
182 | 
183 |       // All git-aware settings should use defaults
184 |       expect(config.getFileFilteringRespectGitIgnore()).toBe(
185 |         DEFAULT_FILE_FILTERING_OPTIONS.respectGitIgnore,
186 |       );
187 |     });
188 |   });
189 | 
190 |   describe('Real-world Configuration Scenarios', () => {
191 |     it('should handle a security-focused configuration', async () => {
192 |       const configParams: ConfigParameters = {
193 |         cwd: '/tmp',
194 |         contentGeneratorConfig: TEST_CONTENT_GENERATOR_CONFIG,
195 |         embeddingModel: 'test-embedding-model',
196 |         sandbox: false,
197 |         targetDir: tempDir,
198 |         debugMode: false,
199 |         fileFiltering: {
200 |           respectGitIgnore: true,
201 |         },
202 |       };
203 | 
204 |       const config = new Config(configParams);
205 | 
206 |       expect(config.getFileFilteringRespectGitIgnore()).toBe(true);
207 |     });
208 | 
209 |     it('should handle a CI/CD environment configuration', async () => {
210 |       const configParams: ConfigParameters = {
211 |         cwd: '/tmp',
212 |         contentGeneratorConfig: TEST_CONTENT_GENERATOR_CONFIG,
213 |         embeddingModel: 'test-embedding-model',
214 |         sandbox: false,
215 |         targetDir: tempDir,
216 |         debugMode: false,
217 |         fileFiltering: {
218 |           respectGitIgnore: false,
219 |         }, // CI might need to see all files
220 |       };
221 | 
222 |       const config = new Config(configParams);
223 | 
224 |       expect(config.getFileFilteringRespectGitIgnore()).toBe(false);
225 |     });
226 |   });
227 | 
228 |   describe('Checkpointing Configuration', () => {
229 |     it('should enable checkpointing when the setting is true', async () => {
230 |       const configParams: ConfigParameters = {
231 |         cwd: '/tmp',
232 |         contentGeneratorConfig: TEST_CONTENT_GENERATOR_CONFIG,
233 |         embeddingModel: 'test-embedding-model',
234 |         sandbox: false,
235 |         targetDir: tempDir,
236 |         debugMode: false,
237 |         checkpointing: true,
238 |       };
239 | 
240 |       const config = new Config(configParams);
241 | 
242 |       expect(config.getCheckpointingEnabled()).toBe(true);
243 |     });
244 |   });
245 | 
246 |   describe('Extension Context Files', () => {
247 |     it('should have an empty array for extension context files by default', () => {
248 |       const configParams: ConfigParameters = {
249 |         cwd: '/tmp',
250 |         contentGeneratorConfig: TEST_CONTENT_GENERATOR_CONFIG,
251 |         embeddingModel: 'test-embedding-model',
252 |         sandbox: false,
253 |         targetDir: tempDir,
254 |         debugMode: false,
255 |       };
256 |       const config = new Config(configParams);
257 |       expect(config.getExtensionContextFilePaths()).toEqual([]);
258 |     });
259 | 
260 |     it('should correctly store and return extension context file paths', () => {
261 |       const contextFiles = ['/path/to/file1.txt', '/path/to/file2.js'];
262 |       const configParams: ConfigParameters = {
263 |         cwd: '/tmp',
264 |         contentGeneratorConfig: TEST_CONTENT_GENERATOR_CONFIG,
265 |         embeddingModel: 'test-embedding-model',
266 |         sandbox: false,
267 |         targetDir: tempDir,
268 |         debugMode: false,
269 |         extensionContextFilePaths: contextFiles,
270 |       };
271 |       const config = new Config(configParams);
272 |       expect(config.getExtensionContextFilePaths()).toEqual(contextFiles);
273 |     });
274 |   });
275 | 
276 |   describe('Approval Mode Integration Tests', () => {
277 |     let parseArguments: typeof import('./config').parseArguments;
278 | 
279 |     beforeEach(async () => {
280 |       // Import the argument parsing function for integration testing
281 |       const { parseArguments: parseArgs } = await import('./config');
282 |       parseArguments = parseArgs;
283 |     });
284 | 
285 |     it('should parse --approval-mode=auto_edit correctly through the full argument parsing flow', async () => {
286 |       const originalArgv = process.argv;
287 | 
288 |       try {
289 |         process.argv = [
290 |           'node',
291 |           'script.js',
292 |           '--approval-mode',
293 |           'auto_edit',
294 |           '-p',
295 |           'test',
296 |         ];
297 | 
298 |         const argv = await parseArguments({} as Settings);
299 | 
300 |         // Verify that the argument was parsed correctly
301 |         expect(argv.approvalMode).toBe('auto_edit');
302 |         expect(argv.prompt).toBe('test');
303 |         expect(argv.yolo).toBe(false);
304 |       } finally {
305 |         process.argv = originalArgv;
306 |       }
307 |     });
308 | 
309 |     it('should parse --approval-mode=yolo correctly through the full argument parsing flow', async () => {
310 |       const originalArgv = process.argv;
311 | 
312 |       try {
313 |         process.argv = [
314 |           'node',
315 |           'script.js',
316 |           '--approval-mode',
317 |           'yolo',
318 |           '-p',
319 |           'test',
320 |         ];
321 | 
322 |         const argv = await parseArguments({} as Settings);
323 | 
324 |         expect(argv.approvalMode).toBe('yolo');
325 |         expect(argv.prompt).toBe('test');
326 |         expect(argv.yolo).toBe(false); // Should NOT be set when using --approval-mode
327 |       } finally {
328 |         process.argv = originalArgv;
329 |       }
330 |     });
331 | 
332 |     it('should parse --approval-mode=default correctly through the full argument parsing flow', async () => {
333 |       const originalArgv = process.argv;
334 | 
335 |       try {
336 |         process.argv = [
337 |           'node',
338 |           'script.js',
339 |           '--approval-mode',
340 |           'default',
341 |           '-p',
342 |           'test',
343 |         ];
344 | 
345 |         const argv = await parseArguments({} as Settings);
346 | 
347 |         expect(argv.approvalMode).toBe('default');
348 |         expect(argv.prompt).toBe('test');
349 |         expect(argv.yolo).toBe(false);
350 |       } finally {
351 |         process.argv = originalArgv;
352 |       }
353 |     });
354 | 
355 |     it('should parse legacy --yolo flag correctly', async () => {
356 |       const originalArgv = process.argv;
357 | 
358 |       try {
359 |         process.argv = ['node', 'script.js', '--yolo', '-p', 'test'];
360 | 
361 |         const argv = await parseArguments({} as Settings);
362 | 
363 |         expect(argv.yolo).toBe(true);
364 |         expect(argv.approvalMode).toBeUndefined(); // Should NOT be set when using --yolo
365 |         expect(argv.prompt).toBe('test');
366 |       } finally {
367 |         process.argv = originalArgv;
368 |       }
369 |     });
370 | 
371 |     it('should reject invalid approval mode values during argument parsing', async () => {
372 |       const originalArgv = process.argv;
373 | 
374 |       try {
375 |         process.argv = ['node', 'script.js', '--approval-mode', 'invalid_mode'];
376 | 
377 |         // Should throw during argument parsing due to yargs validation
378 |         await expect(parseArguments({} as Settings)).rejects.toThrow();
379 |       } finally {
380 |         process.argv = originalArgv;
381 |       }
382 |     });
383 | 
384 |     it('should reject conflicting --yolo and --approval-mode flags', async () => {
385 |       const originalArgv = process.argv;
386 | 
387 |       try {
388 |         process.argv = [
389 |           'node',
390 |           'script.js',
391 |           '--yolo',
392 |           '--approval-mode',
[TRUNCATED]
```

src/config/config.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
8 | import * as os from 'node:os';
9 | import * as path from 'node:path';
10 | import {
11 |   ShellTool,
12 |   EditTool,
13 |   WriteFileTool,
14 |   DEFAULT_GEMINI_MODEL,
15 |   DEFAULT_GEMINI_MODEL_AUTO,
16 |   OutputFormat,
17 |   type GeminiCLIExtension,
18 | } from '@google/gemini-cli-core';
19 | import {
20 |   loadCliConfig,
21 |   loadHierarchicalGeminiMemory,
22 |   parseArguments,
23 |   type CliArgs,
24 | } from './config.js';
25 | import type { Settings } from './settings.js';
26 | import { ExtensionStorage } from './extension.js';
27 | import * as ServerConfig from '@google/gemini-cli-core';
28 | import { isWorkspaceTrusted } from './trustedFolders.js';
29 | import { ExtensionEnablementManager } from './extensions/extensionEnablement.js';
30 | 
31 | vi.mock('./trustedFolders.js', () => ({
32 |   isWorkspaceTrusted: vi
33 |     .fn()
34 |     .mockReturnValue({ isTrusted: true, source: 'file' }), // Default to trusted
35 | }));
36 | 
37 | vi.mock('./sandboxConfig.js', () => ({
38 |   loadSandboxConfig: vi.fn().mockResolvedValue(undefined),
39 | }));
40 | 
41 | vi.mock('fs', async (importOriginal) => {
42 |   const actualFs = await importOriginal<typeof import('fs')>();
43 |   const pathMod = await import('node:path');
44 |   const mockHome = '/mock/home/user';
45 |   const MOCK_CWD1 = process.cwd();
46 |   const MOCK_CWD2 = pathMod.resolve(pathMod.sep, 'home', 'user', 'project');
47 | 
48 |   const mockPaths = new Set([
49 |     MOCK_CWD1,
50 |     MOCK_CWD2,
51 |     pathMod.resolve(pathMod.sep, 'cli', 'path1'),
52 |     pathMod.resolve(pathMod.sep, 'settings', 'path1'),
53 |     pathMod.join(mockHome, 'settings', 'path2'),
54 |     pathMod.join(MOCK_CWD2, 'cli', 'path2'),
55 |     pathMod.join(MOCK_CWD2, 'settings', 'path3'),
56 |   ]);
57 | 
58 |   return {
59 |     ...actualFs,
60 |     mkdirSync: vi.fn(),
61 |     writeFileSync: vi.fn(),
62 |     existsSync: vi.fn((p) => mockPaths.has(p.toString())),
63 |     statSync: vi.fn((p) => {
64 |       if (mockPaths.has(p.toString())) {
65 |         return { isDirectory: () => true } as unknown as import('fs').Stats;
66 |       }
67 |       return (actualFs as typeof import('fs')).statSync(p as unknown as string);
68 |     }),
69 |     realpathSync: vi.fn((p) => p),
70 |   };
71 | });
72 | 
73 | vi.mock('os', async (importOriginal) => {
74 |   const actualOs = await importOriginal<typeof os>();
75 |   return {
76 |     ...actualOs,
77 |     homedir: vi.fn(() => '/mock/home/user'),
78 |   };
79 | });
80 | 
81 | vi.mock('open', () => ({
82 |   default: vi.fn(),
83 | }));
84 | 
85 | vi.mock('read-package-up', () => ({
86 |   readPackageUp: vi.fn(() =>
87 |     Promise.resolve({ packageJson: { version: 'test-version' } }),
88 |   ),
89 | }));
90 | 
91 | vi.mock('@google/gemini-cli-core', async () => {
92 |   const actualServer = await vi.importActual<typeof ServerConfig>(
93 |     '@google/gemini-cli-core',
94 |   );
95 |   return {
96 |     ...actualServer,
97 |     IdeClient: {
98 |       getInstance: vi.fn().mockResolvedValue({
99 |         getConnectionStatus: vi.fn(),
100 |         initialize: vi.fn(),
101 |         shutdown: vi.fn(),
102 |       }),
103 |     },
104 |     loadEnvironment: vi.fn(),
105 |     loadServerHierarchicalMemory: vi.fn(
106 |       (cwd, dirs, debug, fileService, extensionPaths, _maxDirs) =>
107 |         Promise.resolve({
108 |           memoryContent: extensionPaths?.join(',') || '',
109 |           fileCount: extensionPaths?.length || 0,
110 |         }),
111 |     ),
112 |     DEFAULT_MEMORY_FILE_FILTERING_OPTIONS: {
113 |       respectGitIgnore: false,
114 |       respectGeminiIgnore: true,
115 |     },
116 |     DEFAULT_FILE_FILTERING_OPTIONS: {
117 |       respectGitIgnore: true,
118 |       respectGeminiIgnore: true,
119 |     },
120 |   };
121 | });
122 | 
123 | describe('parseArguments', () => {
124 |   const originalArgv = process.argv;
125 | 
126 |   afterEach(() => {
127 |     process.argv = originalArgv;
128 |   });
129 | 
130 |   it('should throw an error when both --prompt and --prompt-interactive are used together', async () => {
131 |     process.argv = [
132 |       'node',
133 |       'script.js',
134 |       '--prompt',
135 |       'test prompt',
136 |       '--prompt-interactive',
137 |       'interactive prompt',
138 |     ];
139 | 
140 |     const mockExit = vi.spyOn(process, 'exit').mockImplementation(() => {
141 |       throw new Error('process.exit called');
142 |     });
143 | 
144 |     const mockConsoleError = vi
145 |       .spyOn(console, 'error')
146 |       .mockImplementation(() => {});
147 | 
148 |     await expect(parseArguments({} as Settings)).rejects.toThrow(
149 |       'process.exit called',
150 |     );
151 | 
152 |     expect(mockConsoleError).toHaveBeenCalledWith(
153 |       expect.stringContaining(
154 |         'Cannot use both --prompt (-p) and --prompt-interactive (-i) together',
155 |       ),
156 |     );
157 | 
158 |     mockExit.mockRestore();
159 |     mockConsoleError.mockRestore();
160 |   });
161 | 
162 |   it('should throw an error when using short flags -p and -i together', async () => {
163 |     process.argv = [
164 |       'node',
165 |       'script.js',
166 |       '-p',
167 |       'test prompt',
168 |       '-i',
169 |       'interactive prompt',
170 |     ];
171 | 
172 |     const mockExit = vi.spyOn(process, 'exit').mockImplementation(() => {
173 |       throw new Error('process.exit called');
174 |     });
175 | 
176 |     const mockConsoleError = vi
177 |       .spyOn(console, 'error')
178 |       .mockImplementation(() => {});
179 | 
180 |     await expect(parseArguments({} as Settings)).rejects.toThrow(
181 |       'process.exit called',
182 |     );
183 | 
184 |     expect(mockConsoleError).toHaveBeenCalledWith(
185 |       expect.stringContaining(
186 |         'Cannot use both --prompt (-p) and --prompt-interactive (-i) together',
187 |       ),
188 |     );
189 | 
190 |     mockExit.mockRestore();
191 |     mockConsoleError.mockRestore();
192 |   });
193 | 
194 |   it('should allow --prompt without --prompt-interactive', async () => {
195 |     process.argv = ['node', 'script.js', '--prompt', 'test prompt'];
196 |     const argv = await parseArguments({} as Settings);
197 |     expect(argv.prompt).toBe('test prompt');
198 |     expect(argv.promptInteractive).toBeUndefined();
199 |   });
200 | 
201 |   it('should allow --prompt-interactive without --prompt', async () => {
202 |     process.argv = [
203 |       'node',
204 |       'script.js',
205 |       '--prompt-interactive',
206 |       'interactive prompt',
207 |     ];
208 |     const argv = await parseArguments({} as Settings);
209 |     expect(argv.promptInteractive).toBe('interactive prompt');
210 |     expect(argv.prompt).toBeUndefined();
211 |   });
212 | 
213 |   it('should allow -i flag as alias for --prompt-interactive', async () => {
214 |     process.argv = ['node', 'script.js', '-i', 'interactive prompt'];
215 |     const argv = await parseArguments({} as Settings);
216 |     expect(argv.promptInteractive).toBe('interactive prompt');
217 |     expect(argv.prompt).toBeUndefined();
218 |   });
219 | 
220 |   it('should convert positional query argument to prompt by default', async () => {
221 |     process.argv = ['node', 'script.js', 'Hi Gemini'];
222 |     const argv = await parseArguments({} as Settings);
223 |     expect(argv.query).toBe('Hi Gemini');
224 |     expect(argv.prompt).toBe('Hi Gemini');
225 |     expect(argv.promptInteractive).toBeUndefined();
226 |   });
227 | 
228 |   it('should map @path to prompt (one-shot) when it starts with @', async () => {
229 |     process.argv = ['node', 'script.js', '@path ./file.md'];
230 |     const argv = await parseArguments({} as Settings);
231 |     expect(argv.query).toBe('@path ./file.md');
232 |     expect(argv.prompt).toBe('@path ./file.md');
233 |     expect(argv.promptInteractive).toBeUndefined();
234 |   });
235 | 
236 |   it('should map @path to prompt even when config flags are present', async () => {
237 |     // @path queries should now go to one-shot mode regardless of other flags
238 |     process.argv = [
239 |       'node',
240 |       'script.js',
241 |       '@path',
242 |       './file.md',
243 |       '--model',
244 |       'gemini-1.5-pro',
245 |     ];
246 |     const argv = await parseArguments({} as Settings);
247 |     expect(argv.query).toBe('@path ./file.md');
248 |     expect(argv.prompt).toBe('@path ./file.md'); // Should map to one-shot
249 |     expect(argv.promptInteractive).toBeUndefined();
250 |     expect(argv.model).toBe('gemini-1.5-pro');
251 |   });
252 | 
253 |   it('maps unquoted positional @path + arg to prompt (one-shot)', async () => {
254 |     // Simulate: gemini @path ./file.md
255 |     process.argv = ['node', 'script.js', '@path', './file.md'];
256 |     const argv = await parseArguments({} as Settings);
257 |     // After normalization, query is a single string
258 |     expect(argv.query).toBe('@path ./file.md');
259 |     // And it's mapped to one-shot prompt when no -p/-i flags are set
260 |     expect(argv.prompt).toBe('@path ./file.md');
261 |     expect(argv.promptInteractive).toBeUndefined();
262 |   });
263 | 
264 |   it('should handle multiple @path arguments in a single command (one-shot)', async () => {
265 |     // Simulate: gemini @path ./file1.md @path ./file2.md
266 |     process.argv = [
267 |       'node',
268 |       'script.js',
269 |       '@path',
270 |       './file1.md',
271 |       '@path',
272 |       './file2.md',
273 |     ];
274 |     const argv = await parseArguments({} as Settings);
275 |     // After normalization, all arguments are joined with spaces
276 |     expect(argv.query).toBe('@path ./file1.md @path ./file2.md');
277 |     // And it's mapped to one-shot prompt
278 |     expect(argv.prompt).toBe('@path ./file1.md @path ./file2.md');
279 |     expect(argv.promptInteractive).toBeUndefined();
280 |   });
281 | 
282 |   it('should handle mixed quoted and unquoted @path arguments (one-shot)', async () => {
283 |     // Simulate: gemini "@path ./file1.md" @path ./file2.md "additional text"
284 |     process.argv = [
285 |       'node',
286 |       'script.js',
287 |       '@path ./file1.md',
288 |       '@path',
289 |       './file2.md',
290 |       'additional text',
291 |     ];
292 |     const argv = await parseArguments({} as Settings);
293 |     // After normalization, all arguments are joined with spaces
294 |     expect(argv.query).toBe(
295 |       '@path ./file1.md @path ./file2.md additional text',
296 |     );
297 |     // And it's mapped to one-shot prompt
298 |     expect(argv.prompt).toBe(
299 |       '@path ./file1.md @path ./file2.md additional text',
300 |     );
301 |     expect(argv.promptInteractive).toBeUndefined();
302 |   });
303 | 
304 |   it('should map @path to prompt with ambient flags (debug, telemetry)', async () => {
305 |     // Ambient flags like debug, telemetry should NOT affect routing
306 |     process.argv = [
307 |       'node',
308 |       'script.js',
309 |       '@path',
310 |       './file.md',
311 |       '--debug',
312 |       '--telemetry',
313 |     ];
314 |     const argv = await parseArguments({} as Settings);
315 |     expect(argv.query).toBe('@path ./file.md');
316 |     expect(argv.prompt).toBe('@path ./file.md'); // Should map to one-shot
317 |     expect(argv.promptInteractive).toBeUndefined();
318 |     expect(argv.debug).toBe(true);
319 |     expect(argv.telemetry).toBe(true);
320 |   });
321 | 
322 |   it('should map any @command to prompt (one-shot)', async () => {
323 |     // Test that all @commands now go to one-shot mode
324 |     const testCases = [
325 |       '@path ./file.md',
326 |       '@include src/',
327 |       '@search pattern',
328 |       '@web query',
329 |       '@git status',
330 |     ];
331 | 
332 |     for (const testQuery of testCases) {
333 |       process.argv = ['node', 'script.js', testQuery];
334 |       const argv = await parseArguments({} as Settings);
335 |       expect(argv.query).toBe(testQuery);
336 |       expect(argv.prompt).toBe(testQuery);
337 |       expect(argv.promptInteractive).toBeUndefined();
338 |     }
339 |   });
340 | 
341 |   it('should handle @command with leading whitespace', async () => {
342 |     // Test that trim() + routing handles leading whitespace correctly
[TRUNCATED]
```

src/config/config.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import * as fs from 'node:fs';
8 | import * as path from 'node:path';
9 | import { homedir } from 'node:os';
10 | import yargs from 'yargs/yargs';
11 | import { hideBin } from 'yargs/helpers';
12 | import process from 'node:process';
13 | import { mcpCommand } from '../commands/mcp.js';
14 | import type {
15 |   FileFilteringOptions,
16 |   MCPServerConfig,
17 |   OutputFormat,
18 |   GeminiCLIExtension,
19 | } from '@google/gemini-cli-core';
20 | import { extensionsCommand } from '../commands/extensions.js';
21 | import {
22 |   Config,
23 |   loadServerHierarchicalMemory,
24 |   setGeminiMdFilename as setServerGeminiMdFilename,
25 |   getCurrentGeminiMdFilename,
26 |   ApprovalMode,
27 |   DEFAULT_GEMINI_MODEL,
28 |   DEFAULT_GEMINI_MODEL_AUTO,
29 |   DEFAULT_GEMINI_EMBEDDING_MODEL,
30 |   DEFAULT_MEMORY_FILE_FILTERING_OPTIONS,
31 |   FileDiscoveryService,
32 |   ShellTool,
33 |   EditTool,
34 |   WRITE_FILE_TOOL_NAME,
35 |   SHELL_TOOL_NAMES,
36 |   resolveTelemetrySettings,
37 |   FatalConfigError,
38 | } from '@google/gemini-cli-core';
39 | import type { Settings } from './settings.js';
40 | 
41 | import { annotateActiveExtensions } from './extension.js';
42 | import { getCliVersion } from '../utils/version.js';
43 | import { loadSandboxConfig } from './sandboxConfig.js';
44 | import { resolvePath } from '../utils/resolvePath.js';
45 | import { appEvents } from '../utils/events.js';
46 | 
47 | import { isWorkspaceTrusted } from './trustedFolders.js';
48 | import { createPolicyEngineConfig } from './policy.js';
49 | import type { ExtensionEnablementManager } from './extensions/extensionEnablement.js';
50 | 
51 | // Simple console logger for now - replace with actual logger if available
52 | const logger = {
53 |   // eslint-disable-next-line @typescript-eslint/no-explicit-any
54 |   debug: (...args: any[]) => console.debug('[DEBUG]', ...args),
55 |   // eslint-disable-next-line @typescript-eslint/no-explicit-any
56 |   warn: (...args: any[]) => console.warn('[WARN]', ...args),
57 |   // eslint-disable-next-line @typescript-eslint/no-explicit-any
58 |   error: (...args: any[]) => console.error('[ERROR]', ...args),
59 | };
60 | 
61 | export interface CliArgs {
62 |   query: string | undefined;
63 |   model: string | undefined;
64 |   sandbox: boolean | string | undefined;
65 |   sandboxImage: string | undefined;
66 |   debug: boolean | undefined;
67 |   prompt: string | undefined;
68 |   promptInteractive: string | undefined;
69 |   allFiles: boolean | undefined;
70 |   showMemoryUsage: boolean | undefined;
71 |   yolo: boolean | undefined;
72 |   approvalMode: string | undefined;
73 |   telemetry: boolean | undefined;
74 |   checkpointing: boolean | undefined;
75 |   telemetryTarget: string | undefined;
76 |   telemetryOtlpEndpoint: string | undefined;
77 |   telemetryOtlpProtocol: string | undefined;
78 |   telemetryLogPrompts: boolean | undefined;
79 |   telemetryOutfile: string | undefined;
80 |   allowedMcpServerNames: string[] | undefined;
81 |   allowedTools: string[] | undefined;
82 |   experimentalAcp: boolean | undefined;
83 |   extensions: string[] | undefined;
84 |   listExtensions: boolean | undefined;
85 |   proxy: string | undefined;
86 |   includeDirectories: string[] | undefined;
87 |   screenReader: boolean | undefined;
88 |   useSmartEdit: boolean | undefined;
89 |   useWriteTodos: boolean | undefined;
90 |   outputFormat: string | undefined;
91 | }
92 | 
93 | export async function parseArguments(settings: Settings): Promise<CliArgs> {
94 |   const rawArgv = hideBin(process.argv);
95 |   const yargsInstance = yargs(rawArgv)
96 |     .locale('en')
97 |     .scriptName('gemini')
98 |     .usage(
99 |       'Usage: gemini [options] [command]\n\nGemini CLI - Launch an interactive CLI, use -p/--prompt for non-interactive mode',
100 |     )
101 |     .option('telemetry', {
102 |       type: 'boolean',
103 |       description:
104 |         'Enable telemetry? This flag specifically controls if telemetry is sent. Other --telemetry-* flags set specific values but do not enable telemetry on their own.',
105 |     })
106 |     .option('telemetry-target', {
107 |       type: 'string',
108 |       choices: ['local', 'gcp'],
109 |       description:
110 |         'Set the telemetry target (local or gcp). Overrides settings files.',
111 |     })
112 |     .option('telemetry-otlp-endpoint', {
113 |       type: 'string',
114 |       description:
115 |         'Set the OTLP endpoint for telemetry. Overrides environment variables and settings files.',
116 |     })
117 |     .option('telemetry-otlp-protocol', {
118 |       type: 'string',
119 |       choices: ['grpc', 'http'],
120 |       description:
121 |         'Set the OTLP protocol for telemetry (grpc or http). Overrides settings files.',
122 |     })
123 |     .option('telemetry-log-prompts', {
124 |       type: 'boolean',
125 |       description:
126 |         'Enable or disable logging of user prompts for telemetry. Overrides settings files.',
127 |     })
128 |     .option('telemetry-outfile', {
129 |       type: 'string',
130 |       description: 'Redirect all telemetry output to the specified file.',
131 |     })
132 |     .deprecateOption(
133 |       'telemetry',
134 |       'Use the "telemetry.enabled" setting in settings.json instead. This flag will be removed in a future version.',
135 |     )
136 |     .deprecateOption(
137 |       'telemetry-target',
138 |       'Use the "telemetry.target" setting in settings.json instead. This flag will be removed in a future version.',
139 |     )
140 |     .deprecateOption(
141 |       'telemetry-otlp-endpoint',
142 |       'Use the "telemetry.otlpEndpoint" setting in settings.json instead. This flag will be removed in a future version.',
143 |     )
144 |     .deprecateOption(
145 |       'telemetry-otlp-protocol',
146 |       'Use the "telemetry.otlpProtocol" setting in settings.json instead. This flag will be removed in a future version.',
147 |     )
148 |     .deprecateOption(
149 |       'telemetry-log-prompts',
150 |       'Use the "telemetry.logPrompts" setting in settings.json instead. This flag will be removed in a future version.',
151 |     )
152 |     .deprecateOption(
153 |       'telemetry-outfile',
154 |       'Use the "telemetry.outfile" setting in settings.json instead. This flag will be removed in a future version.',
155 |     )
156 |     .option('debug', {
157 |       alias: 'd',
158 |       type: 'boolean',
159 |       description: 'Run in debug mode?',
160 |       default: false,
161 |     })
162 |     .option('proxy', {
163 |       type: 'string',
164 |       description:
165 |         'Proxy for gemini client, like schema://user:password@host:port',
166 |     })
167 |     .deprecateOption(
168 |       'proxy',
169 |       'Use the "proxy" setting in settings.json instead. This flag will be removed in a future version.',
170 |     )
171 |     .command('$0 [query..]', 'Launch Gemini CLI', (yargsInstance) =>
172 |       yargsInstance
173 |         .positional('query', {
174 |           description:
175 |             'Positional prompt. Defaults to one-shot; use -i/--prompt-interactive for interactive.',
176 |         })
177 |         .option('model', {
178 |           alias: 'm',
179 |           type: 'string',
180 |           description: `Model`,
181 |         })
182 |         .option('prompt', {
183 |           alias: 'p',
184 |           type: 'string',
185 |           description: 'Prompt. Appended to input on stdin (if any).',
186 |         })
187 |         .option('prompt-interactive', {
188 |           alias: 'i',
189 |           type: 'string',
190 |           description:
191 |             'Execute the provided prompt and continue in interactive mode',
192 |         })
193 |         .option('sandbox', {
194 |           alias: 's',
195 |           type: 'boolean',
196 |           description: 'Run in sandbox?',
197 |         })
198 |         .option('sandbox-image', {
199 |           type: 'string',
200 |           description: 'Sandbox image URI.',
201 |         })
202 |         .option('all-files', {
203 |           alias: ['a'],
204 |           type: 'boolean',
205 |           description: 'Include ALL files in context?',
206 |           default: false,
207 |         })
208 |         .option('show-memory-usage', {
209 |           type: 'boolean',
210 |           description: 'Show memory usage in status bar',
211 |           default: false,
212 |         })
213 |         .option('yolo', {
214 |           alias: 'y',
215 |           type: 'boolean',
216 |           description:
217 |             'Automatically accept all actions (aka YOLO mode, see https://www.youtube.com/watch?v=xvFZjo5PgG0 for more details)?',
218 |           default: false,
219 |         })
220 |         .option('approval-mode', {
221 |           type: 'string',
222 |           choices: ['default', 'auto_edit', 'yolo'],
223 |           description:
224 |             'Set the approval mode: default (prompt for approval), auto_edit (auto-approve edit tools), yolo (auto-approve all tools)',
225 |         })
226 |         .option('checkpointing', {
227 |           alias: 'c',
228 |           type: 'boolean',
229 |           description: 'Enables checkpointing of file edits',
230 |           default: false,
231 |         })
232 |         .option('experimental-acp', {
233 |           type: 'boolean',
234 |           description: 'Starts the agent in ACP mode',
235 |         })
236 |         .option('allowed-mcp-server-names', {
237 |           type: 'array',
238 |           string: true,
239 |           description: 'Allowed MCP server names',
240 |           coerce: (mcpServerNames: string[]) =>
241 |             // Handle comma-separated values
242 |             mcpServerNames.flatMap((mcpServerName) =>
243 |               mcpServerName.split(',').map((m) => m.trim()),
244 |             ),
245 |         })
246 |         .option('allowed-tools', {
247 |           type: 'array',
248 |           string: true,
249 |           description: 'Tools that are allowed to run without confirmation',
250 |           coerce: (tools: string[]) =>
251 |             // Handle comma-separated values
252 |             tools.flatMap((tool) => tool.split(',').map((t) => t.trim())),
253 |         })
254 |         .option('extensions', {
255 |           alias: 'e',
256 |           type: 'array',
257 |           string: true,
258 |           nargs: 1,
259 |           description:
260 |             'A list of extensions to use. If not provided, all extensions are used.',
261 |           coerce: (extensions: string[]) =>
262 |             // Handle comma-separated values
263 |             extensions.flatMap((extension) =>
264 |               extension.split(',').map((e) => e.trim()),
265 |             ),
266 |         })
267 |         .option('list-extensions', {
268 |           alias: 'l',
269 |           type: 'boolean',
270 |           description: 'List all available extensions and exit.',
271 |         })
272 |         .option('include-directories', {
273 |           type: 'array',
274 |           string: true,
275 |           description:
276 |             'Additional directories to include in the workspace (comma-separated or multiple --include-directories)',
277 |           coerce: (dirs: string[]) =>
278 |             // Handle comma-separated values
279 |             dirs.flatMap((dir) => dir.split(',').map((d) => d.trim())),
280 |         })
281 |         .option('screen-reader', {
282 |           type: 'boolean',
283 |           description: 'Enable screen reader mode for accessibility.',
284 |         })
285 |         .option('output-format', {
286 |           alias: 'o',
287 |           type: 'string',
288 |           description: 'The format of the CLI output.',
289 |           choices: ['text', 'json'],
290 |         })
291 |         .deprecateOption(
292 |           'show-memory-usage',
293 |           'Use the "ui.showMemoryUsage" setting in settings.json instead. This flag will be removed in a future version.',
294 |         )
295 |         .deprecateOption(
296 |           'sandbox-image',
297 |           'Use the "tools.sandbox" setting in settings.json instead. This flag will be removed in a future version.',
298 |         )
299 |         .deprecateOption(
300 |           'checkpointing',
301 |           'Use the "general.checkpointing.enabled" setting in settings.json instead. This flag will be removed in a future version.',
302 |         )
303 |         .deprecateOption(
304 |           'all-files',
305 |           'Use @ includes in the application instead. This flag will be removed in a future version.',
306 |         )
307 |         .deprecateOption(
308 |           'prompt',
309 |           'Use the positional prompt instead. This flag will be removed in a future version.',
310 |         )
311 |         // Ensure validation flows through .fail() for clean UX
312 |         .fail((msg, err, yargs) => {
313 |           console.error(msg || err?.message || 'Unknown error');
314 |           yargs.showHelp();
315 |           process.exit(1);
316 |         })
317 |         .check((argv) => {
318 |           // The 'query' positional can be a string (for one arg) or string[] (for multiple).
319 |           // This guard safely checks if any positional argument was provided.
320 |           const query = argv['query'] as string | string[] | undefined;
321 |           const hasPositionalQuery = Array.isArray(query)
322 |             ? query.length > 0
323 |             : !!query;
324 | 
325 |           if (argv['prompt'] && hasPositionalQuery) {
326 |             return 'Cannot use both a positional prompt and the --prompt (-p) flag together';
327 |           }
[TRUNCATED]
```

src/config/extension.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { vi } from 'vitest';
8 | import * as fs from 'node:fs';
9 | import * as os from 'node:os';
10 | import * as path from 'node:path';
11 | import {
12 |   EXTENSIONS_CONFIG_FILENAME,
13 |   ExtensionStorage,
14 |   INSTALL_METADATA_FILENAME,
15 |   annotateActiveExtensions,
16 |   disableExtension,
17 |   enableExtension,
18 |   installOrUpdateExtension,
19 |   loadExtension,
20 |   loadExtensionConfig,
21 |   loadExtensions,
22 |   performWorkspaceExtensionMigration,
23 |   uninstallExtension,
24 | } from './extension.js';
25 | import {
26 |   GEMINI_DIR,
27 |   type GeminiCLIExtension,
28 |   ExtensionUninstallEvent,
29 |   ExtensionDisableEvent,
30 |   ExtensionEnableEvent,
31 | } from '@google/gemini-cli-core';
32 | import { execSync } from 'node:child_process';
33 | import { SettingScope } from './settings.js';
34 | import { isWorkspaceTrusted } from './trustedFolders.js';
35 | import { createExtension } from '../test-utils/createExtension.js';
36 | import { ExtensionEnablementManager } from './extensions/extensionEnablement.js';
37 | 
38 | const mockGit = {
39 |   clone: vi.fn(),
40 |   getRemotes: vi.fn(),
41 |   fetch: vi.fn(),
42 |   checkout: vi.fn(),
43 |   listRemote: vi.fn(),
44 |   revparse: vi.fn(),
45 |   // Not a part of the actual API, but we need to use this to do the correct
46 |   // file system interactions.
47 |   path: vi.fn(),
48 | };
49 | 
50 | vi.mock('simple-git', () => ({
51 |   simpleGit: vi.fn((path: string) => {
52 |     mockGit.path.mockReturnValue(path);
53 |     return mockGit;
54 |   }),
55 | }));
56 | 
57 | vi.mock('os', async (importOriginal) => {
58 |   const mockedOs = await importOriginal<typeof os>();
59 |   return {
60 |     ...mockedOs,
61 |     homedir: vi.fn(),
62 |   };
63 | });
64 | 
65 | vi.mock('./trustedFolders.js', async (importOriginal) => {
66 |   const actual = await importOriginal<typeof import('./trustedFolders.js')>();
67 |   return {
68 |     ...actual,
69 |     isWorkspaceTrusted: vi.fn(),
70 |   };
71 | });
72 | 
73 | const mockLogExtensionEnable = vi.hoisted(() => vi.fn());
74 | const mockLogExtensionInstallEvent = vi.hoisted(() => vi.fn());
75 | const mockLogExtensionUninstall = vi.hoisted(() => vi.fn());
76 | const mockLogExtensionUpdateEvent = vi.hoisted(() => vi.fn());
77 | const mockLogExtensionDisable = vi.hoisted(() => vi.fn());
78 | vi.mock('@google/gemini-cli-core', async (importOriginal) => {
79 |   const actual =
80 |     await importOriginal<typeof import('@google/gemini-cli-core')>();
81 |   return {
82 |     ...actual,
83 |     logExtensionEnable: mockLogExtensionEnable,
84 |     logExtensionInstallEvent: mockLogExtensionInstallEvent,
85 |     logExtensionUninstall: mockLogExtensionUninstall,
86 |     logExtensionUpdateEvent: mockLogExtensionUpdateEvent,
87 |     logExtensionDisable: mockLogExtensionDisable,
88 |     ExtensionEnableEvent: vi.fn(),
89 |     ExtensionInstallEvent: vi.fn(),
90 |     ExtensionUninstallEvent: vi.fn(),
91 |     ExtensionDisableEvent: vi.fn(),
92 |   };
93 | });
94 | 
95 | vi.mock('child_process', async (importOriginal) => {
96 |   const actual = await importOriginal<typeof import('child_process')>();
97 |   return {
98 |     ...actual,
99 |     execSync: vi.fn(),
100 |   };
101 | });
102 | 
103 | const EXTENSIONS_DIRECTORY_NAME = path.join(GEMINI_DIR, 'extensions');
104 | 
105 | describe('extension tests', () => {
106 |   let tempHomeDir: string;
107 |   let tempWorkspaceDir: string;
108 |   let userExtensionsDir: string;
109 | 
110 |   beforeEach(() => {
111 |     tempHomeDir = fs.mkdtempSync(
112 |       path.join(os.tmpdir(), 'gemini-cli-test-home-'),
113 |     );
114 |     tempWorkspaceDir = fs.mkdtempSync(
115 |       path.join(tempHomeDir, 'gemini-cli-test-workspace-'),
116 |     );
117 |     userExtensionsDir = path.join(tempHomeDir, EXTENSIONS_DIRECTORY_NAME);
118 |     fs.mkdirSync(userExtensionsDir, { recursive: true });
119 | 
120 |     vi.mocked(os.homedir).mockReturnValue(tempHomeDir);
121 |     vi.mocked(isWorkspaceTrusted).mockReturnValue({
122 |       isTrusted: true,
123 |       source: undefined,
124 |     });
125 |     vi.spyOn(process, 'cwd').mockReturnValue(tempWorkspaceDir);
126 |     vi.mocked(execSync).mockClear();
127 |     Object.values(mockGit).forEach((fn) => fn.mockReset());
128 |   });
129 | 
130 |   afterEach(() => {
131 |     fs.rmSync(tempHomeDir, { recursive: true, force: true });
132 |     fs.rmSync(tempWorkspaceDir, { recursive: true, force: true });
133 |     vi.restoreAllMocks();
134 |   });
135 | 
136 |   describe('loadExtensions', () => {
137 |     it('should include extension path in loaded extension', () => {
138 |       const extensionDir = path.join(userExtensionsDir, 'test-extension');
139 |       fs.mkdirSync(extensionDir, { recursive: true });
140 | 
141 |       createExtension({
142 |         extensionsDir: userExtensionsDir,
143 |         name: 'test-extension',
144 |         version: '1.0.0',
145 |       });
146 | 
147 |       const extensions = loadExtensions(
148 |         new ExtensionEnablementManager(ExtensionStorage.getUserExtensionsDir()),
149 |       );
150 |       expect(extensions).toHaveLength(1);
151 |       expect(extensions[0].path).toBe(extensionDir);
152 |       expect(extensions[0].name).toBe('test-extension');
153 |     });
154 | 
155 |     it('should load context file path when GEMINI.md is present', () => {
156 |       createExtension({
157 |         extensionsDir: userExtensionsDir,
158 |         name: 'ext1',
159 |         version: '1.0.0',
160 |         addContextFile: true,
161 |       });
162 |       createExtension({
163 |         extensionsDir: userExtensionsDir,
164 |         name: 'ext2',
165 |         version: '2.0.0',
166 |       });
167 | 
168 |       const extensions = loadExtensions(
169 |         new ExtensionEnablementManager(ExtensionStorage.getUserExtensionsDir()),
170 |       );
171 | 
172 |       expect(extensions).toHaveLength(2);
173 |       const ext1 = extensions.find((e) => e.name === 'ext1');
174 |       const ext2 = extensions.find((e) => e.name === 'ext2');
175 |       expect(ext1?.contextFiles).toEqual([
176 |         path.join(userExtensionsDir, 'ext1', 'GEMINI.md'),
177 |       ]);
178 |       expect(ext2?.contextFiles).toEqual([]);
179 |     });
180 | 
181 |     it('should load context file path from the extension config', () => {
182 |       createExtension({
183 |         extensionsDir: userExtensionsDir,
184 |         name: 'ext1',
185 |         version: '1.0.0',
186 |         addContextFile: false,
187 |         contextFileName: 'my-context-file.md',
188 |       });
189 | 
190 |       const extensions = loadExtensions(
191 |         new ExtensionEnablementManager(ExtensionStorage.getUserExtensionsDir()),
192 |       );
193 | 
194 |       expect(extensions).toHaveLength(1);
195 |       const ext1 = extensions.find((e) => e.name === 'ext1');
196 |       expect(ext1?.contextFiles).toEqual([
197 |         path.join(userExtensionsDir, 'ext1', 'my-context-file.md'),
198 |       ]);
199 |     });
200 | 
201 |     it('should filter out disabled extensions', () => {
202 |       createExtension({
203 |         extensionsDir: userExtensionsDir,
204 |         name: 'disabled-extension',
205 |         version: '1.0.0',
206 |       });
207 |       createExtension({
208 |         extensionsDir: userExtensionsDir,
209 |         name: 'enabled-extension',
210 |         version: '2.0.0',
211 |       });
212 |       disableExtension(
213 |         'disabled-extension',
214 |         SettingScope.User,
215 |         tempWorkspaceDir,
216 |       );
217 |       const manager = new ExtensionEnablementManager(
218 |         ExtensionStorage.getUserExtensionsDir(),
219 |       );
220 |       const extensions = loadExtensions(manager);
221 |       const activeExtensions = annotateActiveExtensions(
222 |         extensions,
223 |         tempWorkspaceDir,
224 |         manager,
225 |       ).filter((e) => e.isActive);
226 |       expect(activeExtensions).toHaveLength(1);
227 |       expect(activeExtensions[0].name).toBe('enabled-extension');
228 |     });
229 | 
230 |     it('should hydrate variables', () => {
231 |       createExtension({
232 |         extensionsDir: userExtensionsDir,
233 |         name: 'test-extension',
234 |         version: '1.0.0',
235 |         addContextFile: false,
236 |         contextFileName: undefined,
237 |         mcpServers: {
238 |           'test-server': {
239 |             cwd: '${extensionPath}${/}server',
240 |           },
241 |         },
242 |       });
243 | 
244 |       const extensions = loadExtensions(
245 |         new ExtensionEnablementManager(ExtensionStorage.getUserExtensionsDir()),
246 |       );
247 |       expect(extensions).toHaveLength(1);
248 |       const expectedCwd = path.join(
249 |         userExtensionsDir,
250 |         'test-extension',
251 |         'server',
252 |       );
253 |       expect(extensions[0].mcpServers?.['test-server'].cwd).toBe(expectedCwd);
254 |     });
255 | 
256 |     it('should load a linked extension correctly', async () => {
257 |       const sourceExtDir = createExtension({
258 |         extensionsDir: tempWorkspaceDir,
259 |         name: 'my-linked-extension',
260 |         version: '1.0.0',
261 |         contextFileName: 'context.md',
262 |       });
263 |       fs.writeFileSync(path.join(sourceExtDir, 'context.md'), 'linked context');
264 | 
265 |       const extensionName = await installOrUpdateExtension(
266 |         {
267 |           source: sourceExtDir,
268 |           type: 'link',
269 |         },
270 |         async (_) => true,
271 |       );
272 | 
273 |       expect(extensionName).toEqual('my-linked-extension');
274 |       const extensions = loadExtensions(
275 |         new ExtensionEnablementManager(ExtensionStorage.getUserExtensionsDir()),
276 |       );
277 |       expect(extensions).toHaveLength(1);
278 | 
279 |       const linkedExt = extensions[0];
280 |       expect(linkedExt.name).toBe('my-linked-extension');
281 | 
282 |       expect(linkedExt.path).toBe(sourceExtDir);
283 |       expect(linkedExt.installMetadata).toEqual({
284 |         source: sourceExtDir,
285 |         type: 'link',
286 |       });
287 |       expect(linkedExt.contextFiles).toEqual([
288 |         path.join(sourceExtDir, 'context.md'),
289 |       ]);
290 |     });
291 | 
292 |     it('should resolve environment variables in extension configuration', () => {
293 |       process.env['TEST_API_KEY'] = 'test-api-key-123';
294 |       process.env['TEST_DB_URL'] = 'postgresql://localhost:5432/testdb';
295 | 
296 |       try {
297 |         const userExtensionsDir = path.join(
298 |           tempHomeDir,
299 |           EXTENSIONS_DIRECTORY_NAME,
300 |         );
301 |         fs.mkdirSync(userExtensionsDir, { recursive: true });
302 | 
303 |         const extDir = path.join(userExtensionsDir, 'test-extension');
304 |         fs.mkdirSync(extDir);
305 | 
306 |         // Write config to a separate file for clarity and good practices
307 |         const configPath = path.join(extDir, EXTENSIONS_CONFIG_FILENAME);
308 |         const extensionConfig = {
309 |           name: 'test-extension',
310 |           version: '1.0.0',
311 |           mcpServers: {
312 |             'test-server': {
313 |               command: 'node',
314 |               args: ['server.js'],
315 |               env: {
316 |                 API_KEY: '$TEST_API_KEY',
317 |                 DATABASE_URL: '${TEST_DB_URL}',
318 |                 STATIC_VALUE: 'no-substitution',
319 |               },
320 |             },
321 |           },
322 |         };
323 |         fs.writeFileSync(configPath, JSON.stringify(extensionConfig));
324 | 
325 |         const extensions = loadExtensions(
326 |           new ExtensionEnablementManager(
327 |             ExtensionStorage.getUserExtensionsDir(),
328 |           ),
329 |         );
330 | 
331 |         expect(extensions).toHaveLength(1);
332 |         const extension = extensions[0];
333 |         expect(extension.name).toBe('test-extension');
334 |         expect(extension.mcpServers).toBeDefined();
335 | 
336 |         const serverConfig = extension.mcpServers?.['test-server'];
337 |         expect(serverConfig).toBeDefined();
338 |         expect(serverConfig?.env).toBeDefined();
339 |         expect(serverConfig?.env?.['API_KEY']).toBe('test-api-key-123');
340 |         expect(serverConfig?.env?.['DATABASE_URL']).toBe(
341 |           'postgresql://localhost:5432/testdb',
342 |         );
343 |         expect(serverConfig?.env?.['STATIC_VALUE']).toBe('no-substitution');
344 |       } finally {
345 |         delete process.env['TEST_API_KEY'];
346 |         delete process.env['TEST_DB_URL'];
347 |       }
348 |     });
349 | 
350 |     it('should handle missing environment variables gracefully', () => {
351 |       const userExtensionsDir = path.join(
352 |         tempHomeDir,
353 |         EXTENSIONS_DIRECTORY_NAME,
354 |       );
355 |       fs.mkdirSync(userExtensionsDir, { recursive: true });
356 | 
357 |       const extDir = path.join(userExtensionsDir, 'test-extension');
358 |       fs.mkdirSync(extDir);
359 | 
360 |       const extensionConfig = {
361 |         name: 'test-extension',
362 |         version: '1.0.0',
363 |         mcpServers: {
364 |           'test-server': {
365 |             command: 'node',
366 |             args: ['server.js'],
367 |             env: {
368 |               MISSING_VAR: '$UNDEFINED_ENV_VAR',
369 |               MISSING_VAR_BRACES: '${ALSO_UNDEFINED}',
370 |             },
371 |           },
372 |         },
373 |       };
374 | 
375 |       fs.writeFileSync(
376 |         path.join(extDir, EXTENSIONS_CONFIG_FILENAME),
377 |         JSON.stringify(extensionConfig),
378 |       );
379 | 
380 |       const extensions = loadExtensions(
381 |         new ExtensionEnablementManager(ExtensionStorage.getUserExtensionsDir()),
382 |       );
383 | 
384 |       expect(extensions).toHaveLength(1);
385 |       const extension = extensions[0];
386 |       const serverConfig = extension.mcpServers!['test-server'];
387 |       expect(serverConfig.env).toBeDefined();
[TRUNCATED]
```

src/config/extension.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type {
8 |   MCPServerConfig,
9 |   GeminiCLIExtension,
10 |   ExtensionInstallMetadata,
11 | } from '@google/gemini-cli-core';
12 | import {
13 |   GEMINI_DIR,
14 |   Storage,
15 |   Config,
16 |   ExtensionInstallEvent,
17 |   ExtensionUninstallEvent,
18 |   ExtensionUpdateEvent,
19 |   ExtensionDisableEvent,
20 |   ExtensionEnableEvent,
21 |   logExtensionEnable,
22 |   logExtensionInstallEvent,
23 |   logExtensionUninstall,
24 |   logExtensionUpdateEvent,
25 |   logExtensionDisable,
26 | } from '@google/gemini-cli-core';
27 | import * as fs from 'node:fs';
28 | import * as path from 'node:path';
29 | import * as os from 'node:os';
30 | import { SettingScope, loadSettings } from '../config/settings.js';
31 | import { getErrorMessage } from '../utils/errors.js';
32 | import {
33 |   recursivelyHydrateStrings,
34 |   type JsonObject,
35 | } from './extensions/variables.js';
36 | import { isWorkspaceTrusted } from './trustedFolders.js';
37 | import { resolveEnvVarsInObject } from '../utils/envVarResolver.js';
38 | import { randomUUID } from 'node:crypto';
39 | import {
40 |   cloneFromGit,
41 |   downloadFromGitHubRelease,
42 | } from './extensions/github.js';
43 | import type { LoadExtensionContext } from './extensions/variableSchema.js';
44 | import { ExtensionEnablementManager } from './extensions/extensionEnablement.js';
45 | import chalk from 'chalk';
46 | import type { ConfirmationRequest } from '../ui/types.js';
47 | import { escapeAnsiCtrlCodes } from '../ui/utils/textUtils.js';
48 | 
49 | export const EXTENSIONS_DIRECTORY_NAME = path.join(GEMINI_DIR, 'extensions');
50 | 
51 | export const EXTENSIONS_CONFIG_FILENAME = 'gemini-extension.json';
52 | export const INSTALL_METADATA_FILENAME = '.gemini-extension-install.json';
53 | 
54 | /**
55 |  * Extension definition as written to disk in gemini-extension.json files.
56 |  * This should *not* be referenced outside of the logic for reading files.
57 |  * If information is required for manipulating extensions (load, unload, update)
58 |  * outside of the loading process that data needs to be stored on the
59 |  * GeminiCLIExtension class defined in Core.
60 |  */
61 | interface ExtensionConfig {
62 |   name: string;
63 |   version: string;
64 |   mcpServers?: Record<string, MCPServerConfig>;
65 |   contextFileName?: string | string[];
66 |   excludeTools?: string[];
67 | }
68 | 
69 | export interface ExtensionUpdateInfo {
70 |   name: string;
71 |   originalVersion: string;
72 |   updatedVersion: string;
73 | }
74 | 
75 | export class ExtensionStorage {
76 |   private readonly extensionName: string;
77 | 
78 |   constructor(extensionName: string) {
79 |     this.extensionName = extensionName;
80 |   }
81 | 
82 |   getExtensionDir(): string {
83 |     return path.join(
84 |       ExtensionStorage.getUserExtensionsDir(),
85 |       this.extensionName,
86 |     );
87 |   }
88 | 
89 |   getConfigPath(): string {
90 |     return path.join(this.getExtensionDir(), EXTENSIONS_CONFIG_FILENAME);
91 |   }
92 | 
93 |   static getUserExtensionsDir(): string {
94 |     const storage = new Storage(os.homedir());
95 |     return storage.getExtensionsDir();
96 |   }
97 | 
98 |   static async createTmpDir(): Promise<string> {
99 |     return await fs.promises.mkdtemp(
100 |       path.join(os.tmpdir(), 'gemini-extension'),
101 |     );
102 |   }
103 | }
104 | 
105 | export function getWorkspaceExtensions(
106 |   workspaceDir: string,
107 | ): GeminiCLIExtension[] {
108 |   // If the workspace dir is the user extensions dir, there are no workspace extensions.
109 |   if (path.resolve(workspaceDir) === path.resolve(os.homedir())) {
110 |     return [];
111 |   }
112 |   return loadExtensionsFromDir(workspaceDir);
113 | }
114 | 
115 | export async function copyExtension(
116 |   source: string,
117 |   destination: string,
118 | ): Promise<void> {
119 |   await fs.promises.cp(source, destination, { recursive: true });
120 | }
121 | 
122 | export async function performWorkspaceExtensionMigration(
123 |   extensions: GeminiCLIExtension[],
124 |   requestConsent: (consent: string) => Promise<boolean>,
125 | ): Promise<string[]> {
126 |   const failedInstallNames: string[] = [];
127 | 
128 |   for (const extension of extensions) {
129 |     try {
130 |       const installMetadata: ExtensionInstallMetadata = {
131 |         source: extension.path,
132 |         type: 'local',
133 |       };
134 |       await installOrUpdateExtension(installMetadata, requestConsent);
135 |     } catch (_) {
136 |       failedInstallNames.push(extension.name);
137 |     }
138 |   }
139 |   return failedInstallNames;
140 | }
141 | 
142 | function getTelemetryConfig(cwd: string) {
143 |   const settings = loadSettings(cwd);
144 |   const config = new Config({
145 |     telemetry: settings.merged.telemetry,
146 |     interactive: false,
147 |     sessionId: randomUUID(),
148 |     targetDir: cwd,
149 |     cwd,
150 |     model: '',
151 |     debugMode: false,
152 |   });
153 |   return config;
154 | }
155 | 
156 | export function loadExtensions(
157 |   extensionEnablementManager: ExtensionEnablementManager,
158 |   workspaceDir: string = process.cwd(),
159 | ): GeminiCLIExtension[] {
160 |   const settings = loadSettings(workspaceDir).merged;
161 |   const allExtensions = [...loadUserExtensions()];
162 | 
163 |   if (
164 |     isWorkspaceTrusted(settings).isTrusted &&
165 |     // Default management setting to true
166 |     !(settings.experimental?.extensionManagement ?? true)
167 |   ) {
168 |     allExtensions.push(...getWorkspaceExtensions(workspaceDir));
169 |   }
170 | 
171 |   const uniqueExtensions = new Map<string, GeminiCLIExtension>();
172 | 
173 |   for (const extension of allExtensions) {
174 |     if (
175 |       !uniqueExtensions.has(extension.name) &&
176 |       extensionEnablementManager.isEnabled(extension.name, workspaceDir)
177 |     ) {
178 |       uniqueExtensions.set(extension.name, extension);
179 |     }
180 |   }
181 | 
182 |   return Array.from(uniqueExtensions.values());
183 | }
184 | 
185 | export function loadUserExtensions(): GeminiCLIExtension[] {
186 |   const userExtensions = loadExtensionsFromDir(os.homedir());
187 | 
188 |   const uniqueExtensions = new Map<string, GeminiCLIExtension>();
189 |   for (const extension of userExtensions) {
190 |     if (!uniqueExtensions.has(extension.name)) {
191 |       uniqueExtensions.set(extension.name, extension);
192 |     }
193 |   }
194 | 
195 |   return Array.from(uniqueExtensions.values());
196 | }
197 | 
198 | export function loadExtensionsFromDir(dir: string): GeminiCLIExtension[] {
199 |   const storage = new Storage(dir);
200 |   const extensionsDir = storage.getExtensionsDir();
201 |   if (!fs.existsSync(extensionsDir)) {
202 |     return [];
203 |   }
204 | 
205 |   const extensions: GeminiCLIExtension[] = [];
206 |   for (const subdir of fs.readdirSync(extensionsDir)) {
207 |     const extensionDir = path.join(extensionsDir, subdir);
208 | 
209 |     const extension = loadExtension({ extensionDir, workspaceDir: dir });
210 |     if (extension != null) {
211 |       extensions.push(extension);
212 |     }
213 |   }
214 |   return extensions;
215 | }
216 | 
217 | export function loadExtension(
218 |   context: LoadExtensionContext,
219 | ): GeminiCLIExtension | null {
220 |   const { extensionDir, workspaceDir } = context;
221 |   if (!fs.statSync(extensionDir).isDirectory()) {
222 |     return null;
223 |   }
224 | 
225 |   const installMetadata = loadInstallMetadata(extensionDir);
226 |   let effectiveExtensionPath = extensionDir;
227 | 
228 |   if (installMetadata?.type === 'link') {
229 |     effectiveExtensionPath = installMetadata.source;
230 |   }
231 | 
232 |   try {
233 |     let config = loadExtensionConfig({
234 |       extensionDir: effectiveExtensionPath,
235 |       workspaceDir,
236 |     });
237 | 
238 |     config = resolveEnvVarsInObject(config);
239 | 
240 |     if (config.mcpServers) {
241 |       config.mcpServers = Object.fromEntries(
242 |         Object.entries(config.mcpServers).map(([key, value]) => [
243 |           key,
244 |           filterMcpConfig(value),
245 |         ]),
246 |       );
247 |     }
248 | 
249 |     const contextFiles = getContextFileNames(config)
250 |       .map((contextFileName) =>
251 |         path.join(effectiveExtensionPath, contextFileName),
252 |       )
253 |       .filter((contextFilePath) => fs.existsSync(contextFilePath));
254 | 
255 |     return {
256 |       name: config.name,
257 |       version: config.version,
258 |       path: effectiveExtensionPath,
259 |       contextFiles,
260 |       installMetadata,
261 |       mcpServers: config.mcpServers,
262 |       excludeTools: config.excludeTools,
263 |       isActive: true, // Barring any other signals extensions should be considered Active.
264 |     };
265 |   } catch (e) {
266 |     console.error(
267 |       `Warning: Skipping extension in ${effectiveExtensionPath}: ${getErrorMessage(
268 |         e,
269 |       )}`,
270 |     );
271 |     return null;
272 |   }
273 | }
274 | 
275 | export function loadExtensionByName(
276 |   name: string,
277 |   workspaceDir: string = process.cwd(),
278 | ): GeminiCLIExtension | null {
279 |   const userExtensionsDir = ExtensionStorage.getUserExtensionsDir();
280 |   if (!fs.existsSync(userExtensionsDir)) {
281 |     return null;
282 |   }
283 | 
284 |   for (const subdir of fs.readdirSync(userExtensionsDir)) {
285 |     const extensionDir = path.join(userExtensionsDir, subdir);
286 |     if (!fs.statSync(extensionDir).isDirectory()) {
287 |       continue;
288 |     }
289 |     const extension = loadExtension({ extensionDir, workspaceDir });
290 |     if (extension && extension.name.toLowerCase() === name.toLowerCase()) {
291 |       return extension;
292 |     }
293 |   }
294 | 
295 |   return null;
296 | }
297 | 
298 | function filterMcpConfig(original: MCPServerConfig): MCPServerConfig {
299 |   // eslint-disable-next-line @typescript-eslint/no-unused-vars
300 |   const { trust, ...rest } = original;
301 |   return Object.freeze(rest);
302 | }
303 | 
304 | export function loadInstallMetadata(
305 |   extensionDir: string,
306 | ): ExtensionInstallMetadata | undefined {
307 |   const metadataFilePath = path.join(extensionDir, INSTALL_METADATA_FILENAME);
308 |   try {
309 |     const configContent = fs.readFileSync(metadataFilePath, 'utf-8');
310 |     const metadata = JSON.parse(configContent) as ExtensionInstallMetadata;
311 |     return metadata;
312 |   } catch (_e) {
313 |     return undefined;
314 |   }
315 | }
316 | 
317 | function getContextFileNames(config: ExtensionConfig): string[] {
318 |   if (!config.contextFileName) {
319 |     return ['GEMINI.md'];
320 |   } else if (!Array.isArray(config.contextFileName)) {
321 |     return [config.contextFileName];
322 |   }
323 |   return config.contextFileName;
324 | }
325 | 
326 | /**
327 |  * Returns an annotated list of extensions. If an extension is listed in enabledExtensionNames, it will be active.
328 |  * If enabledExtensionNames is empty, an extension is active unless it is disabled.
329 |  * @param extensions The base list of extensions.
330 |  * @param enabledExtensionNames The names of explicitly enabled extensions.
331 |  * @param workspaceDir The current workspace directory.
332 |  */
333 | export function annotateActiveExtensions(
334 |   extensions: GeminiCLIExtension[],
335 |   workspaceDir: string,
336 |   manager: ExtensionEnablementManager,
337 | ): GeminiCLIExtension[] {
338 |   manager.validateExtensionOverrides(extensions);
339 |   return extensions.map((extension) => ({
340 |     ...extension,
341 |     isActive: manager.isEnabled(extension.name, workspaceDir),
342 |   }));
343 | }
344 | 
345 | /**
346 |  * Requests consent from the user to perform an action, by reading a Y/n
347 |  * character from stdin.
348 |  *
349 |  * This should not be called from interactive mode as it will break the CLI.
350 |  *
351 |  * @param consentDescription The description of the thing they will be consenting to.
352 |  * @returns boolean, whether they consented or not.
353 |  */
354 | export async function requestConsentNonInteractive(
355 |   consentDescription: string,
356 | ): Promise<boolean> {
357 |   console.info(consentDescription);
358 |   const result = await promptForConsentNonInteractive(
359 |     'Do you want to continue? [Y/n]: ',
360 |   );
361 |   return result;
362 | }
363 | 
364 | /**
365 |  * Requests consent from the user to perform an action, in interactive mode.
366 |  *
367 |  * This should not be called from non-interactive mode as it will not work.
368 |  *
369 |  * @param consentDescription The description of the thing they will be consenting to.
370 |  * @param setExtensionUpdateConfirmationRequest A function to actually add a prompt to the UI.
371 |  * @returns boolean, whether they consented or not.
372 |  */
373 | export async function requestConsentInteractive(
374 |   consentDescription: string,
375 |   addExtensionUpdateConfirmationRequest: (value: ConfirmationRequest) => void,
376 | ): Promise<boolean> {
377 |   return await promptForConsentInteractive(
378 |     consentDescription + '\n\nDo you want to continue?',
379 |     addExtensionUpdateConfirmationRequest,
380 |   );
381 | }
382 | 
383 | /**
384 |  * Asks users a prompt and awaits for a y/n response on stdin.
385 |  *
386 |  * This should not be called from interactive mode as it will break the CLI.
387 |  *
388 |  * @param prompt A yes/no prompt to ask the user
[TRUNCATED]
```

src/config/keyBindings.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect } from 'vitest';
8 | import type { KeyBindingConfig } from './keyBindings.js';
9 | import { Command, defaultKeyBindings } from './keyBindings.js';
10 | 
11 | describe('keyBindings config', () => {
12 |   describe('defaultKeyBindings', () => {
13 |     it('should have bindings for all commands', () => {
14 |       const commands = Object.values(Command);
15 | 
16 |       for (const command of commands) {
17 |         expect(defaultKeyBindings[command]).toBeDefined();
18 |         expect(Array.isArray(defaultKeyBindings[command])).toBe(true);
19 |       }
20 |     });
21 | 
22 |     it('should have valid key binding structures', () => {
23 |       for (const [_, bindings] of Object.entries(defaultKeyBindings)) {
24 |         for (const binding of bindings) {
25 |           // Each binding should have either key or sequence, but not both
26 |           const hasKey = binding.key !== undefined;
27 |           const hasSequence = binding.sequence !== undefined;
28 | 
29 |           expect(hasKey || hasSequence).toBe(true);
30 |           expect(hasKey && hasSequence).toBe(false);
31 | 
32 |           // Modifier properties should be boolean or undefined
33 |           if (binding.ctrl !== undefined) {
34 |             expect(typeof binding.ctrl).toBe('boolean');
35 |           }
36 |           if (binding.shift !== undefined) {
37 |             expect(typeof binding.shift).toBe('boolean');
38 |           }
39 |           if (binding.command !== undefined) {
40 |             expect(typeof binding.command).toBe('boolean');
41 |           }
42 |           if (binding.paste !== undefined) {
43 |             expect(typeof binding.paste).toBe('boolean');
44 |           }
45 |         }
46 |       }
47 |     });
48 | 
49 |     it('should export all required types', () => {
50 |       // Basic type checks
51 |       expect(typeof Command.HOME).toBe('string');
52 |       expect(typeof Command.END).toBe('string');
53 | 
54 |       // Config should be readonly
55 |       const config: KeyBindingConfig = defaultKeyBindings;
56 |       expect(config[Command.HOME]).toBeDefined();
57 |     });
58 |   });
59 | });
```

src/config/keyBindings.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | /**
8 |  * Command enum for all available keyboard shortcuts
9 |  */
10 | export enum Command {
11 |   // Basic bindings
12 |   RETURN = 'return',
13 |   ESCAPE = 'escape',
14 | 
15 |   // Cursor movement
16 |   HOME = 'home',
17 |   END = 'end',
18 | 
19 |   // Text deletion
20 |   KILL_LINE_RIGHT = 'killLineRight',
21 |   KILL_LINE_LEFT = 'killLineLeft',
22 |   CLEAR_INPUT = 'clearInput',
23 |   DELETE_WORD_BACKWARD = 'deleteWordBackward',
24 | 
25 |   // Screen control
26 |   CLEAR_SCREEN = 'clearScreen',
27 | 
28 |   // History navigation
29 |   HISTORY_UP = 'historyUp',
30 |   HISTORY_DOWN = 'historyDown',
31 |   NAVIGATION_UP = 'navigationUp',
32 |   NAVIGATION_DOWN = 'navigationDown',
33 | 
34 |   // Auto-completion
35 |   ACCEPT_SUGGESTION = 'acceptSuggestion',
36 |   COMPLETION_UP = 'completionUp',
37 |   COMPLETION_DOWN = 'completionDown',
38 | 
39 |   // Text input
40 |   SUBMIT = 'submit',
41 |   NEWLINE = 'newline',
42 | 
43 |   // External tools
44 |   OPEN_EXTERNAL_EDITOR = 'openExternalEditor',
45 |   PASTE_CLIPBOARD_IMAGE = 'pasteClipboardImage',
46 | 
47 |   // App level bindings
48 |   SHOW_ERROR_DETAILS = 'showErrorDetails',
49 |   TOGGLE_TOOL_DESCRIPTIONS = 'toggleToolDescriptions',
50 |   TOGGLE_IDE_CONTEXT_DETAIL = 'toggleIDEContextDetail',
51 |   QUIT = 'quit',
52 |   EXIT = 'exit',
53 |   SHOW_MORE_LINES = 'showMoreLines',
54 | 
55 |   // Shell commands
56 |   REVERSE_SEARCH = 'reverseSearch',
57 |   SUBMIT_REVERSE_SEARCH = 'submitReverseSearch',
58 |   ACCEPT_SUGGESTION_REVERSE_SEARCH = 'acceptSuggestionReverseSearch',
59 |   TOGGLE_SHELL_INPUT_FOCUS = 'toggleShellInputFocus',
60 | 
61 |   // Suggestion expansion
62 |   EXPAND_SUGGESTION = 'expandSuggestion',
63 |   COLLAPSE_SUGGESTION = 'collapseSuggestion',
64 | }
65 | 
66 | /**
67 |  * Data-driven key binding structure for user configuration
68 |  */
69 | export interface KeyBinding {
70 |   /** The key name (e.g., 'a', 'return', 'tab', 'escape') */
71 |   key?: string;
72 |   /** The key sequence (e.g., '\x18' for Ctrl+X) - alternative to key name */
73 |   sequence?: string;
74 |   /** Control key requirement: true=must be pressed, false=must not be pressed, undefined=ignore */
75 |   ctrl?: boolean;
76 |   /** Shift key requirement: true=must be pressed, false=must not be pressed, undefined=ignore */
77 |   shift?: boolean;
78 |   /** Command/meta key requirement: true=must be pressed, false=must not be pressed, undefined=ignore */
79 |   command?: boolean;
80 |   /** Paste operation requirement: true=must be paste, false=must not be paste, undefined=ignore */
81 |   paste?: boolean;
82 | }
83 | 
84 | /**
85 |  * Configuration type mapping commands to their key bindings
86 |  */
87 | export type KeyBindingConfig = {
88 |   readonly [C in Command]: readonly KeyBinding[];
89 | };
90 | 
91 | /**
92 |  * Default key binding configuration
93 |  * Matches the original hard-coded logic exactly
94 |  */
95 | export const defaultKeyBindings: KeyBindingConfig = {
96 |   // Basic bindings
97 |   [Command.RETURN]: [{ key: 'return' }],
98 |   [Command.ESCAPE]: [{ key: 'escape' }],
99 | 
100 |   // Cursor movement
101 |   [Command.HOME]: [{ key: 'a', ctrl: true }],
102 |   [Command.END]: [{ key: 'e', ctrl: true }],
103 | 
104 |   // Text deletion
105 |   [Command.KILL_LINE_RIGHT]: [{ key: 'k', ctrl: true }],
106 |   [Command.KILL_LINE_LEFT]: [{ key: 'u', ctrl: true }],
107 |   [Command.CLEAR_INPUT]: [{ key: 'c', ctrl: true }],
108 |   // Added command (meta/alt/option) for mac compatibility
109 |   [Command.DELETE_WORD_BACKWARD]: [
110 |     { key: 'backspace', ctrl: true },
111 |     { key: 'backspace', command: true },
112 |   ],
113 | 
114 |   // Screen control
115 |   [Command.CLEAR_SCREEN]: [{ key: 'l', ctrl: true }],
116 | 
117 |   // History navigation
118 |   [Command.HISTORY_UP]: [{ key: 'p', ctrl: true, shift: false }],
119 |   [Command.HISTORY_DOWN]: [{ key: 'n', ctrl: true }],
120 |   [Command.NAVIGATION_UP]: [{ key: 'up' }],
121 |   [Command.NAVIGATION_DOWN]: [{ key: 'down' }],
122 | 
123 |   // Auto-completion
124 |   [Command.ACCEPT_SUGGESTION]: [{ key: 'tab' }, { key: 'return', ctrl: false }],
125 |   // Completion navigation (arrow or Ctrl+P/N)
126 |   [Command.COMPLETION_UP]: [{ key: 'up' }, { key: 'p', ctrl: true }],
127 |   [Command.COMPLETION_DOWN]: [{ key: 'down' }, { key: 'n', ctrl: true }],
128 | 
129 |   // Text input
130 |   // Must also exclude shift to allow shift+enter for newline
131 |   [Command.SUBMIT]: [
132 |     {
133 |       key: 'return',
134 |       ctrl: false,
135 |       command: false,
136 |       paste: false,
137 |       shift: false,
138 |     },
139 |   ],
140 |   // Split into multiple data-driven bindings
141 |   // Now also includes shift+enter for multi-line input
142 |   [Command.NEWLINE]: [
143 |     { key: 'return', ctrl: true },
144 |     { key: 'return', command: true },
145 |     { key: 'return', paste: true },
146 |     { key: 'return', shift: true },
147 |     { key: 'j', ctrl: true },
148 |   ],
149 | 
150 |   // External tools
151 |   [Command.OPEN_EXTERNAL_EDITOR]: [
152 |     { key: 'x', ctrl: true },
153 |     { sequence: '\x18', ctrl: true },
154 |   ],
155 |   [Command.PASTE_CLIPBOARD_IMAGE]: [{ key: 'v', ctrl: true }],
156 | 
157 |   // App level bindings
158 |   [Command.SHOW_ERROR_DETAILS]: [{ key: 'o', ctrl: true }],
159 |   [Command.TOGGLE_TOOL_DESCRIPTIONS]: [{ key: 't', ctrl: true }],
160 |   [Command.TOGGLE_IDE_CONTEXT_DETAIL]: [{ key: 'g', ctrl: true }],
161 |   [Command.QUIT]: [{ key: 'c', ctrl: true }],
162 |   [Command.EXIT]: [{ key: 'd', ctrl: true }],
163 |   [Command.SHOW_MORE_LINES]: [{ key: 's', ctrl: true }],
164 | 
165 |   // Shell commands
166 |   [Command.REVERSE_SEARCH]: [{ key: 'r', ctrl: true }],
167 |   // Note: original logic ONLY checked ctrl=false, ignored meta/shift/paste
168 |   [Command.SUBMIT_REVERSE_SEARCH]: [{ key: 'return', ctrl: false }],
169 |   [Command.ACCEPT_SUGGESTION_REVERSE_SEARCH]: [{ key: 'tab' }],
170 |   [Command.TOGGLE_SHELL_INPUT_FOCUS]: [{ key: 'f', ctrl: true }],
171 | 
172 |   // Suggestion expansion
173 |   [Command.EXPAND_SUGGESTION]: [{ key: 'right' }],
174 |   [Command.COLLAPSE_SUGGESTION]: [{ key: 'left' }],
175 | };
```

src/config/policy-engine.integration.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect } from 'vitest';
8 | import {
9 |   ApprovalMode,
10 |   PolicyDecision,
11 |   PolicyEngine,
12 | } from '@google/gemini-cli-core';
13 | import { createPolicyEngineConfig } from './policy.js';
14 | import type { Settings } from './settings.js';
15 | 
16 | describe('Policy Engine Integration Tests', () => {
17 |   describe('Policy configuration produces valid PolicyEngine config', () => {
18 |     it('should create a working PolicyEngine from basic settings', () => {
19 |       const settings: Settings = {
20 |         tools: {
21 |           allowed: ['run_shell_command'],
22 |           exclude: ['write_file'],
23 |         },
24 |       };
25 | 
26 |       const config = createPolicyEngineConfig(settings, ApprovalMode.DEFAULT);
27 |       const engine = new PolicyEngine(config);
28 | 
29 |       // Allowed tool should be allowed
30 |       expect(engine.check({ name: 'run_shell_command' })).toBe(
31 |         PolicyDecision.ALLOW,
32 |       );
33 | 
34 |       // Excluded tool should be denied
35 |       expect(engine.check({ name: 'write_file' })).toBe(PolicyDecision.DENY);
36 | 
37 |       // Other write tools should ask user
38 |       expect(engine.check({ name: 'replace' })).toBe(PolicyDecision.ASK_USER);
39 | 
40 |       // Unknown tools should use default
41 |       expect(engine.check({ name: 'unknown_tool' })).toBe(
42 |         PolicyDecision.ASK_USER,
43 |       );
44 |     });
45 | 
46 |     it('should handle MCP server wildcard patterns correctly', () => {
47 |       const settings: Settings = {
48 |         mcp: {
49 |           allowed: ['allowed-server'],
50 |           excluded: ['blocked-server'],
51 |         },
52 |         mcpServers: {
53 |           'trusted-server': {
54 |             command: 'node',
55 |             args: ['server.js'],
56 |             trust: true,
57 |           },
58 |         },
59 |       };
60 | 
61 |       const config = createPolicyEngineConfig(settings, ApprovalMode.DEFAULT);
62 |       const engine = new PolicyEngine(config);
63 | 
64 |       // Tools from allowed server should be allowed
65 |       expect(engine.check({ name: 'allowed-server__tool1' })).toBe(
66 |         PolicyDecision.ALLOW,
67 |       );
68 |       expect(engine.check({ name: 'allowed-server__another_tool' })).toBe(
69 |         PolicyDecision.ALLOW,
70 |       );
71 | 
72 |       // Tools from trusted server should be allowed
73 |       expect(engine.check({ name: 'trusted-server__tool1' })).toBe(
74 |         PolicyDecision.ALLOW,
75 |       );
76 |       expect(engine.check({ name: 'trusted-server__special_tool' })).toBe(
77 |         PolicyDecision.ALLOW,
78 |       );
79 | 
80 |       // Tools from blocked server should be denied
81 |       expect(engine.check({ name: 'blocked-server__tool1' })).toBe(
82 |         PolicyDecision.DENY,
83 |       );
84 |       expect(engine.check({ name: 'blocked-server__any_tool' })).toBe(
85 |         PolicyDecision.DENY,
86 |       );
87 | 
88 |       // Tools from unknown servers should use default
89 |       expect(engine.check({ name: 'unknown-server__tool' })).toBe(
90 |         PolicyDecision.ASK_USER,
91 |       );
92 |     });
93 | 
94 |     it('should correctly prioritize specific tool rules over MCP server wildcards', () => {
95 |       const settings: Settings = {
96 |         mcp: {
97 |           allowed: ['my-server'],
98 |         },
99 |         tools: {
100 |           exclude: ['my-server__dangerous-tool'],
101 |         },
102 |       };
103 | 
104 |       const config = createPolicyEngineConfig(settings, ApprovalMode.DEFAULT);
105 |       const engine = new PolicyEngine(config);
106 | 
107 |       // Server is allowed, but specific tool is excluded
108 |       expect(engine.check({ name: 'my-server__safe-tool' })).toBe(
109 |         PolicyDecision.ALLOW,
110 |       );
111 |       expect(engine.check({ name: 'my-server__dangerous-tool' })).toBe(
112 |         PolicyDecision.DENY,
113 |       );
114 |     });
115 | 
116 |     it('should handle complex mixed configurations', () => {
117 |       const settings: Settings = {
118 |         tools: {
119 |           autoAccept: true, // Allows read-only tools
120 |           allowed: ['custom-tool', 'my-server__special-tool'],
121 |           exclude: ['glob', 'dangerous-tool'],
122 |         },
123 |         mcp: {
124 |           allowed: ['allowed-server'],
125 |           excluded: ['blocked-server'],
126 |         },
127 |         mcpServers: {
128 |           'trusted-server': {
129 |             command: 'node',
130 |             args: ['server.js'],
131 |             trust: true,
132 |           },
133 |         },
134 |       };
135 | 
136 |       const config = createPolicyEngineConfig(settings, ApprovalMode.DEFAULT);
137 |       const engine = new PolicyEngine(config);
138 | 
139 |       // Read-only tools should be allowed (autoAccept)
140 |       expect(engine.check({ name: 'read_file' })).toBe(PolicyDecision.ALLOW);
141 |       expect(engine.check({ name: 'list_directory' })).toBe(
142 |         PolicyDecision.ALLOW,
143 |       );
144 | 
145 |       // But glob is explicitly excluded, so it should be denied
146 |       expect(engine.check({ name: 'glob' })).toBe(PolicyDecision.DENY);
147 | 
148 |       // Replace should ask user (normal write tool behavior)
149 |       expect(engine.check({ name: 'replace' })).toBe(PolicyDecision.ASK_USER);
150 | 
151 |       // Explicitly allowed tools
152 |       expect(engine.check({ name: 'custom-tool' })).toBe(PolicyDecision.ALLOW);
153 |       expect(engine.check({ name: 'my-server__special-tool' })).toBe(
154 |         PolicyDecision.ALLOW,
155 |       );
156 | 
157 |       // MCP server tools
158 |       expect(engine.check({ name: 'allowed-server__tool' })).toBe(
159 |         PolicyDecision.ALLOW,
160 |       );
161 |       expect(engine.check({ name: 'trusted-server__tool' })).toBe(
162 |         PolicyDecision.ALLOW,
163 |       );
164 |       expect(engine.check({ name: 'blocked-server__tool' })).toBe(
165 |         PolicyDecision.DENY,
166 |       );
167 | 
168 |       // Write tools should ask by default
169 |       expect(engine.check({ name: 'write_file' })).toBe(
170 |         PolicyDecision.ASK_USER,
171 |       );
172 |     });
173 | 
174 |     it('should handle YOLO mode correctly', () => {
175 |       const settings: Settings = {
176 |         tools: {
177 |           exclude: ['dangerous-tool'], // Even in YOLO, excludes should be respected
178 |         },
179 |       };
180 | 
181 |       const config = createPolicyEngineConfig(settings, ApprovalMode.YOLO);
182 |       const engine = new PolicyEngine(config);
183 | 
184 |       // Most tools should be allowed in YOLO mode
185 |       expect(engine.check({ name: 'run_shell_command' })).toBe(
186 |         PolicyDecision.ALLOW,
187 |       );
188 |       expect(engine.check({ name: 'write_file' })).toBe(PolicyDecision.ALLOW);
189 |       expect(engine.check({ name: 'unknown_tool' })).toBe(PolicyDecision.ALLOW);
190 | 
191 |       // But explicitly excluded tools should still be denied
192 |       expect(engine.check({ name: 'dangerous-tool' })).toBe(
193 |         PolicyDecision.DENY,
194 |       );
195 |     });
196 | 
197 |     it('should handle AUTO_EDIT mode correctly', () => {
198 |       const settings: Settings = {};
199 | 
200 |       const config = createPolicyEngineConfig(settings, ApprovalMode.AUTO_EDIT);
201 |       const engine = new PolicyEngine(config);
202 | 
203 |       // Edit tool should be allowed (EditTool.Name = 'replace')
204 |       expect(engine.check({ name: 'replace' })).toBe(PolicyDecision.ALLOW);
205 | 
206 |       // Other tools should follow normal rules
207 |       expect(engine.check({ name: 'run_shell_command' })).toBe(
208 |         PolicyDecision.ASK_USER,
209 |       );
210 |       expect(engine.check({ name: 'write_file' })).toBe(
211 |         PolicyDecision.ASK_USER,
212 |       );
213 |     });
214 | 
215 |     it('should verify priority ordering works correctly in practice', () => {
216 |       const settings: Settings = {
217 |         tools: {
218 |           autoAccept: true, // Priority 50
219 |           allowed: ['specific-tool'], // Priority 100
220 |           exclude: ['blocked-tool'], // Priority 200
221 |         },
222 |         mcp: {
223 |           allowed: ['mcp-server'], // Priority 85
224 |           excluded: ['blocked-server'], // Priority 195
225 |         },
226 |         mcpServers: {
227 |           'trusted-server': {
228 |             command: 'node',
229 |             args: ['server.js'],
230 |             trust: true, // Priority 90
231 |           },
232 |         },
233 |       };
234 | 
235 |       const config = createPolicyEngineConfig(settings, ApprovalMode.DEFAULT);
236 |       const engine = new PolicyEngine(config);
237 | 
238 |       // Test that priorities are applied correctly
239 |       const rules = config.rules || [];
240 | 
241 |       // Find rules and verify their priorities
242 |       const blockedToolRule = rules.find((r) => r.toolName === 'blocked-tool');
243 |       expect(blockedToolRule?.priority).toBe(200);
244 | 
245 |       const blockedServerRule = rules.find(
246 |         (r) => r.toolName === 'blocked-server__*',
247 |       );
248 |       expect(blockedServerRule?.priority).toBe(195);
249 | 
250 |       const specificToolRule = rules.find(
251 |         (r) => r.toolName === 'specific-tool',
252 |       );
253 |       expect(specificToolRule?.priority).toBe(100);
254 | 
255 |       const trustedServerRule = rules.find(
256 |         (r) => r.toolName === 'trusted-server__*',
257 |       );
258 |       expect(trustedServerRule?.priority).toBe(90);
259 | 
260 |       const mcpServerRule = rules.find((r) => r.toolName === 'mcp-server__*');
261 |       expect(mcpServerRule?.priority).toBe(85);
262 | 
263 |       const readOnlyToolRule = rules.find((r) => r.toolName === 'glob');
264 |       expect(readOnlyToolRule?.priority).toBe(50);
265 | 
266 |       // Verify the engine applies these priorities correctly
267 |       expect(engine.check({ name: 'blocked-tool' })).toBe(PolicyDecision.DENY);
268 |       expect(engine.check({ name: 'blocked-server__any' })).toBe(
269 |         PolicyDecision.DENY,
270 |       );
271 |       expect(engine.check({ name: 'specific-tool' })).toBe(
272 |         PolicyDecision.ALLOW,
273 |       );
274 |       expect(engine.check({ name: 'trusted-server__any' })).toBe(
275 |         PolicyDecision.ALLOW,
276 |       );
277 |       expect(engine.check({ name: 'mcp-server__any' })).toBe(
278 |         PolicyDecision.ALLOW,
279 |       );
280 |       expect(engine.check({ name: 'glob' })).toBe(PolicyDecision.ALLOW);
281 |     });
282 | 
283 |     it('should handle edge case: MCP server with both trust and exclusion', () => {
284 |       const settings: Settings = {
285 |         mcpServers: {
286 |           'conflicted-server': {
287 |             command: 'node',
288 |             args: ['server.js'],
289 |             trust: true, // Priority 90 - ALLOW
290 |           },
291 |         },
292 |         mcp: {
293 |           excluded: ['conflicted-server'], // Priority 195 - DENY
294 |         },
295 |       };
296 | 
297 |       const config = createPolicyEngineConfig(settings, ApprovalMode.DEFAULT);
298 |       const engine = new PolicyEngine(config);
299 | 
300 |       // Exclusion (195) should win over trust (90)
301 |       expect(engine.check({ name: 'conflicted-server__tool' })).toBe(
302 |         PolicyDecision.DENY,
303 |       );
304 |     });
305 | 
306 |     it('should handle edge case: specific tool allowed but server excluded', () => {
307 |       const settings: Settings = {
308 |         mcp: {
309 |           excluded: ['my-server'], // Priority 195 - DENY
310 |         },
311 |         tools: {
312 |           allowed: ['my-server__special-tool'], // Priority 100 - ALLOW
313 |         },
314 |       };
315 | 
316 |       const config = createPolicyEngineConfig(settings, ApprovalMode.DEFAULT);
317 |       const engine = new PolicyEngine(config);
318 | 
319 |       // Server exclusion (195) wins over specific tool allow (100)
320 |       // This might be counterintuitive but follows the priority system
321 |       expect(engine.check({ name: 'my-server__special-tool' })).toBe(
322 |         PolicyDecision.DENY,
323 |       );
324 |       expect(engine.check({ name: 'my-server__other-tool' })).toBe(
325 |         PolicyDecision.DENY,
326 |       );
327 |     });
328 | 
329 |     it('should verify non-interactive mode transformation', () => {
330 |       const settings: Settings = {};
331 | 
332 |       const config = createPolicyEngineConfig(settings, ApprovalMode.DEFAULT);
333 |       // Enable non-interactive mode
334 |       const engineConfig = { ...config, nonInteractive: true };
335 |       const engine = new PolicyEngine(engineConfig);
336 | 
337 |       // ASK_USER should become DENY in non-interactive mode
338 |       expect(engine.check({ name: 'unknown_tool' })).toBe(PolicyDecision.DENY);
339 |       expect(engine.check({ name: 'run_shell_command' })).toBe(
340 |         PolicyDecision.DENY,
341 |       );
342 |     });
343 | 
344 |     it('should handle empty settings gracefully', () => {
345 |       const settings: Settings = {};
346 | 
347 |       const config = createPolicyEngineConfig(settings, ApprovalMode.DEFAULT);
348 |       const engine = new PolicyEngine(config);
349 | 
350 |       // Should have default rules for write tools
351 |       expect(engine.check({ name: 'write_file' })).toBe(
352 |         PolicyDecision.ASK_USER,
[TRUNCATED]
```

src/config/policy.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect } from 'vitest';
8 | import { createPolicyEngineConfig } from './policy.js';
9 | import type { Settings } from './settings.js';
10 | import { ApprovalMode, PolicyDecision } from '@google/gemini-cli-core';
11 | 
12 | describe('createPolicyEngineConfig', () => {
13 |   it('should return ASK_USER for all tools by default', () => {
14 |     const settings: Settings = {};
15 |     const config = createPolicyEngineConfig(settings, ApprovalMode.DEFAULT);
16 |     expect(config.defaultDecision).toBe(PolicyDecision.ASK_USER);
17 |     expect(config.rules).toEqual([
18 |       { toolName: 'replace', decision: 'ask_user', priority: 10 },
19 |       { toolName: 'save_memory', decision: 'ask_user', priority: 10 },
20 |       { toolName: 'run_shell_command', decision: 'ask_user', priority: 10 },
21 |       { toolName: 'write_file', decision: 'ask_user', priority: 10 },
22 |       { toolName: 'web_fetch', decision: 'ask_user', priority: 10 },
23 |     ]);
24 |   });
25 | 
26 |   it('should allow tools in tools.allowed', () => {
27 |     const settings: Settings = {
28 |       tools: { allowed: ['run_shell_command'] },
29 |     };
30 |     const config = createPolicyEngineConfig(settings, ApprovalMode.DEFAULT);
31 |     const rule = config.rules?.find(
32 |       (r) =>
33 |         r.toolName === 'run_shell_command' &&
34 |         r.decision === PolicyDecision.ALLOW,
35 |     );
36 |     expect(rule).toBeDefined();
37 |     expect(rule?.priority).toBe(100);
38 |   });
39 | 
40 |   it('should deny tools in tools.exclude', () => {
41 |     const settings: Settings = {
42 |       tools: { exclude: ['run_shell_command'] },
43 |     };
44 |     const config = createPolicyEngineConfig(settings, ApprovalMode.DEFAULT);
45 |     const rule = config.rules?.find(
46 |       (r) =>
47 |         r.toolName === 'run_shell_command' &&
48 |         r.decision === PolicyDecision.DENY,
49 |     );
50 |     expect(rule).toBeDefined();
51 |     expect(rule?.priority).toBe(200);
52 |   });
53 | 
54 |   it('should allow tools from allowed MCP servers', () => {
55 |     const settings: Settings = {
56 |       mcp: { allowed: ['my-server'] },
57 |     };
58 |     const config = createPolicyEngineConfig(settings, ApprovalMode.DEFAULT);
59 |     const rule = config.rules?.find(
60 |       (r) =>
61 |         r.toolName === 'my-server__*' && r.decision === PolicyDecision.ALLOW,
62 |     );
63 |     expect(rule).toBeDefined();
64 |     expect(rule?.priority).toBe(85);
65 |   });
66 | 
67 |   it('should deny tools from excluded MCP servers', () => {
68 |     const settings: Settings = {
69 |       mcp: { excluded: ['my-server'] },
70 |     };
71 |     const config = createPolicyEngineConfig(settings, ApprovalMode.DEFAULT);
72 |     const rule = config.rules?.find(
73 |       (r) =>
74 |         r.toolName === 'my-server__*' && r.decision === PolicyDecision.DENY,
75 |     );
76 |     expect(rule).toBeDefined();
77 |     expect(rule?.priority).toBe(195);
78 |   });
79 | 
80 |   it('should allow tools from trusted MCP servers', () => {
81 |     const settings: Settings = {
82 |       mcpServers: {
83 |         'trusted-server': {
84 |           command: 'node',
85 |           args: ['server.js'],
86 |           trust: true,
87 |         },
88 |         'untrusted-server': {
89 |           command: 'node',
90 |           args: ['server.js'],
91 |           trust: false,
92 |         },
93 |       },
94 |     };
95 |     const config = createPolicyEngineConfig(settings, ApprovalMode.DEFAULT);
96 | 
97 |     const trustedRule = config.rules?.find(
98 |       (r) =>
99 |         r.toolName === 'trusted-server__*' &&
100 |         r.decision === PolicyDecision.ALLOW,
101 |     );
102 |     expect(trustedRule).toBeDefined();
103 |     expect(trustedRule?.priority).toBe(90);
104 | 
105 |     // Untrusted server should not have an allow rule
106 |     const untrustedRule = config.rules?.find(
107 |       (r) =>
108 |         r.toolName === 'untrusted-server__*' &&
109 |         r.decision === PolicyDecision.ALLOW,
110 |     );
111 |     expect(untrustedRule).toBeUndefined();
112 |   });
113 | 
114 |   it('should handle multiple MCP server configurations together', () => {
115 |     const settings: Settings = {
116 |       mcp: {
117 |         allowed: ['allowed-server'],
118 |         excluded: ['excluded-server'],
119 |       },
120 |       mcpServers: {
121 |         'trusted-server': {
122 |           command: 'node',
123 |           args: ['server.js'],
124 |           trust: true,
125 |         },
126 |       },
127 |     };
128 |     const config = createPolicyEngineConfig(settings, ApprovalMode.DEFAULT);
129 | 
130 |     // Check allowed server
131 |     const allowedRule = config.rules?.find(
132 |       (r) =>
133 |         r.toolName === 'allowed-server__*' &&
134 |         r.decision === PolicyDecision.ALLOW,
135 |     );
136 |     expect(allowedRule).toBeDefined();
137 |     expect(allowedRule?.priority).toBe(85);
138 | 
139 |     // Check trusted server
140 |     const trustedRule = config.rules?.find(
141 |       (r) =>
142 |         r.toolName === 'trusted-server__*' &&
143 |         r.decision === PolicyDecision.ALLOW,
144 |     );
145 |     expect(trustedRule).toBeDefined();
146 |     expect(trustedRule?.priority).toBe(90);
147 | 
148 |     // Check excluded server
149 |     const excludedRule = config.rules?.find(
150 |       (r) =>
151 |         r.toolName === 'excluded-server__*' &&
152 |         r.decision === PolicyDecision.DENY,
153 |     );
154 |     expect(excludedRule).toBeDefined();
155 |     expect(excludedRule?.priority).toBe(195);
156 |   });
157 | 
158 |   it('should allow read-only tools if autoAccept is true', () => {
159 |     const settings: Settings = {
160 |       tools: { autoAccept: true },
161 |     };
162 |     const config = createPolicyEngineConfig(settings, ApprovalMode.DEFAULT);
163 |     const rule = config.rules?.find(
164 |       (r) => r.toolName === 'glob' && r.decision === PolicyDecision.ALLOW,
165 |     );
166 |     expect(rule).toBeDefined();
167 |     expect(rule?.priority).toBe(50);
168 |   });
169 | 
170 |   it('should allow all tools in YOLO mode', () => {
171 |     const settings: Settings = {};
172 |     const config = createPolicyEngineConfig(settings, ApprovalMode.YOLO);
173 |     const rule = config.rules?.find(
174 |       (r) => r.decision === PolicyDecision.ALLOW && r.priority === 0,
175 |     );
176 |     expect(rule).toBeDefined();
177 |   });
178 | 
179 |   it('should allow edit tool in AUTO_EDIT mode', () => {
180 |     const settings: Settings = {};
181 |     const config = createPolicyEngineConfig(settings, ApprovalMode.AUTO_EDIT);
182 |     const rule = config.rules?.find(
183 |       (r) => r.toolName === 'replace' && r.decision === PolicyDecision.ALLOW,
184 |     );
185 |     expect(rule).toBeDefined();
186 |     expect(rule?.priority).toBe(15);
187 |   });
188 | 
189 |   it('should prioritize exclude over allow', () => {
190 |     const settings: Settings = {
191 |       tools: { allowed: ['run_shell_command'], exclude: ['run_shell_command'] },
192 |     };
193 |     const config = createPolicyEngineConfig(settings, ApprovalMode.DEFAULT);
194 |     const denyRule = config.rules?.find(
195 |       (r) =>
196 |         r.toolName === 'run_shell_command' &&
197 |         r.decision === PolicyDecision.DENY,
198 |     );
199 |     const allowRule = config.rules?.find(
200 |       (r) =>
201 |         r.toolName === 'run_shell_command' &&
202 |         r.decision === PolicyDecision.ALLOW,
203 |     );
204 |     expect(denyRule).toBeDefined();
205 |     expect(allowRule).toBeDefined();
206 |     expect(denyRule!.priority).toBeGreaterThan(allowRule!.priority!);
207 |   });
208 | 
209 |   it('should prioritize specific tool allows over MCP server excludes', () => {
210 |     const settings: Settings = {
211 |       mcp: { excluded: ['my-server'] },
212 |       tools: { allowed: ['my-server__specific-tool'] },
213 |     };
214 |     const config = createPolicyEngineConfig(settings, ApprovalMode.DEFAULT);
215 | 
216 |     const serverDenyRule = config.rules?.find(
217 |       (r) =>
218 |         r.toolName === 'my-server__*' && r.decision === PolicyDecision.DENY,
219 |     );
220 |     const toolAllowRule = config.rules?.find(
221 |       (r) =>
222 |         r.toolName === 'my-server__specific-tool' &&
223 |         r.decision === PolicyDecision.ALLOW,
224 |     );
225 | 
226 |     expect(serverDenyRule).toBeDefined();
227 |     expect(serverDenyRule?.priority).toBe(195);
228 |     expect(toolAllowRule).toBeDefined();
229 |     expect(toolAllowRule?.priority).toBe(100);
230 | 
231 |     // Tool allow (100) has lower priority than server deny (195),
232 |     // so server deny wins - this might be counterintuitive
233 |   });
234 | 
235 |   it('should prioritize specific tool excludes over MCP server allows', () => {
236 |     const settings: Settings = {
237 |       mcp: { allowed: ['my-server'] },
238 |       mcpServers: {
239 |         'my-server': {
240 |           command: 'node',
241 |           args: ['server.js'],
242 |           trust: true,
243 |         },
244 |       },
245 |       tools: { exclude: ['my-server__dangerous-tool'] },
246 |     };
247 |     const config = createPolicyEngineConfig(settings, ApprovalMode.DEFAULT);
248 | 
249 |     const serverAllowRule = config.rules?.find(
250 |       (r) =>
251 |         r.toolName === 'my-server__*' && r.decision === PolicyDecision.ALLOW,
252 |     );
253 |     const toolDenyRule = config.rules?.find(
254 |       (r) =>
255 |         r.toolName === 'my-server__dangerous-tool' &&
256 |         r.decision === PolicyDecision.DENY,
257 |     );
258 | 
259 |     expect(serverAllowRule).toBeDefined();
260 |     expect(toolDenyRule).toBeDefined();
261 |     expect(toolDenyRule!.priority).toBeGreaterThan(serverAllowRule!.priority!);
262 |   });
263 | 
264 |   it('should handle complex priority scenarios correctly', () => {
265 |     const settings: Settings = {
266 |       tools: {
267 |         autoAccept: true, // Priority 50 for read-only tools
268 |         allowed: ['my-server__tool1', 'other-tool'], // Priority 100
269 |         exclude: ['my-server__tool2', 'glob'], // Priority 200
270 |       },
271 |       mcp: {
272 |         allowed: ['allowed-server'], // Priority 85
273 |         excluded: ['excluded-server'], // Priority 195
274 |       },
275 |       mcpServers: {
276 |         'trusted-server': {
277 |           command: 'node',
278 |           args: ['server.js'],
279 |           trust: true, // Priority 90
280 |         },
281 |       },
282 |     };
283 |     const config = createPolicyEngineConfig(settings, ApprovalMode.DEFAULT);
284 | 
285 |     // Verify glob is denied even though autoAccept would allow it
286 |     const globDenyRule = config.rules?.find(
287 |       (r) => r.toolName === 'glob' && r.decision === PolicyDecision.DENY,
288 |     );
289 |     const globAllowRule = config.rules?.find(
290 |       (r) => r.toolName === 'glob' && r.decision === PolicyDecision.ALLOW,
291 |     );
292 |     expect(globDenyRule).toBeDefined();
293 |     expect(globAllowRule).toBeDefined();
294 |     expect(globDenyRule!.priority).toBe(200);
295 |     expect(globAllowRule!.priority).toBe(50);
296 | 
297 |     // Verify all priority levels are correct
298 |     const priorities = config.rules
299 |       ?.map((r) => ({
300 |         tool: r.toolName,
301 |         decision: r.decision,
302 |         priority: r.priority,
303 |       }))
304 |       .sort((a, b) => (b.priority ?? 0) - (a.priority ?? 0));
305 | 
306 |     // Check that the highest priority items are the excludes
307 |     const highestPriorityExcludes = priorities?.filter(
308 |       (p) => p.priority === 200,
309 |     );
310 |     expect(
311 |       highestPriorityExcludes?.every((p) => p.decision === PolicyDecision.DENY),
312 |     ).toBe(true);
313 |   });
314 | 
315 |   it('should handle MCP servers with undefined trust property', () => {
316 |     const settings: Settings = {
317 |       mcpServers: {
318 |         'no-trust-property': {
319 |           command: 'node',
320 |           args: ['server.js'],
321 |           // trust property is undefined/missing
322 |         },
323 |         'explicit-false': {
324 |           command: 'node',
325 |           args: ['server.js'],
326 |           trust: false,
327 |         },
328 |       },
329 |     };
330 |     const config = createPolicyEngineConfig(settings, ApprovalMode.DEFAULT);
331 | 
332 |     // Neither server should have an allow rule
333 |     const noTrustRule = config.rules?.find(
334 |       (r) =>
335 |         r.toolName === 'no-trust-property__*' &&
336 |         r.decision === PolicyDecision.ALLOW,
337 |     );
338 |     const explicitFalseRule = config.rules?.find(
339 |       (r) =>
340 |         r.toolName === 'explicit-false__*' &&
341 |         r.decision === PolicyDecision.ALLOW,
342 |     );
343 | 
344 |     expect(noTrustRule).toBeUndefined();
345 |     expect(explicitFalseRule).toBeUndefined();
[TRUNCATED]
```

src/config/policy.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import {
8 |   type PolicyEngineConfig,
9 |   PolicyDecision,
10 |   type PolicyRule,
11 |   ApprovalMode,
12 |   // Read-only tools
13 |   GlobTool,
14 |   GrepTool,
15 |   LSTool,
16 |   ReadFileTool,
17 |   ReadManyFilesTool,
18 |   RipGrepTool,
19 |   // Write tools
20 |   EditTool,
21 |   MemoryTool,
22 |   ShellTool,
23 |   WRITE_FILE_TOOL_NAME,
24 |   WebFetchTool,
25 |   WebSearchTool,
26 | } from '@google/gemini-cli-core';
27 | import type { Settings } from './settings.js';
28 | 
29 | // READ_ONLY_TOOLS is a list of built-in tools that do not modify the user's
30 | // files or system state.
31 | const READ_ONLY_TOOLS = new Set([
32 |   GlobTool.Name,
33 |   GrepTool.Name,
34 |   RipGrepTool.Name,
35 |   LSTool.Name,
36 |   ReadFileTool.Name,
37 |   ReadManyFilesTool.Name,
38 |   WebSearchTool.Name,
39 | ]);
40 | 
41 | // WRITE_TOOLS is a list of built-in tools that can modify the user's files or
42 | // system state. These tools have a shouldConfirmExecute method.
43 | // We are keeping this here for visibility and to maintain backwards compatibility
44 | // with the existing tool permissions system. Eventually we'll remove this and
45 | // any tool that isn't read only will require a confirmation unless altered by
46 | // config and policy.
47 | const WRITE_TOOLS = new Set([
48 |   EditTool.Name,
49 |   MemoryTool.Name,
50 |   ShellTool.Name,
51 |   WRITE_FILE_TOOL_NAME,
52 |   WebFetchTool.Name,
53 | ]);
54 | 
55 | export function createPolicyEngineConfig(
56 |   settings: Settings,
57 |   approvalMode: ApprovalMode,
58 | ): PolicyEngineConfig {
59 |   const rules: PolicyRule[] = [];
60 | 
61 |   // Priority system for policy rules:
62 |   // - Higher priority numbers win over lower priority numbers
63 |   // - When multiple rules match, the highest priority rule is applied
64 |   // - Rules are evaluated in order of priority (highest first)
65 |   //
66 |   // Priority levels used in this configuration:
67 |   //   0: Default allow-all (YOLO mode only)
68 |   //   10: Write tools default to ASK_USER
69 |   //   50: Auto-accept read-only tools
70 |   //   85: MCP servers allowed list
71 |   //   90: MCP servers with trust=true
72 |   //   100: Explicitly allowed individual tools
73 |   //   195: Explicitly excluded MCP servers
74 |   //   200: Explicitly excluded individual tools (highest priority)
75 | 
76 |   // MCP servers that are explicitly allowed in settings.mcp.allowed
77 |   // Priority: 85 (lower than trusted servers)
78 |   if (settings.mcp?.allowed) {
79 |     for (const serverName of settings.mcp.allowed) {
80 |       rules.push({
81 |         toolName: `${serverName}__*`,
82 |         decision: PolicyDecision.ALLOW,
83 |         priority: 85,
84 |       });
85 |     }
86 |   }
87 | 
88 |   // MCP servers that are trusted in the settings.
89 |   // Priority: 90 (higher than general allowed servers but lower than explicit tool allows)
90 |   if (settings.mcpServers) {
91 |     for (const [serverName, serverConfig] of Object.entries(
92 |       settings.mcpServers,
93 |     )) {
94 |       if (serverConfig.trust) {
95 |         // Trust all tools from this MCP server
96 |         // Using pattern matching for MCP tool names which are formatted as "serverName__toolName"
97 |         rules.push({
98 |           toolName: `${serverName}__*`,
99 |           decision: PolicyDecision.ALLOW,
100 |           priority: 90,
101 |         });
102 |       }
103 |     }
104 |   }
105 | 
106 |   // Tools that are explicitly allowed in the settings.
107 |   // Priority: 100
108 |   if (settings.tools?.allowed) {
109 |     for (const tool of settings.tools.allowed) {
110 |       rules.push({
111 |         toolName: tool,
112 |         decision: PolicyDecision.ALLOW,
113 |         priority: 100,
114 |       });
115 |     }
116 |   }
117 | 
118 |   // Tools that are explicitly excluded in the settings.
119 |   // Priority: 200
120 |   if (settings.tools?.exclude) {
121 |     for (const tool of settings.tools.exclude) {
122 |       rules.push({
123 |         toolName: tool,
124 |         decision: PolicyDecision.DENY,
125 |         priority: 200,
126 |       });
127 |     }
128 |   }
129 | 
130 |   // MCP servers that are explicitly excluded in settings.mcp.excluded
131 |   // Priority: 195 (high priority to block servers)
132 |   if (settings.mcp?.excluded) {
133 |     for (const serverName of settings.mcp.excluded) {
134 |       rules.push({
135 |         toolName: `${serverName}__*`,
136 |         decision: PolicyDecision.DENY,
137 |         priority: 195,
138 |       });
139 |     }
140 |   }
141 | 
142 |   // If auto-accept is enabled, allow all read-only tools.
143 |   // Priority: 50
144 |   if (settings.tools?.autoAccept) {
145 |     for (const tool of READ_ONLY_TOOLS) {
146 |       rules.push({
147 |         toolName: tool,
148 |         decision: PolicyDecision.ALLOW,
149 |         priority: 50,
150 |       });
151 |     }
152 |   }
153 | 
154 |   // Only add write tool rules if not in YOLO mode
155 |   // In YOLO mode, the wildcard ALLOW rule handles everything
156 |   if (approvalMode !== ApprovalMode.YOLO) {
157 |     for (const tool of WRITE_TOOLS) {
158 |       rules.push({
159 |         toolName: tool,
160 |         decision: PolicyDecision.ASK_USER,
161 |         priority: 10,
162 |       });
163 |     }
164 |   }
165 | 
166 |   if (approvalMode === ApprovalMode.YOLO) {
167 |     rules.push({
168 |       decision: PolicyDecision.ALLOW,
169 |       priority: 0, // Lowest priority - catches everything not explicitly configured
170 |     });
171 |   } else if (approvalMode === ApprovalMode.AUTO_EDIT) {
172 |     rules.push({
173 |       toolName: EditTool.Name,
174 |       decision: PolicyDecision.ALLOW,
175 |       priority: 15, // Higher than write tools (10) to override ASK_USER
176 |     });
177 |   }
178 | 
179 |   return {
180 |     rules,
181 |     defaultDecision: PolicyDecision.ASK_USER,
182 |   };
183 | }
```

src/config/sandboxConfig.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type { SandboxConfig } from '@google/gemini-cli-core';
8 | import { FatalSandboxError } from '@google/gemini-cli-core';
9 | import commandExists from 'command-exists';
10 | import * as os from 'node:os';
11 | import { getPackageJson } from '../utils/package.js';
12 | import type { Settings } from './settings.js';
13 | 
14 | // This is a stripped-down version of the CliArgs interface from config.ts
15 | // to avoid circular dependencies.
16 | interface SandboxCliArgs {
17 |   sandbox?: boolean | string;
18 |   sandboxImage?: string;
19 | }
20 | 
21 | const VALID_SANDBOX_COMMANDS: ReadonlyArray<SandboxConfig['command']> = [
22 |   'docker',
23 |   'podman',
24 |   'sandbox-exec',
25 | ];
26 | 
27 | function isSandboxCommand(value: string): value is SandboxConfig['command'] {
28 |   return (VALID_SANDBOX_COMMANDS as readonly string[]).includes(value);
29 | }
30 | 
31 | function getSandboxCommand(
32 |   sandbox?: boolean | string,
33 | ): SandboxConfig['command'] | '' {
34 |   // If the SANDBOX env var is set, we're already inside the sandbox.
35 |   if (process.env['SANDBOX']) {
36 |     return '';
37 |   }
38 | 
39 |   // note environment variable takes precedence over argument (from command line or settings)
40 |   const environmentConfiguredSandbox =
41 |     process.env['GEMINI_SANDBOX']?.toLowerCase().trim() ?? '';
42 |   sandbox =
43 |     environmentConfiguredSandbox?.length > 0
44 |       ? environmentConfiguredSandbox
45 |       : sandbox;
46 |   if (sandbox === '1' || sandbox === 'true') sandbox = true;
47 |   else if (sandbox === '0' || sandbox === 'false' || !sandbox) sandbox = false;
48 | 
49 |   if (sandbox === false) {
50 |     return '';
51 |   }
52 | 
53 |   if (typeof sandbox === 'string' && sandbox) {
54 |     if (!isSandboxCommand(sandbox)) {
55 |       throw new FatalSandboxError(
56 |         `Invalid sandbox command '${sandbox}'. Must be one of ${VALID_SANDBOX_COMMANDS.join(
57 |           ', ',
58 |         )}`,
59 |       );
60 |     }
61 |     // confirm that specified command exists
62 |     if (commandExists.sync(sandbox)) {
63 |       return sandbox;
64 |     }
65 |     throw new FatalSandboxError(
66 |       `Missing sandbox command '${sandbox}' (from GEMINI_SANDBOX)`,
67 |     );
68 |   }
69 | 
70 |   // look for seatbelt, docker, or podman, in that order
71 |   // for container-based sandboxing, require sandbox to be enabled explicitly
72 |   if (os.platform() === 'darwin' && commandExists.sync('sandbox-exec')) {
73 |     return 'sandbox-exec';
74 |   } else if (commandExists.sync('docker') && sandbox === true) {
75 |     return 'docker';
76 |   } else if (commandExists.sync('podman') && sandbox === true) {
77 |     return 'podman';
78 |   }
79 | 
80 |   // throw an error if user requested sandbox but no command was found
81 |   if (sandbox === true) {
82 |     throw new FatalSandboxError(
83 |       'GEMINI_SANDBOX is true but failed to determine command for sandbox; ' +
84 |         'install docker or podman or specify command in GEMINI_SANDBOX',
85 |     );
86 |   }
87 | 
88 |   return '';
89 | }
90 | 
91 | export async function loadSandboxConfig(
92 |   settings: Settings,
93 |   argv: SandboxCliArgs,
94 | ): Promise<SandboxConfig | undefined> {
95 |   const sandboxOption = argv.sandbox ?? settings.tools?.sandbox;
96 |   const command = getSandboxCommand(sandboxOption);
97 | 
98 |   const packageJson = await getPackageJson();
99 |   const image =
100 |     argv.sandboxImage ??
101 |     process.env['GEMINI_SANDBOX_IMAGE'] ??
102 |     packageJson?.config?.sandboxImageUri;
103 | 
104 |   return command && image ? { command, image } : undefined;
105 | }
```

src/config/settings.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | /// <reference types="vitest/globals" />
8 | 
9 | // Mock 'os' first.
10 | import * as osActual from 'node:os'; // Import for type info for the mock factory
11 | 
12 | vi.mock('os', async (importOriginal) => {
13 |   const actualOs = await importOriginal<typeof osActual>();
14 |   return {
15 |     ...actualOs,
16 |     homedir: vi.fn(() => '/mock/home/user'),
17 |     platform: vi.fn(() => 'linux'),
18 |   };
19 | });
20 | 
21 | // Mock './settings.js' to ensure it uses the mocked 'os.homedir()' for its internal constants.
22 | vi.mock('./settings.js', async (importActual) => {
23 |   const originalModule = await importActual<typeof import('./settings.js')>();
24 |   return {
25 |     __esModule: true, // Ensure correct module shape
26 |     ...originalModule, // Re-export all original members
27 |     // We are relying on originalModule's USER_SETTINGS_PATH being constructed with mocked os.homedir()
28 |   };
29 | });
30 | 
31 | // Mock trustedFolders
32 | vi.mock('./trustedFolders.js', () => ({
33 |   isWorkspaceTrusted: vi
34 |     .fn()
35 |     .mockReturnValue({ isTrusted: true, source: 'file' }),
36 | }));
37 | 
38 | // NOW import everything else, including the (now effectively re-exported) settings.js
39 | import path, * as pathActual from 'node:path'; // Restored for MOCK_WORKSPACE_SETTINGS_PATH
40 | import {
41 |   describe,
42 |   it,
43 |   expect,
44 |   vi,
45 |   beforeEach,
46 |   afterEach,
47 |   type Mocked,
48 |   type Mock,
49 |   fail,
50 | } from 'vitest';
51 | import * as fs from 'node:fs'; // fs will be mocked separately
52 | import stripJsonComments from 'strip-json-comments'; // Will be mocked separately
53 | import { isWorkspaceTrusted } from './trustedFolders.js';
54 | import { disableExtension } from './extension.js';
55 | 
56 | // These imports will get the versions from the vi.mock('./settings.js', ...) factory.
57 | import {
58 |   loadSettings,
59 |   USER_SETTINGS_PATH, // This IS the mocked path.
60 |   getSystemSettingsPath,
61 |   getSystemDefaultsPath,
62 |   SETTINGS_DIRECTORY_NAME, // This is from the original module, but used by the mock.
63 |   migrateSettingsToV1,
64 |   needsMigration,
65 |   type Settings,
66 |   loadEnvironment,
67 |   migrateDeprecatedSettings,
68 |   SettingScope,
69 | } from './settings.js';
70 | import { FatalConfigError, GEMINI_DIR } from '@google/gemini-cli-core';
71 | 
72 | const MOCK_WORKSPACE_DIR = '/mock/workspace';
73 | // Use the (mocked) SETTINGS_DIRECTORY_NAME for consistency
74 | const MOCK_WORKSPACE_SETTINGS_PATH = pathActual.join(
75 |   MOCK_WORKSPACE_DIR,
76 |   SETTINGS_DIRECTORY_NAME,
77 |   'settings.json',
78 | );
79 | 
80 | // A more flexible type for test data that allows arbitrary properties.
81 | type TestSettings = Settings & { [key: string]: unknown };
82 | 
83 | vi.mock('fs', async (importOriginal) => {
84 |   // Get all the functions from the real 'fs' module
85 |   const actualFs = await importOriginal<typeof fs>();
86 | 
87 |   return {
88 |     ...actualFs, // Keep all the real functions
89 |     // Now, just override the ones we need for the test
90 |     existsSync: vi.fn(),
91 |     readFileSync: vi.fn(),
92 |     writeFileSync: vi.fn(),
93 |     mkdirSync: vi.fn(),
94 |     realpathSync: (p: string) => p,
95 |   };
96 | });
97 | 
98 | vi.mock('./extension.js', () => ({
99 |   disableExtension: vi.fn(),
100 | }));
101 | 
102 | vi.mock('strip-json-comments', () => ({
103 |   default: vi.fn((content) => content),
104 | }));
105 | 
106 | describe('Settings Loading and Merging', () => {
107 |   let mockFsExistsSync: Mocked<typeof fs.existsSync>;
108 |   let mockStripJsonComments: Mocked<typeof stripJsonComments>;
109 |   let mockFsMkdirSync: Mocked<typeof fs.mkdirSync>;
110 | 
111 |   beforeEach(() => {
112 |     vi.resetAllMocks();
113 | 
114 |     mockFsExistsSync = vi.mocked(fs.existsSync);
115 |     mockFsMkdirSync = vi.mocked(fs.mkdirSync);
116 |     mockStripJsonComments = vi.mocked(stripJsonComments);
117 | 
118 |     vi.mocked(osActual.homedir).mockReturnValue('/mock/home/user');
119 |     (mockStripJsonComments as unknown as Mock).mockImplementation(
120 |       (jsonString: string) => jsonString,
121 |     );
122 |     (mockFsExistsSync as Mock).mockReturnValue(false);
123 |     (fs.readFileSync as Mock).mockReturnValue('{}'); // Return valid empty JSON
124 |     (mockFsMkdirSync as Mock).mockImplementation(() => undefined);
125 |     vi.mocked(isWorkspaceTrusted).mockReturnValue({
126 |       isTrusted: true,
127 |       source: 'file',
128 |     });
129 |   });
130 | 
131 |   afterEach(() => {
132 |     vi.restoreAllMocks();
133 |   });
134 | 
135 |   describe('loadSettings', () => {
136 |     it('should load empty settings if no files exist', () => {
137 |       const settings = loadSettings(MOCK_WORKSPACE_DIR);
138 |       expect(settings.system.settings).toEqual({});
139 |       expect(settings.user.settings).toEqual({});
140 |       expect(settings.workspace.settings).toEqual({});
141 |       expect(settings.merged).toEqual({});
142 |     });
143 | 
144 |     it('should load system settings if only system file exists', () => {
145 |       (mockFsExistsSync as Mock).mockImplementation(
146 |         (p: fs.PathLike) => p === getSystemSettingsPath(),
147 |       );
148 |       const systemSettingsContent = {
149 |         ui: {
150 |           theme: 'system-default',
151 |         },
152 |         tools: {
153 |           sandbox: false,
154 |         },
155 |       };
156 |       (fs.readFileSync as Mock).mockImplementation(
157 |         (p: fs.PathOrFileDescriptor) => {
158 |           if (p === getSystemSettingsPath())
159 |             return JSON.stringify(systemSettingsContent);
160 |           return '{}';
161 |         },
162 |       );
163 | 
164 |       const settings = loadSettings(MOCK_WORKSPACE_DIR);
165 | 
166 |       expect(fs.readFileSync).toHaveBeenCalledWith(
167 |         getSystemSettingsPath(),
168 |         'utf-8',
169 |       );
170 |       expect(settings.system.settings).toEqual(systemSettingsContent);
171 |       expect(settings.user.settings).toEqual({});
172 |       expect(settings.workspace.settings).toEqual({});
173 |       expect(settings.merged).toEqual({
174 |         ...systemSettingsContent,
175 |       });
176 |     });
177 | 
178 |     it('should load user settings if only user file exists', () => {
179 |       const expectedUserSettingsPath = USER_SETTINGS_PATH; // Use the path actually resolved by the (mocked) module
180 | 
181 |       (mockFsExistsSync as Mock).mockImplementation(
182 |         (p: fs.PathLike) => p === expectedUserSettingsPath,
183 |       );
184 |       const userSettingsContent = {
185 |         ui: {
186 |           theme: 'dark',
187 |         },
188 |         context: {
189 |           fileName: 'USER_CONTEXT.md',
190 |         },
191 |       };
192 |       (fs.readFileSync as Mock).mockImplementation(
193 |         (p: fs.PathOrFileDescriptor) => {
194 |           if (p === expectedUserSettingsPath)
195 |             return JSON.stringify(userSettingsContent);
196 |           return '{}';
197 |         },
198 |       );
199 | 
200 |       const settings = loadSettings(MOCK_WORKSPACE_DIR);
201 | 
202 |       expect(fs.readFileSync).toHaveBeenCalledWith(
203 |         expectedUserSettingsPath,
204 |         'utf-8',
205 |       );
206 |       expect(settings.user.settings).toEqual(userSettingsContent);
207 |       expect(settings.workspace.settings).toEqual({});
208 |       expect(settings.merged).toEqual({
209 |         ...userSettingsContent,
210 |       });
211 |     });
212 | 
213 |     it('should load workspace settings if only workspace file exists', () => {
214 |       (mockFsExistsSync as Mock).mockImplementation(
215 |         (p: fs.PathLike) => p === MOCK_WORKSPACE_SETTINGS_PATH,
216 |       );
217 |       const workspaceSettingsContent = {
218 |         tools: {
219 |           sandbox: true,
220 |         },
221 |         context: {
222 |           fileName: 'WORKSPACE_CONTEXT.md',
223 |         },
224 |       };
225 |       (fs.readFileSync as Mock).mockImplementation(
226 |         (p: fs.PathOrFileDescriptor) => {
227 |           if (p === MOCK_WORKSPACE_SETTINGS_PATH)
228 |             return JSON.stringify(workspaceSettingsContent);
229 |           return '';
230 |         },
231 |       );
232 | 
233 |       const settings = loadSettings(MOCK_WORKSPACE_DIR);
234 | 
235 |       expect(fs.readFileSync).toHaveBeenCalledWith(
236 |         MOCK_WORKSPACE_SETTINGS_PATH,
237 |         'utf-8',
238 |       );
239 |       expect(settings.user.settings).toEqual({});
240 |       expect(settings.workspace.settings).toEqual(workspaceSettingsContent);
241 |       expect(settings.merged).toEqual({
242 |         ...workspaceSettingsContent,
243 |       });
244 |     });
245 | 
246 |     it('should merge system, user and workspace settings, with system taking precedence over workspace, and workspace over user', () => {
247 |       (mockFsExistsSync as Mock).mockImplementation(
248 |         (p: fs.PathLike) =>
249 |           p === getSystemSettingsPath() ||
250 |           p === USER_SETTINGS_PATH ||
251 |           p === MOCK_WORKSPACE_SETTINGS_PATH,
252 |       );
253 |       const systemSettingsContent = {
254 |         ui: {
255 |           theme: 'system-theme',
256 |         },
257 |         tools: {
258 |           sandbox: false,
259 |         },
260 |         mcp: {
261 |           allowed: ['server1', 'server2'],
262 |         },
263 |         telemetry: { enabled: false },
264 |       };
265 |       const userSettingsContent = {
266 |         ui: {
267 |           theme: 'dark',
268 |         },
269 |         tools: {
270 |           sandbox: true,
271 |         },
272 |         context: {
273 |           fileName: 'USER_CONTEXT.md',
274 |         },
275 |       };
276 |       const workspaceSettingsContent = {
277 |         tools: {
278 |           sandbox: false,
279 |           core: ['tool1'],
280 |         },
281 |         context: {
282 |           fileName: 'WORKSPACE_CONTEXT.md',
283 |         },
284 |         mcp: {
285 |           allowed: ['server1', 'server2', 'server3'],
286 |         },
287 |       };
288 | 
289 |       (fs.readFileSync as Mock).mockImplementation(
290 |         (p: fs.PathOrFileDescriptor) => {
291 |           if (p === getSystemSettingsPath())
292 |             return JSON.stringify(systemSettingsContent);
293 |           if (p === USER_SETTINGS_PATH)
294 |             return JSON.stringify(userSettingsContent);
295 |           if (p === MOCK_WORKSPACE_SETTINGS_PATH)
296 |             return JSON.stringify(workspaceSettingsContent);
297 |           return '';
298 |         },
299 |       );
300 | 
301 |       const settings = loadSettings(MOCK_WORKSPACE_DIR);
302 | 
303 |       expect(settings.system.settings).toEqual(systemSettingsContent);
304 |       expect(settings.user.settings).toEqual(userSettingsContent);
305 |       expect(settings.workspace.settings).toEqual(workspaceSettingsContent);
306 |       expect(settings.merged).toEqual({
307 |         ui: {
308 |           theme: 'system-theme',
309 |         },
310 |         tools: {
311 |           sandbox: false,
312 |           core: ['tool1'],
313 |         },
314 |         telemetry: { enabled: false },
315 |         context: {
316 |           fileName: 'WORKSPACE_CONTEXT.md',
317 |         },
318 |         mcp: {
319 |           allowed: ['server1', 'server2'],
320 |         },
321 |       });
322 |     });
323 | 
324 |     it('should correctly migrate a complex legacy (v1) settings file', () => {
325 |       (mockFsExistsSync as Mock).mockImplementation(
326 |         (p: fs.PathLike) => p === USER_SETTINGS_PATH,
327 |       );
328 |       const legacySettingsContent = {
329 |         theme: 'legacy-dark',
330 |         vimMode: true,
331 |         contextFileName: 'LEGACY_CONTEXT.md',
332 |         model: 'gemini-pro',
333 |         mcpServers: {
334 |           'legacy-server-1': {
335 |             command: 'npm',
336 |             args: ['run', 'start:server1'],
337 |             description: 'Legacy Server 1',
338 |           },
339 |           'legacy-server-2': {
340 |             command: 'node',
341 |             args: ['server2.js'],
342 |             description: 'Legacy Server 2',
343 |           },
344 |         },
345 |         allowMCPServers: ['legacy-server-1'],
346 |         someUnrecognizedSetting: 'should-be-preserved',
347 |       };
348 | 
349 |       (fs.readFileSync as Mock).mockImplementation(
350 |         (p: fs.PathOrFileDescriptor) => {
351 |           if (p === USER_SETTINGS_PATH)
352 |             return JSON.stringify(legacySettingsContent);
353 |           return '{}';
354 |         },
355 |       );
356 | 
357 |       const settings = loadSettings(MOCK_WORKSPACE_DIR);
358 | 
359 |       expect(settings.merged).toEqual({
360 |         ui: {
361 |           theme: 'legacy-dark',
362 |         },
363 |         general: {
364 |           vimMode: true,
365 |         },
366 |         context: {
367 |           fileName: 'LEGACY_CONTEXT.md',
368 |         },
369 |         model: {
370 |           name: 'gemini-pro',
371 |         },
372 |         mcpServers: {
373 |           'legacy-server-1': {
374 |             command: 'npm',
375 |             args: ['run', 'start:server1'],
376 |             description: 'Legacy Server 1',
377 |           },
378 |           'legacy-server-2': {
379 |             command: 'node',
380 |             args: ['server2.js'],
381 |             description: 'Legacy Server 2',
382 |           },
383 |         },
384 |         mcp: {
385 |           allowed: ['legacy-server-1'],
386 |         },
387 |         someUnrecognizedSetting: 'should-be-preserved',
388 |       });
389 |     });
390 | 
391 |     it('should rewrite allowedTools to tools.allowed during migration', () => {
[TRUNCATED]
```

src/config/settings.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import * as fs from 'node:fs';
8 | import * as path from 'node:path';
9 | import { homedir, platform } from 'node:os';
10 | import * as dotenv from 'dotenv';
11 | import process from 'node:process';
12 | import {
13 |   FatalConfigError,
14 |   GEMINI_CONFIG_DIR as GEMINI_DIR,
15 |   getErrorMessage,
16 |   Storage,
17 | } from '@google/gemini-cli-core';
18 | import stripJsonComments from 'strip-json-comments';
19 | import { DefaultLight } from '../ui/themes/default-light.js';
20 | import { DefaultDark } from '../ui/themes/default.js';
21 | import { isWorkspaceTrusted } from './trustedFolders.js';
22 | import {
23 |   type Settings,
24 |   type MemoryImportFormat,
25 |   type MergeStrategy,
26 |   type SettingsSchema,
27 |   type SettingDefinition,
28 |   getSettingsSchema,
29 | } from './settingsSchema.js';
30 | import { resolveEnvVarsInObject } from '../utils/envVarResolver.js';
31 | import { customDeepMerge, type MergeableObject } from '../utils/deepMerge.js';
32 | import { updateSettingsFilePreservingFormat } from '../utils/commentJson.js';
33 | import { disableExtension } from './extension.js';
34 | 
35 | function getMergeStrategyForPath(path: string[]): MergeStrategy | undefined {
36 |   let current: SettingDefinition | undefined = undefined;
37 |   let currentSchema: SettingsSchema | undefined = getSettingsSchema();
38 | 
39 |   for (const key of path) {
40 |     if (!currentSchema || !currentSchema[key]) {
41 |       return undefined;
42 |     }
43 |     current = currentSchema[key];
44 |     currentSchema = current.properties;
45 |   }
46 | 
47 |   return current?.mergeStrategy;
48 | }
49 | 
50 | export type { Settings, MemoryImportFormat };
51 | 
52 | export const SETTINGS_DIRECTORY_NAME = '.gemini';
53 | 
54 | export const USER_SETTINGS_PATH = Storage.getGlobalSettingsPath();
55 | export const USER_SETTINGS_DIR = path.dirname(USER_SETTINGS_PATH);
56 | export const DEFAULT_EXCLUDED_ENV_VARS = ['DEBUG', 'DEBUG_MODE'];
57 | 
58 | const MIGRATE_V2_OVERWRITE = true;
59 | 
60 | const MIGRATION_MAP: Record<string, string> = {
61 |   accessibility: 'ui.accessibility',
62 |   allowedTools: 'tools.allowed',
63 |   allowMCPServers: 'mcp.allowed',
64 |   autoAccept: 'tools.autoAccept',
65 |   autoConfigureMaxOldSpaceSize: 'advanced.autoConfigureMemory',
66 |   bugCommand: 'advanced.bugCommand',
67 |   chatCompression: 'model.chatCompression',
68 |   checkpointing: 'general.checkpointing',
69 |   coreTools: 'tools.core',
70 |   contextFileName: 'context.fileName',
71 |   customThemes: 'ui.customThemes',
72 |   customWittyPhrases: 'ui.customWittyPhrases',
73 |   debugKeystrokeLogging: 'general.debugKeystrokeLogging',
74 |   disableAutoUpdate: 'general.disableAutoUpdate',
75 |   disableUpdateNag: 'general.disableUpdateNag',
76 |   dnsResolutionOrder: 'advanced.dnsResolutionOrder',
77 |   enableMessageBusIntegration: 'tools.enableMessageBusIntegration',
78 |   enablePromptCompletion: 'general.enablePromptCompletion',
79 |   enforcedAuthType: 'security.auth.enforcedType',
80 |   excludeTools: 'tools.exclude',
81 |   excludeMCPServers: 'mcp.excluded',
82 |   excludedProjectEnvVars: 'advanced.excludedEnvVars',
83 |   extensionManagement: 'experimental.extensionManagement',
84 |   extensions: 'extensions',
85 |   fileFiltering: 'context.fileFiltering',
86 |   folderTrustFeature: 'security.folderTrust.featureEnabled',
87 |   folderTrust: 'security.folderTrust.enabled',
88 |   hasSeenIdeIntegrationNudge: 'ide.hasSeenNudge',
89 |   hideWindowTitle: 'ui.hideWindowTitle',
90 |   showStatusInTitle: 'ui.showStatusInTitle',
91 |   hideTips: 'ui.hideTips',
92 |   hideBanner: 'ui.hideBanner',
93 |   hideFooter: 'ui.hideFooter',
94 |   hideCWD: 'ui.footer.hideCWD',
95 |   hideSandboxStatus: 'ui.footer.hideSandboxStatus',
96 |   hideModelInfo: 'ui.footer.hideModelInfo',
97 |   hideContextSummary: 'ui.hideContextSummary',
98 |   showMemoryUsage: 'ui.showMemoryUsage',
99 |   showLineNumbers: 'ui.showLineNumbers',
100 |   showCitations: 'ui.showCitations',
101 |   ideMode: 'ide.enabled',
102 |   includeDirectories: 'context.includeDirectories',
103 |   loadMemoryFromIncludeDirectories: 'context.loadFromIncludeDirectories',
104 |   maxSessionTurns: 'model.maxSessionTurns',
105 |   mcpServers: 'mcpServers',
106 |   mcpServerCommand: 'mcp.serverCommand',
107 |   memoryImportFormat: 'context.importFormat',
108 |   memoryDiscoveryMaxDirs: 'context.discoveryMaxDirs',
109 |   model: 'model.name',
110 |   preferredEditor: 'general.preferredEditor',
111 |   sandbox: 'tools.sandbox',
112 |   selectedAuthType: 'security.auth.selectedType',
113 |   enableInteractiveShell: 'tools.shell.enableInteractiveShell',
114 |   shellPager: 'tools.shell.pager',
115 |   shellShowColor: 'tools.shell.showColor',
116 |   skipNextSpeakerCheck: 'model.skipNextSpeakerCheck',
117 |   summarizeToolOutput: 'model.summarizeToolOutput',
118 |   telemetry: 'telemetry',
119 |   theme: 'ui.theme',
120 |   toolDiscoveryCommand: 'tools.discoveryCommand',
121 |   toolCallCommand: 'tools.callCommand',
122 |   usageStatisticsEnabled: 'privacy.usageStatisticsEnabled',
123 |   useExternalAuth: 'security.auth.useExternal',
124 |   useRipgrep: 'tools.useRipgrep',
125 |   vimMode: 'general.vimMode',
126 | };
127 | 
128 | export function getSystemSettingsPath(): string {
129 |   if (process.env['GEMINI_CLI_SYSTEM_SETTINGS_PATH']) {
130 |     return process.env['GEMINI_CLI_SYSTEM_SETTINGS_PATH'];
131 |   }
132 |   if (platform() === 'darwin') {
133 |     return '/Library/Application Support/GeminiCli/settings.json';
134 |   } else if (platform() === 'win32') {
135 |     return 'C:\\ProgramData\\gemini-cli\\settings.json';
136 |   } else {
137 |     return '/etc/gemini-cli/settings.json';
138 |   }
139 | }
140 | 
141 | export function getSystemDefaultsPath(): string {
142 |   if (process.env['GEMINI_CLI_SYSTEM_DEFAULTS_PATH']) {
143 |     return process.env['GEMINI_CLI_SYSTEM_DEFAULTS_PATH'];
144 |   }
145 |   return path.join(
146 |     path.dirname(getSystemSettingsPath()),
147 |     'system-defaults.json',
148 |   );
149 | }
150 | 
151 | export type { DnsResolutionOrder } from './settingsSchema.js';
152 | 
153 | export enum SettingScope {
154 |   User = 'User',
155 |   Workspace = 'Workspace',
156 |   System = 'System',
157 |   SystemDefaults = 'SystemDefaults',
158 | }
159 | 
160 | export interface CheckpointingSettings {
161 |   enabled?: boolean;
162 | }
163 | 
164 | export interface SummarizeToolOutputSettings {
165 |   tokenBudget?: number;
166 | }
167 | 
168 | export interface AccessibilitySettings {
169 |   disableLoadingPhrases?: boolean;
170 |   screenReader?: boolean;
171 | }
172 | 
173 | export interface SessionRetentionSettings {
174 |   /** Enable automatic session cleanup */
175 |   enabled?: boolean;
176 | 
177 |   /** Maximum age of sessions to keep (e.g., "30d", "7d", "24h", "1w") */
178 |   maxAge?: string;
179 | 
180 |   /** Alternative: Maximum number of sessions to keep (most recent) */
181 |   maxCount?: number;
182 | 
183 |   /** Minimum retention period (safety limit, defaults to "1d") */
184 |   minRetention?: string;
185 | }
186 | 
187 | export interface SettingsError {
188 |   message: string;
189 |   path: string;
190 | }
191 | 
192 | export interface SettingsFile {
193 |   settings: Settings;
194 |   originalSettings: Settings;
195 |   path: string;
196 |   rawJson?: string;
197 | }
198 | 
199 | function setNestedProperty(
200 |   obj: Record<string, unknown>,
201 |   path: string,
202 |   value: unknown,
203 | ) {
204 |   const keys = path.split('.');
205 |   const lastKey = keys.pop();
206 |   if (!lastKey) return;
207 | 
208 |   let current: Record<string, unknown> = obj;
209 |   for (const key of keys) {
210 |     if (current[key] === undefined) {
211 |       current[key] = {};
212 |     }
213 |     const next = current[key];
214 |     if (typeof next === 'object' && next !== null) {
215 |       current = next as Record<string, unknown>;
216 |     } else {
217 |       // This path is invalid, so we stop.
218 |       return;
219 |     }
220 |   }
221 |   current[lastKey] = value;
222 | }
223 | 
224 | export function needsMigration(settings: Record<string, unknown>): boolean {
225 |   // A file needs migration if it contains any top-level key that is moved to a
226 |   // nested location in V2.
227 |   const hasV1Keys = Object.entries(MIGRATION_MAP).some(([v1Key, v2Path]) => {
228 |     if (v1Key === v2Path || !(v1Key in settings)) {
229 |       return false;
230 |     }
231 |     // If a key exists that is both a V1 key and a V2 container (like 'model'),
232 |     // we need to check the type. If it's an object, it's a V2 container and not
233 |     // a V1 key that needs migration.
234 |     if (
235 |       KNOWN_V2_CONTAINERS.has(v1Key) &&
236 |       typeof settings[v1Key] === 'object' &&
237 |       settings[v1Key] !== null
238 |     ) {
239 |       return false;
240 |     }
241 |     return true;
242 |   });
243 | 
244 |   return hasV1Keys;
245 | }
246 | 
247 | function migrateSettingsToV2(
248 |   flatSettings: Record<string, unknown>,
249 | ): Record<string, unknown> | null {
250 |   if (!needsMigration(flatSettings)) {
251 |     return null;
252 |   }
253 | 
254 |   const v2Settings: Record<string, unknown> = {};
255 |   const flatKeys = new Set(Object.keys(flatSettings));
256 | 
257 |   for (const [oldKey, newPath] of Object.entries(MIGRATION_MAP)) {
258 |     if (flatKeys.has(oldKey)) {
259 |       setNestedProperty(v2Settings, newPath, flatSettings[oldKey]);
260 |       flatKeys.delete(oldKey);
261 |     }
262 |   }
263 | 
264 |   // Preserve mcpServers at the top level
265 |   if (flatSettings['mcpServers']) {
266 |     v2Settings['mcpServers'] = flatSettings['mcpServers'];
267 |     flatKeys.delete('mcpServers');
268 |   }
269 | 
270 |   // Carry over any unrecognized keys
271 |   for (const remainingKey of flatKeys) {
272 |     const existingValue = v2Settings[remainingKey];
273 |     const newValue = flatSettings[remainingKey];
274 | 
275 |     if (
276 |       typeof existingValue === 'object' &&
277 |       existingValue !== null &&
278 |       !Array.isArray(existingValue) &&
279 |       typeof newValue === 'object' &&
280 |       newValue !== null &&
281 |       !Array.isArray(newValue)
282 |     ) {
283 |       const pathAwareGetStrategy = (path: string[]) =>
284 |         getMergeStrategyForPath([remainingKey, ...path]);
285 |       v2Settings[remainingKey] = customDeepMerge(
286 |         pathAwareGetStrategy,
287 |         {},
288 |         newValue as MergeableObject,
289 |         existingValue as MergeableObject,
290 |       );
291 |     } else {
292 |       v2Settings[remainingKey] = newValue;
293 |     }
294 |   }
295 | 
296 |   return v2Settings;
297 | }
298 | 
299 | function getNestedProperty(
300 |   obj: Record<string, unknown>,
301 |   path: string,
302 | ): unknown {
303 |   const keys = path.split('.');
304 |   let current: unknown = obj;
305 |   for (const key of keys) {
306 |     if (typeof current !== 'object' || current === null || !(key in current)) {
307 |       return undefined;
308 |     }
309 |     current = (current as Record<string, unknown>)[key];
310 |   }
311 |   return current;
312 | }
313 | 
314 | const REVERSE_MIGRATION_MAP: Record<string, string> = Object.fromEntries(
315 |   Object.entries(MIGRATION_MAP).map(([key, value]) => [value, key]),
316 | );
317 | 
318 | // Dynamically determine the top-level keys from the V2 settings structure.
319 | const KNOWN_V2_CONTAINERS = new Set(
320 |   Object.values(MIGRATION_MAP).map((path) => path.split('.')[0]),
321 | );
322 | 
323 | export function migrateSettingsToV1(
324 |   v2Settings: Record<string, unknown>,
325 | ): Record<string, unknown> {
326 |   const v1Settings: Record<string, unknown> = {};
327 |   const v2Keys = new Set(Object.keys(v2Settings));
328 | 
329 |   for (const [newPath, oldKey] of Object.entries(REVERSE_MIGRATION_MAP)) {
330 |     const value = getNestedProperty(v2Settings, newPath);
331 |     if (value !== undefined) {
332 |       v1Settings[oldKey] = value;
333 |       v2Keys.delete(newPath.split('.')[0]);
334 |     }
335 |   }
336 | 
337 |   // Preserve mcpServers at the top level
338 |   if (v2Settings['mcpServers']) {
339 |     v1Settings['mcpServers'] = v2Settings['mcpServers'];
340 |     v2Keys.delete('mcpServers');
341 |   }
342 | 
343 |   // Carry over any unrecognized keys
344 |   for (const remainingKey of v2Keys) {
345 |     const value = v2Settings[remainingKey];
346 |     if (value === undefined) {
347 |       continue;
348 |     }
349 | 
350 |     // Don't carry over empty objects that were just containers for migrated settings.
351 |     if (
352 |       KNOWN_V2_CONTAINERS.has(remainingKey) &&
353 |       typeof value === 'object' &&
354 |       value !== null &&
355 |       !Array.isArray(value) &&
356 |       Object.keys(value).length === 0
357 |     ) {
358 |       continue;
359 |     }
360 | 
361 |     v1Settings[remainingKey] = value;
362 |   }
363 | 
364 |   return v1Settings;
365 | }
366 | 
367 | function mergeSettings(
368 |   system: Settings,
369 |   systemDefaults: Settings,
370 |   user: Settings,
371 |   workspace: Settings,
372 |   isTrusted: boolean,
373 | ): Settings {
374 |   const safeWorkspace = isTrusted ? workspace : ({} as Settings);
375 | 
[TRUNCATED]
```

src/config/settingsSchema.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect } from 'vitest';
8 | import {
9 |   getSettingsSchema,
10 |   type SettingDefinition,
11 |   type Settings,
12 |   type SettingsSchema,
13 | } from './settingsSchema.js';
14 | 
15 | describe('SettingsSchema', () => {
16 |   describe('getSettingsSchema', () => {
17 |     it('should contain all expected top-level settings', () => {
18 |       const expectedSettings: Array<keyof Settings> = [
19 |         'mcpServers',
20 |         'general',
21 |         'ui',
22 |         'ide',
23 |         'privacy',
24 |         'telemetry',
25 |         'model',
26 |         'context',
27 |         'tools',
28 |         'mcp',
29 |         'security',
30 |         'advanced',
31 |       ];
32 | 
33 |       expectedSettings.forEach((setting) => {
34 |         expect(getSettingsSchema()[setting as keyof Settings]).toBeDefined();
35 |       });
36 |     });
37 | 
38 |     it('should have correct structure for each setting', () => {
39 |       Object.entries(getSettingsSchema()).forEach(([_key, definition]) => {
40 |         expect(definition).toHaveProperty('type');
41 |         expect(definition).toHaveProperty('label');
42 |         expect(definition).toHaveProperty('category');
43 |         expect(definition).toHaveProperty('requiresRestart');
44 |         expect(definition).toHaveProperty('default');
45 |         expect(typeof definition.type).toBe('string');
46 |         expect(typeof definition.label).toBe('string');
47 |         expect(typeof definition.category).toBe('string');
48 |         expect(typeof definition.requiresRestart).toBe('boolean');
49 |       });
50 |     });
51 | 
52 |     it('should have correct nested setting structure', () => {
53 |       const nestedSettings: Array<keyof Settings> = [
54 |         'general',
55 |         'ui',
56 |         'ide',
57 |         'privacy',
58 |         'model',
59 |         'context',
60 |         'tools',
61 |         'mcp',
62 |         'security',
63 |         'advanced',
64 |       ];
65 | 
66 |       nestedSettings.forEach((setting) => {
67 |         const definition = getSettingsSchema()[
68 |           setting as keyof Settings
69 |         ] as SettingDefinition;
70 |         expect(definition.type).toBe('object');
71 |         expect(definition.properties).toBeDefined();
72 |         expect(typeof definition.properties).toBe('object');
73 |       });
74 |     });
75 | 
76 |     it('should have accessibility nested properties', () => {
77 |       expect(
78 |         getSettingsSchema().ui?.properties?.accessibility?.properties,
79 |       ).toBeDefined();
80 |       expect(
81 |         getSettingsSchema().ui?.properties?.accessibility.properties
82 |           ?.disableLoadingPhrases.type,
83 |       ).toBe('boolean');
84 |     });
85 | 
86 |     it('should have checkpointing nested properties', () => {
87 |       expect(
88 |         getSettingsSchema().general?.properties?.checkpointing.properties
89 |           ?.enabled,
90 |       ).toBeDefined();
91 |       expect(
92 |         getSettingsSchema().general?.properties?.checkpointing.properties
93 |           ?.enabled.type,
94 |       ).toBe('boolean');
95 |     });
96 | 
97 |     it('should have fileFiltering nested properties', () => {
98 |       expect(
99 |         getSettingsSchema().context.properties.fileFiltering.properties
100 |           ?.respectGitIgnore,
101 |       ).toBeDefined();
102 |       expect(
103 |         getSettingsSchema().context.properties.fileFiltering.properties
104 |           ?.respectGeminiIgnore,
105 |       ).toBeDefined();
106 |       expect(
107 |         getSettingsSchema().context.properties.fileFiltering.properties
108 |           ?.enableRecursiveFileSearch,
109 |       ).toBeDefined();
110 |     });
111 | 
112 |     it('should have unique categories', () => {
113 |       const categories = new Set();
114 | 
115 |       // Collect categories from top-level settings
116 |       Object.values(getSettingsSchema()).forEach((definition) => {
117 |         categories.add(definition.category);
118 |         // Also collect from nested properties
119 |         const defWithProps = definition as typeof definition & {
120 |           properties?: Record<string, unknown>;
121 |         };
122 |         if (defWithProps.properties) {
123 |           Object.values(defWithProps.properties).forEach(
124 |             (nestedDef: unknown) => {
125 |               const nestedDefTyped = nestedDef as { category?: string };
126 |               if (nestedDefTyped.category) {
127 |                 categories.add(nestedDefTyped.category);
128 |               }
129 |             },
130 |           );
131 |         }
132 |       });
133 | 
134 |       expect(categories.size).toBeGreaterThan(0);
135 |       expect(categories).toContain('General');
136 |       expect(categories).toContain('UI');
137 |       expect(categories).toContain('Advanced');
138 |     });
139 | 
140 |     it('should have consistent default values for boolean settings', () => {
141 |       const checkBooleanDefaults = (schema: SettingsSchema) => {
142 |         Object.entries(schema).forEach(([, definition]) => {
143 |           const def = definition as SettingDefinition;
144 |           if (def.type === 'boolean') {
145 |             // Boolean settings can have boolean or undefined defaults (for optional settings)
146 |             expect(['boolean', 'undefined']).toContain(typeof def.default);
147 |           }
148 |           if (def.properties) {
149 |             checkBooleanDefaults(def.properties);
150 |           }
151 |         });
152 |       };
153 | 
154 |       checkBooleanDefaults(getSettingsSchema() as SettingsSchema);
155 |     });
156 | 
157 |     it('should have showInDialog property configured', () => {
158 |       // Check that user-facing settings are marked for dialog display
159 |       expect(
160 |         getSettingsSchema().ui.properties.showMemoryUsage.showInDialog,
161 |       ).toBe(true);
162 |       expect(getSettingsSchema().general.properties.vimMode.showInDialog).toBe(
163 |         true,
164 |       );
165 |       expect(getSettingsSchema().ide.properties.enabled.showInDialog).toBe(
166 |         true,
167 |       );
168 |       expect(
169 |         getSettingsSchema().general.properties.disableAutoUpdate.showInDialog,
170 |       ).toBe(true);
171 |       expect(
172 |         getSettingsSchema().ui.properties.hideWindowTitle.showInDialog,
173 |       ).toBe(true);
174 |       expect(getSettingsSchema().ui.properties.hideTips.showInDialog).toBe(
175 |         true,
176 |       );
177 |       expect(getSettingsSchema().ui.properties.hideBanner.showInDialog).toBe(
178 |         true,
179 |       );
180 |       expect(
181 |         getSettingsSchema().privacy.properties.usageStatisticsEnabled
182 |           .showInDialog,
183 |       ).toBe(false);
184 | 
185 |       // Check that advanced settings are hidden from dialog
186 |       expect(getSettingsSchema().security.properties.auth.showInDialog).toBe(
187 |         false,
188 |       );
189 |       expect(getSettingsSchema().tools.properties.core.showInDialog).toBe(
190 |         false,
191 |       );
192 |       expect(getSettingsSchema().mcpServers.showInDialog).toBe(false);
193 |       expect(getSettingsSchema().telemetry.showInDialog).toBe(false);
194 | 
195 |       // Check that some settings are appropriately hidden
196 |       expect(getSettingsSchema().ui.properties.theme.showInDialog).toBe(false); // Changed to false
197 |       expect(getSettingsSchema().ui.properties.customThemes.showInDialog).toBe(
198 |         false,
199 |       ); // Managed via theme editor
200 |       expect(
201 |         getSettingsSchema().general.properties.checkpointing.showInDialog,
202 |       ).toBe(false); // Experimental feature
203 |       expect(getSettingsSchema().ui.properties.accessibility.showInDialog).toBe(
204 |         false,
205 |       ); // Changed to false
206 |       expect(
207 |         getSettingsSchema().context.properties.fileFiltering.showInDialog,
208 |       ).toBe(false); // Changed to false
209 |       expect(
210 |         getSettingsSchema().general.properties.preferredEditor.showInDialog,
211 |       ).toBe(false); // Changed to false
212 |       expect(
213 |         getSettingsSchema().advanced.properties.autoConfigureMemory
214 |           .showInDialog,
215 |       ).toBe(false);
216 |     });
217 | 
218 |     it('should infer Settings type correctly', () => {
219 |       // This test ensures that the Settings type is properly inferred from the schema
220 |       const settings: Settings = {
221 |         ui: {
222 |           theme: 'dark',
223 |         },
224 |         context: {
225 |           includeDirectories: ['/path/to/dir'],
226 |           loadMemoryFromIncludeDirectories: true,
227 |         },
228 |       };
229 | 
230 |       // TypeScript should not complain about these properties
231 |       expect(settings.ui?.theme).toBe('dark');
232 |       expect(settings.context?.includeDirectories).toEqual(['/path/to/dir']);
233 |       expect(settings.context?.loadMemoryFromIncludeDirectories).toBe(true);
234 |     });
235 | 
236 |     it('should have includeDirectories setting in schema', () => {
237 |       expect(
238 |         getSettingsSchema().context?.properties.includeDirectories,
239 |       ).toBeDefined();
240 |       expect(
241 |         getSettingsSchema().context?.properties.includeDirectories.type,
242 |       ).toBe('array');
243 |       expect(
244 |         getSettingsSchema().context?.properties.includeDirectories.category,
245 |       ).toBe('Context');
246 |       expect(
247 |         getSettingsSchema().context?.properties.includeDirectories.default,
248 |       ).toEqual([]);
249 |     });
250 | 
251 |     it('should have loadMemoryFromIncludeDirectories setting in schema', () => {
252 |       expect(
253 |         getSettingsSchema().context?.properties
254 |           .loadMemoryFromIncludeDirectories,
255 |       ).toBeDefined();
256 |       expect(
257 |         getSettingsSchema().context?.properties.loadMemoryFromIncludeDirectories
258 |           .type,
259 |       ).toBe('boolean');
260 |       expect(
261 |         getSettingsSchema().context?.properties.loadMemoryFromIncludeDirectories
262 |           .category,
263 |       ).toBe('Context');
264 |       expect(
265 |         getSettingsSchema().context?.properties.loadMemoryFromIncludeDirectories
266 |           .default,
267 |       ).toBe(false);
268 |     });
269 | 
270 |     it('should have folderTrustFeature setting in schema', () => {
271 |       expect(
272 |         getSettingsSchema().security.properties.folderTrust.properties.enabled,
273 |       ).toBeDefined();
274 |       expect(
275 |         getSettingsSchema().security.properties.folderTrust.properties.enabled
276 |           .type,
277 |       ).toBe('boolean');
278 |       expect(
279 |         getSettingsSchema().security.properties.folderTrust.properties.enabled
280 |           .category,
281 |       ).toBe('Security');
282 |       expect(
283 |         getSettingsSchema().security.properties.folderTrust.properties.enabled
284 |           .default,
285 |       ).toBe(false);
286 |       expect(
287 |         getSettingsSchema().security.properties.folderTrust.properties.enabled
288 |           .showInDialog,
289 |       ).toBe(true);
290 |     });
291 | 
292 |     it('should have debugKeystrokeLogging setting in schema', () => {
293 |       expect(
294 |         getSettingsSchema().general.properties.debugKeystrokeLogging,
295 |       ).toBeDefined();
296 |       expect(
297 |         getSettingsSchema().general.properties.debugKeystrokeLogging.type,
298 |       ).toBe('boolean');
299 |       expect(
300 |         getSettingsSchema().general.properties.debugKeystrokeLogging.category,
301 |       ).toBe('General');
302 |       expect(
303 |         getSettingsSchema().general.properties.debugKeystrokeLogging.default,
304 |       ).toBe(false);
305 |       expect(
306 |         getSettingsSchema().general.properties.debugKeystrokeLogging
307 |           .requiresRestart,
308 |       ).toBe(false);
309 |       expect(
310 |         getSettingsSchema().general.properties.debugKeystrokeLogging
311 |           .showInDialog,
312 |       ).toBe(true);
313 |       expect(
314 |         getSettingsSchema().general.properties.debugKeystrokeLogging
315 |           .description,
316 |       ).toBe('Enable debug logging of keystrokes to the console.');
317 |     });
318 | 
319 |     it('should have useModelRouter setting in schema', () => {
320 |       expect(
321 |         getSettingsSchema().experimental.properties.useModelRouter,
322 |       ).toBeDefined();
323 |       expect(
324 |         getSettingsSchema().experimental.properties.useModelRouter.type,
325 |       ).toBe('boolean');
326 |       expect(
327 |         getSettingsSchema().experimental.properties.useModelRouter.category,
328 |       ).toBe('Experimental');
329 |       expect(
330 |         getSettingsSchema().experimental.properties.useModelRouter.default,
331 |       ).toBe(false);
332 |     });
333 | 
334 |     it('should have enableSubagents setting in schema', () => {
335 |       expect(
336 |         getSettingsSchema().experimental.properties.enableSubagents,
337 |       ).toBeDefined();
338 |       expect(
339 |         getSettingsSchema().experimental.properties.enableSubagents.type,
340 |       ).toBe('boolean');
341 |       expect(
342 |         getSettingsSchema().experimental.properties.enableSubagents.category,
343 |       ).toBe('Experimental');
344 |       expect(
345 |         getSettingsSchema().experimental.properties.enableSubagents.default,
346 |       ).toBe(false);
347 |       expect(
348 |         getSettingsSchema().experimental.properties.enableSubagents
349 |           .requiresRestart,
350 |       ).toBe(true);
351 |     });
352 |   });
353 | });
```

src/config/settingsSchema.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type {
8 |   MCPServerConfig,
9 |   BugCommandSettings,
10 |   TelemetrySettings,
11 |   AuthType,
12 |   ChatCompressionSettings,
13 | } from '@google/gemini-cli-core';
14 | import {
15 |   DEFAULT_TRUNCATE_TOOL_OUTPUT_LINES,
16 |   DEFAULT_TRUNCATE_TOOL_OUTPUT_THRESHOLD,
17 | } from '@google/gemini-cli-core';
18 | import type { CustomTheme } from '../ui/themes/theme.js';
19 | import type { SessionRetentionSettings } from './settings.js';
20 | import { DEFAULT_MIN_RETENTION } from '../utils/sessionCleanup.js';
21 | 
22 | export type SettingsType =
23 |   | 'boolean'
24 |   | 'string'
25 |   | 'number'
26 |   | 'array'
27 |   | 'object'
28 |   | 'enum';
29 | 
30 | export type SettingsValue =
31 |   | boolean
32 |   | string
33 |   | number
34 |   | string[]
35 |   | object
36 |   | undefined;
37 | 
38 | /**
39 |  * Setting datatypes that "toggle" through a fixed list of options
40 |  * (e.g. an enum or true/false) rather than allowing for free form input
41 |  * (like a number or string).
42 |  */
43 | export const TOGGLE_TYPES: ReadonlySet<SettingsType | undefined> = new Set([
44 |   'boolean',
45 |   'enum',
46 | ]);
47 | 
48 | export interface SettingEnumOption {
49 |   value: string | number;
50 |   label: string;
51 | }
52 | 
53 | export enum MergeStrategy {
54 |   // Replace the old value with the new value. This is the default.
55 |   REPLACE = 'replace',
56 |   // Concatenate arrays.
57 |   CONCAT = 'concat',
58 |   // Merge arrays, ensuring unique values.
59 |   UNION = 'union',
60 |   // Shallow merge objects.
61 |   SHALLOW_MERGE = 'shallow_merge',
62 | }
63 | 
64 | export interface SettingDefinition {
65 |   type: SettingsType;
66 |   label: string;
67 |   category: string;
68 |   requiresRestart: boolean;
69 |   default: SettingsValue;
70 |   description?: string;
71 |   parentKey?: string;
72 |   childKey?: string;
73 |   key?: string;
74 |   properties?: SettingsSchema;
75 |   showInDialog?: boolean;
76 |   mergeStrategy?: MergeStrategy;
77 |   /** Enum type options  */
78 |   options?: readonly SettingEnumOption[];
79 | }
80 | 
81 | export interface SettingsSchema {
82 |   [key: string]: SettingDefinition;
83 | }
84 | 
85 | export type MemoryImportFormat = 'tree' | 'flat';
86 | export type DnsResolutionOrder = 'ipv4first' | 'verbatim';
87 | 
88 | /**
89 |  * The canonical schema for all settings.
90 |  * The structure of this object defines the structure of the `Settings` type.
91 |  * `as const` is crucial for TypeScript to infer the most specific types possible.
92 |  */
93 | const SETTINGS_SCHEMA = {
94 |   // Maintained for compatibility/criticality
95 |   mcpServers: {
96 |     type: 'object',
97 |     label: 'MCP Servers',
98 |     category: 'Advanced',
99 |     requiresRestart: true,
100 |     default: {} as Record<string, MCPServerConfig>,
101 |     description: 'Configuration for MCP servers.',
102 |     showInDialog: false,
103 |     mergeStrategy: MergeStrategy.SHALLOW_MERGE,
104 |   },
105 | 
106 |   general: {
107 |     type: 'object',
108 |     label: 'General',
109 |     category: 'General',
110 |     requiresRestart: false,
111 |     default: {},
112 |     description: 'General application settings.',
113 |     showInDialog: false,
114 |     properties: {
115 |       preferredEditor: {
116 |         type: 'string',
117 |         label: 'Preferred Editor',
118 |         category: 'General',
119 |         requiresRestart: false,
120 |         default: undefined as string | undefined,
121 |         description: 'The preferred editor to open files in.',
122 |         showInDialog: false,
123 |       },
124 |       vimMode: {
125 |         type: 'boolean',
126 |         label: 'Vim Mode',
127 |         category: 'General',
128 |         requiresRestart: false,
129 |         default: false,
130 |         description: 'Enable Vim keybindings',
131 |         showInDialog: true,
132 |       },
133 |       disableAutoUpdate: {
134 |         type: 'boolean',
135 |         label: 'Disable Auto Update',
136 |         category: 'General',
137 |         requiresRestart: false,
138 |         default: false,
139 |         description: 'Disable automatic updates',
140 |         showInDialog: true,
141 |       },
142 |       disableUpdateNag: {
143 |         type: 'boolean',
144 |         label: 'Disable Update Nag',
145 |         category: 'General',
146 |         requiresRestart: false,
147 |         default: false,
148 |         description: 'Disable update notification prompts.',
149 |         showInDialog: false,
150 |       },
151 |       checkpointing: {
152 |         type: 'object',
153 |         label: 'Checkpointing',
154 |         category: 'General',
155 |         requiresRestart: true,
156 |         default: {},
157 |         description: 'Session checkpointing settings.',
158 |         showInDialog: false,
159 |         properties: {
160 |           enabled: {
161 |             type: 'boolean',
162 |             label: 'Enable Checkpointing',
163 |             category: 'General',
164 |             requiresRestart: true,
165 |             default: false,
166 |             description: 'Enable session checkpointing for recovery',
167 |             showInDialog: false,
168 |           },
169 |         },
170 |       },
171 |       enablePromptCompletion: {
172 |         type: 'boolean',
173 |         label: 'Enable Prompt Completion',
174 |         category: 'General',
175 |         requiresRestart: true,
176 |         default: false,
177 |         description:
178 |           'Enable AI-powered prompt completion suggestions while typing.',
179 |         showInDialog: true,
180 |       },
181 |       debugKeystrokeLogging: {
182 |         type: 'boolean',
183 |         label: 'Debug Keystroke Logging',
184 |         category: 'General',
185 |         requiresRestart: false,
186 |         default: false,
187 |         description: 'Enable debug logging of keystrokes to the console.',
188 |         showInDialog: true,
189 |       },
190 |       sessionRetention: {
191 |         type: 'object',
192 |         label: 'Session Retention',
193 |         category: 'General',
194 |         requiresRestart: false,
195 |         default: undefined as SessionRetentionSettings | undefined,
196 |         properties: {
197 |           enabled: {
198 |             type: 'boolean',
199 |             label: 'Enable Session Cleanup',
200 |             category: 'General',
201 |             requiresRestart: false,
202 |             default: false,
203 |             description: 'Enable automatic session cleanup',
204 |             showInDialog: true,
205 |           },
206 |           maxAge: {
207 |             type: 'string',
208 |             label: 'Max Session Age',
209 |             category: 'General',
210 |             requiresRestart: false,
211 |             default: undefined as string | undefined,
212 |             description:
213 |               'Maximum age of sessions to keep (e.g., "30d", "7d", "24h", "1w")',
214 |             showInDialog: false,
215 |           },
216 |           maxCount: {
217 |             type: 'number',
218 |             label: 'Max Session Count',
219 |             category: 'General',
220 |             requiresRestart: false,
221 |             default: undefined as number | undefined,
222 |             description:
223 |               'Alternative: Maximum number of sessions to keep (most recent)',
224 |             showInDialog: false,
225 |           },
226 |           minRetention: {
227 |             type: 'string',
228 |             label: 'Min Retention Period',
229 |             category: 'General',
230 |             requiresRestart: false,
231 |             default: DEFAULT_MIN_RETENTION,
232 |             description: `Minimum retention period (safety limit, defaults to "${DEFAULT_MIN_RETENTION}")`,
233 |             showInDialog: false,
234 |           },
235 |         },
236 |         description: 'Settings for automatic session cleanup.',
237 |       },
238 |     },
239 |   },
240 |   output: {
241 |     type: 'object',
242 |     label: 'Output',
243 |     category: 'General',
244 |     requiresRestart: false,
245 |     default: {},
246 |     description: 'Settings for the CLI output.',
247 |     showInDialog: false,
248 |     properties: {
249 |       format: {
250 |         type: 'enum',
251 |         label: 'Output Format',
252 |         category: 'General',
253 |         requiresRestart: false,
254 |         default: 'text',
255 |         description: 'The format of the CLI output.',
256 |         showInDialog: true,
257 |         options: [
258 |           { value: 'text', label: 'Text' },
259 |           { value: 'json', label: 'JSON' },
260 |         ],
261 |       },
262 |     },
263 |   },
264 | 
265 |   ui: {
266 |     type: 'object',
267 |     label: 'UI',
268 |     category: 'UI',
269 |     requiresRestart: false,
270 |     default: {},
271 |     description: 'User interface settings.',
272 |     showInDialog: false,
273 |     properties: {
274 |       theme: {
275 |         type: 'string',
276 |         label: 'Theme',
277 |         category: 'UI',
278 |         requiresRestart: false,
279 |         default: undefined as string | undefined,
280 |         description: 'The color theme for the UI.',
281 |         showInDialog: false,
282 |       },
283 |       customThemes: {
284 |         type: 'object',
285 |         label: 'Custom Themes',
286 |         category: 'UI',
287 |         requiresRestart: false,
288 |         default: {} as Record<string, CustomTheme>,
289 |         description: 'Custom theme definitions.',
290 |         showInDialog: false,
291 |       },
292 |       hideWindowTitle: {
293 |         type: 'boolean',
294 |         label: 'Hide Window Title',
295 |         category: 'UI',
296 |         requiresRestart: true,
297 |         default: false,
298 |         description: 'Hide the window title bar',
299 |         showInDialog: true,
300 |       },
301 |       showStatusInTitle: {
302 |         type: 'boolean',
303 |         label: 'Show Status in Title',
304 |         category: 'UI',
305 |         requiresRestart: false,
306 |         default: false,
307 |         description:
308 |           'Show Gemini CLI status and thoughts in the terminal window title',
309 |         showInDialog: true,
310 |       },
311 |       hideTips: {
312 |         type: 'boolean',
313 |         label: 'Hide Tips',
314 |         category: 'UI',
315 |         requiresRestart: false,
316 |         default: false,
317 |         description: 'Hide helpful tips in the UI',
318 |         showInDialog: true,
319 |       },
320 |       hideBanner: {
321 |         type: 'boolean',
322 |         label: 'Hide Banner',
323 |         category: 'UI',
324 |         requiresRestart: false,
325 |         default: false,
326 |         description: 'Hide the application banner',
327 |         showInDialog: true,
328 |       },
329 |       hideContextSummary: {
330 |         type: 'boolean',
331 |         label: 'Hide Context Summary',
332 |         category: 'UI',
333 |         requiresRestart: false,
334 |         default: false,
335 |         description:
336 |           'Hide the context summary (GEMINI.md, MCP servers) above the input.',
337 |         showInDialog: true,
338 |       },
339 |       footer: {
340 |         type: 'object',
341 |         label: 'Footer',
342 |         category: 'UI',
343 |         requiresRestart: false,
344 |         default: {},
345 |         description: 'Settings for the footer.',
346 |         showInDialog: false,
347 |         properties: {
348 |           hideCWD: {
349 |             type: 'boolean',
350 |             label: 'Hide CWD',
351 |             category: 'UI',
352 |             requiresRestart: false,
353 |             default: false,
354 |             description:
355 |               'Hide the current working directory path in the footer.',
356 |             showInDialog: true,
357 |           },
358 |           hideSandboxStatus: {
359 |             type: 'boolean',
360 |             label: 'Hide Sandbox Status',
361 |             category: 'UI',
362 |             requiresRestart: false,
363 |             default: false,
364 |             description: 'Hide the sandbox status indicator in the footer.',
365 |             showInDialog: true,
366 |           },
367 |           hideModelInfo: {
368 |             type: 'boolean',
369 |             label: 'Hide Model Info',
370 |             category: 'UI',
371 |             requiresRestart: false,
372 |             default: false,
373 |             description: 'Hide the model name and context usage in the footer.',
374 |             showInDialog: true,
375 |           },
376 |         },
377 |       },
378 |       hideFooter: {
379 |         type: 'boolean',
380 |         label: 'Hide Footer',
381 |         category: 'UI',
382 |         requiresRestart: false,
383 |         default: false,
384 |         description: 'Hide the footer from the UI',
385 |         showInDialog: true,
386 |       },
387 |       showMemoryUsage: {
388 |         type: 'boolean',
389 |         label: 'Show Memory Usage',
390 |         category: 'UI',
391 |         requiresRestart: false,
392 |         default: false,
393 |         description: 'Display memory usage information in the UI',
394 |         showInDialog: true,
395 |       },
396 |       showLineNumbers: {
397 |         type: 'boolean',
398 |         label: 'Show Line Numbers',
399 |         category: 'UI',
400 |         requiresRestart: false,
401 |         default: false,
402 |         description: 'Show line numbers in the chat.',
403 |         showInDialog: true,
404 |       },
405 |       showCitations: {
406 |         type: 'boolean',
407 |         label: 'Show Citations',
408 |         category: 'UI',
409 |         requiresRestart: false,
410 |         default: false,
411 |         description: 'Show citations for generated text in the chat.',
412 |         showInDialog: true,
413 |       },
414 |       useFullWidth: {
415 |         type: 'boolean',
416 |         label: 'Use Full Width',
417 |         category: 'UI',
418 |         requiresRestart: false,
419 |         default: false,
420 |         description: 'Use the entire width of the terminal for output.',
421 |         showInDialog: true,
422 |       },
423 |       customWittyPhrases: {
424 |         type: 'array',
425 |         label: 'Custom Witty Phrases',
426 |         category: 'UI',
427 |         requiresRestart: false,
[TRUNCATED]
```

src/config/trustedFolders.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import * as osActual from 'node:os';
8 | import { FatalConfigError, ideContextStore } from '@google/gemini-cli-core';
9 | import {
10 |   describe,
11 |   it,
12 |   expect,
13 |   vi,
14 |   beforeEach,
15 |   afterEach,
16 |   type Mocked,
17 |   type Mock,
18 | } from 'vitest';
19 | import * as fs from 'node:fs';
20 | import stripJsonComments from 'strip-json-comments';
21 | import * as path from 'node:path';
22 | import {
23 |   loadTrustedFolders,
24 |   getTrustedFoldersPath,
25 |   TrustLevel,
26 |   isWorkspaceTrusted,
27 |   resetTrustedFoldersForTesting,
28 | } from './trustedFolders.js';
29 | import type { Settings } from './settings.js';
30 | 
31 | vi.mock('os', async (importOriginal) => {
32 |   const actualOs = await importOriginal<typeof osActual>();
33 |   return {
34 |     ...actualOs,
35 |     homedir: vi.fn(() => '/mock/home/user'),
36 |     platform: vi.fn(() => 'linux'),
37 |   };
38 | });
39 | vi.mock('fs', async (importOriginal) => {
40 |   const actualFs = await importOriginal<typeof fs>();
41 |   return {
42 |     ...actualFs,
43 |     existsSync: vi.fn(),
44 |     readFileSync: vi.fn(),
45 |     writeFileSync: vi.fn(),
46 |     mkdirSync: vi.fn(),
47 |   };
48 | });
49 | vi.mock('strip-json-comments', () => ({
50 |   default: vi.fn((content) => content),
51 | }));
52 | 
53 | describe('Trusted Folders Loading', () => {
54 |   let mockFsExistsSync: Mocked<typeof fs.existsSync>;
55 |   let mockStripJsonComments: Mocked<typeof stripJsonComments>;
56 |   let mockFsWriteFileSync: Mocked<typeof fs.writeFileSync>;
57 | 
58 |   beforeEach(() => {
59 |     resetTrustedFoldersForTesting();
60 |     vi.resetAllMocks();
61 |     mockFsExistsSync = vi.mocked(fs.existsSync);
62 |     mockStripJsonComments = vi.mocked(stripJsonComments);
63 |     mockFsWriteFileSync = vi.mocked(fs.writeFileSync);
64 |     vi.mocked(osActual.homedir).mockReturnValue('/mock/home/user');
65 |     (mockStripJsonComments as unknown as Mock).mockImplementation(
66 |       (jsonString: string) => jsonString,
67 |     );
68 |     (mockFsExistsSync as Mock).mockReturnValue(false);
69 |     (fs.readFileSync as Mock).mockReturnValue('{}');
70 |   });
71 | 
72 |   afterEach(() => {
73 |     vi.restoreAllMocks();
74 |   });
75 | 
76 |   it('should load empty rules if no files exist', () => {
77 |     const { rules, errors } = loadTrustedFolders();
78 |     expect(rules).toEqual([]);
79 |     expect(errors).toEqual([]);
80 |   });
81 | 
82 |   describe('isPathTrusted', () => {
83 |     function setup({ config = {} as Record<string, TrustLevel> } = {}) {
84 |       (mockFsExistsSync as Mock).mockImplementation(
85 |         (p) => p === getTrustedFoldersPath(),
86 |       );
87 |       (fs.readFileSync as Mock).mockImplementation((p) => {
88 |         if (p === getTrustedFoldersPath()) return JSON.stringify(config);
89 |         return '{}';
90 |       });
91 | 
92 |       const folders = loadTrustedFolders();
93 | 
94 |       return { folders };
95 |     }
96 | 
97 |     it('provides a method to determine if a path is trusted', () => {
98 |       const { folders } = setup({
99 |         config: {
100 |           './myfolder': TrustLevel.TRUST_FOLDER,
101 |           '/trustedparent/trustme': TrustLevel.TRUST_PARENT,
102 |           '/user/folder': TrustLevel.TRUST_FOLDER,
103 |           '/secret': TrustLevel.DO_NOT_TRUST,
104 |           '/secret/publickeys': TrustLevel.TRUST_FOLDER,
105 |         },
106 |       });
107 |       expect(folders.isPathTrusted('/secret')).toBe(false);
108 |       expect(folders.isPathTrusted('/user/folder')).toBe(true);
109 |       expect(folders.isPathTrusted('/secret/publickeys/public.pem')).toBe(true);
110 |       expect(folders.isPathTrusted('/user/folder/harhar')).toBe(true);
111 |       expect(folders.isPathTrusted('myfolder/somefile.jpg')).toBe(true);
112 |       expect(folders.isPathTrusted('/trustedparent/someotherfolder')).toBe(
113 |         true,
114 |       );
115 |       expect(folders.isPathTrusted('/trustedparent/trustme')).toBe(true);
116 | 
117 |       // No explicit rule covers this file
118 |       expect(folders.isPathTrusted('/secret/bankaccounts.json')).toBe(
119 |         undefined,
120 |       );
121 |       expect(folders.isPathTrusted('/secret/mine/privatekey.pem')).toBe(
122 |         undefined,
123 |       );
124 |       expect(folders.isPathTrusted('/user/someotherfolder')).toBe(undefined);
125 |     });
126 |   });
127 | 
128 |   it('should load user rules if only user file exists', () => {
129 |     const userPath = getTrustedFoldersPath();
130 |     (mockFsExistsSync as Mock).mockImplementation((p) => p === userPath);
131 |     const userContent = {
132 |       '/user/folder': TrustLevel.TRUST_FOLDER,
133 |     };
134 |     (fs.readFileSync as Mock).mockImplementation((p) => {
135 |       if (p === userPath) return JSON.stringify(userContent);
136 |       return '{}';
137 |     });
138 | 
139 |     const { rules, errors } = loadTrustedFolders();
140 |     expect(rules).toEqual([
141 |       { path: '/user/folder', trustLevel: TrustLevel.TRUST_FOLDER },
142 |     ]);
143 |     expect(errors).toEqual([]);
144 |   });
145 | 
146 |   it('should handle JSON parsing errors gracefully', () => {
147 |     const userPath = getTrustedFoldersPath();
148 |     (mockFsExistsSync as Mock).mockImplementation((p) => p === userPath);
149 |     (fs.readFileSync as Mock).mockImplementation((p) => {
150 |       if (p === userPath) return 'invalid json';
151 |       return '{}';
152 |     });
153 | 
154 |     const { rules, errors } = loadTrustedFolders();
155 |     expect(rules).toEqual([]);
156 |     expect(errors.length).toBe(1);
157 |     expect(errors[0].path).toBe(userPath);
158 |     expect(errors[0].message).toContain('Unexpected token');
159 |   });
160 | 
161 |   it('should use GEMINI_CLI_TRUSTED_FOLDERS_PATH env var if set', () => {
162 |     const customPath = '/custom/path/to/trusted_folders.json';
163 |     process.env['GEMINI_CLI_TRUSTED_FOLDERS_PATH'] = customPath;
164 | 
165 |     (mockFsExistsSync as Mock).mockImplementation((p) => p === customPath);
166 |     const userContent = {
167 |       '/user/folder/from/env': TrustLevel.TRUST_FOLDER,
168 |     };
169 |     (fs.readFileSync as Mock).mockImplementation((p) => {
170 |       if (p === customPath) return JSON.stringify(userContent);
171 |       return '{}';
172 |     });
173 | 
174 |     const { rules, errors } = loadTrustedFolders();
175 |     expect(rules).toEqual([
176 |       {
177 |         path: '/user/folder/from/env',
178 |         trustLevel: TrustLevel.TRUST_FOLDER,
179 |       },
180 |     ]);
181 |     expect(errors).toEqual([]);
182 | 
183 |     delete process.env['GEMINI_CLI_TRUSTED_FOLDERS_PATH'];
184 |   });
185 | 
186 |   it('setValue should update the user config and save it', () => {
187 |     const loadedFolders = loadTrustedFolders();
188 |     loadedFolders.setValue('/new/path', TrustLevel.TRUST_FOLDER);
189 | 
190 |     expect(loadedFolders.user.config['/new/path']).toBe(
191 |       TrustLevel.TRUST_FOLDER,
192 |     );
193 |     expect(mockFsWriteFileSync).toHaveBeenCalledWith(
194 |       getTrustedFoldersPath(),
195 |       JSON.stringify({ '/new/path': TrustLevel.TRUST_FOLDER }, null, 2),
196 |       { encoding: 'utf-8', mode: 0o600 },
197 |     );
198 |   });
199 | });
200 | 
201 | describe('isWorkspaceTrusted', () => {
202 |   let mockCwd: string;
203 |   const mockRules: Record<string, TrustLevel> = {};
204 |   const mockSettings: Settings = {
205 |     security: {
206 |       folderTrust: {
207 |         enabled: true,
208 |       },
209 |     },
210 |   };
211 | 
212 |   beforeEach(() => {
213 |     resetTrustedFoldersForTesting();
214 |     vi.spyOn(process, 'cwd').mockImplementation(() => mockCwd);
215 |     vi.spyOn(fs, 'readFileSync').mockImplementation((p) => {
216 |       if (p === getTrustedFoldersPath()) {
217 |         return JSON.stringify(mockRules);
218 |       }
219 |       return '{}';
220 |     });
221 |     vi.spyOn(fs, 'existsSync').mockImplementation(
222 |       (p) => p === getTrustedFoldersPath(),
223 |     );
224 |   });
225 | 
226 |   afterEach(() => {
227 |     vi.restoreAllMocks();
228 |     // Clear the object
229 |     Object.keys(mockRules).forEach((key) => delete mockRules[key]);
230 |   });
231 | 
232 |   it('should throw a fatal error if the config is malformed', () => {
233 |     mockCwd = '/home/user/projectA';
234 |     // This mock needs to be specific to this test to override the one in beforeEach
235 |     vi.spyOn(fs, 'readFileSync').mockImplementation((p) => {
236 |       if (p === getTrustedFoldersPath()) {
237 |         return '{"foo": "bar",}'; // Malformed JSON with trailing comma
238 |       }
239 |       return '{}';
240 |     });
241 |     expect(() => isWorkspaceTrusted(mockSettings)).toThrow(FatalConfigError);
242 |     expect(() => isWorkspaceTrusted(mockSettings)).toThrow(
243 |       /Please fix the configuration file/,
244 |     );
245 |   });
246 | 
247 |   it('should throw a fatal error if the config is not a JSON object', () => {
248 |     mockCwd = '/home/user/projectA';
249 |     vi.spyOn(fs, 'readFileSync').mockImplementation((p) => {
250 |       if (p === getTrustedFoldersPath()) {
251 |         return 'null';
252 |       }
253 |       return '{}';
254 |     });
255 |     expect(() => isWorkspaceTrusted(mockSettings)).toThrow(FatalConfigError);
256 |     expect(() => isWorkspaceTrusted(mockSettings)).toThrow(
257 |       /not a valid JSON object/,
258 |     );
259 |   });
260 | 
261 |   it('should return true for a directly trusted folder', () => {
262 |     mockCwd = '/home/user/projectA';
263 |     mockRules['/home/user/projectA'] = TrustLevel.TRUST_FOLDER;
264 |     expect(isWorkspaceTrusted(mockSettings)).toEqual({
265 |       isTrusted: true,
266 |       source: 'file',
267 |     });
268 |   });
269 | 
270 |   it('should return true for a child of a trusted folder', () => {
271 |     mockCwd = '/home/user/projectA/src';
272 |     mockRules['/home/user/projectA'] = TrustLevel.TRUST_FOLDER;
273 |     expect(isWorkspaceTrusted(mockSettings)).toEqual({
274 |       isTrusted: true,
275 |       source: 'file',
276 |     });
277 |   });
278 | 
279 |   it('should return true for a child of a trusted parent folder', () => {
280 |     mockCwd = '/home/user/projectB';
281 |     mockRules['/home/user/projectB/somefile.txt'] = TrustLevel.TRUST_PARENT;
282 |     expect(isWorkspaceTrusted(mockSettings)).toEqual({
283 |       isTrusted: true,
284 |       source: 'file',
285 |     });
286 |   });
287 | 
288 |   it('should return false for a directly untrusted folder', () => {
289 |     mockCwd = '/home/user/untrusted';
290 |     mockRules['/home/user/untrusted'] = TrustLevel.DO_NOT_TRUST;
291 |     expect(isWorkspaceTrusted(mockSettings)).toEqual({
292 |       isTrusted: false,
293 |       source: 'file',
294 |     });
295 |   });
296 | 
297 |   it('should return undefined for a child of an untrusted folder', () => {
298 |     mockCwd = '/home/user/untrusted/src';
299 |     mockRules['/home/user/untrusted'] = TrustLevel.DO_NOT_TRUST;
300 |     expect(isWorkspaceTrusted(mockSettings).isTrusted).toBeUndefined();
301 |   });
302 | 
303 |   it('should return undefined when no rules match', () => {
304 |     mockCwd = '/home/user/other';
305 |     mockRules['/home/user/projectA'] = TrustLevel.TRUST_FOLDER;
306 |     mockRules['/home/user/untrusted'] = TrustLevel.DO_NOT_TRUST;
307 |     expect(isWorkspaceTrusted(mockSettings).isTrusted).toBeUndefined();
308 |   });
309 | 
310 |   it('should prioritize trust over distrust', () => {
311 |     mockCwd = '/home/user/projectA/untrusted';
312 |     mockRules['/home/user/projectA'] = TrustLevel.TRUST_FOLDER;
313 |     mockRules['/home/user/projectA/untrusted'] = TrustLevel.DO_NOT_TRUST;
314 |     expect(isWorkspaceTrusted(mockSettings)).toEqual({
315 |       isTrusted: true,
316 |       source: 'file',
317 |     });
318 |   });
319 | 
320 |   it('should handle path normalization', () => {
321 |     mockCwd = '/home/user/projectA';
322 |     mockRules[`/home/user/../user/${path.basename('/home/user/projectA')}`] =
323 |       TrustLevel.TRUST_FOLDER;
324 |     expect(isWorkspaceTrusted(mockSettings)).toEqual({
325 |       isTrusted: true,
326 |       source: 'file',
327 |     });
328 |   });
329 | });
330 | 
331 | describe('isWorkspaceTrusted with IDE override', () => {
332 |   afterEach(() => {
333 |     vi.clearAllMocks();
334 |     ideContextStore.clear();
335 |     resetTrustedFoldersForTesting();
336 |   });
337 | 
338 |   const mockSettings: Settings = {
339 |     security: {
340 |       folderTrust: {
341 |         enabled: true,
342 |       },
343 |     },
344 |   };
345 | 
346 |   it('should return true when ideTrust is true, ignoring config', () => {
347 |     ideContextStore.set({ workspaceState: { isTrusted: true } });
348 |     // Even if config says don't trust, ideTrust should win.
349 |     vi.spyOn(fs, 'readFileSync').mockReturnValue(
350 |       JSON.stringify({ [process.cwd()]: TrustLevel.DO_NOT_TRUST }),
351 |     );
352 |     expect(isWorkspaceTrusted(mockSettings)).toEqual({
353 |       isTrusted: true,
354 |       source: 'ide',
355 |     });
356 |   });
357 | 
[TRUNCATED]
```

src/config/trustedFolders.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import * as fs from 'node:fs';
8 | import * as path from 'node:path';
9 | import { homedir } from 'node:os';
10 | import {
11 |   FatalConfigError,
12 |   getErrorMessage,
13 |   isWithinRoot,
14 |   ideContextStore,
15 | } from '@google/gemini-cli-core';
16 | import type { Settings } from './settings.js';
17 | import stripJsonComments from 'strip-json-comments';
18 | 
19 | export const TRUSTED_FOLDERS_FILENAME = 'trustedFolders.json';
20 | export const SETTINGS_DIRECTORY_NAME = '.gemini';
21 | export const USER_SETTINGS_DIR = path.join(homedir(), SETTINGS_DIRECTORY_NAME);
22 | 
23 | export function getTrustedFoldersPath(): string {
24 |   if (process.env['GEMINI_CLI_TRUSTED_FOLDERS_PATH']) {
25 |     return process.env['GEMINI_CLI_TRUSTED_FOLDERS_PATH'];
26 |   }
27 |   return path.join(USER_SETTINGS_DIR, TRUSTED_FOLDERS_FILENAME);
28 | }
29 | 
30 | export enum TrustLevel {
31 |   TRUST_FOLDER = 'TRUST_FOLDER',
32 |   TRUST_PARENT = 'TRUST_PARENT',
33 |   DO_NOT_TRUST = 'DO_NOT_TRUST',
34 | }
35 | 
36 | export interface TrustRule {
37 |   path: string;
38 |   trustLevel: TrustLevel;
39 | }
40 | 
41 | export interface TrustedFoldersError {
42 |   message: string;
43 |   path: string;
44 | }
45 | 
46 | export interface TrustedFoldersFile {
47 |   config: Record<string, TrustLevel>;
48 |   path: string;
49 | }
50 | 
51 | export interface TrustResult {
52 |   isTrusted: boolean | undefined;
53 |   source: 'ide' | 'file' | undefined;
54 | }
55 | 
56 | export class LoadedTrustedFolders {
57 |   constructor(
58 |     readonly user: TrustedFoldersFile,
59 |     readonly errors: TrustedFoldersError[],
60 |   ) {}
61 | 
62 |   get rules(): TrustRule[] {
63 |     return Object.entries(this.user.config).map(([path, trustLevel]) => ({
64 |       path,
65 |       trustLevel,
66 |     }));
67 |   }
68 | 
69 |   /**
70 |    * Returns true or false if the path should be "trusted". This function
71 |    * should only be invoked when the folder trust setting is active.
72 |    *
73 |    * @param location path
74 |    * @returns
75 |    */
76 |   isPathTrusted(location: string): boolean | undefined {
77 |     const trustedPaths: string[] = [];
78 |     const untrustedPaths: string[] = [];
79 | 
80 |     for (const rule of this.rules) {
81 |       switch (rule.trustLevel) {
82 |         case TrustLevel.TRUST_FOLDER:
83 |           trustedPaths.push(rule.path);
84 |           break;
85 |         case TrustLevel.TRUST_PARENT:
86 |           trustedPaths.push(path.dirname(rule.path));
87 |           break;
88 |         case TrustLevel.DO_NOT_TRUST:
89 |           untrustedPaths.push(rule.path);
90 |           break;
91 |         default:
92 |           // Do nothing for unknown trust levels.
93 |           break;
94 |       }
95 |     }
96 | 
97 |     for (const trustedPath of trustedPaths) {
98 |       if (isWithinRoot(location, trustedPath)) {
99 |         return true;
100 |       }
101 |     }
102 | 
103 |     for (const untrustedPath of untrustedPaths) {
104 |       if (path.normalize(location) === path.normalize(untrustedPath)) {
105 |         return false;
106 |       }
107 |     }
108 | 
109 |     return undefined;
110 |   }
111 | 
112 |   setValue(path: string, trustLevel: TrustLevel): void {
113 |     this.user.config[path] = trustLevel;
114 |     saveTrustedFolders(this.user);
115 |   }
116 | }
117 | 
118 | let loadedTrustedFolders: LoadedTrustedFolders | undefined;
119 | 
120 | /**
121 |  * FOR TESTING PURPOSES ONLY.
122 |  * Resets the in-memory cache of the trusted folders configuration.
123 |  */
124 | export function resetTrustedFoldersForTesting(): void {
125 |   loadedTrustedFolders = undefined;
126 | }
127 | 
128 | export function loadTrustedFolders(): LoadedTrustedFolders {
129 |   if (loadedTrustedFolders) {
130 |     return loadedTrustedFolders;
131 |   }
132 | 
133 |   const errors: TrustedFoldersError[] = [];
134 |   let userConfig: Record<string, TrustLevel> = {};
135 | 
136 |   const userPath = getTrustedFoldersPath();
137 | 
138 |   // Load user trusted folders
139 |   try {
140 |     if (fs.existsSync(userPath)) {
141 |       const content = fs.readFileSync(userPath, 'utf-8');
142 |       const parsed: unknown = JSON.parse(stripJsonComments(content));
143 | 
144 |       if (
145 |         typeof parsed !== 'object' ||
146 |         parsed === null ||
147 |         Array.isArray(parsed)
148 |       ) {
149 |         errors.push({
150 |           message: 'Trusted folders file is not a valid JSON object.',
151 |           path: userPath,
152 |         });
153 |       } else {
154 |         userConfig = parsed as Record<string, TrustLevel>;
155 |       }
156 |     }
157 |   } catch (error: unknown) {
158 |     errors.push({
159 |       message: getErrorMessage(error),
160 |       path: userPath,
161 |     });
162 |   }
163 | 
164 |   loadedTrustedFolders = new LoadedTrustedFolders(
165 |     { path: userPath, config: userConfig },
166 |     errors,
167 |   );
168 |   return loadedTrustedFolders;
169 | }
170 | 
171 | export function saveTrustedFolders(
172 |   trustedFoldersFile: TrustedFoldersFile,
173 | ): void {
174 |   try {
175 |     // Ensure the directory exists
176 |     const dirPath = path.dirname(trustedFoldersFile.path);
177 |     if (!fs.existsSync(dirPath)) {
178 |       fs.mkdirSync(dirPath, { recursive: true });
179 |     }
180 | 
181 |     fs.writeFileSync(
182 |       trustedFoldersFile.path,
183 |       JSON.stringify(trustedFoldersFile.config, null, 2),
184 |       { encoding: 'utf-8', mode: 0o600 },
185 |     );
186 |   } catch (error) {
187 |     console.error('Error saving trusted folders file:', error);
188 |   }
189 | }
190 | 
191 | /** Is folder trust feature enabled per the current applied settings */
192 | export function isFolderTrustEnabled(settings: Settings): boolean {
193 |   const folderTrustSetting = settings.security?.folderTrust?.enabled ?? false;
194 |   return folderTrustSetting;
195 | }
196 | 
197 | function getWorkspaceTrustFromLocalConfig(
198 |   trustConfig?: Record<string, TrustLevel>,
199 | ): TrustResult {
200 |   const folders = loadTrustedFolders();
201 | 
202 |   if (trustConfig) {
203 |     folders.user.config = trustConfig;
204 |   }
205 | 
206 |   if (folders.errors.length > 0) {
207 |     const errorMessages = folders.errors.map(
208 |       (error) => `Error in ${error.path}: ${error.message}`,
209 |     );
210 |     throw new FatalConfigError(
211 |       `${errorMessages.join('\n')}\nPlease fix the configuration file and try again.`,
212 |     );
213 |   }
214 | 
215 |   const isTrusted = folders.isPathTrusted(process.cwd());
216 |   return {
217 |     isTrusted,
218 |     source: isTrusted !== undefined ? 'file' : undefined,
219 |   };
220 | }
221 | 
222 | export function isWorkspaceTrusted(
223 |   settings: Settings,
224 |   trustConfig?: Record<string, TrustLevel>,
225 | ): TrustResult {
226 |   if (!isFolderTrustEnabled(settings)) {
227 |     return { isTrusted: true, source: undefined };
228 |   }
229 | 
230 |   const ideTrust = ideContextStore.get()?.workspaceState?.isTrusted;
231 |   if (ideTrust !== undefined) {
232 |     return { isTrusted: ideTrust, source: 'ide' };
233 |   }
234 | 
235 |   // Fall back to the local user configuration
236 |   return getWorkspaceTrustFromLocalConfig(trustConfig);
237 | }
```

src/services/BuiltinCommandLoader.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | vi.mock('../ui/commands/profileCommand.js', async () => {
8 |   const { CommandKind } = await import('../ui/commands/types.js');
9 |   return {
10 |     profileCommand: {
11 |       name: 'profile',
12 |       description: 'Profile command',
13 |       kind: CommandKind.BUILT_IN,
14 |     },
15 |   };
16 | });
17 | 
18 | vi.mock('../ui/commands/aboutCommand.js', async () => {
19 |   const { CommandKind } = await import('../ui/commands/types.js');
20 |   return {
21 |     aboutCommand: {
22 |       name: 'about',
23 |       description: 'About the CLI',
24 |       kind: CommandKind.BUILT_IN,
25 |     },
26 |   };
27 | });
28 | 
29 | vi.mock('../ui/commands/ideCommand.js', async () => {
30 |   const { CommandKind } = await import('../ui/commands/types.js');
31 |   return {
32 |     ideCommand: vi.fn().mockResolvedValue({
33 |       name: 'ide',
34 |       description: 'IDE command',
35 |       kind: CommandKind.BUILT_IN,
36 |     }),
37 |   };
38 | });
39 | vi.mock('../ui/commands/restoreCommand.js', () => ({
40 |   restoreCommand: vi.fn(),
41 | }));
42 | vi.mock('../ui/commands/permissionsCommand.js', async () => {
43 |   const { CommandKind } = await import('../ui/commands/types.js');
44 |   return {
45 |     permissionsCommand: {
46 |       name: 'permissions',
47 |       description: 'Permissions command',
48 |       kind: CommandKind.BUILT_IN,
49 |     },
50 |   };
51 | });
52 | 
53 | import { describe, it, expect, vi, beforeEach, type Mock } from 'vitest';
54 | import { BuiltinCommandLoader } from './BuiltinCommandLoader.js';
55 | import type { Config } from '@google/gemini-cli-core';
56 | import { CommandKind } from '../ui/commands/types.js';
57 | 
58 | import { restoreCommand } from '../ui/commands/restoreCommand.js';
59 | 
60 | vi.mock('../ui/commands/authCommand.js', () => ({ authCommand: {} }));
61 | vi.mock('../ui/commands/bugCommand.js', () => ({ bugCommand: {} }));
62 | vi.mock('../ui/commands/chatCommand.js', () => ({ chatCommand: {} }));
63 | vi.mock('../ui/commands/clearCommand.js', () => ({ clearCommand: {} }));
64 | vi.mock('../ui/commands/compressCommand.js', () => ({ compressCommand: {} }));
65 | vi.mock('../ui/commands/corgiCommand.js', () => ({ corgiCommand: {} }));
66 | vi.mock('../ui/commands/docsCommand.js', () => ({ docsCommand: {} }));
67 | vi.mock('../ui/commands/editorCommand.js', () => ({ editorCommand: {} }));
68 | vi.mock('../ui/commands/extensionsCommand.js', () => ({
69 |   extensionsCommand: {},
70 | }));
71 | vi.mock('../ui/commands/helpCommand.js', () => ({ helpCommand: {} }));
72 | vi.mock('../ui/commands/memoryCommand.js', () => ({ memoryCommand: {} }));
73 | vi.mock('../ui/commands/modelCommand.js', () => ({
74 |   modelCommand: { name: 'model' },
75 | }));
76 | vi.mock('../ui/commands/privacyCommand.js', () => ({ privacyCommand: {} }));
77 | vi.mock('../ui/commands/quitCommand.js', () => ({ quitCommand: {} }));
78 | vi.mock('../ui/commands/statsCommand.js', () => ({ statsCommand: {} }));
79 | vi.mock('../ui/commands/themeCommand.js', () => ({ themeCommand: {} }));
80 | vi.mock('../ui/commands/toolsCommand.js', () => ({ toolsCommand: {} }));
81 | vi.mock('../ui/commands/mcpCommand.js', () => ({
82 |   mcpCommand: {
83 |     name: 'mcp',
84 |     description: 'MCP command',
85 |     kind: 'BUILT_IN',
86 |   },
87 | }));
88 | 
89 | describe('BuiltinCommandLoader', () => {
90 |   let mockConfig: Config;
91 | 
92 |   const restoreCommandMock = restoreCommand as Mock;
93 | 
94 |   beforeEach(() => {
95 |     vi.clearAllMocks();
96 |     mockConfig = {
97 |       getFolderTrust: vi.fn().mockReturnValue(true),
98 |       getUseModelRouter: () => false,
99 |     } as unknown as Config;
100 | 
101 |     restoreCommandMock.mockReturnValue({
102 |       name: 'restore',
103 |       description: 'Restore command',
104 |       kind: CommandKind.BUILT_IN,
105 |     });
106 |   });
107 | 
108 |   it('should correctly pass the config object to restore command factory', async () => {
109 |     const loader = new BuiltinCommandLoader(mockConfig);
110 |     await loader.loadCommands(new AbortController().signal);
111 | 
112 |     // ideCommand is now a constant, no longer needs config
113 |     expect(restoreCommandMock).toHaveBeenCalledTimes(1);
114 |     expect(restoreCommandMock).toHaveBeenCalledWith(mockConfig);
115 |   });
116 | 
117 |   it('should filter out null command definitions returned by factories', async () => {
118 |     // ideCommand is now a constant SlashCommand
119 |     const loader = new BuiltinCommandLoader(mockConfig);
120 |     const commands = await loader.loadCommands(new AbortController().signal);
121 | 
122 |     // The 'ide' command should be present.
123 |     const ideCmd = commands.find((c) => c.name === 'ide');
124 |     expect(ideCmd).toBeDefined();
125 | 
126 |     // Other commands should still be present.
127 |     const aboutCmd = commands.find((c) => c.name === 'about');
128 |     expect(aboutCmd).toBeDefined();
129 |   });
130 | 
131 |   it('should handle a null config gracefully when calling factories', async () => {
132 |     const loader = new BuiltinCommandLoader(null);
133 |     await loader.loadCommands(new AbortController().signal);
134 |     // ideCommand is now a constant, no longer needs config
135 |     expect(restoreCommandMock).toHaveBeenCalledTimes(1);
136 |     expect(restoreCommandMock).toHaveBeenCalledWith(null);
137 |   });
138 | 
139 |   it('should return a list of all loaded commands', async () => {
140 |     const loader = new BuiltinCommandLoader(mockConfig);
141 |     const commands = await loader.loadCommands(new AbortController().signal);
142 | 
143 |     const aboutCmd = commands.find((c) => c.name === 'about');
144 |     expect(aboutCmd).toBeDefined();
145 |     expect(aboutCmd?.kind).toBe(CommandKind.BUILT_IN);
146 | 
147 |     const ideCmd = commands.find((c) => c.name === 'ide');
148 |     expect(ideCmd).toBeDefined();
149 | 
150 |     const mcpCmd = commands.find((c) => c.name === 'mcp');
151 |     expect(mcpCmd).toBeDefined();
152 |   });
153 | 
154 |   it('should include permissions command when folder trust is enabled', async () => {
155 |     const loader = new BuiltinCommandLoader(mockConfig);
156 |     const commands = await loader.loadCommands(new AbortController().signal);
157 |     const permissionsCmd = commands.find((c) => c.name === 'permissions');
158 |     expect(permissionsCmd).toBeDefined();
159 |   });
160 | 
161 |   it('should exclude permissions command when folder trust is disabled', async () => {
162 |     (mockConfig.getFolderTrust as Mock).mockReturnValue(false);
163 |     const loader = new BuiltinCommandLoader(mockConfig);
164 |     const commands = await loader.loadCommands(new AbortController().signal);
165 |     const permissionsCmd = commands.find((c) => c.name === 'permissions');
166 |     expect(permissionsCmd).toBeUndefined();
167 |   });
168 | 
169 |   it('should include modelCommand when getUseModelRouter is true', async () => {
170 |     const mockConfigWithModelRouter = {
171 |       ...mockConfig,
172 |       getUseModelRouter: () => true,
173 |     } as unknown as Config;
174 |     const loader = new BuiltinCommandLoader(mockConfigWithModelRouter);
175 |     const commands = await loader.loadCommands(new AbortController().signal);
176 |     const modelCmd = commands.find((c) => c.name === 'model');
177 |     expect(modelCmd).toBeDefined();
178 |   });
179 | 
180 |   it('should not include modelCommand when getUseModelRouter is false', async () => {
181 |     const mockConfigWithoutModelRouter = {
182 |       ...mockConfig,
183 |       getUseModelRouter: () => false,
184 |     } as unknown as Config;
185 |     const loader = new BuiltinCommandLoader(mockConfigWithoutModelRouter);
186 |     const commands = await loader.loadCommands(new AbortController().signal);
187 |     const modelCmd = commands.find((c) => c.name === 'model');
188 |     expect(modelCmd).toBeUndefined();
189 |   });
190 | });
191 | 
192 | describe('BuiltinCommandLoader profile', () => {
193 |   let mockConfig: Config;
194 | 
195 |   beforeEach(() => {
196 |     vi.resetModules();
197 |     mockConfig = {
198 |       getFolderTrust: vi.fn().mockReturnValue(false),
199 |       getUseModelRouter: () => false,
200 |       getCheckpointingEnabled: () => false,
201 |     } as unknown as Config;
202 |   });
203 | 
204 |   it('should not include profile command when isDevelopment is false', async () => {
205 |     process.env['NODE_ENV'] = 'production';
206 |     const { BuiltinCommandLoader } = await import('./BuiltinCommandLoader.js');
207 |     const loader = new BuiltinCommandLoader(mockConfig);
208 |     const commands = await loader.loadCommands(new AbortController().signal);
209 |     const profileCmd = commands.find((c) => c.name === 'profile');
210 |     expect(profileCmd).toBeUndefined();
211 |   });
212 | 
213 |   it('should include profile command when isDevelopment is true', async () => {
214 |     process.env['NODE_ENV'] = 'development';
215 |     const { BuiltinCommandLoader } = await import('./BuiltinCommandLoader.js');
216 |     const loader = new BuiltinCommandLoader(mockConfig);
217 |     const commands = await loader.loadCommands(new AbortController().signal);
218 |     const profileCmd = commands.find((c) => c.name === 'profile');
219 |     expect(profileCmd).toBeDefined();
220 |   });
221 | });
```

src/services/BuiltinCommandLoader.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { isDevelopment } from '../utils/installationInfo.js';
8 | import type { ICommandLoader } from './types.js';
9 | import type { SlashCommand } from '../ui/commands/types.js';
10 | import type { Config } from '@google/gemini-cli-core';
11 | import { aboutCommand } from '../ui/commands/aboutCommand.js';
12 | import { authCommand } from '../ui/commands/authCommand.js';
13 | import { bugCommand } from '../ui/commands/bugCommand.js';
14 | import { chatCommand } from '../ui/commands/chatCommand.js';
15 | import { clearCommand } from '../ui/commands/clearCommand.js';
16 | import { compressCommand } from '../ui/commands/compressCommand.js';
17 | import { copyCommand } from '../ui/commands/copyCommand.js';
18 | import { corgiCommand } from '../ui/commands/corgiCommand.js';
19 | import { docsCommand } from '../ui/commands/docsCommand.js';
20 | import { directoryCommand } from '../ui/commands/directoryCommand.js';
21 | import { editorCommand } from '../ui/commands/editorCommand.js';
22 | import { extensionsCommand } from '../ui/commands/extensionsCommand.js';
23 | import { helpCommand } from '../ui/commands/helpCommand.js';
24 | import { ideCommand } from '../ui/commands/ideCommand.js';
25 | import { initCommand } from '../ui/commands/initCommand.js';
26 | import { mcpCommand } from '../ui/commands/mcpCommand.js';
27 | import { memoryCommand } from '../ui/commands/memoryCommand.js';
28 | import { modelCommand } from '../ui/commands/modelCommand.js';
29 | import { permissionsCommand } from '../ui/commands/permissionsCommand.js';
30 | import { privacyCommand } from '../ui/commands/privacyCommand.js';
31 | import { profileCommand } from '../ui/commands/profileCommand.js';
32 | import { quitCommand } from '../ui/commands/quitCommand.js';
33 | import { restoreCommand } from '../ui/commands/restoreCommand.js';
34 | import { statsCommand } from '../ui/commands/statsCommand.js';
35 | import { themeCommand } from '../ui/commands/themeCommand.js';
36 | import { toolsCommand } from '../ui/commands/toolsCommand.js';
37 | import { settingsCommand } from '../ui/commands/settingsCommand.js';
38 | import { vimCommand } from '../ui/commands/vimCommand.js';
39 | import { setupGithubCommand } from '../ui/commands/setupGithubCommand.js';
40 | import { terminalSetupCommand } from '../ui/commands/terminalSetupCommand.js';
41 | 
42 | /**
43 |  * Loads the core, hard-coded slash commands that are an integral part
44 |  * of the Gemini CLI application.
45 |  */
46 | export class BuiltinCommandLoader implements ICommandLoader {
47 |   constructor(private config: Config | null) {}
48 | 
49 |   /**
50 |    * Gathers all raw built-in command definitions, injects dependencies where
51 |    * needed (e.g., config) and filters out any that are not available.
52 |    *
53 |    * @param _signal An AbortSignal (unused for this synchronous loader).
54 |    * @returns A promise that resolves to an array of `SlashCommand` objects.
55 |    */
56 |   async loadCommands(_signal: AbortSignal): Promise<SlashCommand[]> {
57 |     const allDefinitions: Array<SlashCommand | null> = [
58 |       aboutCommand,
59 |       authCommand,
60 |       bugCommand,
61 |       chatCommand,
62 |       clearCommand,
63 |       compressCommand,
64 |       copyCommand,
65 |       corgiCommand,
66 |       docsCommand,
67 |       directoryCommand,
68 |       editorCommand,
69 |       extensionsCommand,
70 |       helpCommand,
71 |       await ideCommand(),
72 |       initCommand,
73 |       mcpCommand,
74 |       memoryCommand,
75 |       ...(this.config?.getUseModelRouter() ? [modelCommand] : []),
76 |       ...(this.config?.getFolderTrust() ? [permissionsCommand] : []),
77 |       privacyCommand,
78 |       ...(isDevelopment ? [profileCommand] : []),
79 |       quitCommand,
80 |       restoreCommand(this.config),
81 |       statsCommand,
82 |       themeCommand,
83 |       toolsCommand,
84 |       settingsCommand,
85 |       vimCommand,
86 |       setupGithubCommand,
87 |       terminalSetupCommand,
88 |     ];
89 | 
90 |     return allDefinitions.filter((cmd): cmd is SlashCommand => cmd !== null);
91 |   }
92 | }
```

src/services/CommandService.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { vi, describe, it, expect, beforeEach, afterEach } from 'vitest';
8 | import { CommandService } from './CommandService.js';
9 | import { type ICommandLoader } from './types.js';
10 | import { CommandKind, type SlashCommand } from '../ui/commands/types.js';
11 | 
12 | const createMockCommand = (name: string, kind: CommandKind): SlashCommand => ({
13 |   name,
14 |   description: `Description for ${name}`,
15 |   kind,
16 |   action: vi.fn(),
17 | });
18 | 
19 | const mockCommandA = createMockCommand('command-a', CommandKind.BUILT_IN);
20 | const mockCommandB = createMockCommand('command-b', CommandKind.BUILT_IN);
21 | const mockCommandC = createMockCommand('command-c', CommandKind.FILE);
22 | const mockCommandB_Override = createMockCommand('command-b', CommandKind.FILE);
23 | 
24 | class MockCommandLoader implements ICommandLoader {
25 |   private commandsToLoad: SlashCommand[];
26 | 
27 |   constructor(commandsToLoad: SlashCommand[]) {
28 |     this.commandsToLoad = commandsToLoad;
29 |   }
30 | 
31 |   loadCommands = vi.fn(
32 |     async (): Promise<SlashCommand[]> => Promise.resolve(this.commandsToLoad),
33 |   );
34 | }
35 | 
36 | describe('CommandService', () => {
37 |   beforeEach(() => {
38 |     vi.spyOn(console, 'debug').mockImplementation(() => {});
39 |   });
40 | 
41 |   afterEach(() => {
42 |     vi.restoreAllMocks();
43 |   });
44 | 
45 |   it('should load commands from a single loader', async () => {
46 |     const mockLoader = new MockCommandLoader([mockCommandA, mockCommandB]);
47 |     const service = await CommandService.create(
48 |       [mockLoader],
49 |       new AbortController().signal,
50 |     );
51 | 
52 |     const commands = service.getCommands();
53 | 
54 |     expect(mockLoader.loadCommands).toHaveBeenCalledTimes(1);
55 |     expect(commands).toHaveLength(2);
56 |     expect(commands).toEqual(
57 |       expect.arrayContaining([mockCommandA, mockCommandB]),
58 |     );
59 |   });
60 | 
61 |   it('should aggregate commands from multiple loaders', async () => {
62 |     const loader1 = new MockCommandLoader([mockCommandA]);
63 |     const loader2 = new MockCommandLoader([mockCommandC]);
64 |     const service = await CommandService.create(
65 |       [loader1, loader2],
66 |       new AbortController().signal,
67 |     );
68 | 
69 |     const commands = service.getCommands();
70 | 
71 |     expect(loader1.loadCommands).toHaveBeenCalledTimes(1);
72 |     expect(loader2.loadCommands).toHaveBeenCalledTimes(1);
73 |     expect(commands).toHaveLength(2);
74 |     expect(commands).toEqual(
75 |       expect.arrayContaining([mockCommandA, mockCommandC]),
76 |     );
77 |   });
78 | 
79 |   it('should override commands from earlier loaders with those from later loaders', async () => {
80 |     const loader1 = new MockCommandLoader([mockCommandA, mockCommandB]);
81 |     const loader2 = new MockCommandLoader([
82 |       mockCommandB_Override,
83 |       mockCommandC,
84 |     ]);
85 |     const service = await CommandService.create(
86 |       [loader1, loader2],
87 |       new AbortController().signal,
88 |     );
89 | 
90 |     const commands = service.getCommands();
91 | 
92 |     expect(commands).toHaveLength(3); // Should be A, C, and the overridden B.
93 | 
94 |     // The final list should contain the override from the *last* loader.
95 |     const commandB = commands.find((cmd) => cmd.name === 'command-b');
96 |     expect(commandB).toBeDefined();
97 |     expect(commandB?.kind).toBe(CommandKind.FILE); // Verify it's the overridden version.
98 |     expect(commandB).toEqual(mockCommandB_Override);
99 | 
100 |     // Ensure the other commands are still present.
101 |     expect(commands).toEqual(
102 |       expect.arrayContaining([
103 |         mockCommandA,
104 |         mockCommandC,
105 |         mockCommandB_Override,
106 |       ]),
107 |     );
108 |   });
109 | 
110 |   it('should handle loaders that return an empty array of commands gracefully', async () => {
111 |     const loader1 = new MockCommandLoader([mockCommandA]);
112 |     const emptyLoader = new MockCommandLoader([]);
113 |     const loader3 = new MockCommandLoader([mockCommandB]);
114 |     const service = await CommandService.create(
115 |       [loader1, emptyLoader, loader3],
116 |       new AbortController().signal,
117 |     );
118 | 
119 |     const commands = service.getCommands();
120 | 
121 |     expect(emptyLoader.loadCommands).toHaveBeenCalledTimes(1);
122 |     expect(commands).toHaveLength(2);
123 |     expect(commands).toEqual(
124 |       expect.arrayContaining([mockCommandA, mockCommandB]),
125 |     );
126 |   });
127 | 
128 |   it('should load commands from successful loaders even if one fails', async () => {
129 |     const successfulLoader = new MockCommandLoader([mockCommandA]);
130 |     const failingLoader = new MockCommandLoader([]);
131 |     const error = new Error('Loader failed');
132 |     vi.spyOn(failingLoader, 'loadCommands').mockRejectedValue(error);
133 | 
134 |     const service = await CommandService.create(
135 |       [successfulLoader, failingLoader],
136 |       new AbortController().signal,
137 |     );
138 | 
139 |     const commands = service.getCommands();
140 |     expect(commands).toHaveLength(1);
141 |     expect(commands).toEqual([mockCommandA]);
142 |     expect(console.debug).toHaveBeenCalledWith(
143 |       'A command loader failed:',
144 |       error,
145 |     );
146 |   });
147 | 
148 |   it('getCommands should return a readonly array that cannot be mutated', async () => {
149 |     const service = await CommandService.create(
150 |       [new MockCommandLoader([mockCommandA])],
151 |       new AbortController().signal,
152 |     );
153 | 
154 |     const commands = service.getCommands();
155 | 
156 |     // Expect it to throw a TypeError at runtime because the array is frozen.
157 |     expect(() => {
158 |       // @ts-expect-error - Testing immutability is intentional here.
159 |       commands.push(mockCommandB);
160 |     }).toThrow();
161 | 
162 |     // Verify the original array was not mutated.
163 |     expect(service.getCommands()).toHaveLength(1);
164 |   });
165 | 
166 |   it('should pass the abort signal to all loaders', async () => {
167 |     const controller = new AbortController();
168 |     const signal = controller.signal;
169 | 
170 |     const loader1 = new MockCommandLoader([mockCommandA]);
171 |     const loader2 = new MockCommandLoader([mockCommandB]);
172 | 
173 |     await CommandService.create([loader1, loader2], signal);
174 | 
175 |     expect(loader1.loadCommands).toHaveBeenCalledTimes(1);
176 |     expect(loader1.loadCommands).toHaveBeenCalledWith(signal);
177 |     expect(loader2.loadCommands).toHaveBeenCalledTimes(1);
178 |     expect(loader2.loadCommands).toHaveBeenCalledWith(signal);
179 |   });
180 | 
181 |   it('should rename extension commands when they conflict', async () => {
182 |     const builtinCommand = createMockCommand('deploy', CommandKind.BUILT_IN);
183 |     const userCommand = createMockCommand('sync', CommandKind.FILE);
184 |     const extensionCommand1 = {
185 |       ...createMockCommand('deploy', CommandKind.FILE),
186 |       extensionName: 'firebase',
187 |       description: '[firebase] Deploy to Firebase',
188 |     };
189 |     const extensionCommand2 = {
190 |       ...createMockCommand('sync', CommandKind.FILE),
191 |       extensionName: 'git-helper',
192 |       description: '[git-helper] Sync with remote',
193 |     };
194 | 
195 |     const mockLoader1 = new MockCommandLoader([builtinCommand]);
196 |     const mockLoader2 = new MockCommandLoader([
197 |       userCommand,
198 |       extensionCommand1,
199 |       extensionCommand2,
200 |     ]);
201 | 
202 |     const service = await CommandService.create(
203 |       [mockLoader1, mockLoader2],
204 |       new AbortController().signal,
205 |     );
206 | 
207 |     const commands = service.getCommands();
208 |     expect(commands).toHaveLength(4);
209 | 
210 |     // Built-in command keeps original name
211 |     const deployBuiltin = commands.find(
212 |       (cmd) => cmd.name === 'deploy' && !cmd.extensionName,
213 |     );
214 |     expect(deployBuiltin).toBeDefined();
215 |     expect(deployBuiltin?.kind).toBe(CommandKind.BUILT_IN);
216 | 
217 |     // Extension command conflicting with built-in gets renamed
218 |     const deployExtension = commands.find(
219 |       (cmd) => cmd.name === 'firebase.deploy',
220 |     );
221 |     expect(deployExtension).toBeDefined();
222 |     expect(deployExtension?.extensionName).toBe('firebase');
223 | 
224 |     // User command keeps original name
225 |     const syncUser = commands.find(
226 |       (cmd) => cmd.name === 'sync' && !cmd.extensionName,
227 |     );
228 |     expect(syncUser).toBeDefined();
229 |     expect(syncUser?.kind).toBe(CommandKind.FILE);
230 | 
231 |     // Extension command conflicting with user command gets renamed
232 |     const syncExtension = commands.find(
233 |       (cmd) => cmd.name === 'git-helper.sync',
234 |     );
235 |     expect(syncExtension).toBeDefined();
236 |     expect(syncExtension?.extensionName).toBe('git-helper');
237 |   });
238 | 
239 |   it('should handle user/project command override correctly', async () => {
240 |     const builtinCommand = createMockCommand('help', CommandKind.BUILT_IN);
241 |     const userCommand = createMockCommand('help', CommandKind.FILE);
242 |     const projectCommand = createMockCommand('deploy', CommandKind.FILE);
243 |     const userDeployCommand = createMockCommand('deploy', CommandKind.FILE);
244 | 
245 |     const mockLoader1 = new MockCommandLoader([builtinCommand]);
246 |     const mockLoader2 = new MockCommandLoader([
247 |       userCommand,
248 |       userDeployCommand,
249 |       projectCommand,
250 |     ]);
251 | 
252 |     const service = await CommandService.create(
253 |       [mockLoader1, mockLoader2],
254 |       new AbortController().signal,
255 |     );
256 | 
257 |     const commands = service.getCommands();
258 |     expect(commands).toHaveLength(2);
259 | 
260 |     // User command overrides built-in
261 |     const helpCommand = commands.find((cmd) => cmd.name === 'help');
262 |     expect(helpCommand).toBeDefined();
263 |     expect(helpCommand?.kind).toBe(CommandKind.FILE);
264 | 
265 |     // Project command overrides user command (last wins)
266 |     const deployCommand = commands.find((cmd) => cmd.name === 'deploy');
267 |     expect(deployCommand).toBeDefined();
268 |     expect(deployCommand?.kind).toBe(CommandKind.FILE);
269 |   });
270 | 
271 |   it('should handle secondary conflicts when renaming extension commands', async () => {
272 |     // User has both /deploy and /gcp.deploy commands
273 |     const userCommand1 = createMockCommand('deploy', CommandKind.FILE);
274 |     const userCommand2 = createMockCommand('gcp.deploy', CommandKind.FILE);
275 | 
276 |     // Extension also has a deploy command that will conflict with user's /deploy
277 |     const extensionCommand = {
278 |       ...createMockCommand('deploy', CommandKind.FILE),
279 |       extensionName: 'gcp',
280 |       description: '[gcp] Deploy to Google Cloud',
281 |     };
282 | 
283 |     const mockLoader = new MockCommandLoader([
284 |       userCommand1,
285 |       userCommand2,
286 |       extensionCommand,
287 |     ]);
288 | 
289 |     const service = await CommandService.create(
290 |       [mockLoader],
291 |       new AbortController().signal,
292 |     );
293 | 
294 |     const commands = service.getCommands();
295 |     expect(commands).toHaveLength(3);
296 | 
297 |     // Original user command keeps its name
298 |     const deployUser = commands.find(
299 |       (cmd) => cmd.name === 'deploy' && !cmd.extensionName,
300 |     );
301 |     expect(deployUser).toBeDefined();
302 | 
303 |     // User's dot notation command keeps its name
304 |     const gcpDeployUser = commands.find(
305 |       (cmd) => cmd.name === 'gcp.deploy' && !cmd.extensionName,
306 |     );
307 |     expect(gcpDeployUser).toBeDefined();
308 | 
309 |     // Extension command gets renamed with suffix due to secondary conflict
310 |     const deployExtension = commands.find(
311 |       (cmd) => cmd.name === 'gcp.deploy1' && cmd.extensionName === 'gcp',
312 |     );
313 |     expect(deployExtension).toBeDefined();
314 |     expect(deployExtension?.description).toBe('[gcp] Deploy to Google Cloud');
315 |   });
316 | 
317 |   it('should handle multiple secondary conflicts with incrementing suffixes', async () => {
318 |     // User has /deploy, /gcp.deploy, and /gcp.deploy1
319 |     const userCommand1 = createMockCommand('deploy', CommandKind.FILE);
320 |     const userCommand2 = createMockCommand('gcp.deploy', CommandKind.FILE);
321 |     const userCommand3 = createMockCommand('gcp.deploy1', CommandKind.FILE);
322 | 
323 |     // Extension has a deploy command
324 |     const extensionCommand = {
325 |       ...createMockCommand('deploy', CommandKind.FILE),
326 |       extensionName: 'gcp',
327 |       description: '[gcp] Deploy to Google Cloud',
328 |     };
329 | 
330 |     const mockLoader = new MockCommandLoader([
331 |       userCommand1,
332 |       userCommand2,
333 |       userCommand3,
334 |       extensionCommand,
335 |     ]);
336 | 
337 |     const service = await CommandService.create(
338 |       [mockLoader],
339 |       new AbortController().signal,
340 |     );
341 | 
342 |     const commands = service.getCommands();
343 |     expect(commands).toHaveLength(4);
344 | 
345 |     // Extension command gets renamed with suffix 2 due to multiple conflicts
[TRUNCATED]
```

src/services/CommandService.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type { SlashCommand } from '../ui/commands/types.js';
8 | import type { ICommandLoader } from './types.js';
9 | 
10 | /**
11 |  * Orchestrates the discovery and loading of all slash commands for the CLI.
12 |  *
13 |  * This service operates on a provider-based loader pattern. It is initialized
14 |  * with an array of `ICommandLoader` instances, each responsible for fetching
15 |  * commands from a specific source (e.g., built-in code, local files).
16 |  *
17 |  * The CommandService is responsible for invoking these loaders, aggregating their
18 |  * results, and resolving any name conflicts. This architecture allows the command
19 |  * system to be extended with new sources without modifying the service itself.
20 |  */
21 | export class CommandService {
22 |   /**
23 |    * Private constructor to enforce the use of the async factory.
24 |    * @param commands A readonly array of the fully loaded and de-duplicated commands.
25 |    */
26 |   private constructor(private readonly commands: readonly SlashCommand[]) {}
27 | 
28 |   /**
29 |    * Asynchronously creates and initializes a new CommandService instance.
30 |    *
31 |    * This factory method orchestrates the entire command loading process. It
32 |    * runs all provided loaders in parallel, aggregates their results, handles
33 |    * name conflicts for extension commands by renaming them, and then returns a
34 |    * fully constructed `CommandService` instance.
35 |    *
36 |    * Conflict resolution:
37 |    * - Extension commands that conflict with existing commands are renamed to
38 |    *   `extensionName.commandName`
39 |    * - Non-extension commands (built-in, user, project) override earlier commands
40 |    *   with the same name based on loader order
41 |    *
42 |    * @param loaders An array of objects that conform to the `ICommandLoader`
43 |    *   interface. Built-in commands should come first, followed by FileCommandLoader.
44 |    * @param signal An AbortSignal to cancel the loading process.
45 |    * @returns A promise that resolves to a new, fully initialized `CommandService` instance.
46 |    */
47 |   static async create(
48 |     loaders: ICommandLoader[],
49 |     signal: AbortSignal,
50 |   ): Promise<CommandService> {
51 |     const results = await Promise.allSettled(
52 |       loaders.map((loader) => loader.loadCommands(signal)),
53 |     );
54 | 
55 |     const allCommands: SlashCommand[] = [];
56 |     for (const result of results) {
57 |       if (result.status === 'fulfilled') {
58 |         allCommands.push(...result.value);
59 |       } else {
60 |         console.debug('A command loader failed:', result.reason);
61 |       }
62 |     }
63 | 
64 |     const commandMap = new Map<string, SlashCommand>();
65 |     for (const cmd of allCommands) {
66 |       let finalName = cmd.name;
67 | 
68 |       // Extension commands get renamed if they conflict with existing commands
69 |       if (cmd.extensionName && commandMap.has(cmd.name)) {
70 |         let renamedName = `${cmd.extensionName}.${cmd.name}`;
71 |         let suffix = 1;
72 | 
73 |         // Keep trying until we find a name that doesn't conflict
74 |         while (commandMap.has(renamedName)) {
75 |           renamedName = `${cmd.extensionName}.${cmd.name}${suffix}`;
76 |           suffix++;
77 |         }
78 | 
79 |         finalName = renamedName;
80 |       }
81 | 
82 |       commandMap.set(finalName, {
83 |         ...cmd,
84 |         name: finalName,
85 |       });
86 |     }
87 | 
88 |     const finalCommands = Object.freeze(Array.from(commandMap.values()));
89 |     return new CommandService(finalCommands);
90 |   }
91 | 
92 |   /**
93 |    * Retrieves the currently loaded and de-duplicated list of slash commands.
94 |    *
95 |    * This method is a safe accessor for the service's state. It returns a
96 |    * readonly array, preventing consumers from modifying the service's internal state.
97 |    *
98 |    * @returns A readonly, unified array of available `SlashCommand` objects.
99 |    */
100 |   getCommands(): readonly SlashCommand[] {
101 |     return this.commands;
102 |   }
103 | }
```

src/services/FileCommandLoader.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import * as path from 'node:path';
8 | import type { Config } from '@google/gemini-cli-core';
9 | import { Storage } from '@google/gemini-cli-core';
10 | import mock from 'mock-fs';
11 | import { FileCommandLoader } from './FileCommandLoader.js';
12 | import { assert, vi } from 'vitest';
13 | import { createMockCommandContext } from '../test-utils/mockCommandContext.js';
14 | import {
15 |   SHELL_INJECTION_TRIGGER,
16 |   SHORTHAND_ARGS_PLACEHOLDER,
17 |   type PromptPipelineContent,
18 | } from './prompt-processors/types.js';
19 | import {
20 |   ConfirmationRequiredError,
21 |   ShellProcessor,
22 | } from './prompt-processors/shellProcessor.js';
23 | import { DefaultArgumentProcessor } from './prompt-processors/argumentProcessor.js';
24 | import type { CommandContext } from '../ui/commands/types.js';
25 | import { AtFileProcessor } from './prompt-processors/atFileProcessor.js';
26 | 
27 | const mockShellProcess = vi.hoisted(() => vi.fn());
28 | const mockAtFileProcess = vi.hoisted(() => vi.fn());
29 | vi.mock('./prompt-processors/atFileProcessor.js', () => ({
30 |   AtFileProcessor: vi.fn().mockImplementation(() => ({
31 |     process: mockAtFileProcess,
32 |   })),
33 | }));
34 | vi.mock('./prompt-processors/shellProcessor.js', () => ({
35 |   ShellProcessor: vi.fn().mockImplementation(() => ({
36 |     process: mockShellProcess,
37 |   })),
38 |   ConfirmationRequiredError: class extends Error {
39 |     constructor(
40 |       message: string,
41 |       public commandsToConfirm: string[],
42 |     ) {
43 |       super(message);
44 |       this.name = 'ConfirmationRequiredError';
45 |     }
46 |   },
47 | }));
48 | 
49 | vi.mock('./prompt-processors/argumentProcessor.js', async (importOriginal) => {
50 |   const original =
51 |     await importOriginal<
52 |       typeof import('./prompt-processors/argumentProcessor.js')
53 |     >();
54 |   return {
55 |     DefaultArgumentProcessor: vi
56 |       .fn()
57 |       .mockImplementation(() => new original.DefaultArgumentProcessor()),
58 |   };
59 | });
60 | vi.mock('@google/gemini-cli-core', async (importOriginal) => {
61 |   const original =
62 |     await importOriginal<typeof import('@google/gemini-cli-core')>();
63 |   return {
64 |     ...original,
65 |     Storage: original.Storage,
66 |     isCommandAllowed: vi.fn(),
67 |     ShellExecutionService: {
68 |       execute: vi.fn(),
69 |     },
70 |   };
71 | });
72 | 
73 | describe('FileCommandLoader', () => {
74 |   const signal: AbortSignal = new AbortController().signal;
75 | 
76 |   beforeEach(() => {
77 |     vi.clearAllMocks();
78 |     mockShellProcess.mockImplementation(
79 |       (prompt: PromptPipelineContent, context: CommandContext) => {
80 |         const userArgsRaw = context?.invocation?.args || '';
81 |         // This is a simplified mock. A real implementation would need to iterate
82 |         // through all parts and process only the text parts.
83 |         const firstTextPart = prompt.find(
84 |           (p) => typeof p === 'string' || 'text' in p,
85 |         );
86 |         let textContent = '';
87 |         if (typeof firstTextPart === 'string') {
88 |           textContent = firstTextPart;
89 |         } else if (firstTextPart && 'text' in firstTextPart) {
90 |           textContent = firstTextPart.text ?? '';
91 |         }
92 | 
93 |         const processedText = textContent.replaceAll(
94 |           SHORTHAND_ARGS_PLACEHOLDER,
95 |           userArgsRaw,
96 |         );
97 |         return Promise.resolve([{ text: processedText }]);
98 |       },
99 |     );
100 |     mockAtFileProcess.mockImplementation(async (prompt: string) => prompt);
101 |   });
102 | 
103 |   afterEach(() => {
104 |     mock.restore();
105 |   });
106 | 
107 |   it('loads a single command from a file', async () => {
108 |     const userCommandsDir = Storage.getUserCommandsDir();
109 |     mock({
110 |       [userCommandsDir]: {
111 |         'test.toml': 'prompt = "This is a test prompt"',
112 |       },
113 |     });
114 | 
115 |     const loader = new FileCommandLoader(null);
116 |     const commands = await loader.loadCommands(signal);
117 | 
118 |     expect(commands).toHaveLength(1);
119 |     const command = commands[0];
120 |     expect(command).toBeDefined();
121 |     expect(command.name).toBe('test');
122 | 
123 |     const result = await command.action?.(
124 |       createMockCommandContext({
125 |         invocation: {
126 |           raw: '/test',
127 |           name: 'test',
128 |           args: '',
129 |         },
130 |       }),
131 |       '',
132 |     );
133 |     if (result?.type === 'submit_prompt') {
134 |       expect(result.content).toEqual([{ text: 'This is a test prompt' }]);
135 |     } else {
136 |       assert.fail('Incorrect action type');
137 |     }
138 |   });
139 | 
140 |   // Symlink creation on Windows requires special permissions that are not
141 |   // available in the standard CI environment. Therefore, we skip these tests
142 |   // on Windows to prevent CI failures. The core functionality is still
143 |   // validated on Linux and macOS.
144 |   const itif = (condition: boolean) => (condition ? it : it.skip);
145 | 
146 |   itif(process.platform !== 'win32')(
147 |     'loads commands from a symlinked directory',
148 |     async () => {
149 |       const userCommandsDir = Storage.getUserCommandsDir();
150 |       const realCommandsDir = '/real/commands';
151 |       mock({
152 |         [realCommandsDir]: {
153 |           'test.toml': 'prompt = "This is a test prompt"',
154 |         },
155 |         // Symlink the user commands directory to the real one
156 |         [userCommandsDir]: mock.symlink({
157 |           path: realCommandsDir,
158 |         }),
159 |       });
160 | 
161 |       const loader = new FileCommandLoader(null as unknown as Config);
162 |       const commands = await loader.loadCommands(signal);
163 | 
164 |       expect(commands).toHaveLength(1);
165 |       const command = commands[0];
166 |       expect(command).toBeDefined();
167 |       expect(command.name).toBe('test');
168 |     },
169 |   );
170 | 
171 |   itif(process.platform !== 'win32')(
172 |     'loads commands from a symlinked subdirectory',
173 |     async () => {
174 |       const userCommandsDir = Storage.getUserCommandsDir();
175 |       const realNamespacedDir = '/real/namespaced-commands';
176 |       mock({
177 |         [userCommandsDir]: {
178 |           namespaced: mock.symlink({
179 |             path: realNamespacedDir,
180 |           }),
181 |         },
182 |         [realNamespacedDir]: {
183 |           'my-test.toml': 'prompt = "This is a test prompt"',
184 |         },
185 |       });
186 | 
187 |       const loader = new FileCommandLoader(null as unknown as Config);
188 |       const commands = await loader.loadCommands(signal);
189 | 
190 |       expect(commands).toHaveLength(1);
191 |       const command = commands[0];
192 |       expect(command).toBeDefined();
193 |       expect(command.name).toBe('namespaced:my-test');
194 |     },
195 |   );
196 | 
197 |   it('loads multiple commands', async () => {
198 |     const userCommandsDir = Storage.getUserCommandsDir();
199 |     mock({
200 |       [userCommandsDir]: {
201 |         'test1.toml': 'prompt = "Prompt 1"',
202 |         'test2.toml': 'prompt = "Prompt 2"',
203 |       },
204 |     });
205 | 
206 |     const loader = new FileCommandLoader(null);
207 |     const commands = await loader.loadCommands(signal);
208 | 
209 |     expect(commands).toHaveLength(2);
210 |   });
211 | 
212 |   it('creates deeply nested namespaces correctly', async () => {
213 |     const userCommandsDir = Storage.getUserCommandsDir();
214 | 
215 |     mock({
216 |       [userCommandsDir]: {
217 |         gcp: {
218 |           pipelines: {
219 |             'run.toml': 'prompt = "run pipeline"',
220 |           },
221 |         },
222 |       },
223 |     });
224 |     const mockConfig = {
225 |       getProjectRoot: vi.fn(() => '/path/to/project'),
226 |       getExtensions: vi.fn(() => []),
227 |       getFolderTrust: vi.fn(() => false),
228 |       isTrustedFolder: vi.fn(() => false),
229 |     } as unknown as Config;
230 |     const loader = new FileCommandLoader(mockConfig);
231 |     const commands = await loader.loadCommands(signal);
232 |     expect(commands).toHaveLength(1);
233 |     expect(commands[0]!.name).toBe('gcp:pipelines:run');
234 |   });
235 | 
236 |   it('creates namespaces from nested directories', async () => {
237 |     const userCommandsDir = Storage.getUserCommandsDir();
238 |     mock({
239 |       [userCommandsDir]: {
240 |         git: {
241 |           'commit.toml': 'prompt = "git commit prompt"',
242 |         },
243 |       },
244 |     });
245 | 
246 |     const loader = new FileCommandLoader(null);
247 |     const commands = await loader.loadCommands(signal);
248 | 
249 |     expect(commands).toHaveLength(1);
250 |     const command = commands[0];
251 |     expect(command).toBeDefined();
252 |     expect(command.name).toBe('git:commit');
253 |   });
254 | 
255 |   it('returns both user and project commands in order', async () => {
256 |     const userCommandsDir = Storage.getUserCommandsDir();
257 |     const projectCommandsDir = new Storage(
258 |       process.cwd(),
259 |     ).getProjectCommandsDir();
260 |     mock({
261 |       [userCommandsDir]: {
262 |         'test.toml': 'prompt = "User prompt"',
263 |       },
264 |       [projectCommandsDir]: {
265 |         'test.toml': 'prompt = "Project prompt"',
266 |       },
267 |     });
268 | 
269 |     const mockConfig = {
270 |       getProjectRoot: vi.fn(() => process.cwd()),
271 |       getExtensions: vi.fn(() => []),
272 |       getFolderTrust: vi.fn(() => false),
273 |       isTrustedFolder: vi.fn(() => false),
274 |     } as unknown as Config;
275 |     const loader = new FileCommandLoader(mockConfig);
276 |     const commands = await loader.loadCommands(signal);
277 | 
278 |     expect(commands).toHaveLength(2);
279 |     const userResult = await commands[0].action?.(
280 |       createMockCommandContext({
281 |         invocation: {
282 |           raw: '/test',
283 |           name: 'test',
284 |           args: '',
285 |         },
286 |       }),
287 |       '',
288 |     );
289 |     if (userResult?.type === 'submit_prompt') {
290 |       expect(userResult.content).toEqual([{ text: 'User prompt' }]);
291 |     } else {
292 |       assert.fail('Incorrect action type for user command');
293 |     }
294 |     const projectResult = await commands[1].action?.(
295 |       createMockCommandContext({
296 |         invocation: {
297 |           raw: '/test',
298 |           name: 'test',
299 |           args: '',
300 |         },
301 |       }),
302 |       '',
303 |     );
304 |     if (projectResult?.type === 'submit_prompt') {
305 |       expect(projectResult.content).toEqual([{ text: 'Project prompt' }]);
306 |     } else {
307 |       assert.fail('Incorrect action type for project command');
308 |     }
309 |   });
310 | 
311 |   it('ignores files with TOML syntax errors', async () => {
312 |     const userCommandsDir = Storage.getUserCommandsDir();
313 |     mock({
314 |       [userCommandsDir]: {
315 |         'invalid.toml': 'this is not valid toml',
316 |         'good.toml': 'prompt = "This one is fine"',
317 |       },
318 |     });
319 | 
320 |     const loader = new FileCommandLoader(null);
321 |     const commands = await loader.loadCommands(signal);
322 | 
323 |     expect(commands).toHaveLength(1);
324 |     expect(commands[0].name).toBe('good');
325 |   });
326 | 
327 |   it('ignores files that are semantically invalid (missing prompt)', async () => {
328 |     const userCommandsDir = Storage.getUserCommandsDir();
329 |     mock({
330 |       [userCommandsDir]: {
331 |         'no_prompt.toml': 'description = "This file is missing a prompt"',
332 |         'good.toml': 'prompt = "This one is fine"',
333 |       },
334 |     });
335 | 
336 |     const loader = new FileCommandLoader(null);
337 |     const commands = await loader.loadCommands(signal);
338 | 
339 |     expect(commands).toHaveLength(1);
340 |     expect(commands[0].name).toBe('good');
341 |   });
342 | 
343 |   it('handles filename edge cases correctly', async () => {
344 |     const userCommandsDir = Storage.getUserCommandsDir();
345 |     mock({
346 |       [userCommandsDir]: {
347 |         'test.v1.toml': 'prompt = "Test prompt"',
348 |       },
349 |     });
350 | 
351 |     const loader = new FileCommandLoader(null);
352 |     const commands = await loader.loadCommands(signal);
353 |     const command = commands[0];
354 |     expect(command).toBeDefined();
355 |     expect(command.name).toBe('test.v1');
356 |   });
357 | 
358 |   it('handles file system errors gracefully', async () => {
359 |     mock({}); // Mock an empty file system
360 |     const loader = new FileCommandLoader(null);
361 |     const commands = await loader.loadCommands(signal);
362 |     expect(commands).toHaveLength(0);
363 |   });
364 | 
365 |   it('uses a default description if not provided', async () => {
366 |     const userCommandsDir = Storage.getUserCommandsDir();
367 |     mock({
368 |       [userCommandsDir]: {
369 |         'test.toml': 'prompt = "Test prompt"',
370 |       },
371 |     });
372 | 
[TRUNCATED]
```

src/services/FileCommandLoader.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { promises as fs } from 'node:fs';
8 | import path from 'node:path';
9 | import toml from '@iarna/toml';
10 | import { glob } from 'glob';
11 | import { z } from 'zod';
12 | import type { Config } from '@google/gemini-cli-core';
13 | import { Storage } from '@google/gemini-cli-core';
14 | import type { ICommandLoader } from './types.js';
15 | import type {
16 |   CommandContext,
17 |   SlashCommand,
18 |   SlashCommandActionReturn,
19 | } from '../ui/commands/types.js';
20 | import { CommandKind } from '../ui/commands/types.js';
21 | import { DefaultArgumentProcessor } from './prompt-processors/argumentProcessor.js';
22 | import type {
23 |   IPromptProcessor,
24 |   PromptPipelineContent,
25 | } from './prompt-processors/types.js';
26 | import {
27 |   SHORTHAND_ARGS_PLACEHOLDER,
28 |   SHELL_INJECTION_TRIGGER,
29 |   AT_FILE_INJECTION_TRIGGER,
30 | } from './prompt-processors/types.js';
31 | import {
32 |   ConfirmationRequiredError,
33 |   ShellProcessor,
34 | } from './prompt-processors/shellProcessor.js';
35 | import { AtFileProcessor } from './prompt-processors/atFileProcessor.js';
36 | 
37 | interface CommandDirectory {
38 |   path: string;
39 |   extensionName?: string;
40 | }
41 | 
42 | /**
43 |  * Defines the Zod schema for a command definition file. This serves as the
44 |  * single source of truth for both validation and type inference.
45 |  */
46 | const TomlCommandDefSchema = z.object({
47 |   prompt: z.string({
48 |     required_error: "The 'prompt' field is required.",
49 |     invalid_type_error: "The 'prompt' field must be a string.",
50 |   }),
51 |   description: z.string().optional(),
52 | });
53 | 
54 | /**
55 |  * Discovers and loads custom slash commands from .toml files in both the
56 |  * user's global config directory and the current project's directory.
57 |  *
58 |  * This loader is responsible for:
59 |  * - Recursively scanning command directories.
60 |  * - Parsing and validating TOML files.
61 |  * - Adapting valid definitions into executable SlashCommand objects.
62 |  * - Handling file system errors and malformed files gracefully.
63 |  */
64 | export class FileCommandLoader implements ICommandLoader {
65 |   private readonly projectRoot: string;
66 |   private readonly folderTrustEnabled: boolean;
67 |   private readonly isTrustedFolder: boolean;
68 | 
69 |   constructor(private readonly config: Config | null) {
70 |     this.folderTrustEnabled = !!config?.getFolderTrust();
71 |     this.isTrustedFolder = !!config?.isTrustedFolder();
72 |     this.projectRoot = config?.getProjectRoot() || process.cwd();
73 |   }
74 | 
75 |   /**
76 |    * Loads all commands from user, project, and extension directories.
77 |    * Returns commands in order: user → project → extensions (alphabetically).
78 |    *
79 |    * Order is important for conflict resolution in CommandService:
80 |    * - User/project commands (without extensionName) use "last wins" strategy
81 |    * - Extension commands (with extensionName) get renamed if conflicts exist
82 |    *
83 |    * @param signal An AbortSignal to cancel the loading process.
84 |    * @returns A promise that resolves to an array of all loaded SlashCommands.
85 |    */
86 |   async loadCommands(signal: AbortSignal): Promise<SlashCommand[]> {
87 |     const allCommands: SlashCommand[] = [];
88 |     const globOptions = {
89 |       nodir: true,
90 |       dot: true,
91 |       signal,
92 |       follow: true,
93 |     };
94 | 
95 |     // Load commands from each directory
96 |     const commandDirs = this.getCommandDirectories();
97 |     for (const dirInfo of commandDirs) {
98 |       try {
99 |         const files = await glob('**/*.toml', {
100 |           ...globOptions,
101 |           cwd: dirInfo.path,
102 |         });
103 | 
104 |         if (this.folderTrustEnabled && !this.isTrustedFolder) {
105 |           return [];
106 |         }
107 | 
108 |         const commandPromises = files.map((file) =>
109 |           this.parseAndAdaptFile(
110 |             path.join(dirInfo.path, file),
111 |             dirInfo.path,
112 |             dirInfo.extensionName,
113 |           ),
114 |         );
115 | 
116 |         const commands = (await Promise.all(commandPromises)).filter(
117 |           (cmd): cmd is SlashCommand => cmd !== null,
118 |         );
119 | 
120 |         // Add all commands without deduplication
121 |         allCommands.push(...commands);
122 |       } catch (error) {
123 |         if ((error as NodeJS.ErrnoException).code !== 'ENOENT') {
124 |           console.error(
125 |             `[FileCommandLoader] Error loading commands from ${dirInfo.path}:`,
126 |             error,
127 |           );
128 |         }
129 |       }
130 |     }
131 | 
132 |     return allCommands;
133 |   }
134 | 
135 |   /**
136 |    * Get all command directories in order for loading.
137 |    * User commands → Project commands → Extension commands
138 |    * This order ensures extension commands can detect all conflicts.
139 |    */
140 |   private getCommandDirectories(): CommandDirectory[] {
141 |     const dirs: CommandDirectory[] = [];
142 | 
143 |     const storage = this.config?.storage ?? new Storage(this.projectRoot);
144 | 
145 |     // 1. User commands
146 |     dirs.push({ path: Storage.getUserCommandsDir() });
147 | 
148 |     // 2. Project commands (override user commands)
149 |     dirs.push({ path: storage.getProjectCommandsDir() });
150 | 
151 |     // 3. Extension commands (processed last to detect all conflicts)
152 |     if (this.config) {
153 |       const activeExtensions = this.config
154 |         .getExtensions()
155 |         .filter((ext) => ext.isActive)
156 |         .sort((a, b) => a.name.localeCompare(b.name)); // Sort alphabetically for deterministic loading
157 | 
158 |       const extensionCommandDirs = activeExtensions.map((ext) => ({
159 |         path: path.join(ext.path, 'commands'),
160 |         extensionName: ext.name,
161 |       }));
162 | 
163 |       dirs.push(...extensionCommandDirs);
164 |     }
165 | 
166 |     return dirs;
167 |   }
168 | 
169 |   /**
170 |    * Parses a single .toml file and transforms it into a SlashCommand object.
171 |    * @param filePath The absolute path to the .toml file.
172 |    * @param baseDir The root command directory for name calculation.
173 |    * @param extensionName Optional extension name to prefix commands with.
174 |    * @returns A promise resolving to a SlashCommand, or null if the file is invalid.
175 |    */
176 |   private async parseAndAdaptFile(
177 |     filePath: string,
178 |     baseDir: string,
179 |     extensionName?: string,
180 |   ): Promise<SlashCommand | null> {
181 |     let fileContent: string;
182 |     try {
183 |       fileContent = await fs.readFile(filePath, 'utf-8');
184 |     } catch (error: unknown) {
185 |       console.error(
186 |         `[FileCommandLoader] Failed to read file ${filePath}:`,
187 |         error instanceof Error ? error.message : String(error),
188 |       );
189 |       return null;
190 |     }
191 | 
192 |     let parsed: unknown;
193 |     try {
194 |       parsed = toml.parse(fileContent);
195 |     } catch (error: unknown) {
196 |       console.error(
197 |         `[FileCommandLoader] Failed to parse TOML file ${filePath}:`,
198 |         error instanceof Error ? error.message : String(error),
199 |       );
200 |       return null;
201 |     }
202 | 
203 |     const validationResult = TomlCommandDefSchema.safeParse(parsed);
204 | 
205 |     if (!validationResult.success) {
206 |       console.error(
207 |         `[FileCommandLoader] Skipping invalid command file: ${filePath}. Validation errors:`,
208 |         validationResult.error.flatten(),
209 |       );
210 |       return null;
211 |     }
212 | 
213 |     const validDef = validationResult.data;
214 | 
215 |     const relativePathWithExt = path.relative(baseDir, filePath);
216 |     const relativePath = relativePathWithExt.substring(
217 |       0,
218 |       relativePathWithExt.length - 5, // length of '.toml'
219 |     );
220 |     const baseCommandName = relativePath
221 |       .split(path.sep)
222 |       // Sanitize each path segment to prevent ambiguity. Since ':' is our
223 |       // namespace separator, we replace any literal colons in filenames
224 |       // with underscores to avoid naming conflicts.
225 |       .map((segment) => segment.replaceAll(':', '_'))
226 |       .join(':');
227 | 
228 |     // Add extension name tag for extension commands
229 |     const defaultDescription = `Custom command from ${path.basename(filePath)}`;
230 |     let description = validDef.description || defaultDescription;
231 |     if (extensionName) {
232 |       description = `[${extensionName}] ${description}`;
233 |     }
234 | 
235 |     const processors: IPromptProcessor[] = [];
236 |     const usesArgs = validDef.prompt.includes(SHORTHAND_ARGS_PLACEHOLDER);
237 |     const usesShellInjection = validDef.prompt.includes(
238 |       SHELL_INJECTION_TRIGGER,
239 |     );
240 |     const usesAtFileInjection = validDef.prompt.includes(
241 |       AT_FILE_INJECTION_TRIGGER,
242 |     );
243 | 
244 |     // 1. @-File Injection (Security First).
245 |     // This runs first to ensure we're not executing shell commands that
246 |     // could dynamically generate malicious @-paths.
247 |     if (usesAtFileInjection) {
248 |       processors.push(new AtFileProcessor(baseCommandName));
249 |     }
250 | 
251 |     // 2. Argument and Shell Injection.
252 |     // This runs after file content has been safely injected.
253 |     if (usesShellInjection || usesArgs) {
254 |       processors.push(new ShellProcessor(baseCommandName));
255 |     }
256 | 
257 |     // 3. Default Argument Handling.
258 |     // Appends the raw invocation if no explicit {{args}} are used.
259 |     if (!usesArgs) {
260 |       processors.push(new DefaultArgumentProcessor());
261 |     }
262 | 
263 |     return {
264 |       name: baseCommandName,
265 |       description,
266 |       kind: CommandKind.FILE,
267 |       extensionName,
268 |       action: async (
269 |         context: CommandContext,
270 |         _args: string,
271 |       ): Promise<SlashCommandActionReturn> => {
272 |         if (!context.invocation) {
273 |           console.error(
274 |             `[FileCommandLoader] Critical error: Command '${baseCommandName}' was executed without invocation context.`,
275 |           );
276 |           return {
277 |             type: 'submit_prompt',
278 |             content: [{ text: validDef.prompt }], // Fallback to unprocessed prompt
279 |           };
280 |         }
281 | 
282 |         try {
283 |           let processedContent: PromptPipelineContent = [
284 |             { text: validDef.prompt },
285 |           ];
286 |           for (const processor of processors) {
287 |             processedContent = await processor.process(
288 |               processedContent,
289 |               context,
290 |             );
291 |           }
292 | 
293 |           return {
294 |             type: 'submit_prompt',
295 |             content: processedContent,
296 |           };
297 |         } catch (e) {
298 |           // Check if it's our specific error type
299 |           if (e instanceof ConfirmationRequiredError) {
300 |             // Halt and request confirmation from the UI layer.
301 |             return {
302 |               type: 'confirm_shell_commands',
303 |               commandsToConfirm: e.commandsToConfirm,
304 |               originalInvocation: {
305 |                 raw: context.invocation.raw,
306 |               },
307 |             };
308 |           }
309 |           // Re-throw other errors to be handled by the global error handler.
310 |           throw e;
311 |         }
312 |       },
313 |     };
314 |   }
315 | }
```

src/services/McpPromptLoader.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { McpPromptLoader } from './McpPromptLoader.js';
8 | import type { Config } from '@google/gemini-cli-core';
9 | import type { PromptArgument } from '@modelcontextprotocol/sdk/types.js';
10 | import { describe, it, expect, vi, beforeEach } from 'vitest';
11 | import { CommandKind, type CommandContext } from '../ui/commands/types.js';
12 | import * as cliCore from '@google/gemini-cli-core';
13 | 
14 | // Define the mock prompt data at a higher scope
15 | const mockPrompt = {
16 |   name: 'test-prompt',
17 |   description: 'A test prompt.',
18 |   serverName: 'test-server',
19 |   arguments: [
20 |     { name: 'name', required: true, description: "The animal's name." },
21 |     { name: 'age', required: true, description: "The animal's age." },
22 |     { name: 'species', required: true, description: "The animal's species." },
23 |     {
24 |       name: 'enclosure',
25 |       required: false,
26 |       description: "The animal's enclosure.",
27 |     },
28 |     { name: 'trail', required: false, description: "The animal's trail." },
29 |   ],
30 |   invoke: vi.fn().mockResolvedValue({
31 |     messages: [{ content: { text: 'Hello, world!' } }],
32 |   }),
33 | };
34 | 
35 | describe('McpPromptLoader', () => {
36 |   const mockConfig = {} as Config;
37 | 
38 |   // Use a beforeEach to set up and clean a spy for each test
39 |   beforeEach(() => {
40 |     vi.clearAllMocks();
41 |     vi.spyOn(cliCore, 'getMCPServerPrompts').mockReturnValue([mockPrompt]);
42 |   });
43 | 
44 |   // --- `parseArgs` tests remain the same ---
45 | 
46 |   describe('parseArgs', () => {
47 |     it('should handle multi-word positional arguments', () => {
48 |       const loader = new McpPromptLoader(mockConfig);
49 |       const promptArgs: PromptArgument[] = [
50 |         { name: 'arg1', required: true },
51 |         { name: 'arg2', required: true },
52 |       ];
53 |       const userArgs = 'hello world';
54 |       const result = loader.parseArgs(userArgs, promptArgs);
55 |       expect(result).toEqual({ arg1: 'hello', arg2: 'world' });
56 |     });
57 | 
58 |     it('should handle quoted multi-word positional arguments', () => {
59 |       const loader = new McpPromptLoader(mockConfig);
60 |       const promptArgs: PromptArgument[] = [
61 |         { name: 'arg1', required: true },
62 |         { name: 'arg2', required: true },
63 |       ];
64 |       const userArgs = '"hello world" foo';
65 |       const result = loader.parseArgs(userArgs, promptArgs);
66 |       expect(result).toEqual({ arg1: 'hello world', arg2: 'foo' });
67 |     });
68 | 
69 |     it('should handle a single positional argument with multiple words', () => {
70 |       const loader = new McpPromptLoader(mockConfig);
71 |       const promptArgs: PromptArgument[] = [{ name: 'arg1', required: true }];
72 |       const userArgs = 'hello world';
73 |       const result = loader.parseArgs(userArgs, promptArgs);
74 |       expect(result).toEqual({ arg1: 'hello world' });
75 |     });
76 | 
77 |     it('should handle escaped quotes in positional arguments', () => {
78 |       const loader = new McpPromptLoader(mockConfig);
79 |       const promptArgs: PromptArgument[] = [{ name: 'arg1', required: true }];
80 |       const userArgs = '"hello \\"world\\""';
81 |       const result = loader.parseArgs(userArgs, promptArgs);
82 |       expect(result).toEqual({ arg1: 'hello "world"' });
83 |     });
84 | 
85 |     it('should handle escaped backslashes in positional arguments', () => {
86 |       const loader = new McpPromptLoader(mockConfig);
87 |       const promptArgs: PromptArgument[] = [{ name: 'arg1', required: true }];
88 |       const userArgs = '"hello\\\\world"';
89 |       const result = loader.parseArgs(userArgs, promptArgs);
90 |       expect(result).toEqual({ arg1: 'hello\\world' });
91 |     });
92 | 
93 |     it('should handle named args followed by positional args', () => {
94 |       const loader = new McpPromptLoader(mockConfig);
95 |       const promptArgs: PromptArgument[] = [
96 |         { name: 'named', required: true },
97 |         { name: 'pos', required: true },
98 |       ];
99 |       const userArgs = '--named="value" positional';
100 |       const result = loader.parseArgs(userArgs, promptArgs);
101 |       expect(result).toEqual({ named: 'value', pos: 'positional' });
102 |     });
103 | 
104 |     it('should handle positional args followed by named args', () => {
105 |       const loader = new McpPromptLoader(mockConfig);
106 |       const promptArgs: PromptArgument[] = [
107 |         { name: 'pos', required: true },
108 |         { name: 'named', required: true },
109 |       ];
110 |       const userArgs = 'positional --named="value"';
111 |       const result = loader.parseArgs(userArgs, promptArgs);
112 |       expect(result).toEqual({ pos: 'positional', named: 'value' });
113 |     });
114 | 
115 |     it('should handle positional args interspersed with named args', () => {
116 |       const loader = new McpPromptLoader(mockConfig);
117 |       const promptArgs: PromptArgument[] = [
118 |         { name: 'pos1', required: true },
119 |         { name: 'named', required: true },
120 |         { name: 'pos2', required: true },
121 |       ];
122 |       const userArgs = 'p1 --named="value" p2';
123 |       const result = loader.parseArgs(userArgs, promptArgs);
124 |       expect(result).toEqual({ pos1: 'p1', named: 'value', pos2: 'p2' });
125 |     });
126 | 
127 |     it('should treat an escaped quote at the start as a literal', () => {
128 |       const loader = new McpPromptLoader(mockConfig);
129 |       const promptArgs: PromptArgument[] = [
130 |         { name: 'arg1', required: true },
131 |         { name: 'arg2', required: true },
132 |       ];
133 |       const userArgs = '\\"hello world';
134 |       const result = loader.parseArgs(userArgs, promptArgs);
135 |       expect(result).toEqual({ arg1: '"hello', arg2: 'world' });
136 |     });
137 | 
138 |     it('should handle a complex mix of args', () => {
139 |       const loader = new McpPromptLoader(mockConfig);
140 |       const promptArgs: PromptArgument[] = [
141 |         { name: 'pos1', required: true },
142 |         { name: 'named1', required: true },
143 |         { name: 'pos2', required: true },
144 |         { name: 'named2', required: true },
145 |         { name: 'pos3', required: true },
146 |       ];
147 |       const userArgs =
148 |         'p1 --named1="value 1" "p2 has spaces" --named2=value2 "p3 \\"with quotes\\""';
149 |       const result = loader.parseArgs(userArgs, promptArgs);
150 |       expect(result).toEqual({
151 |         pos1: 'p1',
152 |         named1: 'value 1',
153 |         pos2: 'p2 has spaces',
154 |         named2: 'value2',
155 |         pos3: 'p3 "with quotes"',
156 |       });
157 |     });
158 |   });
159 | 
160 |   describe('loadCommands', () => {
161 |     const mockConfigWithPrompts = {
162 |       getMcpServers: () => ({
163 |         'test-server': { httpUrl: 'https://test-server.com' },
164 |       }),
165 |     } as unknown as Config;
166 | 
167 |     it('should load prompts as slash commands', async () => {
168 |       const loader = new McpPromptLoader(mockConfigWithPrompts);
169 |       const commands = await loader.loadCommands(new AbortController().signal);
170 |       expect(commands).toHaveLength(1);
171 |       expect(commands[0].name).toBe('test-prompt');
172 |       expect(commands[0].description).toBe('A test prompt.');
173 |       expect(commands[0].kind).toBe(CommandKind.MCP_PROMPT);
174 |     });
175 | 
176 |     it('should handle prompt invocation successfully', async () => {
177 |       const loader = new McpPromptLoader(mockConfigWithPrompts);
178 |       const commands = await loader.loadCommands(new AbortController().signal);
179 |       const action = commands[0].action!;
180 |       const context = {} as CommandContext;
181 |       const result = await action(context, 'test-name 123 tiger');
182 |       expect(mockPrompt.invoke).toHaveBeenCalledWith({
183 |         name: 'test-name',
184 |         age: '123',
185 |         species: 'tiger',
186 |       });
187 |       expect(result).toEqual({
188 |         type: 'submit_prompt',
189 |         content: JSON.stringify('Hello, world!'),
190 |       });
191 |     });
192 | 
193 |     it('should return an error for missing required arguments', async () => {
194 |       const loader = new McpPromptLoader(mockConfigWithPrompts);
195 |       const commands = await loader.loadCommands(new AbortController().signal);
196 |       const action = commands[0].action!;
197 |       const context = {} as CommandContext;
198 |       const result = await action(context, 'test-name');
199 |       expect(result).toEqual({
200 |         type: 'message',
201 |         messageType: 'error',
202 |         content: 'Missing required argument(s): --age, --species',
203 |       });
204 |     });
205 | 
206 |     it('should return an error message if prompt invocation fails', async () => {
207 |       vi.spyOn(mockPrompt, 'invoke').mockRejectedValue(
208 |         new Error('Invocation failed!'),
209 |       );
210 |       const loader = new McpPromptLoader(mockConfigWithPrompts);
211 |       const commands = await loader.loadCommands(new AbortController().signal);
212 |       const action = commands[0].action!;
213 |       const context = {} as CommandContext;
214 |       const result = await action(context, 'test-name 123 tiger');
215 |       expect(result).toEqual({
216 |         type: 'message',
217 |         messageType: 'error',
218 |         content: 'Error: Invocation failed!',
219 |       });
220 |     });
221 | 
222 |     it('should return an empty array if config is not available', async () => {
223 |       const loader = new McpPromptLoader(null);
224 |       const commands = await loader.loadCommands(new AbortController().signal);
225 |       expect(commands).toEqual([]);
226 |     });
227 | 
228 |     describe('completion', () => {
229 |       it('should suggest no arguments when using positional arguments', async () => {
230 |         const loader = new McpPromptLoader(mockConfigWithPrompts);
231 |         const commands = await loader.loadCommands(
232 |           new AbortController().signal,
233 |         );
234 |         const completion = commands[0].completion!;
235 |         const context = {} as CommandContext;
236 |         const suggestions = await completion(context, 'test-name 6 tiger');
237 |         expect(suggestions).toEqual([]);
238 |       });
239 | 
240 |       it('should suggest all arguments when none are present', async () => {
241 |         const loader = new McpPromptLoader(mockConfigWithPrompts);
242 |         const commands = await loader.loadCommands(
243 |           new AbortController().signal,
244 |         );
245 |         const completion = commands[0].completion!;
246 |         const context = {
247 |           invocation: {
248 |             raw: '/find ',
249 |             name: 'find',
250 |             args: '',
251 |           },
252 |         } as CommandContext;
253 |         const suggestions = await completion(context, '');
254 |         expect(suggestions).toEqual([
255 |           '--name="',
256 |           '--age="',
257 |           '--species="',
258 |           '--enclosure="',
259 |           '--trail="',
260 |         ]);
261 |       });
262 | 
263 |       it('should suggest remaining arguments when some are present', async () => {
264 |         const loader = new McpPromptLoader(mockConfigWithPrompts);
265 |         const commands = await loader.loadCommands(
266 |           new AbortController().signal,
267 |         );
268 |         const completion = commands[0].completion!;
269 |         const context = {
270 |           invocation: {
271 |             raw: '/find --name="test-name" --age="6" ',
272 |             name: 'find',
273 |             args: '--name="test-name" --age="6"',
274 |           },
275 |         } as CommandContext;
276 |         const suggestions = await completion(context, '');
277 |         expect(suggestions).toEqual([
278 |           '--species="',
279 |           '--enclosure="',
280 |           '--trail="',
281 |         ]);
282 |       });
283 | 
284 |       it('should suggest no arguments when all are present', async () => {
285 |         const loader = new McpPromptLoader(mockConfigWithPrompts);
286 |         const commands = await loader.loadCommands(
287 |           new AbortController().signal,
288 |         );
289 |         const completion = commands[0].completion!;
290 |         const context = {} as CommandContext;
291 |         const suggestions = await completion(
292 |           context,
293 |           '--name="test-name" --age="6" --species="tiger" --enclosure="Tiger Den" --trail="Jungle"',
294 |         );
295 |         expect(suggestions).toEqual([]);
296 |       });
297 | 
298 |       it('should suggest nothing for prompts with no arguments', async () => {
299 |         // Temporarily override the mock to return a prompt with no args
300 |         vi.spyOn(cliCore, 'getMCPServerPrompts').mockReturnValue([
301 |           { ...mockPrompt, arguments: [] },
302 |         ]);
303 |         const loader = new McpPromptLoader(mockConfigWithPrompts);
304 |         const commands = await loader.loadCommands(
305 |           new AbortController().signal,
306 |         );
307 |         const completion = commands[0].completion!;
308 |         const context = {} as CommandContext;
309 |         const suggestions = await completion(context, '');
310 |         expect(suggestions).toEqual([]);
311 |       });
312 | 
313 |       it('should suggest arguments matching a partial argument', async () => {
314 |         const loader = new McpPromptLoader(mockConfigWithPrompts);
315 |         const commands = await loader.loadCommands(
[TRUNCATED]
```

src/services/McpPromptLoader.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type { Config } from '@google/gemini-cli-core';
8 | import { getErrorMessage, getMCPServerPrompts } from '@google/gemini-cli-core';
9 | import type {
10 |   CommandContext,
11 |   SlashCommand,
12 |   SlashCommandActionReturn,
13 | } from '../ui/commands/types.js';
14 | import { CommandKind } from '../ui/commands/types.js';
15 | import type { ICommandLoader } from './types.js';
16 | import type { PromptArgument } from '@modelcontextprotocol/sdk/types.js';
17 | 
18 | /**
19 |  * Discovers and loads executable slash commands from prompts exposed by
20 |  * Model-Context-Protocol (MCP) servers.
21 |  */
22 | export class McpPromptLoader implements ICommandLoader {
23 |   constructor(private readonly config: Config | null) {}
24 | 
25 |   /**
26 |    * Loads all available prompts from all configured MCP servers and adapts
27 |    * them into executable SlashCommand objects.
28 |    *
29 |    * @param _signal An AbortSignal (unused for this synchronous loader).
30 |    * @returns A promise that resolves to an array of loaded SlashCommands.
31 |    */
32 |   loadCommands(_signal: AbortSignal): Promise<SlashCommand[]> {
33 |     const promptCommands: SlashCommand[] = [];
34 |     if (!this.config) {
35 |       return Promise.resolve([]);
36 |     }
37 |     const mcpServers = this.config.getMcpServers() || {};
38 |     for (const serverName in mcpServers) {
39 |       const prompts = getMCPServerPrompts(this.config, serverName) || [];
40 |       for (const prompt of prompts) {
41 |         const commandName = `${prompt.name}`;
42 |         const newPromptCommand: SlashCommand = {
43 |           name: commandName,
44 |           description: prompt.description || `Invoke prompt ${prompt.name}`,
45 |           kind: CommandKind.MCP_PROMPT,
46 |           subCommands: [
47 |             {
48 |               name: 'help',
49 |               description: 'Show help for this prompt',
50 |               kind: CommandKind.MCP_PROMPT,
51 |               action: async (): Promise<SlashCommandActionReturn> => {
52 |                 if (!prompt.arguments || prompt.arguments.length === 0) {
53 |                   return {
54 |                     type: 'message',
55 |                     messageType: 'info',
56 |                     content: `Prompt "${prompt.name}" has no arguments.`,
57 |                   };
58 |                 }
59 | 
60 |                 let helpMessage = `Arguments for "${prompt.name}":\n\n`;
61 |                 if (prompt.arguments && prompt.arguments.length > 0) {
62 |                   helpMessage += `You can provide arguments by name (e.g., --argName="value") or by position.\n\n`;
63 |                   helpMessage += `e.g., ${prompt.name} ${prompt.arguments?.map((_) => `"foo"`)} is equivalent to ${prompt.name} ${prompt.arguments?.map((arg) => `--${arg.name}="foo"`)}\n\n`;
64 |                 }
65 |                 for (const arg of prompt.arguments) {
66 |                   helpMessage += `  --${arg.name}\n`;
67 |                   if (arg.description) {
68 |                     helpMessage += `    ${arg.description}\n`;
69 |                   }
70 |                   helpMessage += `    (required: ${
71 |                     arg.required ? 'yes' : 'no'
72 |                   })\n\n`;
73 |                 }
74 |                 return {
75 |                   type: 'message',
76 |                   messageType: 'info',
77 |                   content: helpMessage,
78 |                 };
79 |               },
80 |             },
81 |           ],
82 |           action: async (
83 |             context: CommandContext,
84 |             args: string,
85 |           ): Promise<SlashCommandActionReturn> => {
86 |             if (!this.config) {
87 |               return {
88 |                 type: 'message',
89 |                 messageType: 'error',
90 |                 content: 'Config not loaded.',
91 |               };
92 |             }
93 | 
94 |             const promptInputs = this.parseArgs(args, prompt.arguments);
95 |             if (promptInputs instanceof Error) {
96 |               return {
97 |                 type: 'message',
98 |                 messageType: 'error',
99 |                 content: promptInputs.message,
100 |               };
101 |             }
102 | 
103 |             try {
104 |               const mcpServers = this.config.getMcpServers() || {};
105 |               const mcpServerConfig = mcpServers[serverName];
106 |               if (!mcpServerConfig) {
107 |                 return {
108 |                   type: 'message',
109 |                   messageType: 'error',
110 |                   content: `MCP server config not found for '${serverName}'.`,
111 |                 };
112 |               }
113 |               const result = await prompt.invoke(promptInputs);
114 | 
115 |               if (result['error']) {
116 |                 return {
117 |                   type: 'message',
118 |                   messageType: 'error',
119 |                   content: `Error invoking prompt: ${result['error']}`,
120 |                 };
121 |               }
122 | 
123 |               if (!result.messages?.[0]?.content?.['text']) {
124 |                 return {
125 |                   type: 'message',
126 |                   messageType: 'error',
127 |                   content:
128 |                     'Received an empty or invalid prompt response from the server.',
129 |                 };
130 |               }
131 | 
132 |               return {
133 |                 type: 'submit_prompt',
134 |                 content: JSON.stringify(result.messages[0].content.text),
135 |               };
136 |             } catch (error) {
137 |               return {
138 |                 type: 'message',
139 |                 messageType: 'error',
140 |                 content: `Error: ${getErrorMessage(error)}`,
141 |               };
142 |             }
143 |           },
144 |           completion: async (
145 |             commandContext: CommandContext,
146 |             partialArg: string,
147 |           ) => {
148 |             const invocation = commandContext.invocation;
149 |             if (!prompt || !prompt.arguments || !invocation) {
150 |               return [];
151 |             }
152 |             const indexOfFirstSpace = invocation.raw.indexOf(' ') + 1;
153 |             let promptInputs =
154 |               indexOfFirstSpace === 0
155 |                 ? {}
156 |                 : this.parseArgs(
157 |                     invocation.raw.substring(indexOfFirstSpace),
158 |                     prompt.arguments,
159 |                   );
160 |             if (promptInputs instanceof Error) {
161 |               promptInputs = {};
162 |             }
163 | 
164 |             const providedArgNames = Object.keys(promptInputs);
165 |             const unusedArguments =
166 |               prompt.arguments
167 |                 .filter((arg) => {
168 |                   // If this arguments is not in the prompt inputs
169 |                   // add it to unusedArguments
170 |                   if (!providedArgNames.includes(arg.name)) {
171 |                     return true;
172 |                   }
173 | 
174 |                   // The parseArgs method assigns the value
175 |                   // at the end of the prompt as a final value
176 |                   // The argument should still be suggested
177 |                   // Example /add --numberOne="34" --num
178 |                   // numberTwo would be assigned a value of --num
179 |                   // numberTwo should still be considered unused
180 |                   const argValue = promptInputs[arg.name];
181 |                   return argValue === partialArg;
182 |                 })
183 |                 .map((argument) => `--${argument.name}="`) || [];
184 | 
185 |             const exactlyMatchingArgumentAtTheEnd = prompt.arguments
186 |               .map((argument) => `--${argument.name}="`)
187 |               .filter((flagArgument) => {
188 |                 const regex = new RegExp(`${flagArgument}[^"]*$`);
189 |                 return regex.test(invocation.raw);
190 |               });
191 | 
192 |             if (exactlyMatchingArgumentAtTheEnd.length === 1) {
193 |               if (exactlyMatchingArgumentAtTheEnd[0] === partialArg) {
194 |                 return [`${partialArg}"`];
195 |               }
196 |               if (partialArg.endsWith('"')) {
197 |                 return [partialArg];
198 |               }
199 |               return [`${partialArg}"`];
200 |             }
201 | 
202 |             const matchingArguments = unusedArguments.filter((flagArgument) =>
203 |               flagArgument.startsWith(partialArg),
204 |             );
205 | 
206 |             return matchingArguments;
207 |           },
208 |         };
209 |         promptCommands.push(newPromptCommand);
210 |       }
211 |     }
212 |     return Promise.resolve(promptCommands);
213 |   }
214 | 
215 |   /**
216 |    * Parses the `userArgs` string representing the prompt arguments (all the text
217 |    * after the command) into a record matching the shape of the `promptArgs`.
218 |    *
219 |    * @param userArgs
220 |    * @param promptArgs
221 |    * @returns A record of the parsed arguments
222 |    * @visibleForTesting
223 |    */
224 |   parseArgs(
225 |     userArgs: string,
226 |     promptArgs: PromptArgument[] | undefined,
227 |   ): Record<string, unknown> | Error {
228 |     const argValues: { [key: string]: string } = {};
229 |     const promptInputs: Record<string, unknown> = {};
230 | 
231 |     // arg parsing: --key="value" or --key=value
232 |     const namedArgRegex = /--([^=]+)=(?:"((?:\\.|[^"\\])*)"|([^ ]+))/g;
233 |     let match;
234 |     let lastIndex = 0;
235 |     const positionalParts: string[] = [];
236 | 
237 |     while ((match = namedArgRegex.exec(userArgs)) !== null) {
238 |       const key = match[1];
239 |       // Extract the quoted or unquoted argument and remove escape chars.
240 |       const value = (match[2] ?? match[3]).replace(/\\(.)/g, '$1');
241 |       argValues[key] = value;
242 |       // Capture text between matches as potential positional args
243 |       if (match.index > lastIndex) {
244 |         positionalParts.push(userArgs.substring(lastIndex, match.index));
245 |       }
246 |       lastIndex = namedArgRegex.lastIndex;
247 |     }
248 | 
249 |     // Capture any remaining text after the last named arg
250 |     if (lastIndex < userArgs.length) {
251 |       positionalParts.push(userArgs.substring(lastIndex));
252 |     }
253 | 
254 |     const positionalArgsString = positionalParts.join('').trim();
255 |     // extracts either quoted strings or non-quoted sequences of non-space characters.
256 |     const positionalArgRegex = /(?:"((?:\\.|[^"\\])*)"|([^ ]+))/g;
257 |     const positionalArgs: string[] = [];
258 |     while ((match = positionalArgRegex.exec(positionalArgsString)) !== null) {
259 |       // Extract the quoted or unquoted argument and remove escape chars.
260 |       positionalArgs.push((match[1] ?? match[2]).replace(/\\(.)/g, '$1'));
261 |     }
262 | 
263 |     if (!promptArgs) {
264 |       return promptInputs;
265 |     }
266 |     for (const arg of promptArgs) {
267 |       if (argValues[arg.name]) {
268 |         promptInputs[arg.name] = argValues[arg.name];
269 |       }
270 |     }
271 | 
272 |     const unfilledArgs = promptArgs.filter(
273 |       (arg) => arg.required && !promptInputs[arg.name],
274 |     );
275 | 
276 |     if (unfilledArgs.length === 1) {
277 |       // If we have only one unfilled arg, we don't require quotes we just
278 |       // join all the given arguments together as if they were quoted.
279 |       promptInputs[unfilledArgs[0].name] = positionalArgs.join(' ');
280 |     } else {
281 |       const missingArgs: string[] = [];
282 |       for (let i = 0; i < unfilledArgs.length; i++) {
283 |         if (positionalArgs.length > i) {
284 |           promptInputs[unfilledArgs[i].name] = positionalArgs[i];
285 |         } else {
286 |           missingArgs.push(unfilledArgs[i].name);
287 |         }
288 |       }
289 |       if (missingArgs.length > 0) {
290 |         const missingArgNames = missingArgs
291 |           .map((name) => `--${name}`)
292 |           .join(', ');
293 |         return new Error(`Missing required argument(s): ${missingArgNames}`);
294 |       }
295 |     }
296 | 
297 |     return promptInputs;
298 |   }
299 | }
```

src/services/types.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type { SlashCommand } from '../ui/commands/types.js';
8 | 
9 | /**
10 |  * Defines the contract for any class that can load and provide slash commands.
11 |  * This allows the CommandService to be extended with new command sources
12 |  * (e.g., file-based, remote APIs) without modification.
13 |  *
14 |  * Loaders should receive any necessary dependencies (like Config) via their
15 |  * constructor.
16 |  */
17 | export interface ICommandLoader {
18 |   /**
19 |    * Discovers and returns a list of slash commands from the loader's source.
20 |    * @param signal An AbortSignal to allow cancellation.
21 |    * @returns A promise that resolves to an array of SlashCommand objects.
22 |    */
23 |   loadCommands(signal: AbortSignal): Promise<SlashCommand[]>;
24 | }
```

src/test-utils/createExtension.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import * as fs from 'node:fs';
8 | import * as path from 'node:path';
9 | import {
10 |   EXTENSIONS_CONFIG_FILENAME,
11 |   INSTALL_METADATA_FILENAME,
12 | } from '../config/extension.js';
13 | import {
14 |   type MCPServerConfig,
15 |   type ExtensionInstallMetadata,
16 | } from '@google/gemini-cli-core';
17 | 
18 | export function createExtension({
19 |   extensionsDir = 'extensions-dir',
20 |   name = 'my-extension',
21 |   version = '1.0.0',
22 |   addContextFile = false,
23 |   contextFileName = undefined as string | undefined,
24 |   mcpServers = {} as Record<string, MCPServerConfig>,
25 |   installMetadata = undefined as ExtensionInstallMetadata | undefined,
26 | } = {}): string {
27 |   const extDir = path.join(extensionsDir, name);
28 |   fs.mkdirSync(extDir, { recursive: true });
29 |   fs.writeFileSync(
30 |     path.join(extDir, EXTENSIONS_CONFIG_FILENAME),
31 |     JSON.stringify({ name, version, contextFileName, mcpServers }),
32 |   );
33 | 
34 |   if (addContextFile) {
35 |     fs.writeFileSync(path.join(extDir, 'GEMINI.md'), 'context');
36 |   }
37 | 
38 |   if (contextFileName) {
39 |     fs.writeFileSync(path.join(extDir, contextFileName), 'context');
40 |   }
41 | 
42 |   if (installMetadata) {
43 |     fs.writeFileSync(
44 |       path.join(extDir, INSTALL_METADATA_FILENAME),
45 |       JSON.stringify(installMetadata),
46 |     );
47 |   }
48 |   return extDir;
49 | }
```

src/test-utils/customMatchers.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | /// <reference types="vitest/globals" />
8 | 
9 | /**
10 |  * @license
11 |  * Copyright 2025 Google LLC
12 |  * SPDX-License-Identifier: Apache-2.0
13 |  */
14 | 
15 | import type { Assertion } from 'vitest';
16 | import { expect } from 'vitest';
17 | import type { TextBuffer } from '../ui/components/shared/text-buffer.js';
18 | 
19 | // RegExp to detect invalid characters: backspace, and ANSI escape codes
20 | // eslint-disable-next-line no-control-regex
21 | const invalidCharsRegex = /[\b\x1b]/;
22 | 
23 | function toHaveOnlyValidCharacters(this: Assertion, buffer: TextBuffer) {
24 |   // eslint-disable-next-line @typescript-eslint/no-explicit-any
25 |   const { isNot } = this as any;
26 |   let pass = true;
27 |   const invalidLines: Array<{ line: number; content: string }> = [];
28 | 
29 |   for (let i = 0; i < buffer.lines.length; i++) {
30 |     const line = buffer.lines[i];
31 |     if (line.includes('\n')) {
32 |       pass = false;
33 |       invalidLines.push({ line: i, content: line });
34 |       break; // Fail fast on newlines
35 |     }
36 |     if (invalidCharsRegex.test(line)) {
37 |       pass = false;
38 |       invalidLines.push({ line: i, content: line });
39 |     }
40 |   }
41 | 
42 |   return {
43 |     pass,
44 |     message: () =>
45 |       `Expected buffer ${isNot ? 'not ' : ''}to have only valid characters, but found invalid characters in lines:\n${invalidLines
46 |         .map((l) => `  [${l.line}]: "${l.content}"`) /* This line was changed */
47 |         .join('\n')}`,
48 |     actual: buffer.lines,
49 |     expected: 'Lines with no line breaks, backspaces, or escape codes.',
50 |   };
51 | }
52 | 
53 | expect.extend({
54 |   toHaveOnlyValidCharacters,
55 |   // eslint-disable-next-line @typescript-eslint/no-explicit-any
56 | } as any);
57 | 
58 | // Extend Vitest's `expect` interface with the custom matcher's type definition.
59 | declare module 'vitest' {
60 |   interface Assertion<T> {
61 |     toHaveOnlyValidCharacters(): T;
62 |   }
63 |   interface AsymmetricMatchersContaining {
64 |     toHaveOnlyValidCharacters(): void;
65 |   }
66 | }
```

src/test-utils/mockCommandContext.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { vi, describe, it, expect } from 'vitest';
8 | import { createMockCommandContext } from './mockCommandContext.js';
9 | 
10 | describe('createMockCommandContext', () => {
11 |   it('should return a valid CommandContext object with default mocks', () => {
12 |     const context = createMockCommandContext();
13 | 
14 |     // Just a few spot checks to ensure the structure is correct
15 |     // and functions are mocks.
16 |     expect(context).toBeDefined();
17 |     expect(context.ui.addItem).toBeInstanceOf(Function);
18 |     expect(vi.isMockFunction(context.ui.addItem)).toBe(true);
19 |   });
20 | 
21 |   it('should apply top-level overrides correctly', () => {
22 |     const mockClear = vi.fn();
23 |     const overrides = {
24 |       ui: {
25 |         clear: mockClear,
26 |       },
27 |     };
28 | 
29 |     const context = createMockCommandContext(overrides);
30 | 
31 |     // Call the function to see if the override was used
32 |     context.ui.clear();
33 | 
34 |     // Assert that our specific mock was called, not the default
35 |     expect(mockClear).toHaveBeenCalled();
36 |     // And that other defaults are still in place
37 |     expect(vi.isMockFunction(context.ui.addItem)).toBe(true);
38 |   });
39 | 
40 |   it('should apply deeply nested overrides correctly', () => {
41 |     // This is the most important test for factory's logic.
42 |     const mockConfig = {
43 |       getProjectRoot: () => '/test/project',
44 |       getModel: () => 'gemini-pro',
45 |     };
46 | 
47 |     const overrides = {
48 |       services: {
49 |         config: mockConfig,
50 |       },
51 |     };
52 | 
53 |     const context = createMockCommandContext(overrides);
54 | 
55 |     expect(context.services.config).toBeDefined();
56 |     expect(context.services.config?.getModel()).toBe('gemini-pro');
57 |     expect(context.services.config?.getProjectRoot()).toBe('/test/project');
58 | 
59 |     // Verify a default property on the same nested object is still there
60 |     expect(context.services.logger).toBeDefined();
61 |   });
62 | });
```

src/test-utils/mockCommandContext.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { vi } from 'vitest';
8 | import type { CommandContext } from '../ui/commands/types.js';
9 | import type { LoadedSettings } from '../config/settings.js';
10 | import type { GitService } from '@google/gemini-cli-core';
11 | import type { SessionStatsState } from '../ui/contexts/SessionContext.js';
12 | 
13 | // A utility type to make all properties of an object, and its nested objects, partial.
14 | type DeepPartial<T> = T extends object
15 |   ? {
16 |       [P in keyof T]?: DeepPartial<T[P]>;
17 |     }
18 |   : T;
19 | 
20 | /**
21 |  * Creates a deep, fully-typed mock of the CommandContext for use in tests.
22 |  * All functions are pre-mocked with `vi.fn()`.
23 |  *
24 |  * @param overrides - A deep partial object to override any default mock values.
25 |  * @returns A complete, mocked CommandContext object.
26 |  */
27 | export const createMockCommandContext = (
28 |   overrides: DeepPartial<CommandContext> = {},
29 | ): CommandContext => {
30 |   const defaultMocks: CommandContext = {
31 |     invocation: {
32 |       raw: '',
33 |       name: '',
34 |       args: '',
35 |     },
36 |     services: {
37 |       config: null,
38 |       settings: { merged: {} } as LoadedSettings,
39 |       git: undefined as GitService | undefined,
40 |       logger: {
41 |         log: vi.fn(),
42 |         logMessage: vi.fn(),
43 |         saveCheckpoint: vi.fn(),
44 |         loadCheckpoint: vi.fn().mockResolvedValue([]),
45 |         // eslint-disable-next-line @typescript-eslint/no-explicit-any
46 |       } as any, // Cast because Logger is a class.
47 |     },
48 |     ui: {
49 |       addItem: vi.fn(),
50 |       clear: vi.fn(),
51 |       setDebugMessage: vi.fn(),
52 |       pendingItem: null,
53 |       setPendingItem: vi.fn(),
54 |       loadHistory: vi.fn(),
55 |       toggleCorgiMode: vi.fn(),
56 |       toggleVimEnabled: vi.fn(),
57 |       extensionsUpdateState: new Map(),
58 |       setExtensionsUpdateState: vi.fn(),
59 |       // eslint-disable-next-line @typescript-eslint/no-explicit-any
60 |     } as any,
61 |     session: {
62 |       sessionShellAllowlist: new Set<string>(),
63 |       stats: {
64 |         sessionStartTime: new Date(),
65 |         lastPromptTokenCount: 0,
66 |         metrics: {
67 |           models: {},
68 |           tools: {
69 |             totalCalls: 0,
70 |             totalSuccess: 0,
71 |             totalFail: 0,
72 |             totalDurationMs: 0,
73 |             totalDecisions: { accept: 0, reject: 0, modify: 0 },
74 |             byName: {},
75 |           },
76 |         },
77 |       } as SessionStatsState,
78 |     },
79 |   };
80 | 
81 |   // eslint-disable-next-line @typescript-eslint/no-explicit-any
82 |   const merge = (target: any, source: any): any => {
83 |     const output = { ...target };
84 | 
85 |     for (const key in source) {
86 |       if (Object.prototype.hasOwnProperty.call(source, key)) {
87 |         const sourceValue = source[key];
88 |         const targetValue = output[key];
89 | 
90 |         if (
91 |           // We only want to recursivlty merge plain objects
92 |           Object.prototype.toString.call(sourceValue) === '[object Object]' &&
93 |           Object.prototype.toString.call(targetValue) === '[object Object]'
94 |         ) {
95 |           output[key] = merge(targetValue, sourceValue);
96 |         } else {
97 |           // If not, we do a direct assignment. This preserves Date objects and others.
98 |           output[key] = sourceValue;
99 |         }
100 |       }
101 |     }
102 |     return output;
103 |   };
104 | 
105 |   return merge(defaultMocks, overrides);
106 | };
```

src/test-utils/render.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { render } from 'ink-testing-library';
8 | import type React from 'react';
9 | import { LoadedSettings, type Settings } from '../config/settings.js';
10 | import { KeypressProvider } from '../ui/contexts/KeypressContext.js';
11 | import { SettingsContext } from '../ui/contexts/SettingsContext.js';
12 | import { ShellFocusContext } from '../ui/contexts/ShellFocusContext.js';
13 | import { UIStateContext, type UIState } from '../ui/contexts/UIStateContext.js';
14 | import { ConfigContext } from '../ui/contexts/ConfigContext.js';
15 | import { calculateMainAreaWidth } from '../ui/utils/ui-sizing.js';
16 | import { VimModeProvider } from '../ui/contexts/VimModeContext.js';
17 | 
18 | import { type Config } from '@google/gemini-cli-core';
19 | 
20 | const mockConfig = {
21 |   getModel: () => 'gemini-pro',
22 |   getTargetDir: () =>
23 |     '/Users/test/project/foo/bar/and/some/more/directories/to/make/it/long',
24 |   getDebugMode: () => false,
25 | };
26 | 
27 | const configProxy = new Proxy(mockConfig, {
28 |   get(target, prop) {
29 |     if (prop in target) {
30 |       return target[prop as keyof typeof target];
31 |     }
32 |     throw new Error(`mockConfig does not have property ${String(prop)}`);
33 |   },
34 | });
35 | 
36 | export const mockSettings = new LoadedSettings(
37 |   { path: '', settings: {}, originalSettings: {} },
38 |   { path: '', settings: {}, originalSettings: {} },
39 |   { path: '', settings: {}, originalSettings: {} },
40 |   { path: '', settings: {}, originalSettings: {} },
41 |   true,
42 |   new Set(),
43 | );
44 | 
45 | export const createMockSettings = (
46 |   overrides: Partial<Settings>,
47 | ): LoadedSettings => {
48 |   const settings = overrides as Settings;
49 |   return new LoadedSettings(
50 |     { path: '', settings: {}, originalSettings: {} },
51 |     { path: '', settings: {}, originalSettings: {} },
52 |     { path: '', settings, originalSettings: settings },
53 |     { path: '', settings: {}, originalSettings: {} },
54 |     true,
55 |     new Set(),
56 |   );
57 | };
58 | 
59 | // A minimal mock UIState to satisfy the context provider.
60 | // Tests that need specific UIState values should provide their own.
61 | const baseMockUiState = {
62 |   mainAreaWidth: 100,
63 |   terminalWidth: 120,
64 | };
65 | 
66 | export const renderWithProviders = (
67 |   component: React.ReactElement,
68 |   {
69 |     shellFocus = true,
70 |     settings = mockSettings,
71 |     uiState: providedUiState,
72 |     width,
73 |     config = configProxy as unknown as Config,
74 |   }: {
75 |     shellFocus?: boolean;
76 |     settings?: LoadedSettings;
77 |     uiState?: Partial<UIState>;
78 |     width?: number;
79 |     config?: Config;
80 |   } = {},
81 | ): ReturnType<typeof render> => {
82 |   const baseState: UIState = new Proxy(
83 |     { ...baseMockUiState, ...providedUiState },
84 |     {
85 |       get(target, prop) {
86 |         if (prop in target) {
87 |           return target[prop as keyof typeof target];
88 |         }
89 |         // For properties not in the base mock or provided state,
90 |         // we'll check the original proxy to see if it's a defined but
91 |         // unprovided property, and if not, throw.
92 |         if (prop in baseMockUiState) {
93 |           return baseMockUiState[prop as keyof typeof baseMockUiState];
94 |         }
95 |         throw new Error(`mockUiState does not have property ${String(prop)}`);
96 |       },
97 |     },
98 |   ) as UIState;
99 | 
100 |   const terminalWidth = width ?? baseState.terminalWidth;
101 |   const mainAreaWidth = calculateMainAreaWidth(terminalWidth, settings);
102 | 
103 |   const finalUiState = {
104 |     ...baseState,
105 |     terminalWidth,
106 |     mainAreaWidth,
107 |   };
108 | 
109 |   return render(
110 |     <ConfigContext.Provider value={config}>
111 |       <SettingsContext.Provider value={settings}>
112 |         <UIStateContext.Provider value={finalUiState}>
113 |           <VimModeProvider settings={settings}>
114 |             <ShellFocusContext.Provider value={shellFocus}>
115 |               <KeypressProvider kittyProtocolEnabled={true}>
116 |                 {component}
117 |               </KeypressProvider>
118 |             </ShellFocusContext.Provider>
119 |           </VimModeProvider>
120 |         </UIStateContext.Provider>
121 |       </SettingsContext.Provider>
122 |     </ConfigContext.Provider>,
123 |   );
124 | };
```

src/ui/App.test.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect, vi } from 'vitest';
8 | import { render } from 'ink-testing-library';
9 | import { Text, useIsScreenReaderEnabled } from 'ink';
10 | import { App } from './App.js';
11 | import { UIStateContext, type UIState } from './contexts/UIStateContext.js';
12 | import { StreamingState } from './types.js';
13 | import {
14 |   ConfigContext,
15 |   type Config,
16 |   type Telemetry,
17 | } from './contexts/ConfigContext.js';
18 | 
19 | vi.mock('ink', async (importOriginal) => {
20 |   const original = await importOriginal<typeof import('ink')>();
21 |   return {
22 |     ...original,
23 |     useIsScreenReaderEnabled: vi.fn(),
24 |   };
25 | });
26 | 
27 | vi.mock('./components/MainContent.js', () => ({
28 |   MainContent: () => <Text>MainContent</Text>,
29 | }));
30 | 
31 | vi.mock('./components/DialogManager.js', () => ({
32 |   DialogManager: () => <Text>DialogManager</Text>,
33 | }));
34 | 
35 | vi.mock('./components/Composer.js', () => ({
36 |   Composer: () => <Text>Composer</Text>,
37 | }));
38 | 
39 | vi.mock('./components/Notifications.js', () => ({
40 |   Notifications: () => <Text>Notifications</Text>,
41 | }));
42 | 
43 | vi.mock('./components/QuittingDisplay.js', () => ({
44 |   QuittingDisplay: () => <Text>Quitting...</Text>,
45 | }));
46 | 
47 | vi.mock('./components/Footer.js', () => ({
48 |   Footer: () => <Text>Footer</Text>,
49 | }));
50 | 
51 | describe('App', () => {
52 |   const mockUIState: Partial<UIState> = {
53 |     streamingState: StreamingState.Idle,
54 |     quittingMessages: null,
55 |     dialogsVisible: false,
56 |     mainControlsRef: { current: null },
57 |     rootUiRef: { current: null },
58 |     historyManager: {
59 |       addItem: vi.fn(),
60 |       history: [],
61 |       updateItem: vi.fn(),
62 |       clearItems: vi.fn(),
63 |       loadHistory: vi.fn(),
64 |     },
65 |   };
66 | 
67 |   const mockConfig = {
68 |     telemetry: {} as Telemetry,
69 |   } as Config;
70 | 
71 |   const renderWithProviders = (ui: React.ReactElement, state: UIState) =>
72 |     render(
73 |       <ConfigContext.Provider value={mockConfig}>
74 |         <UIStateContext.Provider value={state}>{ui}</UIStateContext.Provider>
75 |       </ConfigContext.Provider>,
76 |     );
77 | 
78 |   it('should render main content and composer when not quitting', () => {
79 |     const { lastFrame } = renderWithProviders(<App />, mockUIState as UIState);
80 | 
81 |     expect(lastFrame()).toContain('MainContent');
82 |     expect(lastFrame()).toContain('Notifications');
83 |     expect(lastFrame()).toContain('Composer');
84 |   });
85 | 
86 |   it('should render quitting display when quittingMessages is set', () => {
87 |     const quittingUIState = {
88 |       ...mockUIState,
89 |       quittingMessages: [{ id: 1, type: 'user', text: 'test' }],
90 |     } as UIState;
91 | 
92 |     const { lastFrame } = renderWithProviders(<App />, quittingUIState);
93 | 
94 |     expect(lastFrame()).toContain('Quitting...');
95 |   });
96 | 
97 |   it('should render dialog manager when dialogs are visible', () => {
98 |     const dialogUIState = {
99 |       ...mockUIState,
100 |       dialogsVisible: true,
101 |     } as UIState;
102 | 
103 |     const { lastFrame } = renderWithProviders(<App />, dialogUIState);
104 | 
105 |     expect(lastFrame()).toContain('MainContent');
106 |     expect(lastFrame()).toContain('Notifications');
107 |     expect(lastFrame()).toContain('DialogManager');
108 |   });
109 | 
110 |   it('should show Ctrl+C exit prompt when dialogs are visible and ctrlCPressedOnce is true', () => {
111 |     const ctrlCUIState = {
112 |       ...mockUIState,
113 |       dialogsVisible: true,
114 |       ctrlCPressedOnce: true,
115 |     } as UIState;
116 | 
117 |     const { lastFrame } = renderWithProviders(<App />, ctrlCUIState);
118 | 
119 |     expect(lastFrame()).toContain('Press Ctrl+C again to exit.');
120 |   });
121 | 
122 |   it('should show Ctrl+D exit prompt when dialogs are visible and ctrlDPressedOnce is true', () => {
123 |     const ctrlDUIState = {
124 |       ...mockUIState,
125 |       dialogsVisible: true,
126 |       ctrlDPressedOnce: true,
127 |     } as UIState;
128 | 
129 |     const { lastFrame } = renderWithProviders(<App />, ctrlDUIState);
130 | 
131 |     expect(lastFrame()).toContain('Press Ctrl+D again to exit.');
132 |   });
133 | 
134 |   it('should render ScreenReaderAppLayout when screen reader is enabled', () => {
135 |     (useIsScreenReaderEnabled as vi.Mock).mockReturnValue(true);
136 | 
137 |     const { lastFrame } = renderWithProviders(<App />, mockUIState as UIState);
138 | 
139 |     expect(lastFrame()).toContain(
140 |       'Notifications\nFooter\nMainContent\nComposer',
141 |     );
142 |   });
143 | 
144 |   it('should render DefaultAppLayout when screen reader is not enabled', () => {
145 |     (useIsScreenReaderEnabled as vi.Mock).mockReturnValue(false);
146 | 
147 |     const { lastFrame } = renderWithProviders(<App />, mockUIState as UIState);
148 | 
149 |     expect(lastFrame()).toContain('MainContent\nNotifications\nComposer');
150 |   });
151 | });
```

src/ui/App.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { useIsScreenReaderEnabled } from 'ink';
8 | import { useUIState } from './contexts/UIStateContext.js';
9 | import { StreamingContext } from './contexts/StreamingContext.js';
10 | import { QuittingDisplay } from './components/QuittingDisplay.js';
11 | import { ScreenReaderAppLayout } from './layouts/ScreenReaderAppLayout.js';
12 | import { DefaultAppLayout } from './layouts/DefaultAppLayout.js';
13 | 
14 | export const App = () => {
15 |   const uiState = useUIState();
16 |   const isScreenReaderEnabled = useIsScreenReaderEnabled();
17 | 
18 |   if (uiState.quittingMessages) {
19 |     return <QuittingDisplay />;
20 |   }
21 | 
22 |   return (
23 |     <StreamingContext.Provider value={uiState.streamingState}>
24 |       {isScreenReaderEnabled ? <ScreenReaderAppLayout /> : <DefaultAppLayout />}
25 |     </StreamingContext.Provider>
26 |   );
27 | };
```

src/ui/AppContainer.test.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import {
8 |   describe,
9 |   it,
10 |   expect,
11 |   vi,
12 |   beforeEach,
13 |   afterEach,
14 |   type Mock,
15 | } from 'vitest';
16 | import { render, cleanup } from 'ink-testing-library';
17 | import { AppContainer } from './AppContainer.js';
18 | import { type Config, makeFakeConfig } from '@google/gemini-cli-core';
19 | import type { LoadedSettings } from '../config/settings.js';
20 | import type { InitializationResult } from '../core/initializer.js';
21 | import { useQuotaAndFallback } from './hooks/useQuotaAndFallback.js';
22 | import { UIStateContext, type UIState } from './contexts/UIStateContext.js';
23 | import {
24 |   UIActionsContext,
25 |   type UIActions,
26 | } from './contexts/UIActionsContext.js';
27 | import { useContext } from 'react';
28 | 
29 | // Mock useStdout to capture terminal title writes
30 | let mockStdout: { write: ReturnType<typeof vi.fn> };
31 | vi.mock('ink', async (importOriginal) => {
32 |   const actual = await importOriginal<typeof import('ink')>();
33 |   return {
34 |     ...actual,
35 |     useStdout: () => ({ stdout: mockStdout }),
36 |     measureElement: vi.fn(),
37 |   };
38 | });
39 | 
40 | // Helper component will read the context values provided by AppContainer
41 | // so we can assert against them in our tests.
42 | let capturedUIState: UIState;
43 | let capturedUIActions: UIActions;
44 | function TestContextConsumer() {
45 |   capturedUIState = useContext(UIStateContext)!;
46 |   capturedUIActions = useContext(UIActionsContext)!;
47 |   return null;
48 | }
49 | 
50 | vi.mock('./App.js', () => ({
51 |   App: TestContextConsumer,
52 | }));
53 | 
54 | vi.mock('./hooks/useQuotaAndFallback.js');
55 | vi.mock('./hooks/useHistoryManager.js');
56 | vi.mock('./hooks/useThemeCommand.js');
57 | vi.mock('./auth/useAuth.js');
58 | vi.mock('./hooks/useEditorSettings.js');
59 | vi.mock('./hooks/useSettingsCommand.js');
60 | vi.mock('./hooks/useModelCommand.js');
61 | vi.mock('./hooks/slashCommandProcessor.js');
62 | vi.mock('./hooks/useConsoleMessages.js');
63 | vi.mock('./hooks/useTerminalSize.js', () => ({
64 |   useTerminalSize: vi.fn(() => ({ columns: 80, rows: 24 })),
65 | }));
66 | vi.mock('./hooks/useGeminiStream.js');
67 | vi.mock('./hooks/vim.js');
68 | vi.mock('./hooks/useFocus.js');
69 | vi.mock('./hooks/useBracketedPaste.js');
70 | vi.mock('./hooks/useKeypress.js');
71 | vi.mock('./hooks/useLoadingIndicator.js');
72 | vi.mock('./hooks/useFolderTrust.js');
73 | vi.mock('./hooks/useIdeTrustListener.js');
74 | vi.mock('./hooks/useMessageQueue.js');
75 | vi.mock('./hooks/useAutoAcceptIndicator.js');
76 | vi.mock('./hooks/useWorkspaceMigration.js');
77 | vi.mock('./hooks/useGitBranchName.js');
78 | vi.mock('./contexts/VimModeContext.js');
79 | vi.mock('./contexts/SessionContext.js');
80 | vi.mock('./components/shared/text-buffer.js');
81 | vi.mock('./hooks/useLogger.js');
82 | 
83 | // Mock external utilities
84 | vi.mock('../utils/events.js');
85 | vi.mock('../utils/handleAutoUpdate.js');
86 | vi.mock('./utils/ConsolePatcher.js');
87 | vi.mock('../utils/cleanup.js');
88 | 
89 | import { useHistory } from './hooks/useHistoryManager.js';
90 | import { useThemeCommand } from './hooks/useThemeCommand.js';
91 | import { useAuthCommand } from './auth/useAuth.js';
92 | import { useEditorSettings } from './hooks/useEditorSettings.js';
93 | import { useSettingsCommand } from './hooks/useSettingsCommand.js';
94 | import { useModelCommand } from './hooks/useModelCommand.js';
95 | import { useSlashCommandProcessor } from './hooks/slashCommandProcessor.js';
96 | import { useConsoleMessages } from './hooks/useConsoleMessages.js';
97 | import { useGeminiStream } from './hooks/useGeminiStream.js';
98 | import { useVim } from './hooks/vim.js';
99 | import { useFolderTrust } from './hooks/useFolderTrust.js';
100 | import { useIdeTrustListener } from './hooks/useIdeTrustListener.js';
101 | import { useMessageQueue } from './hooks/useMessageQueue.js';
102 | import { useAutoAcceptIndicator } from './hooks/useAutoAcceptIndicator.js';
103 | import { useWorkspaceMigration } from './hooks/useWorkspaceMigration.js';
104 | import { useGitBranchName } from './hooks/useGitBranchName.js';
105 | import { useVimMode } from './contexts/VimModeContext.js';
106 | import { useSessionStats } from './contexts/SessionContext.js';
107 | import { useTextBuffer } from './components/shared/text-buffer.js';
108 | import { useLogger } from './hooks/useLogger.js';
109 | import { useLoadingIndicator } from './hooks/useLoadingIndicator.js';
110 | import { measureElement } from 'ink';
111 | import { useTerminalSize } from './hooks/useTerminalSize.js';
112 | import { ShellExecutionService } from '@google/gemini-cli-core';
113 | 
114 | describe('AppContainer State Management', () => {
115 |   let mockConfig: Config;
116 |   let mockSettings: LoadedSettings;
117 |   let mockInitResult: InitializationResult;
118 | 
119 |   // Create typed mocks for all hooks
120 |   const mockedUseQuotaAndFallback = useQuotaAndFallback as Mock;
121 |   const mockedUseHistory = useHistory as Mock;
122 |   const mockedUseThemeCommand = useThemeCommand as Mock;
123 |   const mockedUseAuthCommand = useAuthCommand as Mock;
124 |   const mockedUseEditorSettings = useEditorSettings as Mock;
125 |   const mockedUseSettingsCommand = useSettingsCommand as Mock;
126 |   const mockedUseModelCommand = useModelCommand as Mock;
127 |   const mockedUseSlashCommandProcessor = useSlashCommandProcessor as Mock;
128 |   const mockedUseConsoleMessages = useConsoleMessages as Mock;
129 |   const mockedUseGeminiStream = useGeminiStream as Mock;
130 |   const mockedUseVim = useVim as Mock;
131 |   const mockedUseFolderTrust = useFolderTrust as Mock;
132 |   const mockedUseIdeTrustListener = useIdeTrustListener as Mock;
133 |   const mockedUseMessageQueue = useMessageQueue as Mock;
134 |   const mockedUseAutoAcceptIndicator = useAutoAcceptIndicator as Mock;
135 |   const mockedUseWorkspaceMigration = useWorkspaceMigration as Mock;
136 |   const mockedUseGitBranchName = useGitBranchName as Mock;
137 |   const mockedUseVimMode = useVimMode as Mock;
138 |   const mockedUseSessionStats = useSessionStats as Mock;
139 |   const mockedUseTextBuffer = useTextBuffer as Mock;
140 |   const mockedUseLogger = useLogger as Mock;
141 |   const mockedUseLoadingIndicator = useLoadingIndicator as Mock;
142 | 
143 |   beforeEach(() => {
144 |     vi.clearAllMocks();
145 | 
146 |     // Initialize mock stdout for terminal title tests
147 |     mockStdout = { write: vi.fn() };
148 | 
149 |     // Mock computeWindowTitle function to centralize title logic testing
150 |     vi.mock('../utils/windowTitle.js', async () => ({
151 |       computeWindowTitle: vi.fn(
152 |         (folderName: string) =>
153 |           // Default behavior: return "Gemini - {folderName}" unless CLI_TITLE is set
154 |           process.env['CLI_TITLE'] || `Gemini - ${folderName}`,
155 |       ),
156 |     }));
157 | 
158 |     capturedUIState = null!;
159 |     capturedUIActions = null!;
160 | 
161 |     // **Provide a default return value for EVERY mocked hook.**
162 |     mockedUseQuotaAndFallback.mockReturnValue({
163 |       proQuotaRequest: null,
164 |       handleProQuotaChoice: vi.fn(),
165 |     });
166 |     mockedUseHistory.mockReturnValue({
167 |       history: [],
168 |       addItem: vi.fn(),
169 |       updateItem: vi.fn(),
170 |       clearItems: vi.fn(),
171 |       loadHistory: vi.fn(),
172 |     });
173 |     mockedUseThemeCommand.mockReturnValue({
174 |       isThemeDialogOpen: false,
175 |       openThemeDialog: vi.fn(),
176 |       handleThemeSelect: vi.fn(),
177 |       handleThemeHighlight: vi.fn(),
178 |     });
179 |     mockedUseAuthCommand.mockReturnValue({
180 |       authState: 'authenticated',
181 |       setAuthState: vi.fn(),
182 |       authError: null,
183 |       onAuthError: vi.fn(),
184 |     });
185 |     mockedUseEditorSettings.mockReturnValue({
186 |       isEditorDialogOpen: false,
187 |       openEditorDialog: vi.fn(),
188 |       handleEditorSelect: vi.fn(),
189 |       exitEditorDialog: vi.fn(),
190 |     });
191 |     mockedUseSettingsCommand.mockReturnValue({
192 |       isSettingsDialogOpen: false,
193 |       openSettingsDialog: vi.fn(),
194 |       closeSettingsDialog: vi.fn(),
195 |     });
196 |     mockedUseModelCommand.mockReturnValue({
197 |       isModelDialogOpen: false,
198 |       openModelDialog: vi.fn(),
199 |       closeModelDialog: vi.fn(),
200 |     });
201 |     mockedUseSlashCommandProcessor.mockReturnValue({
202 |       handleSlashCommand: vi.fn(),
203 |       slashCommands: [],
204 |       pendingHistoryItems: [],
205 |       commandContext: {},
206 |       shellConfirmationRequest: null,
207 |       confirmationRequest: null,
208 |     });
209 |     mockedUseConsoleMessages.mockReturnValue({
210 |       consoleMessages: [],
211 |       handleNewMessage: vi.fn(),
212 |       clearConsoleMessages: vi.fn(),
213 |     });
214 |     mockedUseGeminiStream.mockReturnValue({
215 |       streamingState: 'idle',
216 |       submitQuery: vi.fn(),
217 |       initError: null,
218 |       pendingHistoryItems: [],
219 |       thought: null,
220 |       cancelOngoingRequest: vi.fn(),
221 |     });
222 |     mockedUseVim.mockReturnValue({ handleInput: vi.fn() });
223 |     mockedUseFolderTrust.mockReturnValue({
224 |       isFolderTrustDialogOpen: false,
225 |       handleFolderTrustSelect: vi.fn(),
226 |       isRestarting: false,
227 |     });
228 |     mockedUseIdeTrustListener.mockReturnValue({
229 |       needsRestart: false,
230 |       restartReason: 'NONE',
231 |     });
232 |     mockedUseMessageQueue.mockReturnValue({
233 |       messageQueue: [],
234 |       addMessage: vi.fn(),
235 |       clearQueue: vi.fn(),
236 |       getQueuedMessagesText: vi.fn().mockReturnValue(''),
237 |     });
238 |     mockedUseAutoAcceptIndicator.mockReturnValue(false);
239 |     mockedUseWorkspaceMigration.mockReturnValue({
240 |       showWorkspaceMigrationDialog: false,
241 |       workspaceExtensions: [],
242 |       onWorkspaceMigrationDialogOpen: vi.fn(),
243 |       onWorkspaceMigrationDialogClose: vi.fn(),
244 |     });
245 |     mockedUseGitBranchName.mockReturnValue('main');
246 |     mockedUseVimMode.mockReturnValue({
247 |       isVimEnabled: false,
248 |       toggleVimEnabled: vi.fn(),
249 |     });
250 |     mockedUseSessionStats.mockReturnValue({ stats: {} });
251 |     mockedUseTextBuffer.mockReturnValue({
252 |       text: '',
253 |       setText: vi.fn(),
254 |       // Add other properties if AppContainer uses them
255 |     });
256 |     mockedUseLogger.mockReturnValue({
257 |       getPreviousUserMessages: vi.fn().mockResolvedValue([]),
258 |     });
259 |     mockedUseLoadingIndicator.mockReturnValue({
260 |       elapsedTime: '0.0s',
261 |       currentLoadingPhrase: '',
262 |     });
263 | 
264 |     // Mock Config
265 |     mockConfig = makeFakeConfig();
266 | 
267 |     // Mock config's getTargetDir to return consistent workspace directory
268 |     vi.spyOn(mockConfig, 'getTargetDir').mockReturnValue('/test/workspace');
269 | 
270 |     // Mock LoadedSettings
271 |     mockSettings = {
272 |       merged: {
273 |         hideBanner: false,
274 |         hideFooter: false,
275 |         hideTips: false,
276 |         showMemoryUsage: false,
277 |         theme: 'default',
278 |         ui: {
279 |           showStatusInTitle: false,
280 |           hideWindowTitle: false,
281 |         },
282 |       },
283 |     } as unknown as LoadedSettings;
284 | 
285 |     // Mock InitializationResult
286 |     mockInitResult = {
287 |       themeError: null,
288 |       authError: null,
289 |       shouldOpenAuthDialog: false,
290 |       geminiMdFileCount: 0,
291 |     } as InitializationResult;
292 |   });
293 | 
294 |   afterEach(() => {
295 |     cleanup();
296 |   });
297 | 
298 |   describe('Basic Rendering', () => {
299 |     it('renders without crashing with minimal props', () => {
300 |       expect(() => {
301 |         render(
302 |           <AppContainer
303 |             config={mockConfig}
304 |             settings={mockSettings}
305 |             version="1.0.0"
306 |             initializationResult={mockInitResult}
307 |           />,
308 |         );
309 |       }).not.toThrow();
310 |     });
311 | 
312 |     it('renders with startup warnings', () => {
313 |       const startupWarnings = ['Warning 1', 'Warning 2'];
314 | 
315 |       expect(() => {
316 |         render(
317 |           <AppContainer
318 |             config={mockConfig}
319 |             settings={mockSettings}
320 |             startupWarnings={startupWarnings}
321 |             version="1.0.0"
322 |             initializationResult={mockInitResult}
323 |           />,
324 |         );
325 |       }).not.toThrow();
326 |     });
327 |   });
328 | 
329 |   describe('State Initialization', () => {
330 |     it('initializes with theme error from initialization result', () => {
331 |       const initResultWithError = {
332 |         ...mockInitResult,
333 |         themeError: 'Failed to load theme',
334 |       };
335 | 
336 |       expect(() => {
337 |         render(
338 |           <AppContainer
339 |             config={mockConfig}
340 |             settings={mockSettings}
341 |             version="1.0.0"
342 |             initializationResult={initResultWithError}
343 |           />,
344 |         );
345 |       }).not.toThrow();
346 |     });
347 | 
348 |     it('handles debug mode state', () => {
349 |       const debugConfig = makeFakeConfig();
350 |       vi.spyOn(debugConfig, 'getDebugMode').mockReturnValue(true);
351 | 
352 |       expect(() => {
353 |         render(
354 |           <AppContainer
355 |             config={debugConfig}
356 |             settings={mockSettings}
357 |             version="1.0.0"
358 |             initializationResult={mockInitResult}
359 |           />,
360 |         );
361 |       }).not.toThrow();
362 |     });
363 |   });
364 | 
365 |   describe('Context Providers', () => {
366 |     it('provides AppContext with correct values', () => {
367 |       const { unmount } = render(
368 |         <AppContainer
369 |           config={mockConfig}
370 |           settings={mockSettings}
371 |           version="2.0.0"
372 |           initializationResult={mockInitResult}
373 |         />,
374 |       );
375 | 
376 |       // Should render and unmount cleanly
377 |       expect(() => unmount()).not.toThrow();
378 |     });
379 | 
380 |     it('provides UIStateContext with state management', () => {
381 |       expect(() => {
382 |         render(
383 |           <AppContainer
384 |             config={mockConfig}
385 |             settings={mockSettings}
[TRUNCATED]
```

src/ui/AppContainer.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import {
8 |   useMemo,
9 |   useState,
10 |   useCallback,
11 |   useEffect,
12 |   useRef,
13 |   useLayoutEffect,
14 | } from 'react';
15 | import { type DOMElement, measureElement } from 'ink';
16 | import { App } from './App.js';
17 | import { AppContext } from './contexts/AppContext.js';
18 | import { UIStateContext, type UIState } from './contexts/UIStateContext.js';
19 | import {
20 |   UIActionsContext,
21 |   type UIActions,
22 | } from './contexts/UIActionsContext.js';
23 | import { ConfigContext } from './contexts/ConfigContext.js';
24 | import {
25 |   type HistoryItem,
26 |   ToolCallStatus,
27 |   type HistoryItemWithoutId,
28 |   AuthState,
29 | } from './types.js';
30 | import { MessageType, StreamingState } from './types.js';
31 | import {
32 |   type EditorType,
33 |   type Config,
34 |   type IdeInfo,
35 |   type IdeContext,
36 |   type UserTierId,
37 |   DEFAULT_GEMINI_FLASH_MODEL,
38 |   IdeClient,
39 |   ideContextStore,
40 |   getErrorMessage,
41 |   getAllGeminiMdFilenames,
42 |   AuthType,
43 |   clearCachedCredentialFile,
44 |   ShellExecutionService,
45 | } from '@google/gemini-cli-core';
46 | import { validateAuthMethod } from '../config/auth.js';
47 | import { loadHierarchicalGeminiMemory } from '../config/config.js';
48 | import process from 'node:process';
49 | import { useHistory } from './hooks/useHistoryManager.js';
50 | import { useMemoryMonitor } from './hooks/useMemoryMonitor.js';
51 | import { useThemeCommand } from './hooks/useThemeCommand.js';
52 | import { useAuthCommand } from './auth/useAuth.js';
53 | import { useQuotaAndFallback } from './hooks/useQuotaAndFallback.js';
54 | import { useEditorSettings } from './hooks/useEditorSettings.js';
55 | import { useSettingsCommand } from './hooks/useSettingsCommand.js';
56 | import { useModelCommand } from './hooks/useModelCommand.js';
57 | import { useSlashCommandProcessor } from './hooks/slashCommandProcessor.js';
58 | import { useVimMode } from './contexts/VimModeContext.js';
59 | import { useConsoleMessages } from './hooks/useConsoleMessages.js';
60 | import { useTerminalSize } from './hooks/useTerminalSize.js';
61 | import { calculatePromptWidths } from './components/InputPrompt.js';
62 | import { useStdout, useStdin } from 'ink';
63 | import { calculateMainAreaWidth } from './utils/ui-sizing.js';
64 | import ansiEscapes from 'ansi-escapes';
65 | import * as fs from 'node:fs';
66 | import { basename } from 'node:path';
67 | import { computeWindowTitle } from '../utils/windowTitle.js';
68 | import { useTextBuffer } from './components/shared/text-buffer.js';
69 | import { useLogger } from './hooks/useLogger.js';
70 | import { useGeminiStream } from './hooks/useGeminiStream.js';
71 | import { useVim } from './hooks/vim.js';
72 | import { type LoadedSettings, SettingScope } from '../config/settings.js';
73 | import { type InitializationResult } from '../core/initializer.js';
74 | import { useFocus } from './hooks/useFocus.js';
75 | import { useBracketedPaste } from './hooks/useBracketedPaste.js';
76 | import { useKeypress, type Key } from './hooks/useKeypress.js';
77 | import { keyMatchers, Command } from './keyMatchers.js';
78 | import { useLoadingIndicator } from './hooks/useLoadingIndicator.js';
79 | import { useFolderTrust } from './hooks/useFolderTrust.js';
80 | import { useIdeTrustListener } from './hooks/useIdeTrustListener.js';
81 | import { type IdeIntegrationNudgeResult } from './IdeIntegrationNudge.js';
82 | import { appEvents, AppEvent } from '../utils/events.js';
83 | import { type UpdateObject } from './utils/updateCheck.js';
84 | import { setUpdateHandler } from '../utils/handleAutoUpdate.js';
85 | import { ConsolePatcher } from './utils/ConsolePatcher.js';
86 | import { registerCleanup, runExitCleanup } from '../utils/cleanup.js';
87 | import { useMessageQueue } from './hooks/useMessageQueue.js';
88 | import { useAutoAcceptIndicator } from './hooks/useAutoAcceptIndicator.js';
89 | import { useWorkspaceMigration } from './hooks/useWorkspaceMigration.js';
90 | import { useSessionStats } from './contexts/SessionContext.js';
91 | import { useGitBranchName } from './hooks/useGitBranchName.js';
92 | import { useExtensionUpdates } from './hooks/useExtensionUpdates.js';
93 | import { ShellFocusContext } from './contexts/ShellFocusContext.js';
94 | 
95 | const CTRL_EXIT_PROMPT_DURATION_MS = 1000;
96 | 
97 | function isToolExecuting(pendingHistoryItems: HistoryItemWithoutId[]) {
98 |   return pendingHistoryItems.some((item) => {
99 |     if (item && item.type === 'tool_group') {
100 |       return item.tools.some(
101 |         (tool) => ToolCallStatus.Executing === tool.status,
102 |       );
103 |     }
104 |     return false;
105 |   });
106 | }
107 | 
108 | interface AppContainerProps {
109 |   config: Config;
110 |   settings: LoadedSettings;
111 |   startupWarnings?: string[];
112 |   version: string;
113 |   initializationResult: InitializationResult;
114 | }
115 | 
116 | /**
117 |  * The fraction of the terminal width to allocate to the shell.
118 |  * This provides horizontal padding.
119 |  */
120 | const SHELL_WIDTH_FRACTION = 0.89;
121 | 
122 | /**
123 |  * The number of lines to subtract from the available terminal height
124 |  * for the shell. This provides vertical padding and space for other UI elements.
125 |  */
126 | const SHELL_HEIGHT_PADDING = 10;
127 | 
128 | export const AppContainer = (props: AppContainerProps) => {
129 |   const { settings, config, initializationResult } = props;
130 |   const historyManager = useHistory();
131 |   useMemoryMonitor(historyManager);
132 |   const [corgiMode, setCorgiMode] = useState(false);
133 |   const [debugMessage, setDebugMessage] = useState<string>('');
134 |   const [quittingMessages, setQuittingMessages] = useState<
135 |     HistoryItem[] | null
136 |   >(null);
137 |   const [showPrivacyNotice, setShowPrivacyNotice] = useState<boolean>(false);
138 |   const [themeError, setThemeError] = useState<string | null>(
139 |     initializationResult.themeError,
140 |   );
141 |   const [isProcessing, setIsProcessing] = useState<boolean>(false);
142 |   const [embeddedShellFocused, setEmbeddedShellFocused] = useState(false);
143 |   const [showDebugProfiler, setShowDebugProfiler] = useState(false);
144 | 
145 |   const [geminiMdFileCount, setGeminiMdFileCount] = useState<number>(
146 |     initializationResult.geminiMdFileCount,
147 |   );
148 |   const [shellModeActive, setShellModeActive] = useState(false);
149 |   const [modelSwitchedFromQuotaError, setModelSwitchedFromQuotaError] =
150 |     useState<boolean>(false);
151 |   const [historyRemountKey, setHistoryRemountKey] = useState(0);
152 |   const [updateInfo, setUpdateInfo] = useState<UpdateObject | null>(null);
153 |   const [isTrustedFolder, setIsTrustedFolder] = useState<boolean | undefined>(
154 |     config.isTrustedFolder(),
155 |   );
156 | 
157 |   const extensions = config.getExtensions();
158 |   const {
159 |     extensionsUpdateState,
160 |     extensionsUpdateStateInternal,
161 |     dispatchExtensionStateUpdate,
162 |     confirmUpdateExtensionRequests,
163 |     addConfirmUpdateExtensionRequest,
164 |   } = useExtensionUpdates(
165 |     extensions,
166 |     historyManager.addItem,
167 |     config.getWorkingDir(),
168 |   );
169 | 
170 |   const [isPermissionsDialogOpen, setPermissionsDialogOpen] = useState(false);
171 |   const openPermissionsDialog = useCallback(
172 |     () => setPermissionsDialogOpen(true),
173 |     [],
174 |   );
175 |   const closePermissionsDialog = useCallback(
176 |     () => setPermissionsDialogOpen(false),
177 |     [],
178 |   );
179 | 
180 |   const toggleDebugProfiler = useCallback(
181 |     () => setShowDebugProfiler((prev) => !prev),
182 |     [],
183 |   );
184 | 
185 |   // Helper to determine the effective model, considering the fallback state.
186 |   const getEffectiveModel = useCallback(() => {
187 |     if (config.isInFallbackMode()) {
188 |       return DEFAULT_GEMINI_FLASH_MODEL;
189 |     }
190 |     return config.getModel();
191 |   }, [config]);
192 | 
193 |   const [currentModel, setCurrentModel] = useState(getEffectiveModel());
194 | 
195 |   const [userTier, setUserTier] = useState<UserTierId | undefined>(undefined);
196 | 
197 |   const [isConfigInitialized, setConfigInitialized] = useState(false);
198 | 
199 |   const logger = useLogger(config.storage);
200 |   const [userMessages, setUserMessages] = useState<string[]>([]);
201 | 
202 |   // Terminal and layout hooks
203 |   const { columns: terminalWidth, rows: terminalHeight } = useTerminalSize();
204 |   const { stdin, setRawMode } = useStdin();
205 |   const { stdout } = useStdout();
206 | 
207 |   // Additional hooks moved from App.tsx
208 |   const { stats: sessionStats } = useSessionStats();
209 |   const branchName = useGitBranchName(config.getTargetDir());
210 | 
211 |   // Layout measurements
212 |   const mainControlsRef = useRef<DOMElement>(null);
213 |   // For performance profiling only
214 |   const rootUiRef = useRef<DOMElement>(null);
215 |   const originalTitleRef = useRef(
216 |     computeWindowTitle(basename(config.getTargetDir())),
217 |   );
218 |   const lastTitleRef = useRef<string | null>(null);
219 |   const staticExtraHeight = 3;
220 | 
221 |   useEffect(() => {
222 |     (async () => {
223 |       // Note: the program will not work if this fails so let errors be
224 |       // handled by the global catch.
225 |       await config.initialize();
226 |       setConfigInitialized(true);
227 |     })();
228 |     registerCleanup(async () => {
229 |       const ideClient = await IdeClient.getInstance();
230 |       await ideClient.disconnect();
231 |     });
232 |   }, [config]);
233 | 
234 |   useEffect(
235 |     () => setUpdateHandler(historyManager.addItem, setUpdateInfo),
236 |     [historyManager.addItem],
237 |   );
238 | 
239 |   // Watch for model changes (e.g., from Flash fallback)
240 |   useEffect(() => {
241 |     const checkModelChange = () => {
242 |       const effectiveModel = getEffectiveModel();
243 |       if (effectiveModel !== currentModel) {
244 |         setCurrentModel(effectiveModel);
245 |       }
246 |     };
247 | 
248 |     checkModelChange();
249 |     const interval = setInterval(checkModelChange, 1000); // Check every second
250 | 
251 |     return () => clearInterval(interval);
252 |   }, [config, currentModel, getEffectiveModel]);
253 | 
254 |   const {
255 |     consoleMessages,
256 |     handleNewMessage,
257 |     clearConsoleMessages: clearConsoleMessagesState,
258 |   } = useConsoleMessages();
259 | 
260 |   useEffect(() => {
261 |     const consolePatcher = new ConsolePatcher({
262 |       onNewMessage: handleNewMessage,
263 |       debugMode: config.getDebugMode(),
264 |     });
265 |     consolePatcher.patch();
266 |     registerCleanup(consolePatcher.cleanup);
267 |   }, [handleNewMessage, config]);
268 | 
269 |   const mainAreaWidth = calculateMainAreaWidth(terminalWidth, settings);
270 |   // Derive widths for InputPrompt using shared helper
271 |   const { inputWidth, suggestionsWidth } = useMemo(() => {
272 |     const { inputWidth, suggestionsWidth } =
273 |       calculatePromptWidths(mainAreaWidth);
274 |     return { inputWidth, suggestionsWidth };
275 |   }, [mainAreaWidth]);
276 | 
277 |   const staticAreaMaxItemHeight = Math.max(terminalHeight * 4, 100);
278 | 
279 |   const isValidPath = useCallback((filePath: string): boolean => {
280 |     try {
281 |       return fs.existsSync(filePath) && fs.statSync(filePath).isFile();
282 |     } catch (_e) {
283 |       return false;
284 |     }
285 |   }, []);
286 | 
287 |   const buffer = useTextBuffer({
288 |     initialText: '',
289 |     viewport: { height: 10, width: inputWidth },
290 |     stdin,
291 |     setRawMode,
292 |     isValidPath,
293 |     shellModeActive,
294 |   });
295 | 
296 |   useEffect(() => {
297 |     const fetchUserMessages = async () => {
298 |       const pastMessagesRaw = (await logger?.getPreviousUserMessages()) || [];
299 |       const currentSessionUserMessages = historyManager.history
300 |         .filter(
301 |           (item): item is HistoryItem & { type: 'user'; text: string } =>
302 |             item.type === 'user' &&
303 |             typeof item.text === 'string' &&
304 |             item.text.trim() !== '',
305 |         )
306 |         .map((item) => item.text)
307 |         .reverse();
308 |       const combinedMessages = [
309 |         ...currentSessionUserMessages,
310 |         ...pastMessagesRaw,
311 |       ];
312 |       const deduplicatedMessages: string[] = [];
313 |       if (combinedMessages.length > 0) {
314 |         deduplicatedMessages.push(combinedMessages[0]);
315 |         for (let i = 1; i < combinedMessages.length; i++) {
316 |           if (combinedMessages[i] !== combinedMessages[i - 1]) {
317 |             deduplicatedMessages.push(combinedMessages[i]);
318 |           }
319 |         }
320 |       }
321 |       setUserMessages(deduplicatedMessages.reverse());
322 |     };
323 |     fetchUserMessages();
324 |   }, [historyManager.history, logger]);
325 | 
326 |   const refreshStatic = useCallback(() => {
327 |     stdout.write(ansiEscapes.clearTerminal);
328 |     setHistoryRemountKey((prev) => prev + 1);
329 |   }, [setHistoryRemountKey, stdout]);
330 | 
331 |   const {
332 |     isThemeDialogOpen,
333 |     openThemeDialog,
334 |     handleThemeSelect,
335 |     handleThemeHighlight,
336 |   } = useThemeCommand(
337 |     settings,
338 |     setThemeError,
339 |     historyManager.addItem,
340 |     initializationResult.themeError,
341 |   );
342 | 
343 |   const { authState, setAuthState, authError, onAuthError } = useAuthCommand(
344 |     settings,
345 |     config,
346 |   );
347 | 
348 |   const { proQuotaRequest, handleProQuotaChoice } = useQuotaAndFallback({
349 |     config,
350 |     historyManager,
351 |     userTier,
352 |     setAuthState,
353 |     setModelSwitchedFromQuotaError,
354 |   });
355 | 
356 |   // Derive auth state variables for backward compatibility with UIStateContext
357 |   const isAuthDialogOpen = authState === AuthState.Updating;
358 |   const isAuthenticating = authState === AuthState.Unauthenticated;
359 | 
360 |   // Create handleAuthSelect wrapper for backward compatibility
361 |   const handleAuthSelect = useCallback(
362 |     async (authType: AuthType | undefined, scope: SettingScope) => {
363 |       if (authType) {
364 |         await clearCachedCredentialFile();
365 |         settings.setValue(scope, 'security.auth.selectedType', authType);
366 | 
367 |         try {
368 |           await config.refreshAuth(authType);
[TRUNCATED]
```

src/ui/IdeIntegrationNudge.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type { IdeInfo } from '@google/gemini-cli-core';
8 | import { Box, Text } from 'ink';
9 | import type { RadioSelectItem } from './components/shared/RadioButtonSelect.js';
10 | import { RadioButtonSelect } from './components/shared/RadioButtonSelect.js';
11 | import { useKeypress } from './hooks/useKeypress.js';
12 | import { theme } from './semantic-colors.js';
13 | 
14 | export type IdeIntegrationNudgeResult = {
15 |   userSelection: 'yes' | 'no' | 'dismiss';
16 |   isExtensionPreInstalled: boolean;
17 | };
18 | 
19 | interface IdeIntegrationNudgeProps {
20 |   ide: IdeInfo;
21 |   onComplete: (result: IdeIntegrationNudgeResult) => void;
22 | }
23 | 
24 | export function IdeIntegrationNudge({
25 |   ide,
26 |   onComplete,
27 | }: IdeIntegrationNudgeProps) {
28 |   useKeypress(
29 |     (key) => {
30 |       if (key.name === 'escape') {
31 |         onComplete({
32 |           userSelection: 'no',
33 |           isExtensionPreInstalled: false,
34 |         });
35 |       }
36 |     },
37 |     { isActive: true },
38 |   );
39 | 
40 |   const { displayName: ideName } = ide;
41 |   // Assume extension is already installed if the env variables are set.
42 |   const isExtensionPreInstalled =
43 |     !!process.env['GEMINI_CLI_IDE_SERVER_PORT'] &&
44 |     !!process.env['GEMINI_CLI_IDE_WORKSPACE_PATH'];
45 | 
46 |   const OPTIONS: Array<RadioSelectItem<IdeIntegrationNudgeResult>> = [
47 |     {
48 |       label: 'Yes',
49 |       value: {
50 |         userSelection: 'yes',
51 |         isExtensionPreInstalled,
52 |       },
53 |       key: 'Yes',
54 |     },
55 |     {
56 |       label: 'No (esc)',
57 |       value: {
58 |         userSelection: 'no',
59 |         isExtensionPreInstalled,
60 |       },
61 |       key: 'No (esc)',
62 |     },
63 |     {
64 |       label: "No, don't ask again",
65 |       value: {
66 |         userSelection: 'dismiss',
67 |         isExtensionPreInstalled,
68 |       },
69 |       key: "No, don't ask again",
70 |     },
71 |   ];
72 | 
73 |   const installText = isExtensionPreInstalled
74 |     ? `If you select Yes, the CLI will have access to your open files and display diffs directly in ${
75 |         ideName ?? 'your editor'
76 |       }.`
77 |     : `If you select Yes, we'll install an extension that allows the CLI to access your open files and display diffs directly in ${
78 |         ideName ?? 'your editor'
79 |       }.`;
80 | 
81 |   return (
82 |     <Box
83 |       flexDirection="column"
84 |       borderStyle="round"
85 |       borderColor={theme.status.warning}
86 |       padding={1}
87 |       width="100%"
88 |       marginLeft={1}
89 |     >
90 |       <Box marginBottom={1} flexDirection="column">
91 |         <Text>
92 |           <Text color={theme.status.warning}>{'> '}</Text>
93 |           {`Do you want to connect ${ideName ?? 'your editor'} to Gemini CLI?`}
94 |         </Text>
95 |         <Text color={theme.text.secondary}>{installText}</Text>
96 |       </Box>
97 |       <RadioButtonSelect items={OPTIONS} onSelect={onComplete} />
98 |     </Box>
99 |   );
100 | }
```

src/ui/colors.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { themeManager } from './themes/theme-manager.js';
8 | import type { ColorsTheme } from './themes/theme.js';
9 | 
10 | export const Colors: ColorsTheme = {
11 |   get type() {
12 |     return themeManager.getActiveTheme().colors.type;
13 |   },
14 |   get Foreground() {
15 |     return themeManager.getActiveTheme().colors.Foreground;
16 |   },
17 |   get Background() {
18 |     return themeManager.getActiveTheme().colors.Background;
19 |   },
20 |   get LightBlue() {
21 |     return themeManager.getActiveTheme().colors.LightBlue;
22 |   },
23 |   get AccentBlue() {
24 |     return themeManager.getActiveTheme().colors.AccentBlue;
25 |   },
26 |   get AccentPurple() {
27 |     return themeManager.getActiveTheme().colors.AccentPurple;
28 |   },
29 |   get AccentCyan() {
30 |     return themeManager.getActiveTheme().colors.AccentCyan;
31 |   },
32 |   get AccentGreen() {
33 |     return themeManager.getActiveTheme().colors.AccentGreen;
34 |   },
35 |   get AccentYellow() {
36 |     return themeManager.getActiveTheme().colors.AccentYellow;
37 |   },
38 |   get AccentRed() {
39 |     return themeManager.getActiveTheme().colors.AccentRed;
40 |   },
41 |   get DiffAdded() {
42 |     return themeManager.getActiveTheme().colors.DiffAdded;
43 |   },
44 |   get DiffRemoved() {
45 |     return themeManager.getActiveTheme().colors.DiffRemoved;
46 |   },
47 |   get Comment() {
48 |     return themeManager.getActiveTheme().colors.Comment;
49 |   },
50 |   get Gray() {
51 |     return themeManager.getActiveTheme().colors.Gray;
52 |   },
53 |   get GradientColors() {
54 |     return themeManager.getActiveTheme().colors.GradientColors;
55 |   },
56 | };
```

src/ui/constants.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | const EstimatedArtWidth = 59;
8 | const BoxBorderWidth = 1;
9 | export const BOX_PADDING_X = 1;
10 | 
11 | // Calculate width based on art, padding, and border
12 | export const UI_WIDTH =
13 |   EstimatedArtWidth + BOX_PADDING_X * 2 + BoxBorderWidth * 2; // ~63
14 | 
15 | export const STREAM_DEBOUNCE_MS = 100;
16 | 
17 | export const SHELL_COMMAND_NAME = 'Shell Command';
18 | 
19 | export const SHELL_NAME = 'Shell';
20 | 
21 | // Tool status symbols used in ToolMessage component
22 | export const TOOL_STATUS = {
23 |   SUCCESS: '✓',
24 |   PENDING: 'o',
25 |   EXECUTING: '⊷',
26 |   CONFIRMING: '?',
27 |   CANCELED: '-',
28 |   ERROR: 'x',
29 | } as const;
```

src/ui/keyMatchers.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect } from 'vitest';
8 | import { keyMatchers, Command, createKeyMatchers } from './keyMatchers.js';
9 | import type { KeyBindingConfig } from '../config/keyBindings.js';
10 | import { defaultKeyBindings } from '../config/keyBindings.js';
11 | import type { Key } from './hooks/useKeypress.js';
12 | 
13 | describe('keyMatchers', () => {
14 |   const createKey = (name: string, mods: Partial<Key> = {}): Key => ({
15 |     name,
16 |     ctrl: false,
17 |     meta: false,
18 |     shift: false,
19 |     paste: false,
20 |     sequence: name,
21 |     ...mods,
22 |   });
23 | 
24 |   // Original hard-coded logic (for comparison)
25 |   const originalMatchers: Record<Command, (key: Key) => boolean> = {
26 |     [Command.RETURN]: (key: Key) => key.name === 'return',
27 |     [Command.HOME]: (key: Key) => key.ctrl && key.name === 'a',
28 |     [Command.END]: (key: Key) => key.ctrl && key.name === 'e',
29 |     [Command.KILL_LINE_RIGHT]: (key: Key) => key.ctrl && key.name === 'k',
30 |     [Command.KILL_LINE_LEFT]: (key: Key) => key.ctrl && key.name === 'u',
31 |     [Command.CLEAR_INPUT]: (key: Key) => key.ctrl && key.name === 'c',
32 |     [Command.DELETE_WORD_BACKWARD]: (key: Key) =>
33 |       (key.ctrl || key.meta) && key.name === 'backspace',
34 |     [Command.CLEAR_SCREEN]: (key: Key) => key.ctrl && key.name === 'l',
35 |     [Command.HISTORY_UP]: (key: Key) => key.ctrl && key.name === 'p',
36 |     [Command.HISTORY_DOWN]: (key: Key) => key.ctrl && key.name === 'n',
37 |     [Command.NAVIGATION_UP]: (key: Key) => key.name === 'up',
38 |     [Command.NAVIGATION_DOWN]: (key: Key) => key.name === 'down',
39 |     [Command.ACCEPT_SUGGESTION]: (key: Key) =>
40 |       key.name === 'tab' || (key.name === 'return' && !key.ctrl),
41 |     [Command.COMPLETION_UP]: (key: Key) =>
42 |       key.name === 'up' || (key.ctrl && key.name === 'p'),
43 |     [Command.COMPLETION_DOWN]: (key: Key) =>
44 |       key.name === 'down' || (key.ctrl && key.name === 'n'),
45 |     [Command.ESCAPE]: (key: Key) => key.name === 'escape',
46 |     [Command.SUBMIT]: (key: Key) =>
47 |       key.name === 'return' && !key.ctrl && !key.meta && !key.paste,
48 |     [Command.NEWLINE]: (key: Key) =>
49 |       key.name === 'return' && (key.ctrl || key.meta || key.paste),
50 |     [Command.OPEN_EXTERNAL_EDITOR]: (key: Key) =>
51 |       key.ctrl && (key.name === 'x' || key.sequence === '\x18'),
52 |     [Command.PASTE_CLIPBOARD_IMAGE]: (key: Key) => key.ctrl && key.name === 'v',
53 |     [Command.SHOW_ERROR_DETAILS]: (key: Key) => key.ctrl && key.name === 'o',
54 |     [Command.TOGGLE_TOOL_DESCRIPTIONS]: (key: Key) =>
55 |       key.ctrl && key.name === 't',
56 |     [Command.TOGGLE_IDE_CONTEXT_DETAIL]: (key: Key) =>
57 |       key.ctrl && key.name === 'g',
58 |     [Command.QUIT]: (key: Key) => key.ctrl && key.name === 'c',
59 |     [Command.EXIT]: (key: Key) => key.ctrl && key.name === 'd',
60 |     [Command.SHOW_MORE_LINES]: (key: Key) => key.ctrl && key.name === 's',
61 |     [Command.REVERSE_SEARCH]: (key: Key) => key.ctrl && key.name === 'r',
62 |     [Command.SUBMIT_REVERSE_SEARCH]: (key: Key) =>
63 |       key.name === 'return' && !key.ctrl,
64 |     [Command.ACCEPT_SUGGESTION_REVERSE_SEARCH]: (key: Key) =>
65 |       key.name === 'tab',
66 |     [Command.TOGGLE_SHELL_INPUT_FOCUS]: (key: Key) =>
67 |       key.ctrl && key.name === 'f',
68 |     [Command.EXPAND_SUGGESTION]: (key: Key) => key.name === 'right',
69 |     [Command.COLLAPSE_SUGGESTION]: (key: Key) => key.name === 'left',
70 |   };
71 | 
72 |   // Test data for each command with positive and negative test cases
73 |   const testCases = [
74 |     // Basic bindings
75 |     {
76 |       command: Command.RETURN,
77 |       positive: [createKey('return')],
78 |       negative: [createKey('r')],
79 |     },
80 |     {
81 |       command: Command.ESCAPE,
82 |       positive: [createKey('escape'), createKey('escape', { ctrl: true })],
83 |       negative: [createKey('e'), createKey('esc')],
84 |     },
85 | 
86 |     // Cursor movement
87 |     {
88 |       command: Command.HOME,
89 |       positive: [createKey('a', { ctrl: true })],
90 |       negative: [
91 |         createKey('a'),
92 |         createKey('a', { shift: true }),
93 |         createKey('b', { ctrl: true }),
94 |       ],
95 |     },
96 |     {
97 |       command: Command.END,
98 |       positive: [createKey('e', { ctrl: true })],
99 |       negative: [
100 |         createKey('e'),
101 |         createKey('e', { shift: true }),
102 |         createKey('a', { ctrl: true }),
103 |       ],
104 |     },
105 | 
106 |     // Text deletion
107 |     {
108 |       command: Command.KILL_LINE_RIGHT,
109 |       positive: [createKey('k', { ctrl: true })],
110 |       negative: [createKey('k'), createKey('l', { ctrl: true })],
111 |     },
112 |     {
113 |       command: Command.KILL_LINE_LEFT,
114 |       positive: [createKey('u', { ctrl: true })],
115 |       negative: [createKey('u'), createKey('k', { ctrl: true })],
116 |     },
117 |     {
118 |       command: Command.CLEAR_INPUT,
119 |       positive: [createKey('c', { ctrl: true })],
120 |       negative: [createKey('c'), createKey('k', { ctrl: true })],
121 |     },
122 |     {
123 |       command: Command.DELETE_WORD_BACKWARD,
124 |       positive: [
125 |         createKey('backspace', { ctrl: true }),
126 |         createKey('backspace', { meta: true }),
127 |       ],
128 |       negative: [createKey('backspace'), createKey('delete', { ctrl: true })],
129 |     },
130 | 
131 |     // Screen control
132 |     {
133 |       command: Command.CLEAR_SCREEN,
134 |       positive: [createKey('l', { ctrl: true })],
135 |       negative: [createKey('l'), createKey('k', { ctrl: true })],
136 |     },
137 | 
138 |     // History navigation
139 |     {
140 |       command: Command.HISTORY_UP,
141 |       positive: [createKey('p', { ctrl: true })],
142 |       negative: [createKey('p'), createKey('up')],
143 |     },
144 |     {
145 |       command: Command.HISTORY_DOWN,
146 |       positive: [createKey('n', { ctrl: true })],
147 |       negative: [createKey('n'), createKey('down')],
148 |     },
149 |     {
150 |       command: Command.NAVIGATION_UP,
151 |       positive: [createKey('up'), createKey('up', { ctrl: true })],
152 |       negative: [createKey('p'), createKey('u')],
153 |     },
154 |     {
155 |       command: Command.NAVIGATION_DOWN,
156 |       positive: [createKey('down'), createKey('down', { ctrl: true })],
157 |       negative: [createKey('n'), createKey('d')],
158 |     },
159 | 
160 |     // Auto-completion
161 |     {
162 |       command: Command.ACCEPT_SUGGESTION,
163 |       positive: [createKey('tab'), createKey('return')],
164 |       negative: [createKey('return', { ctrl: true }), createKey('space')],
165 |     },
166 |     {
167 |       command: Command.COMPLETION_UP,
168 |       positive: [createKey('up'), createKey('p', { ctrl: true })],
169 |       negative: [createKey('p'), createKey('down')],
170 |     },
171 |     {
172 |       command: Command.COMPLETION_DOWN,
173 |       positive: [createKey('down'), createKey('n', { ctrl: true })],
174 |       negative: [createKey('n'), createKey('up')],
175 |     },
176 | 
177 |     // Text input
178 |     {
179 |       command: Command.SUBMIT,
180 |       positive: [createKey('return')],
181 |       negative: [
182 |         createKey('return', { ctrl: true }),
183 |         createKey('return', { meta: true }),
184 |         createKey('return', { paste: true }),
185 |       ],
186 |     },
187 |     {
188 |       command: Command.NEWLINE,
189 |       positive: [
190 |         createKey('return', { ctrl: true }),
191 |         createKey('return', { meta: true }),
192 |         createKey('return', { paste: true }),
193 |       ],
194 |       negative: [createKey('return'), createKey('n')],
195 |     },
196 | 
197 |     // External tools
198 |     {
199 |       command: Command.OPEN_EXTERNAL_EDITOR,
200 |       positive: [
201 |         createKey('x', { ctrl: true }),
202 |         { ...createKey('\x18'), sequence: '\x18', ctrl: true },
203 |       ],
204 |       negative: [createKey('x'), createKey('c', { ctrl: true })],
205 |     },
206 |     {
207 |       command: Command.PASTE_CLIPBOARD_IMAGE,
208 |       positive: [createKey('v', { ctrl: true })],
209 |       negative: [createKey('v'), createKey('c', { ctrl: true })],
210 |     },
211 | 
212 |     // App level bindings
213 |     {
214 |       command: Command.SHOW_ERROR_DETAILS,
215 |       positive: [createKey('o', { ctrl: true })],
216 |       negative: [createKey('o'), createKey('e', { ctrl: true })],
217 |     },
218 |     {
219 |       command: Command.TOGGLE_TOOL_DESCRIPTIONS,
220 |       positive: [createKey('t', { ctrl: true })],
221 |       negative: [createKey('t'), createKey('s', { ctrl: true })],
222 |     },
223 |     {
224 |       command: Command.TOGGLE_IDE_CONTEXT_DETAIL,
225 |       positive: [createKey('g', { ctrl: true })],
226 |       negative: [createKey('g'), createKey('t', { ctrl: true })],
227 |     },
228 |     {
229 |       command: Command.QUIT,
230 |       positive: [createKey('c', { ctrl: true })],
231 |       negative: [createKey('c'), createKey('d', { ctrl: true })],
232 |     },
233 |     {
234 |       command: Command.EXIT,
235 |       positive: [createKey('d', { ctrl: true })],
236 |       negative: [createKey('d'), createKey('c', { ctrl: true })],
237 |     },
238 |     {
239 |       command: Command.SHOW_MORE_LINES,
240 |       positive: [createKey('s', { ctrl: true })],
241 |       negative: [createKey('s'), createKey('l', { ctrl: true })],
242 |     },
243 | 
244 |     // Shell commands
245 |     {
246 |       command: Command.REVERSE_SEARCH,
247 |       positive: [createKey('r', { ctrl: true })],
248 |       negative: [createKey('r'), createKey('s', { ctrl: true })],
249 |     },
250 |     {
251 |       command: Command.SUBMIT_REVERSE_SEARCH,
252 |       positive: [createKey('return')],
253 |       negative: [createKey('return', { ctrl: true }), createKey('tab')],
254 |     },
255 |     {
256 |       command: Command.ACCEPT_SUGGESTION_REVERSE_SEARCH,
257 |       positive: [createKey('tab'), createKey('tab', { ctrl: true })],
258 |       negative: [createKey('return'), createKey('space')],
259 |     },
260 |     {
261 |       command: Command.TOGGLE_SHELL_INPUT_FOCUS,
262 |       positive: [createKey('f', { ctrl: true })],
263 |       negative: [createKey('f')],
264 |     },
265 |   ];
266 | 
267 |   describe('Data-driven key binding matches original logic', () => {
268 |     testCases.forEach(({ command, positive, negative }) => {
269 |       it(`should match ${command} correctly`, () => {
270 |         positive.forEach((key) => {
271 |           expect(
272 |             keyMatchers[command](key),
273 |             `Expected ${command} to match ${JSON.stringify(key)}`,
274 |           ).toBe(true);
275 |           expect(
276 |             originalMatchers[command](key),
277 |             `Original matcher should also match ${JSON.stringify(key)}`,
278 |           ).toBe(true);
279 |         });
280 | 
281 |         negative.forEach((key) => {
282 |           expect(
283 |             keyMatchers[command](key),
284 |             `Expected ${command} to NOT match ${JSON.stringify(key)}`,
285 |           ).toBe(false);
286 |           expect(
287 |             originalMatchers[command](key),
288 |             `Original matcher should also NOT match ${JSON.stringify(key)}`,
289 |           ).toBe(false);
290 |         });
291 |       });
292 |     });
293 | 
294 |     it('should properly handle ACCEPT_SUGGESTION_REVERSE_SEARCH cases', () => {
295 |       expect(
296 |         keyMatchers[Command.ACCEPT_SUGGESTION_REVERSE_SEARCH](
297 |           createKey('return', { ctrl: true }),
298 |         ),
299 |       ).toBe(false); // ctrl must be false
300 |       expect(
301 |         keyMatchers[Command.ACCEPT_SUGGESTION_REVERSE_SEARCH](createKey('tab')),
302 |       ).toBe(true);
303 |       expect(
304 |         keyMatchers[Command.ACCEPT_SUGGESTION_REVERSE_SEARCH](
305 |           createKey('tab', { ctrl: true }),
306 |         ),
307 |       ).toBe(true); // modifiers ignored
308 |     });
309 |   });
310 | 
311 |   describe('Custom key bindings', () => {
312 |     it('should work with custom configuration', () => {
313 |       const customConfig: KeyBindingConfig = {
314 |         ...defaultKeyBindings,
315 |         [Command.HOME]: [{ key: 'h', ctrl: true }, { key: '0' }],
316 |       };
317 | 
318 |       const customMatchers = createKeyMatchers(customConfig);
319 | 
320 |       expect(customMatchers[Command.HOME](createKey('h', { ctrl: true }))).toBe(
321 |         true,
322 |       );
323 |       expect(customMatchers[Command.HOME](createKey('0'))).toBe(true);
324 |       expect(customMatchers[Command.HOME](createKey('a', { ctrl: true }))).toBe(
325 |         false,
326 |       );
327 |     });
328 | 
329 |     it('should support multiple key bindings for same command', () => {
330 |       const config: KeyBindingConfig = {
331 |         ...defaultKeyBindings,
332 |         [Command.QUIT]: [
[TRUNCATED]
```

src/ui/keyMatchers.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type { Key } from './hooks/useKeypress.js';
8 | import type { KeyBinding, KeyBindingConfig } from '../config/keyBindings.js';
9 | import { Command, defaultKeyBindings } from '../config/keyBindings.js';
10 | 
11 | /**
12 |  * Matches a KeyBinding against an actual Key press
13 |  * Pure data-driven matching logic
14 |  */
15 | function matchKeyBinding(keyBinding: KeyBinding, key: Key): boolean {
16 |   // Either key name or sequence must match (but not both should be defined)
17 |   let keyMatches = false;
18 | 
19 |   if (keyBinding.key !== undefined) {
20 |     keyMatches = keyBinding.key === key.name;
21 |   } else if (keyBinding.sequence !== undefined) {
22 |     keyMatches = keyBinding.sequence === key.sequence;
23 |   } else {
24 |     // Neither key nor sequence defined - invalid binding
25 |     return false;
26 |   }
27 | 
28 |   if (!keyMatches) {
29 |     return false;
30 |   }
31 | 
32 |   // Check modifiers - follow original logic:
33 |   // undefined = ignore this modifier (original behavior)
34 |   // true = modifier must be pressed
35 |   // false = modifier must NOT be pressed
36 | 
37 |   if (keyBinding.ctrl !== undefined && key.ctrl !== keyBinding.ctrl) {
38 |     return false;
39 |   }
40 | 
41 |   if (keyBinding.shift !== undefined && key.shift !== keyBinding.shift) {
42 |     return false;
43 |   }
44 | 
45 |   if (keyBinding.command !== undefined && key.meta !== keyBinding.command) {
46 |     return false;
47 |   }
48 | 
49 |   if (keyBinding.paste !== undefined && key.paste !== keyBinding.paste) {
50 |     return false;
51 |   }
52 | 
53 |   return true;
54 | }
55 | 
56 | /**
57 |  * Checks if a key matches any of the bindings for a command
58 |  */
59 | function matchCommand(
60 |   command: Command,
61 |   key: Key,
62 |   config: KeyBindingConfig = defaultKeyBindings,
63 | ): boolean {
64 |   const bindings = config[command];
65 |   return bindings.some((binding) => matchKeyBinding(binding, key));
66 | }
67 | 
68 | /**
69 |  * Key matcher function type
70 |  */
71 | type KeyMatcher = (key: Key) => boolean;
72 | 
73 | /**
74 |  * Type for key matchers mapped to Command enum
75 |  */
76 | export type KeyMatchers = {
77 |   readonly [C in Command]: KeyMatcher;
78 | };
79 | 
80 | /**
81 |  * Creates key matchers from a key binding configuration
82 |  */
83 | export function createKeyMatchers(
84 |   config: KeyBindingConfig = defaultKeyBindings,
85 | ): KeyMatchers {
86 |   const matchers = {} as { [C in Command]: KeyMatcher };
87 | 
88 |   for (const command of Object.values(Command)) {
89 |     matchers[command] = (key: Key) => matchCommand(command, key, config);
90 |   }
91 | 
92 |   return matchers as KeyMatchers;
93 | }
94 | 
95 | /**
96 |  * Default key binding matchers using the default configuration
97 |  */
98 | export const keyMatchers: KeyMatchers = createKeyMatchers(defaultKeyBindings);
99 | 
100 | // Re-export Command for convenience
101 | export { Command };
```

src/ui/semantic-colors.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { themeManager } from './themes/theme-manager.js';
8 | import type { SemanticColors } from './themes/semantic-tokens.js';
9 | 
10 | export const theme: SemanticColors = {
11 |   get text() {
12 |     return themeManager.getSemanticColors().text;
13 |   },
14 |   get background() {
15 |     return themeManager.getSemanticColors().background;
16 |   },
17 |   get border() {
18 |     return themeManager.getSemanticColors().border;
19 |   },
20 |   get ui() {
21 |     return themeManager.getSemanticColors().ui;
22 |   },
23 |   get status() {
24 |     return themeManager.getSemanticColors().status;
25 |   },
26 | };
```

src/ui/textConstants.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | export const SCREEN_READER_USER_PREFIX = 'User: ';
8 | 
9 | export const SCREEN_READER_MODEL_PREFIX = 'Model: ';
10 | 
11 | export const SCREEN_READER_LOADING = 'loading';
12 | 
13 | export const SCREEN_READER_RESPONDING = 'responding';
```

src/ui/types.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type {
8 |   CompressionStatus,
9 |   MCPServerConfig,
10 |   ThoughtSummary,
11 |   ToolCallConfirmationDetails,
12 |   ToolConfirmationOutcome,
13 |   ToolResultDisplay,
14 | } from '@google/gemini-cli-core';
15 | import type { PartListUnion } from '@google/genai';
16 | import { type ReactNode } from 'react';
17 | 
18 | export type { ThoughtSummary };
19 | 
20 | export enum AuthState {
21 |   // Attemtping to authenticate or re-authenticate
22 |   Unauthenticated = 'unauthenticated',
23 |   // Auth dialog is open for user to select auth method
24 |   Updating = 'updating',
25 |   // Successfully authenticated
26 |   Authenticated = 'authenticated',
27 | }
28 | 
29 | // Only defining the state enum needed by the UI
30 | export enum StreamingState {
31 |   Idle = 'idle',
32 |   Responding = 'responding',
33 |   WaitingForConfirmation = 'waiting_for_confirmation',
34 | }
35 | 
36 | // Copied from server/src/core/turn.ts for CLI usage
37 | export enum GeminiEventType {
38 |   Content = 'content',
39 |   ToolCallRequest = 'tool_call_request',
40 |   // Add other event types if the UI hook needs to handle them
41 | }
42 | 
43 | export enum ToolCallStatus {
44 |   Pending = 'Pending',
45 |   Canceled = 'Canceled',
46 |   Confirming = 'Confirming',
47 |   Executing = 'Executing',
48 |   Success = 'Success',
49 |   Error = 'Error',
50 | }
51 | 
52 | export interface ToolCallEvent {
53 |   type: 'tool_call';
54 |   status: ToolCallStatus;
55 |   callId: string;
56 |   name: string;
57 |   args: Record<string, never>;
58 |   resultDisplay: ToolResultDisplay | undefined;
59 |   confirmationDetails: ToolCallConfirmationDetails | undefined;
60 | }
61 | 
62 | export interface IndividualToolCallDisplay {
63 |   callId: string;
64 |   name: string;
65 |   description: string;
66 |   resultDisplay: ToolResultDisplay | undefined;
67 |   status: ToolCallStatus;
68 |   confirmationDetails: ToolCallConfirmationDetails | undefined;
69 |   renderOutputAsMarkdown?: boolean;
70 |   ptyId?: number;
71 |   outputFile?: string;
72 | }
73 | 
74 | export interface CompressionProps {
75 |   isPending: boolean;
76 |   originalTokenCount: number | null;
77 |   newTokenCount: number | null;
78 |   compressionStatus: CompressionStatus | null;
79 | }
80 | 
81 | export interface HistoryItemBase {
82 |   text?: string; // Text content for user/gemini/info/error messages
83 | }
84 | 
85 | export type HistoryItemUser = HistoryItemBase & {
86 |   type: 'user';
87 |   text: string;
88 | };
89 | 
90 | export type HistoryItemGemini = HistoryItemBase & {
91 |   type: 'gemini';
92 |   text: string;
93 | };
94 | 
95 | export type HistoryItemGeminiContent = HistoryItemBase & {
96 |   type: 'gemini_content';
97 |   text: string;
98 | };
99 | 
100 | export type HistoryItemInfo = HistoryItemBase & {
101 |   type: 'info';
102 |   text: string;
103 | };
104 | 
105 | export type HistoryItemError = HistoryItemBase & {
106 |   type: 'error';
107 |   text: string;
108 | };
109 | 
110 | export type HistoryItemWarning = HistoryItemBase & {
111 |   type: 'warning';
112 |   text: string;
113 | };
114 | 
115 | export type HistoryItemAbout = HistoryItemBase & {
116 |   type: 'about';
117 |   cliVersion: string;
118 |   osVersion: string;
119 |   sandboxEnv: string;
120 |   modelVersion: string;
121 |   selectedAuthType: string;
122 |   gcpProject: string;
123 |   ideClient: string;
124 | };
125 | 
126 | export type HistoryItemHelp = HistoryItemBase & {
127 |   type: 'help';
128 |   timestamp: Date;
129 | };
130 | 
131 | export type HistoryItemStats = HistoryItemBase & {
132 |   type: 'stats';
133 |   duration: string;
134 | };
135 | 
136 | export type HistoryItemModelStats = HistoryItemBase & {
137 |   type: 'model_stats';
138 | };
139 | 
140 | export type HistoryItemToolStats = HistoryItemBase & {
141 |   type: 'tool_stats';
142 | };
143 | 
144 | export type HistoryItemQuit = HistoryItemBase & {
145 |   type: 'quit';
146 |   duration: string;
147 | };
148 | 
149 | export type HistoryItemToolGroup = HistoryItemBase & {
150 |   type: 'tool_group';
151 |   tools: IndividualToolCallDisplay[];
152 | };
153 | 
154 | export type HistoryItemUserShell = HistoryItemBase & {
155 |   type: 'user_shell';
156 |   text: string;
157 | };
158 | 
159 | export type HistoryItemCompression = HistoryItemBase & {
160 |   type: 'compression';
161 |   compression: CompressionProps;
162 | };
163 | 
164 | export type HistoryItemExtensionsList = HistoryItemBase & {
165 |   type: 'extensions_list';
166 | };
167 | 
168 | export interface ChatDetail {
169 |   name: string;
170 |   mtime: string;
171 | }
172 | 
173 | export type HistoryItemChatList = HistoryItemBase & {
174 |   type: 'chat_list';
175 |   chats: ChatDetail[];
176 | };
177 | 
178 | export interface ToolDefinition {
179 |   name: string;
180 |   displayName: string;
181 |   description?: string;
182 | }
183 | 
184 | export type HistoryItemToolsList = HistoryItemBase & {
185 |   type: 'tools_list';
186 |   tools: ToolDefinition[];
187 |   showDescriptions: boolean;
188 | };
189 | 
190 | // JSON-friendly types for using as a simple data model showing info about an
191 | // MCP Server.
192 | export interface JsonMcpTool {
193 |   serverName: string;
194 |   name: string;
195 |   description?: string;
196 |   schema?: {
197 |     parametersJsonSchema?: unknown;
198 |     parameters?: unknown;
199 |   };
200 | }
201 | 
202 | export interface JsonMcpPrompt {
203 |   serverName: string;
204 |   name: string;
205 |   description?: string;
206 | }
207 | 
208 | export type HistoryItemMcpStatus = HistoryItemBase & {
209 |   type: 'mcp_status';
210 |   servers: Record<string, MCPServerConfig>;
211 |   tools: JsonMcpTool[];
212 |   prompts: JsonMcpPrompt[];
213 |   authStatus: Record<
214 |     string,
215 |     'authenticated' | 'expired' | 'unauthenticated' | 'not-configured'
216 |   >;
217 |   blockedServers: Array<{ name: string; extensionName: string }>;
218 |   discoveryInProgress: boolean;
219 |   connectingServers: string[];
220 |   showDescriptions: boolean;
221 |   showSchema: boolean;
222 |   showTips: boolean;
223 | };
224 | 
225 | // Using Omit<HistoryItem, 'id'> seems to have some issues with typescript's
226 | // type inference e.g. historyItem.type === 'tool_group' isn't auto-inferring that
227 | // 'tools' in historyItem.
228 | // Individually exported types extending HistoryItemBase
229 | export type HistoryItemWithoutId =
230 |   | HistoryItemUser
231 |   | HistoryItemUserShell
232 |   | HistoryItemGemini
233 |   | HistoryItemGeminiContent
234 |   | HistoryItemInfo
235 |   | HistoryItemError
236 |   | HistoryItemWarning
237 |   | HistoryItemAbout
238 |   | HistoryItemHelp
239 |   | HistoryItemToolGroup
240 |   | HistoryItemStats
241 |   | HistoryItemModelStats
242 |   | HistoryItemToolStats
243 |   | HistoryItemQuit
244 |   | HistoryItemCompression
245 |   | HistoryItemExtensionsList
246 |   | HistoryItemToolsList
247 |   | HistoryItemMcpStatus
248 |   | HistoryItemChatList;
249 | 
250 | export type HistoryItem = HistoryItemWithoutId & { id: number };
251 | 
252 | // Message types used by internal command feedback (subset of HistoryItem types)
253 | export enum MessageType {
254 |   INFO = 'info',
255 |   ERROR = 'error',
256 |   WARNING = 'warning',
257 |   USER = 'user',
258 |   ABOUT = 'about',
259 |   HELP = 'help',
260 |   STATS = 'stats',
261 |   MODEL_STATS = 'model_stats',
262 |   TOOL_STATS = 'tool_stats',
263 |   QUIT = 'quit',
264 |   GEMINI = 'gemini',
265 |   COMPRESSION = 'compression',
266 |   EXTENSIONS_LIST = 'extensions_list',
267 |   TOOLS_LIST = 'tools_list',
268 |   MCP_STATUS = 'mcp_status',
269 |   CHAT_LIST = 'chat_list',
270 | }
271 | 
272 | // Simplified message structure for internal feedback
273 | export type Message =
274 |   | {
275 |       type: MessageType.INFO | MessageType.ERROR | MessageType.USER;
276 |       content: string; // Renamed from text for clarity in this context
277 |       timestamp: Date;
278 |     }
279 |   | {
280 |       type: MessageType.ABOUT;
281 |       timestamp: Date;
282 |       cliVersion: string;
283 |       osVersion: string;
284 |       sandboxEnv: string;
285 |       modelVersion: string;
286 |       selectedAuthType: string;
287 |       gcpProject: string;
288 |       ideClient: string;
289 |       content?: string; // Optional content, not really used for ABOUT
290 |     }
291 |   | {
292 |       type: MessageType.HELP;
293 |       timestamp: Date;
294 |       content?: string; // Optional content, not really used for HELP
295 |     }
296 |   | {
297 |       type: MessageType.STATS;
298 |       timestamp: Date;
299 |       duration: string;
300 |       content?: string;
301 |     }
302 |   | {
303 |       type: MessageType.MODEL_STATS;
304 |       timestamp: Date;
305 |       content?: string;
306 |     }
307 |   | {
308 |       type: MessageType.TOOL_STATS;
309 |       timestamp: Date;
310 |       content?: string;
311 |     }
312 |   | {
313 |       type: MessageType.QUIT;
314 |       timestamp: Date;
315 |       duration: string;
316 |       content?: string;
317 |     }
318 |   | {
319 |       type: MessageType.COMPRESSION;
320 |       compression: CompressionProps;
321 |       timestamp: Date;
322 |     };
323 | 
324 | export interface ConsoleMessageItem {
325 |   type: 'log' | 'warn' | 'error' | 'debug' | 'info';
326 |   content: string;
327 |   count: number;
328 | }
329 | 
330 | /**
331 |  * Result type for a slash command that should immediately result in a prompt
332 |  * being submitted to the Gemini model.
333 |  */
334 | export interface SubmitPromptResult {
335 |   type: 'submit_prompt';
336 |   content: PartListUnion;
337 | }
338 | 
339 | /**
340 |  * Defines the result of the slash command processor for its consumer (useGeminiStream).
341 |  */
342 | export type SlashCommandProcessorResult =
343 |   | {
344 |       type: 'schedule_tool';
345 |       toolName: string;
346 |       toolArgs: Record<string, unknown>;
347 |     }
348 |   | {
349 |       type: 'handled'; // Indicates the command was processed and no further action is needed.
350 |     }
351 |   | SubmitPromptResult;
352 | 
353 | export interface ShellConfirmationRequest {
354 |   commands: string[];
355 |   onConfirm: (
356 |     outcome: ToolConfirmationOutcome,
357 |     approvedCommands?: string[],
358 |   ) => void;
359 | }
360 | 
361 | export interface ConfirmationRequest {
362 |   prompt: ReactNode;
363 |   onConfirm: (confirm: boolean) => void;
364 | }
365 | 
366 | export interface LoopDetectionConfirmationRequest {
367 |   onComplete: (result: { userSelection: 'disable' | 'keep' }) => void;
368 | }
```

src/utils/checks.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | /* Fail to compile on unexpected values. */
8 | export function assumeExhaustive(_value: never): void {}
9 | 
10 | /**
11 |  * Throws an exception on unexpected values.
12 |  *
13 |  * A common use case is switch statements:
14 |  * switch(enumValue) {
15 |  *   case Enum.A:
16 |  *   case Enum.B:
17 |  *     break;
18 |  *   default:
19 |  *     checkExhaustive(enumValue);
20 |  * }
21 |  */
22 | export function checkExhaustive(
23 |   value: never,
24 |   msg = `unexpected value ${value}!`,
25 | ): never {
26 |   assumeExhaustive(value);
27 |   throw new Error(msg);
28 | }
```

src/utils/cleanup.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { vi } from 'vitest';
8 | import { registerCleanup, runExitCleanup } from './cleanup';
9 | 
10 | describe('cleanup', () => {
11 |   const originalCleanupFunctions = global['cleanupFunctions'];
12 | 
13 |   beforeEach(() => {
14 |     // Isolate cleanup functions for each test
15 |     global['cleanupFunctions'] = [];
16 |   });
17 | 
18 |   afterAll(() => {
19 |     // Restore original cleanup functions
20 |     global['cleanupFunctions'] = originalCleanupFunctions;
21 |   });
22 | 
23 |   it('should run a registered synchronous function', async () => {
24 |     const cleanupFn = vi.fn();
25 |     registerCleanup(cleanupFn);
26 | 
27 |     await runExitCleanup();
28 | 
29 |     expect(cleanupFn).toHaveBeenCalledTimes(1);
30 |   });
31 | 
32 |   it('should run a registered asynchronous function', async () => {
33 |     const cleanupFn = vi.fn().mockResolvedValue(undefined);
34 |     registerCleanup(cleanupFn);
35 | 
36 |     await runExitCleanup();
37 | 
38 |     expect(cleanupFn).toHaveBeenCalledTimes(1);
39 |   });
40 | 
41 |   it('should run multiple registered functions', async () => {
42 |     const syncFn = vi.fn();
43 |     const asyncFn = vi.fn().mockResolvedValue(undefined);
44 | 
45 |     registerCleanup(syncFn);
46 |     registerCleanup(asyncFn);
47 | 
48 |     await runExitCleanup();
49 | 
50 |     expect(syncFn).toHaveBeenCalledTimes(1);
51 |     expect(asyncFn).toHaveBeenCalledTimes(1);
52 |   });
53 | 
54 |   it('should continue running cleanup functions even if one throws an error', async () => {
55 |     const errorFn = vi.fn(() => {
56 |       throw new Error('Test Error');
57 |     });
58 |     const successFn = vi.fn();
59 | 
60 |     registerCleanup(errorFn);
61 |     registerCleanup(successFn);
62 | 
63 |     await runExitCleanup();
64 | 
65 |     expect(errorFn).toHaveBeenCalledTimes(1);
66 |     expect(successFn).toHaveBeenCalledTimes(1);
67 |   });
68 | });
```

src/utils/cleanup.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { promises as fs } from 'node:fs';
8 | import { join } from 'node:path';
9 | import { Storage } from '@google/gemini-cli-core';
10 | 
11 | const cleanupFunctions: Array<(() => void) | (() => Promise<void>)> = [];
12 | 
13 | export function registerCleanup(fn: (() => void) | (() => Promise<void>)) {
14 |   cleanupFunctions.push(fn);
15 | }
16 | 
17 | export async function runExitCleanup() {
18 |   for (const fn of cleanupFunctions) {
19 |     try {
20 |       await fn();
21 |     } catch (_) {
22 |       // Ignore errors during cleanup.
23 |     }
24 |   }
25 |   cleanupFunctions.length = 0; // Clear the array
26 | }
27 | 
28 | export async function cleanupCheckpoints() {
29 |   const storage = new Storage(process.cwd());
30 |   const tempDir = storage.getProjectTempDir();
31 |   const checkpointsDir = join(tempDir, 'checkpoints');
32 |   try {
33 |     await fs.rm(checkpointsDir, { recursive: true, force: true });
34 |   } catch {
35 |     // Ignore errors if the directory doesn't exist or fails to delete.
36 |   }
37 | }
```

src/utils/commands.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect } from 'vitest';
8 | import { parseSlashCommand } from './commands.js';
9 | import { CommandKind, type SlashCommand } from '../ui/commands/types.js';
10 | 
11 | // Mock command structure for testing
12 | const mockCommands: readonly SlashCommand[] = [
13 |   {
14 |     name: 'help',
15 |     description: 'Show help',
16 |     action: async () => {},
17 |     kind: CommandKind.BUILT_IN,
18 |   },
19 |   {
20 |     name: 'commit',
21 |     description: 'Commit changes',
22 |     action: async () => {},
23 |     kind: CommandKind.FILE,
24 |   },
25 |   {
26 |     name: 'memory',
27 |     description: 'Manage memory',
28 |     altNames: ['mem'],
29 |     subCommands: [
30 |       {
31 |         name: 'add',
32 |         description: 'Add to memory',
33 |         action: async () => {},
34 |         kind: CommandKind.BUILT_IN,
35 |       },
36 |       {
37 |         name: 'clear',
38 |         description: 'Clear memory',
39 |         altNames: ['c'],
40 |         action: async () => {},
41 |         kind: CommandKind.BUILT_IN,
42 |       },
43 |     ],
44 |     kind: CommandKind.BUILT_IN,
45 |   },
46 | ];
47 | 
48 | describe('parseSlashCommand', () => {
49 |   it('should parse a simple command without arguments', () => {
50 |     const result = parseSlashCommand('/help', mockCommands);
51 |     expect(result.commandToExecute?.name).toBe('help');
52 |     expect(result.args).toBe('');
53 |     expect(result.canonicalPath).toEqual(['help']);
54 |   });
55 | 
56 |   it('should parse a simple command with arguments', () => {
57 |     const result = parseSlashCommand(
58 |       '/commit -m "Initial commit"',
59 |       mockCommands,
60 |     );
61 |     expect(result.commandToExecute?.name).toBe('commit');
62 |     expect(result.args).toBe('-m "Initial commit"');
63 |     expect(result.canonicalPath).toEqual(['commit']);
64 |   });
65 | 
66 |   it('should parse a subcommand', () => {
67 |     const result = parseSlashCommand('/memory add', mockCommands);
68 |     expect(result.commandToExecute?.name).toBe('add');
69 |     expect(result.args).toBe('');
70 |     expect(result.canonicalPath).toEqual(['memory', 'add']);
71 |   });
72 | 
73 |   it('should parse a subcommand with arguments', () => {
74 |     const result = parseSlashCommand(
75 |       '/memory add some important data',
76 |       mockCommands,
77 |     );
78 |     expect(result.commandToExecute?.name).toBe('add');
79 |     expect(result.args).toBe('some important data');
80 |     expect(result.canonicalPath).toEqual(['memory', 'add']);
81 |   });
82 | 
83 |   it('should handle a command alias', () => {
84 |     const result = parseSlashCommand('/mem add some data', mockCommands);
85 |     expect(result.commandToExecute?.name).toBe('add');
86 |     expect(result.args).toBe('some data');
87 |     expect(result.canonicalPath).toEqual(['memory', 'add']);
88 |   });
89 | 
90 |   it('should handle a subcommand alias', () => {
91 |     const result = parseSlashCommand('/memory c', mockCommands);
92 |     expect(result.commandToExecute?.name).toBe('clear');
93 |     expect(result.args).toBe('');
94 |     expect(result.canonicalPath).toEqual(['memory', 'clear']);
95 |   });
96 | 
97 |   it('should return undefined for an unknown command', () => {
98 |     const result = parseSlashCommand('/unknown', mockCommands);
99 |     expect(result.commandToExecute).toBeUndefined();
100 |     expect(result.args).toBe('unknown');
101 |     expect(result.canonicalPath).toEqual([]);
102 |   });
103 | 
104 |   it('should return the parent command if subcommand is unknown', () => {
105 |     const result = parseSlashCommand(
106 |       '/memory unknownsub some args',
107 |       mockCommands,
108 |     );
109 |     expect(result.commandToExecute?.name).toBe('memory');
110 |     expect(result.args).toBe('unknownsub some args');
111 |     expect(result.canonicalPath).toEqual(['memory']);
112 |   });
113 | 
114 |   it('should handle extra whitespace', () => {
115 |     const result = parseSlashCommand(
116 |       '  /memory   add  some data  ',
117 |       mockCommands,
118 |     );
119 |     expect(result.commandToExecute?.name).toBe('add');
120 |     expect(result.args).toBe('some data');
121 |     expect(result.canonicalPath).toEqual(['memory', 'add']);
122 |   });
123 | 
124 |   it('should return undefined if query does not start with a slash', () => {
125 |     const result = parseSlashCommand('help', mockCommands);
126 |     expect(result.commandToExecute).toBeUndefined();
127 |   });
128 | 
129 |   it('should handle an empty query', () => {
130 |     const result = parseSlashCommand('', mockCommands);
131 |     expect(result.commandToExecute).toBeUndefined();
132 |   });
133 | 
134 |   it('should handle a query with only a slash', () => {
135 |     const result = parseSlashCommand('/', mockCommands);
136 |     expect(result.commandToExecute).toBeUndefined();
137 |     expect(result.args).toBe('');
138 |     expect(result.canonicalPath).toEqual([]);
139 |   });
140 | });
```

src/utils/commands.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { type SlashCommand } from '../ui/commands/types.js';
8 | 
9 | export type ParsedSlashCommand = {
10 |   commandToExecute: SlashCommand | undefined;
11 |   args: string;
12 |   canonicalPath: string[];
13 | };
14 | 
15 | /**
16 |  * Parses a raw slash command string into its command, arguments, and canonical path.
17 |  * If no valid command is found, the `commandToExecute` property will be `undefined`.
18 |  *
19 |  * @param query The raw input string, e.g., "/memory add some data" or "/help".
20 |  * @param commands The list of available top-level slash commands.
21 |  * @returns An object containing the resolved command, its arguments, and its canonical path.
22 |  */
23 | export const parseSlashCommand = (
24 |   query: string,
25 |   commands: readonly SlashCommand[],
26 | ): ParsedSlashCommand => {
27 |   const trimmed = query.trim();
28 | 
29 |   const parts = trimmed.substring(1).trim().split(/\s+/);
30 |   const commandPath = parts.filter((p) => p); // The parts of the command, e.g., ['memory', 'add']
31 | 
32 |   let currentCommands = commands;
33 |   let commandToExecute: SlashCommand | undefined;
34 |   let pathIndex = 0;
35 |   const canonicalPath: string[] = [];
36 | 
37 |   for (const part of commandPath) {
38 |     // TODO: For better performance and architectural clarity, this two-pass
39 |     // search could be replaced. A more optimal approach would be to
40 |     // pre-compute a single lookup map in `CommandService.ts` that resolves
41 |     // all name and alias conflicts during the initial loading phase. The
42 |     // processor would then perform a single, fast lookup on that map.
43 | 
44 |     // First pass: check for an exact match on the primary command name.
45 |     let foundCommand = currentCommands.find((cmd) => cmd.name === part);
46 | 
47 |     // Second pass: if no primary name matches, check for an alias.
48 |     if (!foundCommand) {
49 |       foundCommand = currentCommands.find((cmd) =>
50 |         cmd.altNames?.includes(part),
51 |       );
52 |     }
53 | 
54 |     if (foundCommand) {
55 |       commandToExecute = foundCommand;
56 |       canonicalPath.push(foundCommand.name);
57 |       pathIndex++;
58 |       if (foundCommand.subCommands) {
59 |         currentCommands = foundCommand.subCommands;
60 |       } else {
61 |         break;
62 |       }
63 |     } else {
64 |       break;
65 |     }
66 |   }
67 | 
68 |   const args = parts.slice(pathIndex).join(' ');
69 | 
70 |   return { commandToExecute, args, canonicalPath };
71 | };
```

src/utils/commentJson.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
8 | import * as fs from 'node:fs';
9 | import * as path from 'node:path';
10 | import * as os from 'node:os';
11 | import { updateSettingsFilePreservingFormat } from './commentJson.js';
12 | 
13 | describe('commentJson', () => {
14 |   let tempDir: string;
15 |   let testFilePath: string;
16 | 
17 |   beforeEach(() => {
18 |     // Create a temporary directory for test files
19 |     tempDir = fs.mkdtempSync(path.join(os.tmpdir(), 'preserve-format-test-'));
20 |     testFilePath = path.join(tempDir, 'settings.json');
21 |   });
22 | 
23 |   afterEach(() => {
24 |     // Clean up temporary directory
25 |     if (fs.existsSync(tempDir)) {
26 |       fs.rmSync(tempDir, { recursive: true, force: true });
27 |     }
28 |   });
29 | 
30 |   describe('updateSettingsFilePreservingFormat', () => {
31 |     it('should preserve comments when updating settings', () => {
32 |       const originalContent = `{
33 |         // Model configuration
34 |         "model": "gemini-2.5-pro",
35 |         "ui": {
36 |           // Theme setting
37 |           "theme": "dark"
38 |         }
39 |       }`;
40 | 
41 |       fs.writeFileSync(testFilePath, originalContent, 'utf-8');
42 | 
43 |       updateSettingsFilePreservingFormat(testFilePath, {
44 |         model: 'gemini-2.5-flash',
45 |         ui: {
46 |           theme: 'dark',
47 |         },
48 |       });
49 | 
50 |       const updatedContent = fs.readFileSync(testFilePath, 'utf-8');
51 | 
52 |       expect(updatedContent).toContain('// Model configuration');
53 |       expect(updatedContent).toContain('// Theme setting');
54 |       expect(updatedContent).toContain('"model": "gemini-2.5-flash"');
55 |       expect(updatedContent).toContain('"theme": "dark"');
56 |     });
57 | 
58 |     it('should handle nested object updates', () => {
59 |       const originalContent = `{
60 |         "ui": {
61 |           "theme": "dark",
62 |           "showLineNumbers": true
63 |         }
64 |       }`;
65 | 
66 |       fs.writeFileSync(testFilePath, originalContent, 'utf-8');
67 | 
68 |       updateSettingsFilePreservingFormat(testFilePath, {
69 |         ui: {
70 |           theme: 'light',
71 |           showLineNumbers: true,
72 |         },
73 |       });
74 | 
75 |       const updatedContent = fs.readFileSync(testFilePath, 'utf-8');
76 |       expect(updatedContent).toContain('"theme": "light"');
77 |       expect(updatedContent).toContain('"showLineNumbers": true');
78 |     });
79 | 
80 |     it('should add new fields while preserving existing structure', () => {
81 |       const originalContent = `{
82 |         // Existing config
83 |         "model": "gemini-2.5-pro"
84 |       }`;
85 | 
86 |       fs.writeFileSync(testFilePath, originalContent, 'utf-8');
87 | 
88 |       updateSettingsFilePreservingFormat(testFilePath, {
89 |         model: 'gemini-2.5-pro',
90 |         newField: 'newValue',
91 |       });
92 | 
93 |       const updatedContent = fs.readFileSync(testFilePath, 'utf-8');
94 |       expect(updatedContent).toContain('// Existing config');
95 |       expect(updatedContent).toContain('"newField": "newValue"');
96 |     });
97 | 
98 |     it('should create file if it does not exist', () => {
99 |       updateSettingsFilePreservingFormat(testFilePath, {
100 |         model: 'gemini-2.5-pro',
101 |       });
102 | 
103 |       expect(fs.existsSync(testFilePath)).toBe(true);
104 |       const content = fs.readFileSync(testFilePath, 'utf-8');
105 |       expect(content).toContain('"model": "gemini-2.5-pro"');
106 |     });
107 | 
108 |     it('should handle complex real-world scenario', () => {
109 |       const complexContent = `{
110 |         // Settings
111 |         "model": "gemini-2.5-pro",
112 |         "mcpServers": {
113 |           // Active server
114 |           "context7": {
115 |             "headers": {
116 |               "API_KEY": "test-key" // API key
117 |             }
118 |           }
119 |         }
120 |       }`;
121 | 
122 |       fs.writeFileSync(testFilePath, complexContent, 'utf-8');
123 | 
124 |       updateSettingsFilePreservingFormat(testFilePath, {
125 |         model: 'gemini-2.5-flash',
126 |         mcpServers: {
127 |           context7: {
128 |             headers: {
129 |               API_KEY: 'new-test-key',
130 |             },
131 |           },
132 |         },
133 |         newSection: {
134 |           setting: 'value',
135 |         },
136 |       });
137 | 
138 |       const updatedContent = fs.readFileSync(testFilePath, 'utf-8');
139 | 
140 |       // Verify comments preserved
141 |       expect(updatedContent).toContain('// Settings');
142 |       expect(updatedContent).toContain('// Active server');
143 |       expect(updatedContent).toContain('// API key');
144 | 
145 |       // Verify updates applied
146 |       expect(updatedContent).toContain('"model": "gemini-2.5-flash"');
147 |       expect(updatedContent).toContain('"newSection"');
148 |       expect(updatedContent).toContain('"API_KEY": "new-test-key"');
149 |     });
150 | 
151 |     it('should handle corrupted JSON files gracefully', () => {
152 |       const corruptedContent = `{
153 |         "model": "gemini-2.5-pro",
154 |         "ui": {
155 |           "theme": "dark"
156 |         // Missing closing brace
157 |       `;
158 | 
159 |       fs.writeFileSync(testFilePath, corruptedContent, 'utf-8');
160 | 
161 |       const consoleSpy = vi
162 |         .spyOn(console, 'error')
163 |         .mockImplementation(() => {});
164 | 
165 |       expect(() => {
166 |         updateSettingsFilePreservingFormat(testFilePath, {
167 |           model: 'gemini-2.5-flash',
168 |         });
169 |       }).not.toThrow();
170 | 
171 |       expect(consoleSpy).toHaveBeenCalledWith(
172 |         'Error parsing settings file:',
173 |         expect.any(Error),
174 |       );
175 |       expect(consoleSpy).toHaveBeenCalledWith(
176 |         'Settings file may be corrupted. Please check the JSON syntax.',
177 |       );
178 | 
179 |       const unchangedContent = fs.readFileSync(testFilePath, 'utf-8');
180 |       expect(unchangedContent).toBe(corruptedContent);
181 | 
182 |       consoleSpy.mockRestore();
183 |     });
184 | 
185 |     it('should handle array updates while preserving comments', () => {
186 |       const originalContent = `{
187 |         // Server configurations
188 |         "servers": [
189 |           // First server
190 |           "server1",
191 |           "server2" // Second server
192 |         ]
193 |       }`;
194 | 
195 |       fs.writeFileSync(testFilePath, originalContent, 'utf-8');
196 | 
197 |       updateSettingsFilePreservingFormat(testFilePath, {
198 |         servers: ['server1', 'server3'],
199 |       });
200 | 
201 |       const updatedContent = fs.readFileSync(testFilePath, 'utf-8');
202 |       expect(updatedContent).toContain('// Server configurations');
203 |       expect(updatedContent).toContain('"server1"');
204 |       expect(updatedContent).toContain('"server3"');
205 |       expect(updatedContent).not.toContain('"server2"');
206 |     });
207 | 
208 |     it('should sync nested objects, removing omitted fields', () => {
209 |       const originalContent = `{
210 |         // Configuration
211 |         "model": "gemini-2.5-pro",
212 |         "ui": {
213 |           "theme": "dark",
214 |           "existingSetting": "value"
215 |         },
216 |         "preservedField": "keep me"
217 |       }`;
218 | 
219 |       fs.writeFileSync(testFilePath, originalContent, 'utf-8');
220 | 
221 |       updateSettingsFilePreservingFormat(testFilePath, {
222 |         model: 'gemini-2.5-flash',
223 |         ui: {
224 |           theme: 'light',
225 |         },
226 |         preservedField: 'keep me',
227 |       });
228 | 
229 |       const updatedContent = fs.readFileSync(testFilePath, 'utf-8');
230 |       expect(updatedContent).toContain('// Configuration');
231 |       expect(updatedContent).toContain('"model": "gemini-2.5-flash"');
232 |       expect(updatedContent).toContain('"theme": "light"');
233 |       expect(updatedContent).not.toContain('"existingSetting": "value"');
234 |       expect(updatedContent).toContain('"preservedField": "keep me"');
235 |     });
236 | 
237 |     it('should handle mcpServers field deletion properly', () => {
238 |       const originalContent = `{
239 |         "model": "gemini-2.5-pro",
240 |         "mcpServers": {
241 |           // Server to keep
242 |           "context7": {
243 |             "command": "node",
244 |             "args": ["server.js"]
245 |           },
246 |           // Server to remove
247 |           "oldServer": {
248 |             "command": "old",
249 |             "args": ["old.js"]
250 |           }
251 |         }
252 |       }`;
253 | 
254 |       fs.writeFileSync(testFilePath, originalContent, 'utf-8');
255 | 
256 |       updateSettingsFilePreservingFormat(testFilePath, {
257 |         model: 'gemini-2.5-pro',
258 |         mcpServers: {
259 |           context7: {
260 |             command: 'node',
261 |             args: ['server.js'],
262 |           },
263 |         },
264 |       });
265 | 
266 |       const updatedContent = fs.readFileSync(testFilePath, 'utf-8');
267 |       expect(updatedContent).toContain('// Server to keep');
268 |       expect(updatedContent).toContain('"context7"');
269 |       expect(updatedContent).not.toContain('"oldServer"');
270 |       // The comment for the removed server should still be preserved
271 |       expect(updatedContent).toContain('// Server to remove');
272 |     });
273 | 
274 |     it('preserves sibling-level commented-out blocks when removing another key', () => {
275 |       const originalContent = `{
276 |         "mcpServers": {
277 |           // "sleep": {
278 |           //   "command": "node",
279 |           //   "args": [
280 |           //     "/Users/testUser/test-mcp-server/sleep-mcp/build/index.js"
281 |           //   ],
282 |           //   "timeout": 300000
283 |           // },
284 |           "playwright": {
285 |             "command": "npx",
286 |             "args": [
287 |               "@playwright/mcp@latest",
288 |               "--headless",
289 |               "--isolated"
290 |             ]
291 |           }
292 |         }
293 |       }`;
294 | 
295 |       fs.writeFileSync(testFilePath, originalContent, 'utf-8');
296 | 
297 |       updateSettingsFilePreservingFormat(testFilePath, {
298 |         mcpServers: {},
299 |       });
300 | 
301 |       const updatedContent = fs.readFileSync(testFilePath, 'utf-8');
302 |       expect(updatedContent).toContain('// "sleep": {');
303 |       expect(updatedContent).toContain('"mcpServers"');
304 |       expect(updatedContent).not.toContain('"playwright"');
305 |     });
306 | 
307 |     it('should handle type conversion from object to array', () => {
308 |       const originalContent = `{
309 |         "data": {
310 |           "key": "value"
311 |         }
312 |       }`;
313 | 
314 |       fs.writeFileSync(testFilePath, originalContent, 'utf-8');
315 | 
316 |       updateSettingsFilePreservingFormat(testFilePath, {
317 |         data: ['item1', 'item2'],
318 |       });
319 | 
320 |       const updatedContent = fs.readFileSync(testFilePath, 'utf-8');
321 |       expect(updatedContent).toContain('"data": [');
322 |       expect(updatedContent).toContain('"item1"');
323 |       expect(updatedContent).toContain('"item2"');
324 |     });
325 | 
326 |     it('should remove both nested and non-nested objects when omitted', () => {
327 |       const originalContent = `{
328 |         // Top-level config
329 |         "topLevelObject": {
330 |           "field1": "value1",
331 |           "field2": "value2"
332 |         },
333 |         // Parent object
334 |         "parent": {
335 |           "nestedObject": {
336 |             "nestedField1": "value1",
337 |             "nestedField2": "value2"
338 |           },
339 |           "keepThis": "value"
340 |         },
341 |         // This should be preserved
342 |         "preservedObject": {
343 |           "data": "keep"
344 |         }
345 |       }`;
346 | 
347 |       fs.writeFileSync(testFilePath, originalContent, 'utf-8');
348 | 
349 |       updateSettingsFilePreservingFormat(testFilePath, {
350 |         parent: {
351 |           keepThis: 'value',
352 |         },
353 |         preservedObject: {
354 |           data: 'keep',
355 |         },
356 |       });
357 | 
358 |       const updatedContent = fs.readFileSync(testFilePath, 'utf-8');
359 | 
360 |       expect(updatedContent).not.toContain('"topLevelObject"');
361 | 
362 |       expect(updatedContent).not.toContain('"nestedObject"');
363 | 
364 |       expect(updatedContent).toContain('"keepThis": "value"');
365 |       expect(updatedContent).toContain('"preservedObject"');
366 |       expect(updatedContent).toContain('"data": "keep"');
367 | 
368 |       expect(updatedContent).toContain('// This should be preserved');
369 |     });
370 |   });
371 | });
```

src/utils/commentJson.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import * as fs from 'node:fs';
8 | import { parse, stringify } from 'comment-json';
9 | 
10 | /**
11 |  * Type representing an object that may contain Symbol keys for comments.
12 |  */
13 | type CommentedRecord = Record<string | symbol, unknown>;
14 | 
15 | /**
16 |  * Updates a JSON file while preserving comments and formatting.
17 |  */
18 | export function updateSettingsFilePreservingFormat(
19 |   filePath: string,
20 |   updates: Record<string, unknown>,
21 | ): void {
22 |   if (!fs.existsSync(filePath)) {
23 |     fs.writeFileSync(filePath, JSON.stringify(updates, null, 2), 'utf-8');
24 |     return;
25 |   }
26 | 
27 |   const originalContent = fs.readFileSync(filePath, 'utf-8');
28 | 
29 |   let parsed: Record<string, unknown>;
30 |   try {
31 |     parsed = parse(originalContent) as Record<string, unknown>;
32 |   } catch (error) {
33 |     console.error('Error parsing settings file:', error);
34 |     console.error(
35 |       'Settings file may be corrupted. Please check the JSON syntax.',
36 |     );
37 |     return;
38 |   }
39 | 
40 |   const updatedStructure = applyUpdates(parsed, updates);
41 |   const updatedContent = stringify(updatedStructure, null, 2);
42 | 
43 |   fs.writeFileSync(filePath, updatedContent, 'utf-8');
44 | }
45 | 
46 | /**
47 |  * When deleting a property from a comment-json parsed object, relocate any
48 |  * leading/trailing comments that were attached to that property so they are not lost.
49 |  *
50 |  * This function re-attaches comments to the next sibling's leading comments if
51 |  * available, otherwise to the previous sibling's trailing comments, otherwise
52 |  * to the container's leading/trailing comments.
53 |  */
54 | function preserveCommentsOnPropertyDeletion(
55 |   container: Record<string, unknown>,
56 |   propName: string,
57 | ): void {
58 |   const target = container as CommentedRecord;
59 |   const beforeSym = Symbol.for(`before:${propName}`);
60 |   const afterSym = Symbol.for(`after:${propName}`);
61 | 
62 |   const beforeComments = target[beforeSym] as unknown[] | undefined;
63 |   const afterComments = target[afterSym] as unknown[] | undefined;
64 | 
65 |   if (!beforeComments && !afterComments) return;
66 | 
67 |   const keys = Object.getOwnPropertyNames(container);
68 |   const idx = keys.indexOf(propName);
69 |   const nextKey = idx >= 0 && idx + 1 < keys.length ? keys[idx + 1] : undefined;
70 |   const prevKey = idx > 0 ? keys[idx - 1] : undefined;
71 | 
72 |   function appendToSymbol(destSym: symbol, comments: unknown[]) {
73 |     if (!comments || comments.length === 0) return;
74 |     const existing = target[destSym];
75 |     target[destSym] = Array.isArray(existing)
76 |       ? existing.concat(comments)
77 |       : comments;
78 |   }
79 | 
80 |   if (beforeComments && beforeComments.length > 0) {
81 |     if (nextKey) {
82 |       appendToSymbol(Symbol.for(`before:${nextKey}`), beforeComments);
83 |     } else if (prevKey) {
84 |       appendToSymbol(Symbol.for(`after:${prevKey}`), beforeComments);
85 |     } else {
86 |       appendToSymbol(Symbol.for('before'), beforeComments);
87 |     }
88 |     delete target[beforeSym];
89 |   }
90 | 
91 |   if (afterComments && afterComments.length > 0) {
92 |     if (nextKey) {
93 |       appendToSymbol(Symbol.for(`before:${nextKey}`), afterComments);
94 |     } else if (prevKey) {
95 |       appendToSymbol(Symbol.for(`after:${prevKey}`), afterComments);
96 |     } else {
97 |       appendToSymbol(Symbol.for('after'), afterComments);
98 |     }
99 |     delete target[afterSym];
100 |   }
101 | }
102 | 
103 | /**
104 |  * Applies sync-by-omission semantics: synchronizes base to match desired.
105 |  * - Adds/updates keys from desired
106 |  * - Removes keys from base that are not in desired
107 |  * - Recursively applies to nested objects
108 |  * - Preserves comments when deleting keys
109 |  */
110 | function applyKeyDiff(
111 |   base: Record<string, unknown>,
112 |   desired: Record<string, unknown>,
113 | ): void {
114 |   for (const existingKey of Object.getOwnPropertyNames(base)) {
115 |     if (!Object.prototype.hasOwnProperty.call(desired, existingKey)) {
116 |       preserveCommentsOnPropertyDeletion(base, existingKey);
117 |       delete base[existingKey];
118 |     }
119 |   }
120 | 
121 |   for (const nextKey of Object.getOwnPropertyNames(desired)) {
122 |     const nextVal = desired[nextKey];
123 |     const baseVal = base[nextKey];
124 | 
125 |     const isObj =
126 |       typeof nextVal === 'object' &&
127 |       nextVal !== null &&
128 |       !Array.isArray(nextVal);
129 |     const isBaseObj =
130 |       typeof baseVal === 'object' &&
131 |       baseVal !== null &&
132 |       !Array.isArray(baseVal);
133 |     const isArr = Array.isArray(nextVal);
134 |     const isBaseArr = Array.isArray(baseVal);
135 | 
136 |     if (isObj && isBaseObj) {
137 |       applyKeyDiff(
138 |         baseVal as Record<string, unknown>,
139 |         nextVal as Record<string, unknown>,
140 |       );
141 |     } else if (isArr && isBaseArr) {
142 |       // In-place mutate arrays to preserve array-level comments on CommentArray
143 |       const baseArr = baseVal as unknown[];
144 |       const desiredArr = nextVal as unknown[];
145 |       baseArr.length = 0;
146 |       for (const el of desiredArr) {
147 |         baseArr.push(el);
148 |       }
149 |     } else {
150 |       base[nextKey] = nextVal;
151 |     }
152 |   }
153 | }
154 | 
155 | function applyUpdates(
156 |   current: Record<string, unknown>,
157 |   updates: Record<string, unknown>,
158 | ): Record<string, unknown> {
159 |   // Apply sync-by-omission semantics consistently at all levels
160 |   applyKeyDiff(current, updates);
161 |   return current;
162 | }
```

src/utils/deepMerge.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect } from 'vitest';
8 | import { customDeepMerge } from './deepMerge.js';
9 | import { MergeStrategy } from '../config/settingsSchema.js';
10 | 
11 | describe('customDeepMerge', () => {
12 |   it('should merge simple objects', () => {
13 |     const target = { a: 1, b: 2 };
14 |     const source = { b: 3, c: 4 };
15 |     const getMergeStrategy = () => undefined;
16 |     const result = customDeepMerge(getMergeStrategy, target, source);
17 |     expect(result).toEqual({ a: 1, b: 3, c: 4 });
18 |   });
19 | 
20 |   it('should merge nested objects', () => {
21 |     const target = { a: { x: 1 }, b: 2 };
22 |     const source = { a: { y: 2 }, c: 3 };
23 |     const getMergeStrategy = () => undefined;
24 |     const result = customDeepMerge(getMergeStrategy, target, source);
25 |     expect(result).toEqual({ a: { x: 1, y: 2 }, b: 2, c: 3 });
26 |   });
27 | 
28 |   it('should replace arrays by default', () => {
29 |     const target = { a: [1, 2] };
30 |     const source = { a: [3, 4] };
31 |     const getMergeStrategy = () => undefined;
32 |     const result = customDeepMerge(getMergeStrategy, target, source);
33 |     expect(result).toEqual({ a: [3, 4] });
34 |   });
35 | 
36 |   it('should concatenate arrays with CONCAT strategy', () => {
37 |     const target = { a: [1, 2] };
38 |     const source = { a: [3, 4] };
39 |     const getMergeStrategy = (path: string[]) =>
40 |       path.join('.') === 'a' ? MergeStrategy.CONCAT : undefined;
41 |     const result = customDeepMerge(getMergeStrategy, target, source);
42 |     expect(result).toEqual({ a: [1, 2, 3, 4] });
43 |   });
44 | 
45 |   it('should union arrays with UNION strategy', () => {
46 |     const target = { a: [1, 2, 3] };
47 |     const source = { a: [3, 4, 5] };
48 |     const getMergeStrategy = (path: string[]) =>
49 |       path.join('.') === 'a' ? MergeStrategy.UNION : undefined;
50 |     const result = customDeepMerge(getMergeStrategy, target, source);
51 |     expect(result).toEqual({ a: [1, 2, 3, 4, 5] });
52 |   });
53 | 
54 |   it('should shallow merge objects with SHALLOW_MERGE strategy', () => {
55 |     const target = { a: { x: 1, y: 1 } };
56 |     const source = { a: { y: 2, z: 2 } };
57 |     const getMergeStrategy = (path: string[]) =>
58 |       path.join('.') === 'a' ? MergeStrategy.SHALLOW_MERGE : undefined;
59 |     const result = customDeepMerge(getMergeStrategy, target, source);
60 |     // This is still a deep merge, but the properties of the object are merged.
61 |     expect(result).toEqual({ a: { x: 1, y: 2, z: 2 } });
62 |   });
63 | 
64 |   it('should handle multiple source objects', () => {
65 |     const target = { a: 1 };
66 |     const source1 = { b: 2 };
67 |     const source2 = { c: 3 };
68 |     const getMergeStrategy = () => undefined;
69 |     const result = customDeepMerge(getMergeStrategy, target, source1, source2);
70 |     expect(result).toEqual({ a: 1, b: 2, c: 3 });
71 |   });
72 | 
73 |   it('should return an empty object if no sources are provided', () => {
74 |     const getMergeStrategy = () => undefined;
75 |     const result = customDeepMerge(getMergeStrategy);
76 |     expect(result).toEqual({});
77 |   });
78 | 
79 |   it('should return a deep copy of the first source if only one is provided', () => {
80 |     const target = { a: { b: 1 } };
81 |     const getMergeStrategy = () => undefined;
82 |     const result = customDeepMerge(getMergeStrategy, target);
83 |     expect(result).toEqual(target);
84 |     expect(result).not.toBe(target);
85 |   });
86 | 
87 |   it('should not mutate the original source objects', () => {
88 |     const target = { a: { x: 1 }, b: [1, 2] };
89 |     const source = { a: { y: 2 }, b: [3, 4] };
90 |     const originalTarget = JSON.parse(JSON.stringify(target));
91 |     const originalSource = JSON.parse(JSON.stringify(source));
92 |     const getMergeStrategy = () => undefined;
93 | 
94 |     customDeepMerge(getMergeStrategy, target, source);
95 | 
96 |     expect(target).toEqual(originalTarget);
97 |     expect(source).toEqual(originalSource);
98 |   });
99 | 
100 |   it('should not mutate sources when merging multiple levels deep', () => {
101 |     const s1 = { data: { common: { val: 'from s1' }, s1_only: true } };
102 |     const s2 = { data: { common: { val: 'from s2' }, s2_only: true } };
103 |     const s1_original = JSON.parse(JSON.stringify(s1));
104 |     const s2_original = JSON.parse(JSON.stringify(s2));
105 | 
106 |     const getMergeStrategy = () => undefined;
107 |     const result = customDeepMerge(getMergeStrategy, s1, s2);
108 | 
109 |     expect(s1).toEqual(s1_original);
110 |     expect(s2).toEqual(s2_original);
111 |     expect(result).toEqual({
112 |       data: {
113 |         common: { val: 'from s2' },
114 |         s1_only: true,
115 |         s2_only: true,
116 |       },
117 |     });
118 |   });
119 | 
120 |   it('should handle complex nested strategies', () => {
121 |     const target = {
122 |       level1: {
123 |         arr1: [1, 2],
124 |         arr2: [1, 2],
125 |         obj1: { a: 1 },
126 |       },
127 |     };
128 |     const source = {
129 |       level1: {
130 |         arr1: [3, 4],
131 |         arr2: [2, 3],
132 |         obj1: { b: 2 },
133 |       },
134 |     };
135 |     const getMergeStrategy = (path: string[]) => {
136 |       const p = path.join('.');
137 |       if (p === 'level1.arr1') return MergeStrategy.CONCAT;
138 |       if (p === 'level1.arr2') return MergeStrategy.UNION;
139 |       if (p === 'level1.obj1') return MergeStrategy.SHALLOW_MERGE;
140 |       return undefined;
141 |     };
142 | 
143 |     const result = customDeepMerge(getMergeStrategy, target, source);
144 | 
145 |     expect(result).toEqual({
146 |       level1: {
147 |         arr1: [1, 2, 3, 4],
148 |         arr2: [1, 2, 3],
149 |         obj1: { a: 1, b: 2 },
150 |       },
151 |     });
152 |   });
153 | 
154 |   it('should not pollute the prototype', () => {
155 |     const maliciousSource = JSON.parse('{"__proto__": {"polluted": "true"}}');
156 |     const getMergeStrategy = () => undefined;
157 |     const result = customDeepMerge(getMergeStrategy, {}, maliciousSource);
158 | 
159 |     expect(result).toEqual({});
160 |     // eslint-disable-next-line @typescript-eslint/no-explicit-any
161 |     expect(({} as any).polluted).toBeUndefined();
162 |   });
163 | });
```

src/utils/deepMerge.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { MergeStrategy } from '../config/settingsSchema.js';
8 | 
9 | export type Mergeable =
10 |   | string
11 |   | number
12 |   | boolean
13 |   | null
14 |   | undefined
15 |   | object
16 |   | Mergeable[];
17 | 
18 | export type MergeableObject = Record<string, Mergeable>;
19 | 
20 | function isPlainObject(item: unknown): item is MergeableObject {
21 |   return !!item && typeof item === 'object' && !Array.isArray(item);
22 | }
23 | 
24 | function mergeRecursively(
25 |   target: MergeableObject,
26 |   source: MergeableObject,
27 |   getMergeStrategyForPath: (path: string[]) => MergeStrategy | undefined,
28 |   path: string[] = [],
29 | ) {
30 |   for (const key of Object.keys(source)) {
31 |     if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
32 |       continue;
33 |     }
34 |     const newPath = [...path, key];
35 |     const srcValue = source[key];
36 |     const objValue = target[key];
37 |     const mergeStrategy = getMergeStrategyForPath(newPath);
38 | 
39 |     if (mergeStrategy === MergeStrategy.SHALLOW_MERGE && objValue && srcValue) {
40 |       const obj1 =
41 |         typeof objValue === 'object' && objValue !== null ? objValue : {};
42 |       const obj2 =
43 |         typeof srcValue === 'object' && srcValue !== null ? srcValue : {};
44 |       target[key] = { ...obj1, ...obj2 };
45 |       continue;
46 |     }
47 | 
48 |     if (Array.isArray(objValue)) {
49 |       const srcArray = Array.isArray(srcValue) ? srcValue : [srcValue];
50 |       if (mergeStrategy === MergeStrategy.CONCAT) {
51 |         target[key] = objValue.concat(srcArray);
52 |         continue;
53 |       }
54 |       if (mergeStrategy === MergeStrategy.UNION) {
55 |         target[key] = [...new Set(objValue.concat(srcArray))];
56 |         continue;
57 |       }
58 |     }
59 | 
60 |     if (isPlainObject(objValue) && isPlainObject(srcValue)) {
61 |       mergeRecursively(objValue, srcValue, getMergeStrategyForPath, newPath);
62 |     } else if (isPlainObject(srcValue)) {
63 |       target[key] = {};
64 |       mergeRecursively(
65 |         target[key] as MergeableObject,
66 |         srcValue,
67 |         getMergeStrategyForPath,
68 |         newPath,
69 |       );
70 |     } else {
71 |       target[key] = srcValue;
72 |     }
73 |   }
74 |   return target;
75 | }
76 | 
77 | export function customDeepMerge(
78 |   getMergeStrategyForPath: (path: string[]) => MergeStrategy | undefined,
79 |   ...sources: MergeableObject[]
80 | ): MergeableObject {
81 |   const result: MergeableObject = {};
82 | 
83 |   for (const source of sources) {
84 |     if (source) {
85 |       mergeRecursively(result, source, getMergeStrategyForPath);
86 |     }
87 |   }
88 | 
89 |   return result;
90 | }
```

src/utils/dialogScopeUtils.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type { LoadedSettings } from '../config/settings.js';
8 | import { SettingScope } from '../config/settings.js';
9 | import { settingExistsInScope } from './settingsUtils.js';
10 | 
11 | /**
12 |  * Shared scope labels for dialog components that need to display setting scopes
13 |  */
14 | export const SCOPE_LABELS = {
15 |   [SettingScope.User]: 'User Settings',
16 |   [SettingScope.Workspace]: 'Workspace Settings',
17 |   [SettingScope.System]: 'System Settings',
18 | } as const;
19 | 
20 | /**
21 |  * Helper function to get scope items for radio button selects
22 |  */
23 | export function getScopeItems() {
24 |   return [
25 |     { label: SCOPE_LABELS[SettingScope.User], value: SettingScope.User },
26 |     {
27 |       label: SCOPE_LABELS[SettingScope.Workspace],
28 |       value: SettingScope.Workspace,
29 |     },
30 |     { label: SCOPE_LABELS[SettingScope.System], value: SettingScope.System },
31 |   ];
32 | }
33 | 
34 | /**
35 |  * Generate scope message for a specific setting
36 |  */
37 | export function getScopeMessageForSetting(
38 |   settingKey: string,
39 |   selectedScope: SettingScope,
40 |   settings: LoadedSettings,
41 | ): string {
42 |   const otherScopes = Object.values(SettingScope).filter(
43 |     (scope) => scope !== selectedScope,
44 |   );
45 | 
46 |   const modifiedInOtherScopes = otherScopes.filter((scope) => {
47 |     const scopeSettings = settings.forScope(scope).settings;
48 |     return settingExistsInScope(settingKey, scopeSettings);
49 |   });
50 | 
51 |   if (modifiedInOtherScopes.length === 0) {
52 |     return '';
53 |   }
54 | 
55 |   const modifiedScopesStr = modifiedInOtherScopes.join(', ');
56 |   const currentScopeSettings = settings.forScope(selectedScope).settings;
57 |   const existsInCurrentScope = settingExistsInScope(
58 |     settingKey,
59 |     currentScopeSettings,
60 |   );
61 | 
62 |   return existsInCurrentScope
63 |     ? `(Also modified in ${modifiedScopesStr})`
64 |     : `(Modified in ${modifiedScopesStr})`;
65 | }
```

src/utils/envVarResolver.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect, beforeEach, afterEach } from 'vitest';
8 | import {
9 |   resolveEnvVarsInString,
10 |   resolveEnvVarsInObject,
11 | } from './envVarResolver.js';
12 | 
13 | describe('resolveEnvVarsInString', () => {
14 |   let originalEnv: NodeJS.ProcessEnv;
15 | 
16 |   beforeEach(() => {
17 |     originalEnv = { ...process.env };
18 |   });
19 | 
20 |   afterEach(() => {
21 |     process.env = originalEnv;
22 |   });
23 | 
24 |   it('should resolve $VAR_NAME format', () => {
25 |     process.env['TEST_VAR'] = 'test-value';
26 | 
27 |     const result = resolveEnvVarsInString('Value is $TEST_VAR');
28 | 
29 |     expect(result).toBe('Value is test-value');
30 |   });
31 | 
32 |   it('should resolve ${VAR_NAME} format', () => {
33 |     process.env['TEST_VAR'] = 'test-value';
34 | 
35 |     const result = resolveEnvVarsInString('Value is ${TEST_VAR}');
36 | 
37 |     expect(result).toBe('Value is test-value');
38 |   });
39 | 
40 |   it('should resolve multiple variables in the same string', () => {
41 |     process.env['HOST'] = 'localhost';
42 |     process.env['PORT'] = '3000';
43 | 
44 |     const result = resolveEnvVarsInString('URL: http://$HOST:${PORT}/api');
45 | 
46 |     expect(result).toBe('URL: http://localhost:3000/api');
47 |   });
48 | 
49 |   it('should leave undefined variables unchanged', () => {
50 |     const result = resolveEnvVarsInString('Value is $UNDEFINED_VAR');
51 | 
52 |     expect(result).toBe('Value is $UNDEFINED_VAR');
53 |   });
54 | 
55 |   it('should leave undefined variables with braces unchanged', () => {
56 |     const result = resolveEnvVarsInString('Value is ${UNDEFINED_VAR}');
57 | 
58 |     expect(result).toBe('Value is ${UNDEFINED_VAR}');
59 |   });
60 | 
61 |   it('should handle empty string', () => {
62 |     const result = resolveEnvVarsInString('');
63 | 
64 |     expect(result).toBe('');
65 |   });
66 | 
67 |   it('should handle string without variables', () => {
68 |     const result = resolveEnvVarsInString('No variables here');
69 | 
70 |     expect(result).toBe('No variables here');
71 |   });
72 | 
73 |   it('should handle mixed defined and undefined variables', () => {
74 |     process.env['DEFINED'] = 'value';
75 | 
76 |     const result = resolveEnvVarsInString('$DEFINED and $UNDEFINED mixed');
77 | 
78 |     expect(result).toBe('value and $UNDEFINED mixed');
79 |   });
80 | });
81 | 
82 | describe('resolveEnvVarsInObject', () => {
83 |   let originalEnv: NodeJS.ProcessEnv;
84 | 
85 |   beforeEach(() => {
86 |     originalEnv = { ...process.env };
87 |   });
88 | 
89 |   afterEach(() => {
90 |     process.env = originalEnv;
91 |   });
92 | 
93 |   it('should resolve variables in nested objects', () => {
94 |     process.env['API_KEY'] = 'secret-123';
95 |     process.env['DB_URL'] = 'postgresql://localhost/test';
96 | 
97 |     const config = {
98 |       server: {
99 |         auth: {
100 |           key: '$API_KEY',
101 |         },
102 |         database: '${DB_URL}',
103 |       },
104 |       port: 3000,
105 |     };
106 | 
107 |     const result = resolveEnvVarsInObject(config);
108 | 
109 |     expect(result).toEqual({
110 |       server: {
111 |         auth: {
112 |           key: 'secret-123',
113 |         },
114 |         database: 'postgresql://localhost/test',
115 |       },
116 |       port: 3000,
117 |     });
118 |   });
119 | 
120 |   it('should resolve variables in arrays', () => {
121 |     process.env['ENV'] = 'production';
122 |     process.env['VERSION'] = '1.0.0';
123 | 
124 |     const config = {
125 |       tags: ['$ENV', 'app', '${VERSION}'],
126 |       metadata: {
127 |         env: '$ENV',
128 |       },
129 |     };
130 | 
131 |     const result = resolveEnvVarsInObject(config);
132 | 
133 |     expect(result).toEqual({
134 |       tags: ['production', 'app', '1.0.0'],
135 |       metadata: {
136 |         env: 'production',
137 |       },
138 |     });
139 |   });
140 | 
141 |   it('should preserve non-string types', () => {
142 |     const config = {
143 |       enabled: true,
144 |       count: 42,
145 |       value: null,
146 |       data: undefined,
147 |       tags: ['item1', 'item2'],
148 |     };
149 | 
150 |     const result = resolveEnvVarsInObject(config);
151 | 
152 |     expect(result).toEqual(config);
153 |   });
154 | 
155 |   it('should handle MCP server config structure', () => {
156 |     process.env['API_TOKEN'] = 'token-123';
157 |     process.env['SERVER_PORT'] = '8080';
158 | 
159 |     const extensionConfig = {
160 |       name: 'test-extension',
161 |       version: '1.0.0',
162 |       mcpServers: {
163 |         'test-server': {
164 |           command: 'node',
165 |           args: ['server.js', '--port', '${SERVER_PORT}'],
166 |           env: {
167 |             API_KEY: '$API_TOKEN',
168 |             STATIC_VALUE: 'unchanged',
169 |           },
170 |           timeout: 5000,
171 |         },
172 |       },
173 |     };
174 | 
175 |     const result = resolveEnvVarsInObject(extensionConfig);
176 | 
177 |     expect(result).toEqual({
178 |       name: 'test-extension',
179 |       version: '1.0.0',
180 |       mcpServers: {
181 |         'test-server': {
182 |           command: 'node',
183 |           args: ['server.js', '--port', '8080'],
184 |           env: {
185 |             API_KEY: 'token-123',
186 |             STATIC_VALUE: 'unchanged',
187 |           },
188 |           timeout: 5000,
189 |         },
190 |       },
191 |     });
192 |   });
193 | 
194 |   it('should handle empty and null values', () => {
195 |     const config = {
196 |       empty: '',
197 |       nullValue: null,
198 |       undefinedValue: undefined,
199 |       zero: 0,
200 |       false: false,
201 |     };
202 | 
203 |     const result = resolveEnvVarsInObject(config);
204 | 
205 |     expect(result).toEqual(config);
206 |   });
207 | 
208 |   it('should handle circular references in objects without infinite recursion', () => {
209 |     process.env['TEST_VAR'] = 'resolved-value';
210 | 
211 |     type ConfigWithCircularRef = {
212 |       name: string;
213 |       value: number;
214 |       self?: ConfigWithCircularRef;
215 |     };
216 | 
217 |     const config: ConfigWithCircularRef = {
218 |       name: '$TEST_VAR',
219 |       value: 42,
220 |     };
221 |     // Create circular reference
222 |     config.self = config;
223 | 
224 |     const result = resolveEnvVarsInObject(config);
225 | 
226 |     expect(result.name).toBe('resolved-value');
227 |     expect(result.value).toBe(42);
228 |     expect(result.self).toBeDefined();
229 |     expect(result.self?.name).toBe('$TEST_VAR'); // Circular reference should be shallow copied
230 |     expect(result.self?.value).toBe(42);
231 |     // Verify it doesn't create infinite recursion by checking it's not the same object
232 |     expect(result.self).not.toBe(result);
233 |   });
234 | 
235 |   it('should handle circular references in arrays without infinite recursion', () => {
236 |     process.env['ARRAY_VAR'] = 'array-value';
237 | 
238 |     type ArrayWithCircularRef = Array<string | number | ArrayWithCircularRef>;
239 |     const arr: ArrayWithCircularRef = ['$ARRAY_VAR', 123];
240 |     // Create circular reference
241 |     arr.push(arr);
242 | 
243 |     const result = resolveEnvVarsInObject(arr) as ArrayWithCircularRef;
244 | 
245 |     expect(result[0]).toBe('array-value');
246 |     expect(result[1]).toBe(123);
247 |     expect(Array.isArray(result[2])).toBe(true);
248 |     const subArray = result[2] as ArrayWithCircularRef;
249 |     expect(subArray[0]).toBe('$ARRAY_VAR'); // Circular reference should be shallow copied
250 |     expect(subArray[1]).toBe(123);
251 |     // Verify it doesn't create infinite recursion
252 |     expect(result[2]).not.toBe(result);
253 |   });
254 | 
255 |   it('should handle complex nested circular references', () => {
256 |     process.env['NESTED_VAR'] = 'nested-resolved';
257 | 
258 |     type ObjWithRef = {
259 |       name: string;
260 |       id: number;
261 |       ref?: ObjWithRef;
262 |     };
263 | 
264 |     const obj1: ObjWithRef = { name: '$NESTED_VAR', id: 1 };
265 |     const obj2: ObjWithRef = { name: 'static', id: 2 };
266 | 
267 |     // Create cross-references
268 |     obj1.ref = obj2;
269 |     obj2.ref = obj1;
270 | 
271 |     const config = {
272 |       primary: obj1,
273 |       secondary: obj2,
274 |       value: '$NESTED_VAR',
275 |     };
276 | 
277 |     const result = resolveEnvVarsInObject(config);
278 | 
279 |     expect(result.value).toBe('nested-resolved');
280 |     expect(result.primary.name).toBe('nested-resolved');
281 |     expect(result.primary.id).toBe(1);
282 |     expect(result.secondary.name).toBe('static');
283 |     expect(result.secondary.id).toBe(2);
284 | 
285 |     // Check that circular references are handled (shallow copied)
286 |     expect(result.primary.ref).toBeDefined();
287 |     expect(result.secondary.ref).toBeDefined();
288 |     expect(result.primary.ref?.name).toBe('static'); // Should be shallow copy
289 |     expect(result.secondary.ref?.name).toBe('nested-resolved'); // The shallow copy still gets processed
290 | 
291 |     // Most importantly: verify no infinite recursion by checking objects are different
292 |     expect(result.primary.ref).not.toBe(result.secondary);
293 |     expect(result.secondary.ref).not.toBe(result.primary);
294 |     expect(result.primary).not.toBe(obj1); // New object created
295 |     expect(result.secondary).not.toBe(obj2); // New object created
296 |   });
297 | });
```

src/utils/envVarResolver.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | /**
8 |  * Resolves environment variables in a string.
9 |  * Replaces $VAR_NAME and ${VAR_NAME} with their corresponding environment variable values.
10 |  * If the environment variable is not defined, the original placeholder is preserved.
11 |  *
12 |  * @param value - The string that may contain environment variable placeholders
13 |  * @returns The string with environment variables resolved
14 |  *
15 |  * @example
16 |  * resolveEnvVarsInString("Token: $API_KEY") // Returns "Token: secret-123"
17 |  * resolveEnvVarsInString("URL: ${BASE_URL}/api") // Returns "URL: https://api.example.com/api"
18 |  * resolveEnvVarsInString("Missing: $UNDEFINED_VAR") // Returns "Missing: $UNDEFINED_VAR"
19 |  */
20 | export function resolveEnvVarsInString(value: string): string {
21 |   const envVarRegex = /\$(?:(\w+)|{([^}]+)})/g; // Find $VAR_NAME or ${VAR_NAME}
22 |   return value.replace(envVarRegex, (match, varName1, varName2) => {
23 |     const varName = varName1 || varName2;
24 |     if (process && process.env && typeof process.env[varName] === 'string') {
25 |       return process.env[varName]!;
26 |     }
27 |     return match;
28 |   });
29 | }
30 | 
31 | /**
32 |  * Recursively resolves environment variables in an object of any type.
33 |  * Handles strings, arrays, nested objects, and preserves other primitive types.
34 |  * Protected against circular references using a WeakSet to track visited objects.
35 |  *
36 |  * @param obj - The object to process for environment variable resolution
37 |  * @returns A new object with environment variables resolved
38 |  *
39 |  * @example
40 |  * const config = {
41 |  *   server: {
42 |  *     host: "$HOST",
43 |  *     port: "${PORT}",
44 |  *     enabled: true,
45 |  *     tags: ["$ENV", "api"]
46 |  *   }
47 |  * };
48 |  * const resolved = resolveEnvVarsInObject(config);
49 |  */
50 | export function resolveEnvVarsInObject<T>(obj: T): T {
51 |   return resolveEnvVarsInObjectInternal(obj, new WeakSet());
52 | }
53 | 
54 | /**
55 |  * Internal implementation of resolveEnvVarsInObject with circular reference protection.
56 |  *
57 |  * @param obj - The object to process
58 |  * @param visited - WeakSet to track visited objects and prevent circular references
59 |  * @returns A new object with environment variables resolved
60 |  */
61 | function resolveEnvVarsInObjectInternal<T>(
62 |   obj: T,
63 |   visited: WeakSet<object>,
64 | ): T {
65 |   if (
66 |     obj === null ||
67 |     obj === undefined ||
68 |     typeof obj === 'boolean' ||
69 |     typeof obj === 'number'
70 |   ) {
71 |     return obj;
72 |   }
73 | 
74 |   if (typeof obj === 'string') {
75 |     return resolveEnvVarsInString(obj) as unknown as T;
76 |   }
77 | 
78 |   if (Array.isArray(obj)) {
79 |     // Check for circular reference
80 |     if (visited.has(obj)) {
81 |       // Return a shallow copy to break the cycle
82 |       return [...obj] as unknown as T;
83 |     }
84 | 
85 |     visited.add(obj);
86 |     const result = obj.map((item) =>
87 |       resolveEnvVarsInObjectInternal(item, visited),
88 |     ) as unknown as T;
89 |     visited.delete(obj);
90 |     return result;
91 |   }
92 | 
93 |   if (typeof obj === 'object') {
94 |     // Check for circular reference
95 |     if (visited.has(obj as object)) {
96 |       // Return a shallow copy to break the cycle
97 |       return { ...obj } as T;
98 |     }
99 | 
100 |     visited.add(obj as object);
101 |     const newObj = { ...obj } as T;
102 |     for (const key in newObj) {
103 |       if (Object.prototype.hasOwnProperty.call(newObj, key)) {
104 |         newObj[key] = resolveEnvVarsInObjectInternal(newObj[key], visited);
105 |       }
106 |     }
107 |     visited.delete(obj as object);
108 |     return newObj;
109 |   }
110 | 
111 |   return obj;
112 | }
```

src/utils/errors.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { vi, type MockInstance } from 'vitest';
8 | import type { Config } from '@google/gemini-cli-core';
9 | import { OutputFormat, FatalInputError } from '@google/gemini-cli-core';
10 | import {
11 |   getErrorMessage,
12 |   handleError,
13 |   handleToolError,
14 |   handleCancellationError,
15 |   handleMaxTurnsExceededError,
16 | } from './errors.js';
17 | 
18 | // Mock the core modules
19 | vi.mock('@google/gemini-cli-core', async (importOriginal) => {
20 |   const original =
21 |     await importOriginal<typeof import('@google/gemini-cli-core')>();
22 | 
23 |   return {
24 |     ...original,
25 |     parseAndFormatApiError: vi.fn((error: unknown) => {
26 |       if (error instanceof Error) {
27 |         return `API Error: ${error.message}`;
28 |       }
29 |       return `API Error: ${String(error)}`;
30 |     }),
31 |     JsonFormatter: vi.fn().mockImplementation(() => ({
32 |       formatError: vi.fn((error: Error, code?: string | number) =>
33 |         JSON.stringify(
34 |           {
35 |             error: {
36 |               type: error.constructor.name,
37 |               message: error.message,
38 |               ...(code && { code }),
39 |             },
40 |           },
41 |           null,
42 |           2,
43 |         ),
44 |       ),
45 |     })),
46 |     FatalToolExecutionError: class extends Error {
47 |       constructor(message: string) {
48 |         super(message);
49 |         this.name = 'FatalToolExecutionError';
50 |         this.exitCode = 54;
51 |       }
52 |       exitCode: number;
53 |     },
54 |     FatalCancellationError: class extends Error {
55 |       constructor(message: string) {
56 |         super(message);
57 |         this.name = 'FatalCancellationError';
58 |         this.exitCode = 130;
59 |       }
60 |       exitCode: number;
61 |     },
62 |   };
63 | });
64 | 
65 | describe('errors', () => {
66 |   let mockConfig: Config;
67 |   let processExitSpy: MockInstance;
68 |   let consoleErrorSpy: MockInstance;
69 | 
70 |   beforeEach(() => {
71 |     // Reset mocks
72 |     vi.clearAllMocks();
73 | 
74 |     // Mock console.error
75 |     consoleErrorSpy = vi.spyOn(console, 'error').mockImplementation(() => {});
76 | 
77 |     // Mock process.exit to throw instead of actually exiting
78 |     processExitSpy = vi.spyOn(process, 'exit').mockImplementation((code) => {
79 |       throw new Error(`process.exit called with code: ${code}`);
80 |     });
81 | 
82 |     // Create mock config
83 |     mockConfig = {
84 |       getOutputFormat: vi.fn().mockReturnValue(OutputFormat.TEXT),
85 |       getContentGeneratorConfig: vi.fn().mockReturnValue({ authType: 'test' }),
86 |     } as unknown as Config;
87 |   });
88 | 
89 |   afterEach(() => {
90 |     consoleErrorSpy.mockRestore();
91 |     processExitSpy.mockRestore();
92 |   });
93 | 
94 |   describe('getErrorMessage', () => {
95 |     it('should return error message for Error instances', () => {
96 |       const error = new Error('Test error message');
97 |       expect(getErrorMessage(error)).toBe('Test error message');
98 |     });
99 | 
100 |     it('should convert non-Error values to strings', () => {
101 |       expect(getErrorMessage('string error')).toBe('string error');
102 |       expect(getErrorMessage(123)).toBe('123');
103 |       expect(getErrorMessage(null)).toBe('null');
104 |       expect(getErrorMessage(undefined)).toBe('undefined');
105 |     });
106 | 
107 |     it('should handle objects', () => {
108 |       const obj = { message: 'test' };
109 |       expect(getErrorMessage(obj)).toBe('[object Object]');
110 |     });
111 |   });
112 | 
113 |   describe('handleError', () => {
114 |     describe('in text mode', () => {
115 |       beforeEach(() => {
116 |         (
117 |           mockConfig.getOutputFormat as ReturnType<typeof vi.fn>
118 |         ).mockReturnValue(OutputFormat.TEXT);
119 |       });
120 | 
121 |       it('should log error message and re-throw', () => {
122 |         const testError = new Error('Test error');
123 | 
124 |         expect(() => {
125 |           handleError(testError, mockConfig);
126 |         }).toThrow(testError);
127 | 
128 |         expect(consoleErrorSpy).toHaveBeenCalledWith('API Error: Test error');
129 |       });
130 | 
131 |       it('should handle non-Error objects', () => {
132 |         const testError = 'String error';
133 | 
134 |         expect(() => {
135 |           handleError(testError, mockConfig);
136 |         }).toThrow(testError);
137 | 
138 |         expect(consoleErrorSpy).toHaveBeenCalledWith('API Error: String error');
139 |       });
140 |     });
141 | 
142 |     describe('in JSON mode', () => {
143 |       beforeEach(() => {
144 |         (
145 |           mockConfig.getOutputFormat as ReturnType<typeof vi.fn>
146 |         ).mockReturnValue(OutputFormat.JSON);
147 |       });
148 | 
149 |       it('should format error as JSON and exit with default code', () => {
150 |         const testError = new Error('Test error');
151 | 
152 |         expect(() => {
153 |           handleError(testError, mockConfig);
154 |         }).toThrow('process.exit called with code: 1');
155 | 
156 |         expect(consoleErrorSpy).toHaveBeenCalledWith(
157 |           JSON.stringify(
158 |             {
159 |               error: {
160 |                 type: 'Error',
161 |                 message: 'Test error',
162 |                 code: 1,
163 |               },
164 |             },
165 |             null,
166 |             2,
167 |           ),
168 |         );
169 |       });
170 | 
171 |       it('should use custom error code when provided', () => {
172 |         const testError = new Error('Test error');
173 | 
174 |         expect(() => {
175 |           handleError(testError, mockConfig, 42);
176 |         }).toThrow('process.exit called with code: 42');
177 | 
178 |         expect(consoleErrorSpy).toHaveBeenCalledWith(
179 |           JSON.stringify(
180 |             {
181 |               error: {
182 |                 type: 'Error',
183 |                 message: 'Test error',
184 |                 code: 42,
185 |               },
186 |             },
187 |             null,
188 |             2,
189 |           ),
190 |         );
191 |       });
192 | 
193 |       it('should extract exitCode from FatalError instances', () => {
194 |         const fatalError = new FatalInputError('Fatal error');
195 | 
196 |         expect(() => {
197 |           handleError(fatalError, mockConfig);
198 |         }).toThrow('process.exit called with code: 42');
199 | 
200 |         expect(consoleErrorSpy).toHaveBeenCalledWith(
201 |           JSON.stringify(
202 |             {
203 |               error: {
204 |                 type: 'FatalInputError',
205 |                 message: 'Fatal error',
206 |                 code: 42,
207 |               },
208 |             },
209 |             null,
210 |             2,
211 |           ),
212 |         );
213 |       });
214 | 
215 |       it('should handle error with code property', () => {
216 |         const errorWithCode = new Error('Error with code') as Error & {
217 |           code: number;
218 |         };
219 |         errorWithCode.code = 404;
220 | 
221 |         expect(() => {
222 |           handleError(errorWithCode, mockConfig);
223 |         }).toThrow('process.exit called with code: 404');
224 |       });
225 | 
226 |       it('should handle error with status property', () => {
227 |         const errorWithStatus = new Error('Error with status') as Error & {
228 |           status: string;
229 |         };
230 |         errorWithStatus.status = 'TIMEOUT';
231 | 
232 |         expect(() => {
233 |           handleError(errorWithStatus, mockConfig);
234 |         }).toThrow('process.exit called with code: 1'); // string codes become 1
235 | 
236 |         expect(consoleErrorSpy).toHaveBeenCalledWith(
237 |           JSON.stringify(
238 |             {
239 |               error: {
240 |                 type: 'Error',
241 |                 message: 'Error with status',
242 |                 code: 'TIMEOUT',
243 |               },
244 |             },
245 |             null,
246 |             2,
247 |           ),
248 |         );
249 |       });
250 |     });
251 |   });
252 | 
253 |   describe('handleToolError', () => {
254 |     const toolName = 'test-tool';
255 |     const toolError = new Error('Tool failed');
256 | 
257 |     describe('in text mode', () => {
258 |       beforeEach(() => {
259 |         (
260 |           mockConfig.getOutputFormat as ReturnType<typeof vi.fn>
261 |         ).mockReturnValue(OutputFormat.TEXT);
262 |       });
263 | 
264 |       it('should log error message to stderr', () => {
265 |         handleToolError(toolName, toolError, mockConfig);
266 | 
267 |         expect(consoleErrorSpy).toHaveBeenCalledWith(
268 |           'Error executing tool test-tool: Tool failed',
269 |         );
270 |       });
271 | 
272 |       it('should use resultDisplay when provided', () => {
273 |         handleToolError(
274 |           toolName,
275 |           toolError,
276 |           mockConfig,
277 |           'CUSTOM_ERROR',
278 |           'Custom display message',
279 |         );
280 | 
281 |         expect(consoleErrorSpy).toHaveBeenCalledWith(
282 |           'Error executing tool test-tool: Custom display message',
283 |         );
284 |       });
285 |     });
286 | 
287 |     describe('in JSON mode', () => {
288 |       beforeEach(() => {
289 |         (
290 |           mockConfig.getOutputFormat as ReturnType<typeof vi.fn>
291 |         ).mockReturnValue(OutputFormat.JSON);
292 |       });
293 | 
294 |       describe('non-fatal errors', () => {
295 |         it('should log error message to stderr without exiting for recoverable errors', () => {
296 |           handleToolError(
297 |             toolName,
298 |             toolError,
299 |             mockConfig,
300 |             'invalid_tool_params',
301 |           );
302 | 
303 |           expect(consoleErrorSpy).toHaveBeenCalledWith(
304 |             'Error executing tool test-tool: Tool failed',
305 |           );
306 |           // Should not exit for non-fatal errors
307 |           expect(processExitSpy).not.toHaveBeenCalled();
308 |         });
309 | 
310 |         it('should not exit for file not found errors', () => {
311 |           handleToolError(toolName, toolError, mockConfig, 'file_not_found');
312 | 
313 |           expect(consoleErrorSpy).toHaveBeenCalledWith(
314 |             'Error executing tool test-tool: Tool failed',
315 |           );
316 |           expect(processExitSpy).not.toHaveBeenCalled();
317 |         });
318 | 
319 |         it('should not exit for permission denied errors', () => {
320 |           handleToolError(toolName, toolError, mockConfig, 'permission_denied');
321 | 
322 |           expect(consoleErrorSpy).toHaveBeenCalledWith(
323 |             'Error executing tool test-tool: Tool failed',
324 |           );
325 |           expect(processExitSpy).not.toHaveBeenCalled();
326 |         });
327 | 
328 |         it('should not exit for path not in workspace errors', () => {
329 |           handleToolError(
330 |             toolName,
331 |             toolError,
332 |             mockConfig,
333 |             'path_not_in_workspace',
334 |           );
335 | 
336 |           expect(consoleErrorSpy).toHaveBeenCalledWith(
337 |             'Error executing tool test-tool: Tool failed',
338 |           );
339 |           expect(processExitSpy).not.toHaveBeenCalled();
340 |         });
341 | 
342 |         it('should prefer resultDisplay over error message', () => {
343 |           handleToolError(
344 |             toolName,
345 |             toolError,
346 |             mockConfig,
347 |             'invalid_tool_params',
348 |             'Display message',
349 |           );
350 | 
351 |           expect(consoleErrorSpy).toHaveBeenCalledWith(
352 |             'Error executing tool test-tool: Display message',
353 |           );
354 |           expect(processExitSpy).not.toHaveBeenCalled();
355 |         });
356 |       });
357 | 
358 |       describe('fatal errors', () => {
359 |         it('should exit immediately for NO_SPACE_LEFT errors', () => {
360 |           expect(() => {
361 |             handleToolError(toolName, toolError, mockConfig, 'no_space_left');
362 |           }).toThrow('process.exit called with code: 54');
363 | 
364 |           expect(consoleErrorSpy).toHaveBeenCalledWith(
365 |             JSON.stringify(
366 |               {
367 |                 error: {
368 |                   type: 'FatalToolExecutionError',
369 |                   message: 'Error executing tool test-tool: Tool failed',
370 |                   code: 'no_space_left',
371 |                 },
372 |               },
373 |               null,
374 |               2,
375 |             ),
376 |           );
377 |         });
378 |       });
379 |     });
380 |   });
381 | 
382 |   describe('handleCancellationError', () => {
383 |     describe('in text mode', () => {
384 |       beforeEach(() => {
385 |         (
386 |           mockConfig.getOutputFormat as ReturnType<typeof vi.fn>
387 |         ).mockReturnValue(OutputFormat.TEXT);
388 |       });
389 | 
390 |       it('should log cancellation message and exit with 130', () => {
391 |         expect(() => {
392 |           handleCancellationError(mockConfig);
393 |         }).toThrow('process.exit called with code: 130');
394 | 
395 |         expect(consoleErrorSpy).toHaveBeenCalledWith('Operation cancelled.');
396 |       });
397 |     });
398 | 
399 |     describe('in JSON mode', () => {
400 |       beforeEach(() => {
401 |         (
402 |           mockConfig.getOutputFormat as ReturnType<typeof vi.fn>
403 |         ).mockReturnValue(OutputFormat.JSON);
404 |       });
405 | 
406 |       it('should format cancellation as JSON and exit with 130', () => {
407 |         expect(() => {
408 |           handleCancellationError(mockConfig);
409 |         }).toThrow('process.exit called with code: 130');
410 | 
411 |         expect(consoleErrorSpy).toHaveBeenCalledWith(
412 |           JSON.stringify(
413 |             {
414 |               error: {
415 |                 type: 'FatalCancellationError',
416 |                 message: 'Operation cancelled.',
417 |                 code: 130,
418 |               },
419 |             },
420 |             null,
421 |             2,
422 |           ),
423 |         );
424 |       });
425 |     });
426 |   });
427 | 
428 |   describe('handleMaxTurnsExceededError', () => {
429 |     describe('in text mode', () => {
[TRUNCATED]
```

src/utils/errors.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type { Config } from '@google/gemini-cli-core';
8 | import {
9 |   OutputFormat,
10 |   JsonFormatter,
11 |   parseAndFormatApiError,
12 |   FatalTurnLimitedError,
13 |   FatalCancellationError,
14 |   FatalToolExecutionError,
15 |   isFatalToolError,
16 | } from '@google/gemini-cli-core';
17 | 
18 | export function getErrorMessage(error: unknown): string {
19 |   if (error instanceof Error) {
20 |     return error.message;
21 |   }
22 |   return String(error);
23 | }
24 | 
25 | interface ErrorWithCode extends Error {
26 |   exitCode?: number;
27 |   code?: string | number;
28 |   status?: string | number;
29 | }
30 | 
31 | /**
32 |  * Extracts the appropriate error code from an error object.
33 |  */
34 | function extractErrorCode(error: unknown): string | number {
35 |   const errorWithCode = error as ErrorWithCode;
36 | 
37 |   // Prioritize exitCode for FatalError types, fall back to other codes
38 |   if (typeof errorWithCode.exitCode === 'number') {
39 |     return errorWithCode.exitCode;
40 |   }
41 |   if (errorWithCode.code !== undefined) {
42 |     return errorWithCode.code;
43 |   }
44 |   if (errorWithCode.status !== undefined) {
45 |     return errorWithCode.status;
46 |   }
47 | 
48 |   return 1; // Default exit code
49 | }
50 | 
51 | /**
52 |  * Converts an error code to a numeric exit code.
53 |  */
54 | function getNumericExitCode(errorCode: string | number): number {
55 |   return typeof errorCode === 'number' ? errorCode : 1;
56 | }
57 | 
58 | /**
59 |  * Handles errors consistently for both JSON and text output formats.
60 |  * In JSON mode, outputs formatted JSON error and exits.
61 |  * In text mode, outputs error message and re-throws.
62 |  */
63 | export function handleError(
64 |   error: unknown,
65 |   config: Config,
66 |   customErrorCode?: string | number,
67 | ): never {
68 |   const errorMessage = parseAndFormatApiError(
69 |     error,
70 |     config.getContentGeneratorConfig()?.authType,
71 |   );
72 | 
73 |   if (config.getOutputFormat() === OutputFormat.JSON) {
74 |     const formatter = new JsonFormatter();
75 |     const errorCode = customErrorCode ?? extractErrorCode(error);
76 | 
77 |     const formattedError = formatter.formatError(
78 |       error instanceof Error ? error : new Error(getErrorMessage(error)),
79 |       errorCode,
80 |     );
81 | 
82 |     console.error(formattedError);
83 |     process.exit(getNumericExitCode(errorCode));
84 |   } else {
85 |     console.error(errorMessage);
86 |     throw error;
87 |   }
88 | }
89 | 
90 | /**
91 |  * Handles tool execution errors specifically.
92 |  *
93 |  * Fatal errors (e.g., NO_SPACE_LEFT) cause the CLI to exit immediately,
94 |  * as they indicate unrecoverable system state.
95 |  *
96 |  * Non-fatal errors (e.g., INVALID_TOOL_PARAMS, FILE_NOT_FOUND, PATH_NOT_IN_WORKSPACE)
97 |  * are logged to stderr and the error response is sent back to the model,
98 |  * allowing it to self-correct.
99 |  */
100 | export function handleToolError(
101 |   toolName: string,
102 |   toolError: Error,
103 |   config: Config,
104 |   errorType?: string,
105 |   resultDisplay?: string,
106 | ): void {
107 |   const errorMessage = `Error executing tool ${toolName}: ${resultDisplay || toolError.message}`;
108 | 
109 |   const isFatal = isFatalToolError(errorType);
110 | 
111 |   if (isFatal) {
112 |     const toolExecutionError = new FatalToolExecutionError(errorMessage);
113 |     if (config.getOutputFormat() === OutputFormat.JSON) {
114 |       const formatter = new JsonFormatter();
115 |       const formattedError = formatter.formatError(
116 |         toolExecutionError,
117 |         errorType ?? toolExecutionError.exitCode,
118 |       );
119 |       console.error(formattedError);
120 |     } else {
121 |       console.error(errorMessage);
122 |     }
123 |     process.exit(toolExecutionError.exitCode);
124 |   }
125 | 
126 |   // Non-fatal: log and continue
127 |   console.error(errorMessage);
128 | }
129 | 
130 | /**
131 |  * Handles cancellation/abort signals consistently.
132 |  */
133 | export function handleCancellationError(config: Config): never {
134 |   const cancellationError = new FatalCancellationError('Operation cancelled.');
135 | 
136 |   if (config.getOutputFormat() === OutputFormat.JSON) {
137 |     const formatter = new JsonFormatter();
138 |     const formattedError = formatter.formatError(
139 |       cancellationError,
140 |       cancellationError.exitCode,
141 |     );
142 | 
143 |     console.error(formattedError);
144 |     process.exit(cancellationError.exitCode);
145 |   } else {
146 |     console.error(cancellationError.message);
147 |     process.exit(cancellationError.exitCode);
148 |   }
149 | }
150 | 
151 | /**
152 |  * Handles max session turns exceeded consistently.
153 |  */
154 | export function handleMaxTurnsExceededError(config: Config): never {
155 |   const maxTurnsError = new FatalTurnLimitedError(
156 |     'Reached max session turns for this session. Increase the number of turns by specifying maxSessionTurns in settings.json.',
157 |   );
158 | 
159 |   if (config.getOutputFormat() === OutputFormat.JSON) {
160 |     const formatter = new JsonFormatter();
161 |     const formattedError = formatter.formatError(
162 |       maxTurnsError,
163 |       maxTurnsError.exitCode,
164 |     );
165 | 
166 |     console.error(formattedError);
167 |     process.exit(maxTurnsError.exitCode);
168 |   } else {
169 |     console.error(maxTurnsError.message);
170 |     process.exit(maxTurnsError.exitCode);
171 |   }
172 | }
```

src/utils/events.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { EventEmitter } from 'node:events';
8 | 
9 | export enum AppEvent {
10 |   OpenDebugConsole = 'open-debug-console',
11 |   LogError = 'log-error',
12 |   OauthDisplayMessage = 'oauth-display-message',
13 |   Flicker = 'flicker',
14 | }
15 | 
16 | export const appEvents = new EventEmitter();
```

src/utils/gitUtils.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { vi, describe, expect, it, afterEach, beforeEach } from 'vitest';
8 | import * as child_process from 'node:child_process';
9 | import {
10 |   isGitHubRepository,
11 |   getGitRepoRoot,
12 |   getLatestGitHubRelease,
13 |   getGitHubRepoInfo,
14 | } from './gitUtils.js';
15 | 
16 | vi.mock('child_process');
17 | 
18 | describe('isGitHubRepository', async () => {
19 |   beforeEach(() => {
20 |     vi.resetAllMocks();
21 |   });
22 | 
23 |   afterEach(() => {
24 |     vi.restoreAllMocks();
25 |   });
26 | 
27 |   it('returns false if the git command fails', async () => {
28 |     vi.mocked(child_process.execSync).mockImplementation((): string => {
29 |       throw new Error('oops');
30 |     });
31 |     expect(isGitHubRepository()).toBe(false);
32 |   });
33 | 
34 |   it('returns false if the remote is not github.com', async () => {
35 |     vi.mocked(child_process.execSync).mockReturnValueOnce('https://gitlab.com');
36 |     expect(isGitHubRepository()).toBe(false);
37 |   });
38 | 
39 |   it('returns true if the remote is github.com', async () => {
40 |     vi.mocked(child_process.execSync).mockReturnValueOnce(`
41 |       origin  https://github.com/sethvargo/gemini-cli (fetch)
42 |       origin  https://github.com/sethvargo/gemini-cli (push)
43 |     `);
44 |     expect(isGitHubRepository()).toBe(true);
45 |   });
46 | });
47 | 
48 | describe('getGitHubRepoInfo', async () => {
49 |   beforeEach(() => {
50 |     vi.resetAllMocks();
51 |   });
52 | 
53 |   afterEach(() => {
54 |     vi.restoreAllMocks();
55 |   });
56 | 
57 |   it('throws an error if github repo info cannot be determined', async () => {
58 |     vi.mocked(child_process.execSync).mockImplementation((): string => {
59 |       throw new Error('oops');
60 |     });
61 |     expect(() => {
62 |       getGitHubRepoInfo();
63 |     }).toThrowError(/oops/);
64 |   });
65 | 
66 |   it('throws an error if owner/repo could not be determined', async () => {
67 |     vi.mocked(child_process.execSync).mockReturnValueOnce('');
68 |     expect(() => {
69 |       getGitHubRepoInfo();
70 |     }).toThrowError(/Owner & repo could not be extracted from remote URL/);
71 |   });
72 | 
73 |   it('returns the owner and repo', async () => {
74 |     vi.mocked(child_process.execSync).mockReturnValueOnce(
75 |       'https://github.com/owner/repo.git ',
76 |     );
77 |     expect(getGitHubRepoInfo()).toEqual({ owner: 'owner', repo: 'repo' });
78 |   });
79 | });
80 | 
81 | describe('getGitRepoRoot', async () => {
82 |   beforeEach(() => {
83 |     vi.resetAllMocks();
84 |   });
85 | 
86 |   afterEach(() => {
87 |     vi.restoreAllMocks();
88 |   });
89 | 
90 |   it('throws an error if git root cannot be determined', async () => {
91 |     vi.mocked(child_process.execSync).mockImplementation((): string => {
92 |       throw new Error('oops');
93 |     });
94 |     expect(() => {
95 |       getGitRepoRoot();
96 |     }).toThrowError(/oops/);
97 |   });
98 | 
99 |   it('throws an error if git root is empty', async () => {
100 |     vi.mocked(child_process.execSync).mockReturnValueOnce('');
101 |     expect(() => {
102 |       getGitRepoRoot();
103 |     }).toThrowError(/Git repo returned empty value/);
104 |   });
105 | 
106 |   it('returns the root', async () => {
107 |     vi.mocked(child_process.execSync).mockReturnValueOnce('/path/to/git/repo');
108 |     expect(getGitRepoRoot()).toBe('/path/to/git/repo');
109 |   });
110 | });
111 | 
112 | describe('getLatestRelease', async () => {
113 |   beforeEach(() => {
114 |     vi.resetAllMocks();
115 |   });
116 | 
117 |   afterEach(() => {
118 |     vi.restoreAllMocks();
119 |   });
120 | 
121 |   it('throws an error if the fetch fails', async () => {
122 |     global.fetch = vi.fn(() => Promise.reject('nope'));
123 |     await expect(getLatestGitHubRelease()).rejects.toThrowError(
124 |       /Unable to determine the latest/,
125 |     );
126 |   });
127 | 
128 |   it('throws an error if the fetch does not return a json body', async () => {
129 |     global.fetch = vi.fn(() =>
130 |       Promise.resolve({
131 |         ok: true,
132 |         json: () => Promise.resolve({ foo: 'bar' }),
133 |       } as Response),
134 |     );
135 |     await expect(getLatestGitHubRelease()).rejects.toThrowError(
136 |       /Unable to determine the latest/,
137 |     );
138 |   });
139 | 
140 |   it('returns the release version', async () => {
141 |     global.fetch = vi.fn(() =>
142 |       Promise.resolve({
143 |         ok: true,
144 |         json: () => Promise.resolve({ tag_name: 'v1.2.3' }),
145 |       } as Response),
146 |     );
147 |     await expect(getLatestGitHubRelease()).resolves.toBe('v1.2.3');
148 |   });
149 | });
```

src/utils/gitUtils.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { execSync } from 'node:child_process';
8 | import { ProxyAgent } from 'undici';
9 | 
10 | /**
11 |  * Checks if a directory is within a git repository hosted on GitHub.
12 |  * @returns true if the directory is in a git repository with a github.com remote, false otherwise
13 |  */
14 | export const isGitHubRepository = (): boolean => {
15 |   try {
16 |     const remotes = (
17 |       execSync('git remote -v', {
18 |         encoding: 'utf-8',
19 |       }) || ''
20 |     ).trim();
21 | 
22 |     const pattern = /github\.com/;
23 | 
24 |     return pattern.test(remotes);
25 |   } catch (_error) {
26 |     // If any filesystem error occurs, assume not a git repo
27 |     console.debug(`Failed to get git remote:`, _error);
28 |     return false;
29 |   }
30 | };
31 | 
32 | /**
33 |  * getGitRepoRoot returns the root directory of the git repository.
34 |  * @returns the path to the root of the git repo.
35 |  * @throws error if the exec command fails.
36 |  */
37 | export const getGitRepoRoot = (): string => {
38 |   const gitRepoRoot = (
39 |     execSync('git rev-parse --show-toplevel', {
40 |       encoding: 'utf-8',
41 |     }) || ''
42 |   ).trim();
43 | 
44 |   if (!gitRepoRoot) {
45 |     throw new Error(`Git repo returned empty value`);
46 |   }
47 | 
48 |   return gitRepoRoot;
49 | };
50 | 
51 | /**
52 |  * getLatestGitHubRelease returns the release tag as a string.
53 |  * @returns string of the release tag (e.g. "v1.2.3").
54 |  */
55 | export const getLatestGitHubRelease = async (
56 |   proxy?: string,
57 | ): Promise<string> => {
58 |   try {
59 |     const controller = new AbortController();
60 | 
61 |     const endpoint = `https://api.github.com/repos/google-github-actions/run-gemini-cli/releases/latest`;
62 | 
63 |     const response = await fetch(endpoint, {
64 |       method: 'GET',
65 |       headers: {
66 |         Accept: 'application/vnd.github+json',
67 |         'Content-Type': 'application/json',
68 |         'X-GitHub-Api-Version': '2022-11-28',
69 |       },
70 |       dispatcher: proxy ? new ProxyAgent(proxy) : undefined,
71 |       signal: AbortSignal.any([AbortSignal.timeout(30_000), controller.signal]),
72 |     } as RequestInit);
73 | 
74 |     if (!response.ok) {
75 |       throw new Error(
76 |         `Invalid response code: ${response.status} - ${response.statusText}`,
77 |       );
78 |     }
79 | 
80 |     const releaseTag = (await response.json()).tag_name;
81 |     if (!releaseTag) {
82 |       throw new Error(`Response did not include tag_name field`);
83 |     }
84 |     return releaseTag;
85 |   } catch (_error) {
86 |     console.debug(`Failed to determine latest run-gemini-cli release:`, _error);
87 |     throw new Error(
88 |       `Unable to determine the latest run-gemini-cli release on GitHub.`,
89 |     );
90 |   }
91 | };
92 | 
93 | /**
94 |  * getGitHubRepoInfo returns the owner and repository for a GitHub repo.
95 |  * @returns the owner and repository of the github repo.
96 |  * @throws error if the exec command fails.
97 |  */
98 | export function getGitHubRepoInfo(): { owner: string; repo: string } {
99 |   const remoteUrl = execSync('git remote get-url origin', {
100 |     encoding: 'utf-8',
101 |   }).trim();
102 | 
103 |   // Matches either https://github.com/owner/repo.git or git@github.com:owner/repo.git
104 |   const match = remoteUrl.match(
105 |     /(?:https?:\/\/|git@)github\.com(?::|\/)([^/]+)\/([^/]+?)(?:\.git)?$/,
106 |   );
107 | 
108 |   // If the regex fails match, throw an error.
109 |   if (!match || !match[1] || !match[2]) {
110 |     throw new Error(
111 |       `Owner & repo could not be extracted from remote URL: ${remoteUrl}`,
112 |     );
113 |   }
114 | 
115 |   return { owner: match[1], repo: match[2] };
116 | }
```

src/utils/handleAutoUpdate.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type { Mock } from 'vitest';
8 | import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
9 | import { getInstallationInfo, PackageManager } from './installationInfo.js';
10 | import { updateEventEmitter } from './updateEventEmitter.js';
11 | import type { UpdateObject } from '../ui/utils/updateCheck.js';
12 | import type { LoadedSettings } from '../config/settings.js';
13 | import EventEmitter from 'node:events';
14 | import { handleAutoUpdate } from './handleAutoUpdate.js';
15 | 
16 | vi.mock('./installationInfo.js', async () => {
17 |   const actual = await vi.importActual('./installationInfo.js');
18 |   return {
19 |     ...actual,
20 |     getInstallationInfo: vi.fn(),
21 |   };
22 | });
23 | 
24 | vi.mock('./updateEventEmitter.js', async () => {
25 |   const actual = await vi.importActual('./updateEventEmitter.js');
26 |   return {
27 |     ...actual,
28 |     updateEventEmitter: {
29 |       ...actual.updateEventEmitter,
30 |       emit: vi.fn(),
31 |     },
32 |   };
33 | });
34 | 
35 | interface MockChildProcess extends EventEmitter {
36 |   stdin: EventEmitter & {
37 |     write: Mock;
38 |     end: Mock;
39 |   };
40 |   stderr: EventEmitter;
41 | }
42 | 
43 | const mockGetInstallationInfo = vi.mocked(getInstallationInfo);
44 | const mockUpdateEventEmitter = vi.mocked(updateEventEmitter);
45 | 
46 | describe('handleAutoUpdate', () => {
47 |   let mockSpawn: Mock;
48 |   let mockUpdateInfo: UpdateObject;
49 |   let mockSettings: LoadedSettings;
50 |   let mockChildProcess: MockChildProcess;
51 | 
52 |   beforeEach(() => {
53 |     mockSpawn = vi.fn();
54 |     vi.clearAllMocks();
55 |     mockUpdateInfo = {
56 |       update: {
57 |         latest: '2.0.0',
58 |         current: '1.0.0',
59 |         type: 'major',
60 |         name: '@google/gemini-cli',
61 |       },
62 |       message: 'An update is available!',
63 |     };
64 | 
65 |     mockSettings = {
66 |       merged: {
67 |         general: {
68 |           disableAutoUpdate: false,
69 |         },
70 |       },
71 |     } as LoadedSettings;
72 | 
73 |     mockChildProcess = Object.assign(new EventEmitter(), {
74 |       stdin: Object.assign(new EventEmitter(), {
75 |         write: vi.fn(),
76 |         end: vi.fn(),
77 |       }),
78 |       stderr: new EventEmitter(),
79 |     }) as MockChildProcess;
80 | 
81 |     mockSpawn.mockReturnValue(
82 |       mockChildProcess as unknown as ReturnType<typeof mockSpawn>,
83 |     );
84 |   });
85 | 
86 |   afterEach(() => {
87 |     vi.clearAllMocks();
88 |   });
89 | 
90 |   it('should do nothing if update info is null', () => {
91 |     handleAutoUpdate(null, mockSettings, '/root', mockSpawn);
92 |     expect(mockGetInstallationInfo).not.toHaveBeenCalled();
93 |     expect(mockUpdateEventEmitter.emit).not.toHaveBeenCalled();
94 |     expect(mockSpawn).not.toHaveBeenCalled();
95 |   });
96 | 
97 |   it('should do nothing if update nag is disabled', () => {
98 |     mockSettings.merged.general!.disableUpdateNag = true;
99 |     handleAutoUpdate(mockUpdateInfo, mockSettings, '/root', mockSpawn);
100 |     expect(mockGetInstallationInfo).not.toHaveBeenCalled();
101 |     expect(mockUpdateEventEmitter.emit).not.toHaveBeenCalled();
102 |     expect(mockSpawn).not.toHaveBeenCalled();
103 |   });
104 | 
105 |   it('should emit "update-received" but not update if auto-updates are disabled', () => {
106 |     mockSettings.merged.general!.disableAutoUpdate = true;
107 |     mockGetInstallationInfo.mockReturnValue({
108 |       updateCommand: 'npm i -g @google/gemini-cli@latest',
109 |       updateMessage: 'Please update manually.',
110 |       isGlobal: true,
111 |       packageManager: PackageManager.NPM,
112 |     });
113 | 
114 |     handleAutoUpdate(mockUpdateInfo, mockSettings, '/root', mockSpawn);
115 | 
116 |     expect(mockUpdateEventEmitter.emit).toHaveBeenCalledTimes(1);
117 |     expect(mockUpdateEventEmitter.emit).toHaveBeenCalledWith(
118 |       'update-received',
119 |       {
120 |         message: 'An update is available!\nPlease update manually.',
121 |       },
122 |     );
123 |     expect(mockSpawn).not.toHaveBeenCalled();
124 |   });
125 | 
126 |   it.each([PackageManager.NPX, PackageManager.PNPX, PackageManager.BUNX])(
127 |     'should suppress update notifications when running via %s',
128 |     (packageManager) => {
129 |       mockGetInstallationInfo.mockReturnValue({
130 |         updateCommand: undefined,
131 |         updateMessage: `Running via ${packageManager}, update not applicable.`,
132 |         isGlobal: false,
133 |         packageManager,
134 |       });
135 | 
136 |       handleAutoUpdate(mockUpdateInfo, mockSettings, '/root', mockSpawn);
137 | 
138 |       expect(mockUpdateEventEmitter.emit).not.toHaveBeenCalled();
139 |       expect(mockSpawn).not.toHaveBeenCalled();
140 |     },
141 |   );
142 | 
143 |   it('should emit "update-received" but not update if no update command is found', () => {
144 |     mockGetInstallationInfo.mockReturnValue({
145 |       updateCommand: undefined,
146 |       updateMessage: 'Cannot determine update command.',
147 |       isGlobal: false,
148 |       packageManager: PackageManager.NPM,
149 |     });
150 | 
151 |     handleAutoUpdate(mockUpdateInfo, mockSettings, '/root', mockSpawn);
152 | 
153 |     expect(mockUpdateEventEmitter.emit).toHaveBeenCalledTimes(1);
154 |     expect(mockUpdateEventEmitter.emit).toHaveBeenCalledWith(
155 |       'update-received',
156 |       {
157 |         message: 'An update is available!\nCannot determine update command.',
158 |       },
159 |     );
160 |     expect(mockSpawn).not.toHaveBeenCalled();
161 |   });
162 | 
163 |   it('should combine update messages correctly', () => {
164 |     mockGetInstallationInfo.mockReturnValue({
165 |       updateCommand: undefined, // No command to prevent spawn
166 |       updateMessage: 'This is an additional message.',
167 |       isGlobal: false,
168 |       packageManager: PackageManager.NPM,
169 |     });
170 | 
171 |     handleAutoUpdate(mockUpdateInfo, mockSettings, '/root', mockSpawn);
172 | 
173 |     expect(mockUpdateEventEmitter.emit).toHaveBeenCalledTimes(1);
174 |     expect(mockUpdateEventEmitter.emit).toHaveBeenCalledWith(
175 |       'update-received',
176 |       {
177 |         message: 'An update is available!\nThis is an additional message.',
178 |       },
179 |     );
180 |   });
181 | 
182 |   it('should attempt to perform an update when conditions are met', async () => {
183 |     mockGetInstallationInfo.mockReturnValue({
184 |       updateCommand: 'npm i -g @google/gemini-cli@latest',
185 |       updateMessage: 'This is an additional message.',
186 |       isGlobal: false,
187 |       packageManager: PackageManager.NPM,
188 |     });
189 | 
190 |     // Simulate successful execution
191 |     setTimeout(() => {
192 |       mockChildProcess.emit('close', 0);
193 |     }, 0);
194 | 
195 |     handleAutoUpdate(mockUpdateInfo, mockSettings, '/root', mockSpawn);
196 | 
197 |     expect(mockSpawn).toHaveBeenCalledOnce();
198 |   });
199 | 
200 |   it('should emit "update-failed" when the update process fails', async () => {
201 |     await new Promise<void>((resolve) => {
202 |       mockGetInstallationInfo.mockReturnValue({
203 |         updateCommand: 'npm i -g @google/gemini-cli@latest',
204 |         updateMessage: 'This is an additional message.',
205 |         isGlobal: false,
206 |         packageManager: PackageManager.NPM,
207 |       });
208 | 
209 |       // Simulate failed execution
210 |       setTimeout(() => {
211 |         mockChildProcess.stderr.emit('data', 'An error occurred');
212 |         mockChildProcess.emit('close', 1);
213 |         resolve();
214 |       }, 0);
215 | 
216 |       handleAutoUpdate(mockUpdateInfo, mockSettings, '/root', mockSpawn);
217 |     });
218 | 
219 |     expect(mockUpdateEventEmitter.emit).toHaveBeenCalledWith('update-failed', {
220 |       message:
221 |         'Automatic update failed. Please try updating manually. (command: npm i -g @google/gemini-cli@2.0.0, stderr: An error occurred)',
222 |     });
223 |   });
224 | 
225 |   it('should emit "update-failed" when the spawn function throws an error', async () => {
226 |     await new Promise<void>((resolve) => {
227 |       mockGetInstallationInfo.mockReturnValue({
228 |         updateCommand: 'npm i -g @google/gemini-cli@latest',
229 |         updateMessage: 'This is an additional message.',
230 |         isGlobal: false,
231 |         packageManager: PackageManager.NPM,
232 |       });
233 | 
234 |       // Simulate an error event
235 |       setTimeout(() => {
236 |         mockChildProcess.emit('error', new Error('Spawn error'));
237 |         resolve();
238 |       }, 0);
239 | 
240 |       handleAutoUpdate(mockUpdateInfo, mockSettings, '/root', mockSpawn);
241 |     });
242 | 
243 |     expect(mockUpdateEventEmitter.emit).toHaveBeenCalledWith('update-failed', {
244 |       message:
245 |         'Automatic update failed. Please try updating manually. (error: Spawn error)',
246 |     });
247 |   });
248 | 
249 |   it('should use the "@nightly" tag for nightly updates', async () => {
250 |     mockUpdateInfo.update.latest = '2.0.0-nightly';
251 |     mockGetInstallationInfo.mockReturnValue({
252 |       updateCommand: 'npm i -g @google/gemini-cli@latest',
253 |       updateMessage: 'This is an additional message.',
254 |       isGlobal: false,
255 |       packageManager: PackageManager.NPM,
256 |     });
257 | 
258 |     handleAutoUpdate(mockUpdateInfo, mockSettings, '/root', mockSpawn);
259 | 
260 |     expect(mockSpawn).toHaveBeenCalledWith(
261 |       'npm i -g @google/gemini-cli@nightly',
262 |       {
263 |         shell: true,
264 |         stdio: 'pipe',
265 |       },
266 |     );
267 |   });
268 | 
269 |   it('should emit "update-success" when the update process succeeds', async () => {
270 |     await new Promise<void>((resolve) => {
271 |       mockGetInstallationInfo.mockReturnValue({
272 |         updateCommand: 'npm i -g @google/gemini-cli@latest',
273 |         updateMessage: 'This is an additional message.',
274 |         isGlobal: false,
275 |         packageManager: PackageManager.NPM,
276 |       });
277 | 
278 |       // Simulate successful execution
279 |       setTimeout(() => {
280 |         mockChildProcess.emit('close', 0);
281 |         resolve();
282 |       }, 0);
283 | 
284 |       handleAutoUpdate(mockUpdateInfo, mockSettings, '/root', mockSpawn);
285 |     });
286 | 
287 |     expect(mockUpdateEventEmitter.emit).toHaveBeenCalledWith('update-success', {
288 |       message:
289 |         'Update successful! The new version will be used on your next run.',
290 |     });
291 |   });
292 | });
```

src/utils/handleAutoUpdate.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type { UpdateObject } from '../ui/utils/updateCheck.js';
8 | import type { LoadedSettings } from '../config/settings.js';
9 | import { getInstallationInfo, PackageManager } from './installationInfo.js';
10 | import { updateEventEmitter } from './updateEventEmitter.js';
11 | import type { HistoryItem } from '../ui/types.js';
12 | import { MessageType } from '../ui/types.js';
13 | import { spawnWrapper } from './spawnWrapper.js';
14 | import type { spawn } from 'node:child_process';
15 | 
16 | export function handleAutoUpdate(
17 |   info: UpdateObject | null,
18 |   settings: LoadedSettings,
19 |   projectRoot: string,
20 |   spawnFn: typeof spawn = spawnWrapper,
21 | ) {
22 |   if (!info) {
23 |     return;
24 |   }
25 | 
26 |   if (settings.merged.general?.disableUpdateNag) {
27 |     return;
28 |   }
29 | 
30 |   const installationInfo = getInstallationInfo(
31 |     projectRoot,
32 |     settings.merged.general?.disableAutoUpdate ?? false,
33 |   );
34 | 
35 |   if (
36 |     [PackageManager.NPX, PackageManager.PNPX, PackageManager.BUNX].includes(
37 |       installationInfo.packageManager,
38 |     )
39 |   ) {
40 |     return;
41 |   }
42 | 
43 |   let combinedMessage = info.message;
44 |   if (installationInfo.updateMessage) {
45 |     combinedMessage += `\n${installationInfo.updateMessage}`;
46 |   }
47 | 
48 |   updateEventEmitter.emit('update-received', {
49 |     message: combinedMessage,
50 |   });
51 | 
52 |   if (
53 |     !installationInfo.updateCommand ||
54 |     settings.merged.general?.disableAutoUpdate
55 |   ) {
56 |     return;
57 |   }
58 |   const isNightly = info.update.latest.includes('nightly');
59 | 
60 |   const updateCommand = installationInfo.updateCommand.replace(
61 |     '@latest',
62 |     isNightly ? '@nightly' : `@${info.update.latest}`,
63 |   );
64 |   const updateProcess = spawnFn(updateCommand, { stdio: 'pipe', shell: true });
65 |   let errorOutput = '';
66 |   updateProcess.stderr.on('data', (data) => {
67 |     errorOutput += data.toString();
68 |   });
69 | 
70 |   updateProcess.on('close', (code) => {
71 |     if (code === 0) {
72 |       updateEventEmitter.emit('update-success', {
73 |         message:
74 |           'Update successful! The new version will be used on your next run.',
75 |       });
76 |     } else {
77 |       updateEventEmitter.emit('update-failed', {
78 |         message: `Automatic update failed. Please try updating manually. (command: ${updateCommand}, stderr: ${errorOutput.trim()})`,
79 |       });
80 |     }
81 |   });
82 | 
83 |   updateProcess.on('error', (err) => {
84 |     updateEventEmitter.emit('update-failed', {
85 |       message: `Automatic update failed. Please try updating manually. (error: ${err.message})`,
86 |     });
87 |   });
88 |   return updateProcess;
89 | }
90 | 
91 | export function setUpdateHandler(
92 |   addItem: (item: Omit<HistoryItem, 'id'>, timestamp: number) => void,
93 |   setUpdateInfo: (info: UpdateObject | null) => void,
94 | ) {
95 |   let successfullyInstalled = false;
96 |   const handleUpdateRecieved = (info: UpdateObject) => {
97 |     setUpdateInfo(info);
98 |     const savedMessage = info.message;
99 |     setTimeout(() => {
100 |       if (!successfullyInstalled) {
101 |         addItem(
102 |           {
103 |             type: MessageType.INFO,
104 |             text: savedMessage,
105 |           },
106 |           Date.now(),
107 |         );
108 |       }
109 |       setUpdateInfo(null);
110 |     }, 60000);
111 |   };
112 | 
113 |   const handleUpdateFailed = () => {
114 |     setUpdateInfo(null);
115 |     addItem(
116 |       {
117 |         type: MessageType.ERROR,
118 |         text: `Automatic update failed. Please try updating manually`,
119 |       },
120 |       Date.now(),
121 |     );
122 |   };
123 | 
124 |   const handleUpdateSuccess = () => {
125 |     successfullyInstalled = true;
126 |     setUpdateInfo(null);
127 |     addItem(
128 |       {
129 |         type: MessageType.INFO,
130 |         text: `Update successful! The new version will be used on your next run.`,
131 |       },
132 |       Date.now(),
133 |     );
134 |   };
135 | 
136 |   const handleUpdateInfo = (data: { message: string }) => {
137 |     addItem(
138 |       {
139 |         type: MessageType.INFO,
140 |         text: data.message,
141 |       },
142 |       Date.now(),
143 |     );
144 |   };
145 | 
146 |   updateEventEmitter.on('update-received', handleUpdateRecieved);
147 |   updateEventEmitter.on('update-failed', handleUpdateFailed);
148 |   updateEventEmitter.on('update-success', handleUpdateSuccess);
149 |   updateEventEmitter.on('update-info', handleUpdateInfo);
150 | 
151 |   return () => {
152 |     updateEventEmitter.off('update-received', handleUpdateRecieved);
153 |     updateEventEmitter.off('update-failed', handleUpdateFailed);
154 |     updateEventEmitter.off('update-success', handleUpdateSuccess);
155 |     updateEventEmitter.off('update-info', handleUpdateInfo);
156 |   };
157 | }
```

src/utils/installationInfo.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { vi, describe, it, expect, beforeEach, afterEach } from 'vitest';
8 | import { getInstallationInfo, PackageManager } from './installationInfo.js';
9 | import * as fs from 'node:fs';
10 | import * as path from 'node:path';
11 | import * as childProcess from 'node:child_process';
12 | import { isGitRepository } from '@google/gemini-cli-core';
13 | 
14 | vi.mock('@google/gemini-cli-core', () => ({
15 |   isGitRepository: vi.fn(),
16 | }));
17 | 
18 | vi.mock('fs', async (importOriginal) => {
19 |   const actualFs = await importOriginal<typeof fs>();
20 |   return {
21 |     ...actualFs,
22 |     realpathSync: vi.fn(),
23 |     existsSync: vi.fn(),
24 |   };
25 | });
26 | 
27 | vi.mock('child_process', async (importOriginal) => {
28 |   const actual = await importOriginal<typeof import('child_process')>();
29 |   return {
30 |     ...actual,
31 |     execSync: vi.fn(),
32 |   };
33 | });
34 | 
35 | const mockedIsGitRepository = vi.mocked(isGitRepository);
36 | const mockedRealPathSync = vi.mocked(fs.realpathSync);
37 | const mockedExistsSync = vi.mocked(fs.existsSync);
38 | const mockedExecSync = vi.mocked(childProcess.execSync);
39 | 
40 | describe('getInstallationInfo', () => {
41 |   const projectRoot = '/path/to/project';
42 |   let originalArgv: string[];
43 | 
44 |   beforeEach(() => {
45 |     vi.resetAllMocks();
46 |     originalArgv = [...process.argv];
47 |     // Mock process.cwd() for isGitRepository
48 |     vi.spyOn(process, 'cwd').mockReturnValue(projectRoot);
49 |   });
50 | 
51 |   afterEach(() => {
52 |     process.argv = originalArgv;
53 |   });
54 | 
55 |   it('should return UNKNOWN when cliPath is not available', () => {
56 |     process.argv[1] = '';
57 |     const info = getInstallationInfo(projectRoot, false);
58 |     expect(info.packageManager).toBe(PackageManager.UNKNOWN);
59 |   });
60 | 
61 |   it('should return UNKNOWN and log error if realpathSync fails', () => {
62 |     const consoleSpy = vi.spyOn(console, 'log').mockImplementation(() => {});
63 |     process.argv[1] = '/path/to/cli';
64 |     const error = new Error('realpath failed');
65 |     mockedRealPathSync.mockImplementation(() => {
66 |       throw error;
67 |     });
68 | 
69 |     const info = getInstallationInfo(projectRoot, false);
70 | 
71 |     expect(info.packageManager).toBe(PackageManager.UNKNOWN);
72 |     expect(consoleSpy).toHaveBeenCalledWith(error);
73 |     consoleSpy.mockRestore();
74 |   });
75 | 
76 |   it('should detect running from a local git clone', () => {
77 |     process.argv[1] = `${projectRoot}/packages/cli/dist/index.js`;
78 |     mockedRealPathSync.mockReturnValue(
79 |       `${projectRoot}/packages/cli/dist/index.js`,
80 |     );
81 |     mockedIsGitRepository.mockReturnValue(true);
82 | 
83 |     const info = getInstallationInfo(projectRoot, false);
84 | 
85 |     expect(info.packageManager).toBe(PackageManager.UNKNOWN);
86 |     expect(info.isGlobal).toBe(false);
87 |     expect(info.updateMessage).toBe(
88 |       'Running from a local git clone. Please update with "git pull".',
89 |     );
90 |   });
91 | 
92 |   it('should detect running via npx', () => {
93 |     const npxPath = `/Users/test/.npm/_npx/12345/bin/gemini`;
94 |     process.argv[1] = npxPath;
95 |     mockedRealPathSync.mockReturnValue(npxPath);
96 | 
97 |     const info = getInstallationInfo(projectRoot, false);
98 | 
99 |     expect(info.packageManager).toBe(PackageManager.NPX);
100 |     expect(info.isGlobal).toBe(false);
101 |     expect(info.updateMessage).toBe('Running via npx, update not applicable.');
102 |   });
103 | 
104 |   it('should detect running via pnpx', () => {
105 |     const pnpxPath = `/Users/test/.pnpm/_pnpx/12345/bin/gemini`;
106 |     process.argv[1] = pnpxPath;
107 |     mockedRealPathSync.mockReturnValue(pnpxPath);
108 | 
109 |     const info = getInstallationInfo(projectRoot, false);
110 | 
111 |     expect(info.packageManager).toBe(PackageManager.PNPX);
112 |     expect(info.isGlobal).toBe(false);
113 |     expect(info.updateMessage).toBe('Running via pnpx, update not applicable.');
114 |   });
115 | 
116 |   it('should detect running via bunx', () => {
117 |     const bunxPath = `/Users/test/.bun/install/cache/12345/bin/gemini`;
118 |     process.argv[1] = bunxPath;
119 |     mockedRealPathSync.mockReturnValue(bunxPath);
120 |     mockedExecSync.mockImplementation(() => {
121 |       throw new Error('Command failed');
122 |     });
123 | 
124 |     const info = getInstallationInfo(projectRoot, false);
125 | 
126 |     expect(info.packageManager).toBe(PackageManager.BUNX);
127 |     expect(info.isGlobal).toBe(false);
128 |     expect(info.updateMessage).toBe('Running via bunx, update not applicable.');
129 |   });
130 | 
131 |   it('should detect Homebrew installation via execSync', () => {
132 |     Object.defineProperty(process, 'platform', {
133 |       value: 'darwin',
134 |     });
135 |     const cliPath = '/usr/local/bin/gemini';
136 |     process.argv[1] = cliPath;
137 |     mockedRealPathSync.mockReturnValue(cliPath);
138 |     mockedExecSync.mockReturnValue(Buffer.from('gemini-cli')); // Simulate successful command
139 | 
140 |     const info = getInstallationInfo(projectRoot, false);
141 | 
142 |     expect(mockedExecSync).toHaveBeenCalledWith(
143 |       'brew list -1 | grep -q "^gemini-cli$"',
144 |       { stdio: 'ignore' },
145 |     );
146 |     expect(info.packageManager).toBe(PackageManager.HOMEBREW);
147 |     expect(info.isGlobal).toBe(true);
148 |     expect(info.updateMessage).toContain('brew upgrade');
149 |   });
150 | 
151 |   it('should fall through if brew command fails', () => {
152 |     Object.defineProperty(process, 'platform', {
153 |       value: 'darwin',
154 |     });
155 |     const cliPath = '/usr/local/bin/gemini';
156 |     process.argv[1] = cliPath;
157 |     mockedRealPathSync.mockReturnValue(cliPath);
158 |     mockedExecSync.mockImplementation(() => {
159 |       throw new Error('Command failed');
160 |     });
161 | 
162 |     const info = getInstallationInfo(projectRoot, false);
163 | 
164 |     expect(mockedExecSync).toHaveBeenCalledWith(
165 |       'brew list -1 | grep -q "^gemini-cli$"',
166 |       { stdio: 'ignore' },
167 |     );
168 |     // Should fall back to default global npm
169 |     expect(info.packageManager).toBe(PackageManager.NPM);
170 |     expect(info.isGlobal).toBe(true);
171 |   });
172 | 
173 |   it('should detect global pnpm installation', () => {
174 |     const pnpmPath = `/Users/test/.pnpm/global/5/node_modules/.pnpm/some-hash/node_modules/@google/gemini-cli/dist/index.js`;
175 |     process.argv[1] = pnpmPath;
176 |     mockedRealPathSync.mockReturnValue(pnpmPath);
177 |     mockedExecSync.mockImplementation(() => {
178 |       throw new Error('Command failed');
179 |     });
180 | 
181 |     const info = getInstallationInfo(projectRoot, false);
182 |     expect(info.packageManager).toBe(PackageManager.PNPM);
183 |     expect(info.isGlobal).toBe(true);
184 |     expect(info.updateCommand).toBe('pnpm add -g @google/gemini-cli@latest');
185 |     expect(info.updateMessage).toContain('Attempting to automatically update');
186 | 
187 |     const infoDisabled = getInstallationInfo(projectRoot, true);
188 |     expect(infoDisabled.updateMessage).toContain('Please run pnpm add');
189 |   });
190 | 
191 |   it('should detect global yarn installation', () => {
192 |     const yarnPath = `/Users/test/.yarn/global/node_modules/@google/gemini-cli/dist/index.js`;
193 |     process.argv[1] = yarnPath;
194 |     mockedRealPathSync.mockReturnValue(yarnPath);
195 |     mockedExecSync.mockImplementation(() => {
196 |       throw new Error('Command failed');
197 |     });
198 | 
199 |     const info = getInstallationInfo(projectRoot, false);
200 |     expect(info.packageManager).toBe(PackageManager.YARN);
201 |     expect(info.isGlobal).toBe(true);
202 |     expect(info.updateCommand).toBe(
203 |       'yarn global add @google/gemini-cli@latest',
204 |     );
205 |     expect(info.updateMessage).toContain('Attempting to automatically update');
206 | 
207 |     const infoDisabled = getInstallationInfo(projectRoot, true);
208 |     expect(infoDisabled.updateMessage).toContain('Please run yarn global add');
209 |   });
210 | 
211 |   it('should detect global bun installation', () => {
212 |     const bunPath = `/Users/test/.bun/bin/gemini`;
213 |     process.argv[1] = bunPath;
214 |     mockedRealPathSync.mockReturnValue(bunPath);
215 |     mockedExecSync.mockImplementation(() => {
216 |       throw new Error('Command failed');
217 |     });
218 | 
219 |     const info = getInstallationInfo(projectRoot, false);
220 |     expect(info.packageManager).toBe(PackageManager.BUN);
221 |     expect(info.isGlobal).toBe(true);
222 |     expect(info.updateCommand).toBe('bun add -g @google/gemini-cli@latest');
223 |     expect(info.updateMessage).toContain('Attempting to automatically update');
224 | 
225 |     const infoDisabled = getInstallationInfo(projectRoot, true);
226 |     expect(infoDisabled.updateMessage).toContain('Please run bun add');
227 |   });
228 | 
229 |   it('should detect local installation and identify yarn from lockfile', () => {
230 |     const localPath = `${projectRoot}/node_modules/.bin/gemini`;
231 |     process.argv[1] = localPath;
232 |     mockedRealPathSync.mockReturnValue(localPath);
233 |     mockedExecSync.mockImplementation(() => {
234 |       throw new Error('Command failed');
235 |     });
236 |     mockedExistsSync.mockImplementation(
237 |       (p) => p === path.join(projectRoot, 'yarn.lock'),
238 |     );
239 | 
240 |     const info = getInstallationInfo(projectRoot, false);
241 | 
242 |     expect(info.packageManager).toBe(PackageManager.YARN);
243 |     expect(info.isGlobal).toBe(false);
244 |     expect(info.updateMessage).toContain('Locally installed');
245 |   });
246 | 
247 |   it('should detect local installation and identify pnpm from lockfile', () => {
248 |     const localPath = `${projectRoot}/node_modules/.bin/gemini`;
249 |     process.argv[1] = localPath;
250 |     mockedRealPathSync.mockReturnValue(localPath);
251 |     mockedExecSync.mockImplementation(() => {
252 |       throw new Error('Command failed');
253 |     });
254 |     mockedExistsSync.mockImplementation(
255 |       (p) => p === path.join(projectRoot, 'pnpm-lock.yaml'),
256 |     );
257 | 
258 |     const info = getInstallationInfo(projectRoot, false);
259 | 
260 |     expect(info.packageManager).toBe(PackageManager.PNPM);
261 |     expect(info.isGlobal).toBe(false);
262 |   });
263 | 
264 |   it('should detect local installation and identify bun from lockfile', () => {
265 |     const localPath = `${projectRoot}/node_modules/.bin/gemini`;
266 |     process.argv[1] = localPath;
267 |     mockedRealPathSync.mockReturnValue(localPath);
268 |     mockedExecSync.mockImplementation(() => {
269 |       throw new Error('Command failed');
270 |     });
271 |     mockedExistsSync.mockImplementation(
272 |       (p) => p === path.join(projectRoot, 'bun.lockb'),
273 |     );
274 | 
275 |     const info = getInstallationInfo(projectRoot, false);
276 | 
277 |     expect(info.packageManager).toBe(PackageManager.BUN);
278 |     expect(info.isGlobal).toBe(false);
279 |   });
280 | 
281 |   it('should default to local npm installation if no lockfile is found', () => {
282 |     const localPath = `${projectRoot}/node_modules/.bin/gemini`;
283 |     process.argv[1] = localPath;
284 |     mockedRealPathSync.mockReturnValue(localPath);
285 |     mockedExecSync.mockImplementation(() => {
286 |       throw new Error('Command failed');
287 |     });
288 |     mockedExistsSync.mockReturnValue(false); // No lockfiles
289 | 
290 |     const info = getInstallationInfo(projectRoot, false);
291 | 
292 |     expect(info.packageManager).toBe(PackageManager.NPM);
293 |     expect(info.isGlobal).toBe(false);
294 |   });
295 | 
296 |   it('should default to global npm installation for unrecognized paths', () => {
297 |     const globalPath = `/usr/local/bin/gemini`;
298 |     process.argv[1] = globalPath;
299 |     mockedRealPathSync.mockReturnValue(globalPath);
300 |     mockedExecSync.mockImplementation(() => {
301 |       throw new Error('Command failed');
302 |     });
303 | 
304 |     const info = getInstallationInfo(projectRoot, false);
305 |     expect(info.packageManager).toBe(PackageManager.NPM);
306 |     expect(info.isGlobal).toBe(true);
307 |     expect(info.updateCommand).toBe('npm install -g @google/gemini-cli@latest');
308 |     expect(info.updateMessage).toContain('Attempting to automatically update');
309 | 
310 |     const infoDisabled = getInstallationInfo(projectRoot, true);
311 |     expect(infoDisabled.updateMessage).toContain('Please run npm install');
312 |   });
313 | });
```

src/utils/installationInfo.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { isGitRepository } from '@google/gemini-cli-core';
8 | import * as fs from 'node:fs';
9 | import * as path from 'node:path';
10 | import * as childProcess from 'node:child_process';
11 | import process from 'node:process';
12 | 
13 | export const isDevelopment = process.env['NODE_ENV'] === 'development';
14 | 
15 | export enum PackageManager {
16 |   NPM = 'npm',
17 |   YARN = 'yarn',
18 |   PNPM = 'pnpm',
19 |   PNPX = 'pnpx',
20 |   BUN = 'bun',
21 |   BUNX = 'bunx',
22 |   HOMEBREW = 'homebrew',
23 |   NPX = 'npx',
24 |   UNKNOWN = 'unknown',
25 | }
26 | 
27 | export interface InstallationInfo {
28 |   packageManager: PackageManager;
29 |   isGlobal: boolean;
30 |   updateCommand?: string;
31 |   updateMessage?: string;
32 | }
33 | 
34 | export function getInstallationInfo(
35 |   projectRoot: string,
36 |   isAutoUpdateDisabled: boolean,
37 | ): InstallationInfo {
38 |   const cliPath = process.argv[1];
39 |   if (!cliPath) {
40 |     return { packageManager: PackageManager.UNKNOWN, isGlobal: false };
41 |   }
42 | 
43 |   try {
44 |     // Normalize path separators to forward slashes for consistent matching.
45 |     const realPath = fs.realpathSync(cliPath).replace(/\\/g, '/');
46 |     const normalizedProjectRoot = projectRoot?.replace(/\\/g, '/');
47 |     const isGit = isGitRepository(process.cwd());
48 | 
49 |     // Check for local git clone first
50 |     if (
51 |       isGit &&
52 |       normalizedProjectRoot &&
53 |       realPath.startsWith(normalizedProjectRoot) &&
54 |       !realPath.includes('/node_modules/')
55 |     ) {
56 |       return {
57 |         packageManager: PackageManager.UNKNOWN, // Not managed by a package manager in this sense
58 |         isGlobal: false,
59 |         updateMessage:
60 |           'Running from a local git clone. Please update with "git pull".',
61 |       };
62 |     }
63 | 
64 |     // Check for npx/pnpx
65 |     if (realPath.includes('/.npm/_npx') || realPath.includes('/npm/_npx')) {
66 |       return {
67 |         packageManager: PackageManager.NPX,
68 |         isGlobal: false,
69 |         updateMessage: 'Running via npx, update not applicable.',
70 |       };
71 |     }
72 |     if (realPath.includes('/.pnpm/_pnpx')) {
73 |       return {
74 |         packageManager: PackageManager.PNPX,
75 |         isGlobal: false,
76 |         updateMessage: 'Running via pnpx, update not applicable.',
77 |       };
78 |     }
79 | 
80 |     // Check for Homebrew
81 |     if (process.platform === 'darwin') {
82 |       try {
83 |         // The package name in homebrew is gemini-cli
84 |         childProcess.execSync('brew list -1 | grep -q "^gemini-cli$"', {
85 |           stdio: 'ignore',
86 |         });
87 |         return {
88 |           packageManager: PackageManager.HOMEBREW,
89 |           isGlobal: true,
90 |           updateMessage:
91 |             'Installed via Homebrew. Please update with "brew upgrade".',
92 |         };
93 |       } catch (_error) {
94 |         // Brew is not installed or gemini-cli is not installed via brew.
95 |         // Continue to the next check.
96 |       }
97 |     }
98 | 
99 |     // Check for pnpm
100 |     if (realPath.includes('/.pnpm/global')) {
101 |       const updateCommand = 'pnpm add -g @google/gemini-cli@latest';
102 |       return {
103 |         packageManager: PackageManager.PNPM,
104 |         isGlobal: true,
105 |         updateCommand,
106 |         updateMessage: isAutoUpdateDisabled
107 |           ? `Please run ${updateCommand} to update`
108 |           : 'Installed with pnpm. Attempting to automatically update now...',
109 |       };
110 |     }
111 | 
112 |     // Check for yarn
113 |     if (realPath.includes('/.yarn/global')) {
114 |       const updateCommand = 'yarn global add @google/gemini-cli@latest';
115 |       return {
116 |         packageManager: PackageManager.YARN,
117 |         isGlobal: true,
118 |         updateCommand,
119 |         updateMessage: isAutoUpdateDisabled
120 |           ? `Please run ${updateCommand} to update`
121 |           : 'Installed with yarn. Attempting to automatically update now...',
122 |       };
123 |     }
124 | 
125 |     // Check for bun
126 |     if (realPath.includes('/.bun/install/cache')) {
127 |       return {
128 |         packageManager: PackageManager.BUNX,
129 |         isGlobal: false,
130 |         updateMessage: 'Running via bunx, update not applicable.',
131 |       };
132 |     }
133 |     if (realPath.includes('/.bun/bin')) {
134 |       const updateCommand = 'bun add -g @google/gemini-cli@latest';
135 |       return {
136 |         packageManager: PackageManager.BUN,
137 |         isGlobal: true,
138 |         updateCommand,
139 |         updateMessage: isAutoUpdateDisabled
140 |           ? `Please run ${updateCommand} to update`
141 |           : 'Installed with bun. Attempting to automatically update now...',
142 |       };
143 |     }
144 | 
145 |     // Check for local install
146 |     if (
147 |       normalizedProjectRoot &&
148 |       realPath.startsWith(`${normalizedProjectRoot}/node_modules`)
149 |     ) {
150 |       let pm = PackageManager.NPM;
151 |       if (fs.existsSync(path.join(projectRoot, 'yarn.lock'))) {
152 |         pm = PackageManager.YARN;
153 |       } else if (fs.existsSync(path.join(projectRoot, 'pnpm-lock.yaml'))) {
154 |         pm = PackageManager.PNPM;
155 |       } else if (fs.existsSync(path.join(projectRoot, 'bun.lockb'))) {
156 |         pm = PackageManager.BUN;
157 |       }
158 |       return {
159 |         packageManager: pm,
160 |         isGlobal: false,
161 |         updateMessage:
162 |           "Locally installed. Please update via your project's package.json.",
163 |       };
164 |     }
165 | 
166 |     // Assume global npm
167 |     const updateCommand = 'npm install -g @google/gemini-cli@latest';
168 |     return {
169 |       packageManager: PackageManager.NPM,
170 |       isGlobal: true,
171 |       updateCommand,
172 |       updateMessage: isAutoUpdateDisabled
173 |         ? `Please run ${updateCommand} to update`
174 |         : 'Installed with npm. Attempting to automatically update now...',
175 |     };
176 |   } catch (error) {
177 |     console.log(error);
178 |     return { packageManager: PackageManager.UNKNOWN, isGlobal: false };
179 |   }
180 | }
```

src/utils/math.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | /**
8 |  * Linearly interpolates between two values.
9 |  *
10 |  * @param start The start value.
11 |  * @param end The end value.
12 |  * @param t The interpolation amount (typically between 0 and 1).
13 |  */
14 | export const lerp = (start: number, end: number, t: number): number =>
15 |   start + (end - start) * t;
```

src/utils/package.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import {
8 |   readPackageUp,
9 |   type PackageJson as BasePackageJson,
10 | } from 'read-package-up';
11 | import { fileURLToPath } from 'node:url';
12 | import path from 'node:path';
13 | 
14 | export type PackageJson = BasePackageJson & {
15 |   config?: {
16 |     sandboxImageUri?: string;
17 |   };
18 | };
19 | 
20 | const __filename = fileURLToPath(import.meta.url);
21 | const __dirname = path.dirname(__filename);
22 | 
23 | let packageJson: PackageJson | undefined;
24 | 
25 | export async function getPackageJson(): Promise<PackageJson | undefined> {
26 |   if (packageJson) {
27 |     return packageJson;
28 |   }
29 | 
30 |   const result = await readPackageUp({ cwd: __dirname });
31 |   if (!result) {
32 |     // TODO: Maybe bubble this up as an error.
33 |     return;
34 |   }
35 | 
36 |   packageJson = result.packageJson;
37 |   return packageJson;
38 | }
```

src/utils/processUtils.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { vi } from 'vitest';
8 | import { RELAUNCH_EXIT_CODE, relaunchApp } from './processUtils.js';
9 | import * as cleanup from './cleanup.js';
10 | 
11 | describe('processUtils', () => {
12 |   const processExit = vi
13 |     .spyOn(process, 'exit')
14 |     .mockReturnValue(undefined as never);
15 |   const runExitCleanup = vi.spyOn(cleanup, 'runExitCleanup');
16 | 
17 |   it('should run cleanup and exit with the relaunch code', async () => {
18 |     await relaunchApp();
19 |     expect(runExitCleanup).toHaveBeenCalledTimes(1);
20 |     expect(processExit).toHaveBeenCalledWith(RELAUNCH_EXIT_CODE);
21 |   });
22 | });
```

src/utils/processUtils.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { runExitCleanup } from './cleanup.js';
8 | 
9 | /**
10 |  * Exit code used to signal that the CLI should be relaunched.
11 |  */
12 | export const RELAUNCH_EXIT_CODE = 42;
13 | 
14 | /**
15 |  * Exits the process with a special code to signal that the parent process should relaunch it.
16 |  */
17 | export async function relaunchApp(): Promise<void> {
18 |   await runExitCleanup();
19 |   process.exit(RELAUNCH_EXIT_CODE);
20 | }
```

src/utils/readStdin.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { vi, describe, expect, it, beforeEach, afterEach } from 'vitest';
8 | import { readStdin } from './readStdin.js';
9 | 
10 | // Mock process.stdin
11 | const mockStdin = {
12 |   setEncoding: vi.fn(),
13 |   read: vi.fn(),
14 |   on: vi.fn(),
15 |   removeListener: vi.fn(),
16 |   destroy: vi.fn(),
17 | };
18 | 
19 | describe('readStdin', () => {
20 |   let originalStdin: typeof process.stdin;
21 |   let onReadableHandler: () => void;
22 |   let onEndHandler: () => void;
23 | 
24 |   beforeEach(() => {
25 |     vi.clearAllMocks();
26 |     originalStdin = process.stdin;
27 | 
28 |     // Replace process.stdin with our mock
29 |     Object.defineProperty(process, 'stdin', {
30 |       value: mockStdin,
31 |       writable: true,
32 |       configurable: true,
33 |     });
34 | 
35 |     // Capture event handlers
36 |     mockStdin.on.mockImplementation((event: string, handler: () => void) => {
37 |       if (event === 'readable') onReadableHandler = handler;
38 |       if (event === 'end') onEndHandler = handler;
39 |     });
40 |   });
41 | 
42 |   afterEach(() => {
43 |     vi.restoreAllMocks();
44 |     Object.defineProperty(process, 'stdin', {
45 |       value: originalStdin,
46 |       writable: true,
47 |       configurable: true,
48 |     });
49 |   });
50 | 
51 |   it('should read and accumulate data from stdin', async () => {
52 |     mockStdin.read
53 |       .mockReturnValueOnce('I love ')
54 |       .mockReturnValueOnce('Gemini!')
55 |       .mockReturnValueOnce(null);
56 | 
57 |     const promise = readStdin();
58 | 
59 |     // Trigger readable event
60 |     onReadableHandler();
61 | 
62 |     // Trigger end to resolve
63 |     onEndHandler();
64 | 
65 |     await expect(promise).resolves.toBe('I love Gemini!');
66 |   });
67 | 
68 |   it('should handle empty stdin input', async () => {
69 |     mockStdin.read.mockReturnValue(null);
70 | 
71 |     const promise = readStdin();
72 | 
73 |     // Trigger end immediately
74 |     onEndHandler();
75 | 
76 |     await expect(promise).resolves.toBe('');
77 |   });
78 | 
79 |   // Emulate terminals where stdin is not TTY (eg: git bash)
80 |   it('should timeout and resolve with empty string when no input is available', async () => {
81 |     vi.useFakeTimers();
82 | 
83 |     const promise = readStdin();
84 | 
85 |     // Fast-forward past the timeout (to run test faster)
86 |     vi.advanceTimersByTime(500);
87 | 
88 |     await expect(promise).resolves.toBe('');
89 | 
90 |     vi.useRealTimers();
91 |   });
92 | 
93 |   it('should clear timeout once when data is received and resolve with data', async () => {
94 |     const clearTimeoutSpy = vi.spyOn(global, 'clearTimeout');
95 |     mockStdin.read
96 |       .mockReturnValueOnce('chunk1')
97 |       .mockReturnValueOnce('chunk2')
98 |       .mockReturnValueOnce(null);
99 | 
100 |     const promise = readStdin();
101 | 
102 |     // Trigger readable event
103 |     onReadableHandler();
104 | 
105 |     expect(clearTimeoutSpy).toHaveBeenCalledOnce();
106 | 
107 |     // Trigger end to resolve
108 |     onEndHandler();
109 | 
110 |     await expect(promise).resolves.toBe('chunk1chunk2');
111 |   });
112 | });
```

src/utils/readStdin.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | export async function readStdin(): Promise<string> {
8 |   const MAX_STDIN_SIZE = 8 * 1024 * 1024; // 8MB
9 |   return new Promise((resolve, reject) => {
10 |     let data = '';
11 |     let totalSize = 0;
12 |     process.stdin.setEncoding('utf8');
13 | 
14 |     const pipedInputShouldBeAvailableInMs = 500;
15 |     let pipedInputTimerId: null | NodeJS.Timeout = setTimeout(() => {
16 |       // stop reading if input is not available yet, this is needed
17 |       // in terminals where stdin is never TTY and nothing's piped
18 |       // which causes the program to get stuck expecting data from stdin
19 |       onEnd();
20 |     }, pipedInputShouldBeAvailableInMs);
21 | 
22 |     const onReadable = () => {
23 |       let chunk;
24 |       while ((chunk = process.stdin.read()) !== null) {
25 |         if (pipedInputTimerId) {
26 |           clearTimeout(pipedInputTimerId);
27 |           pipedInputTimerId = null;
28 |         }
29 | 
30 |         if (totalSize + chunk.length > MAX_STDIN_SIZE) {
31 |           const remainingSize = MAX_STDIN_SIZE - totalSize;
32 |           data += chunk.slice(0, remainingSize);
33 |           console.warn(
34 |             `Warning: stdin input truncated to ${MAX_STDIN_SIZE} bytes.`,
35 |           );
36 |           process.stdin.destroy(); // Stop reading further
37 |           break;
38 |         }
39 |         data += chunk;
40 |         totalSize += chunk.length;
41 |       }
42 |     };
43 | 
44 |     const onEnd = () => {
45 |       cleanup();
46 |       resolve(data);
47 |     };
48 | 
49 |     const onError = (err: Error) => {
50 |       cleanup();
51 |       reject(err);
52 |     };
53 | 
54 |     const cleanup = () => {
55 |       if (pipedInputTimerId) {
56 |         clearTimeout(pipedInputTimerId);
57 |         pipedInputTimerId = null;
58 |       }
59 |       process.stdin.removeListener('readable', onReadable);
60 |       process.stdin.removeListener('end', onEnd);
61 |       process.stdin.removeListener('error', onError);
62 |     };
63 | 
64 |     process.stdin.on('readable', onReadable);
65 |     process.stdin.on('end', onEnd);
66 |     process.stdin.on('error', onError);
67 |   });
68 | }
```

src/utils/relaunch.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import {
8 |   vi,
9 |   describe,
10 |   it,
11 |   expect,
12 |   beforeEach,
13 |   afterEach,
14 |   type MockInstance,
15 | } from 'vitest';
16 | import { EventEmitter } from 'node:events';
17 | import { RELAUNCH_EXIT_CODE } from './processUtils.js';
18 | import type { ChildProcess } from 'node:child_process';
19 | import { spawn } from 'node:child_process';
20 | 
21 | vi.mock('node:child_process', async (importOriginal) => {
22 |   const actual = await importOriginal<typeof import('node:child_process')>();
23 |   return {
24 |     ...actual,
25 |     spawn: vi.fn(),
26 |   };
27 | });
28 | 
29 | const mockedSpawn = vi.mocked(spawn);
30 | 
31 | // Import the functions initially
32 | import { relaunchAppInChildProcess, relaunchOnExitCode } from './relaunch.js';
33 | 
34 | describe('relaunchOnExitCode', () => {
35 |   let processExitSpy: MockInstance;
36 |   let consoleErrorSpy: MockInstance;
37 |   let stdinResumeSpy: MockInstance;
38 | 
39 |   beforeEach(() => {
40 |     processExitSpy = vi.spyOn(process, 'exit').mockImplementation(() => {
41 |       throw new Error('PROCESS_EXIT_CALLED');
42 |     });
43 |     consoleErrorSpy = vi.spyOn(console, 'error').mockImplementation(() => {});
44 |     stdinResumeSpy = vi
45 |       .spyOn(process.stdin, 'resume')
46 |       .mockImplementation(() => process.stdin);
47 |     vi.clearAllMocks();
48 |   });
49 | 
50 |   afterEach(() => {
51 |     processExitSpy.mockRestore();
52 |     consoleErrorSpy.mockRestore();
53 |     stdinResumeSpy.mockRestore();
54 |   });
55 | 
56 |   it('should exit with non-RELAUNCH_EXIT_CODE', async () => {
57 |     const runner = vi.fn().mockResolvedValue(0);
58 | 
59 |     await expect(relaunchOnExitCode(runner)).rejects.toThrow(
60 |       'PROCESS_EXIT_CALLED',
61 |     );
62 | 
63 |     expect(runner).toHaveBeenCalledTimes(1);
64 |     expect(processExitSpy).toHaveBeenCalledWith(0);
65 |   });
66 | 
67 |   it('should continue running when RELAUNCH_EXIT_CODE is returned', async () => {
68 |     let callCount = 0;
69 |     const runner = vi.fn().mockImplementation(async () => {
70 |       callCount++;
71 |       if (callCount === 1) return RELAUNCH_EXIT_CODE;
72 |       if (callCount === 2) return RELAUNCH_EXIT_CODE;
73 |       return 0; // Exit on third call
74 |     });
75 | 
76 |     await expect(relaunchOnExitCode(runner)).rejects.toThrow(
77 |       'PROCESS_EXIT_CALLED',
78 |     );
79 | 
80 |     expect(runner).toHaveBeenCalledTimes(3);
81 |     expect(processExitSpy).toHaveBeenCalledWith(0);
82 |   });
83 | 
84 |   it('should handle runner errors', async () => {
85 |     const error = new Error('Runner failed');
86 |     const runner = vi.fn().mockRejectedValue(error);
87 | 
88 |     await expect(relaunchOnExitCode(runner)).rejects.toThrow(
89 |       'PROCESS_EXIT_CALLED',
90 |     );
91 | 
92 |     expect(runner).toHaveBeenCalledTimes(1);
93 |     expect(consoleErrorSpy).toHaveBeenCalledWith(
94 |       'Fatal error: Failed to relaunch the CLI process.',
95 |       error,
96 |     );
97 |     expect(stdinResumeSpy).toHaveBeenCalled();
98 |     expect(processExitSpy).toHaveBeenCalledWith(1);
99 |   });
100 | });
101 | 
102 | describe('relaunchAppInChildProcess', () => {
103 |   let processExitSpy: MockInstance;
104 |   let consoleErrorSpy: MockInstance;
105 |   let stdinPauseSpy: MockInstance;
106 |   let stdinResumeSpy: MockInstance;
107 | 
108 |   // Store original values to restore later
109 |   const originalEnv = { ...process.env };
110 |   const originalExecArgv = [...process.execArgv];
111 |   const originalArgv = [...process.argv];
112 |   const originalExecPath = process.execPath;
113 | 
114 |   beforeEach(() => {
115 |     vi.clearAllMocks();
116 | 
117 |     process.env = { ...originalEnv };
118 |     delete process.env['GEMINI_CLI_NO_RELAUNCH'];
119 | 
120 |     process.execArgv = [...originalExecArgv];
121 |     process.argv = [...originalArgv];
122 |     process.execPath = '/usr/bin/node';
123 | 
124 |     processExitSpy = vi.spyOn(process, 'exit').mockImplementation(() => {
125 |       throw new Error('PROCESS_EXIT_CALLED');
126 |     });
127 |     consoleErrorSpy = vi.spyOn(console, 'error').mockImplementation(() => {});
128 |     stdinPauseSpy = vi
129 |       .spyOn(process.stdin, 'pause')
130 |       .mockImplementation(() => process.stdin);
131 |     stdinResumeSpy = vi
132 |       .spyOn(process.stdin, 'resume')
133 |       .mockImplementation(() => process.stdin);
134 |   });
135 | 
136 |   afterEach(() => {
137 |     process.env = { ...originalEnv };
138 |     process.execArgv = [...originalExecArgv];
139 |     process.argv = [...originalArgv];
140 |     process.execPath = originalExecPath;
141 | 
142 |     processExitSpy.mockRestore();
143 |     consoleErrorSpy.mockRestore();
144 |     stdinPauseSpy.mockRestore();
145 |     stdinResumeSpy.mockRestore();
146 |   });
147 | 
148 |   describe('when GEMINI_CLI_NO_RELAUNCH is set', () => {
149 |     it('should return early without spawning a child process', async () => {
150 |       process.env['GEMINI_CLI_NO_RELAUNCH'] = 'true';
151 | 
152 |       await relaunchAppInChildProcess(['--test'], ['--verbose']);
153 | 
154 |       expect(mockedSpawn).not.toHaveBeenCalled();
155 |       expect(processExitSpy).not.toHaveBeenCalled();
156 |     });
157 |   });
158 | 
159 |   describe('when GEMINI_CLI_NO_RELAUNCH is not set', () => {
160 |     beforeEach(() => {
161 |       delete process.env['GEMINI_CLI_NO_RELAUNCH'];
162 |     });
163 | 
164 |     it('should construct correct node arguments from execArgv, additionalNodeArgs, script, additionalScriptArgs, and argv', () => {
165 |       // Test the argument construction logic directly by extracting it into a testable function
166 |       // This tests the same logic that's used in relaunchAppInChildProcess
167 | 
168 |       // Setup test data to verify argument ordering
169 |       const mockExecArgv = ['--inspect=9229', '--trace-warnings'];
170 |       const mockArgv = [
171 |         '/usr/bin/node',
172 |         '/path/to/cli.js',
173 |         'command',
174 |         '--flag=value',
175 |         '--verbose',
176 |       ];
177 |       const additionalNodeArgs = [
178 |         '--max-old-space-size=4096',
179 |         '--experimental-modules',
180 |       ];
181 |       const additionalScriptArgs = ['--model', 'gemini-1.5-pro', '--debug'];
182 | 
183 |       // Extract the argument construction logic from relaunchAppInChildProcess
184 |       const script = mockArgv[1];
185 |       const scriptArgs = mockArgv.slice(2);
186 | 
187 |       const nodeArgs = [
188 |         ...mockExecArgv,
189 |         ...additionalNodeArgs,
190 |         script,
191 |         ...additionalScriptArgs,
192 |         ...scriptArgs,
193 |       ];
194 | 
195 |       // Verify the argument construction follows the expected pattern:
196 |       // [...process.execArgv, ...additionalNodeArgs, script, ...additionalScriptArgs, ...scriptArgs]
197 |       const expectedArgs = [
198 |         // Original node execution arguments
199 |         '--inspect=9229',
200 |         '--trace-warnings',
201 |         // Additional node arguments passed to function
202 |         '--max-old-space-size=4096',
203 |         '--experimental-modules',
204 |         // The script path
205 |         '/path/to/cli.js',
206 |         // Additional script arguments passed to function
207 |         '--model',
208 |         'gemini-1.5-pro',
209 |         '--debug',
210 |         // Original script arguments (everything after the script in process.argv)
211 |         'command',
212 |         '--flag=value',
213 |         '--verbose',
214 |       ];
215 | 
216 |       expect(nodeArgs).toEqual(expectedArgs);
217 |     });
218 | 
219 |     it('should handle empty additional arguments correctly', () => {
220 |       // Test edge cases with empty arrays
221 |       const mockExecArgv = ['--trace-warnings'];
222 |       const mockArgv = ['/usr/bin/node', '/app/cli.js', 'start'];
223 |       const additionalNodeArgs: string[] = [];
224 |       const additionalScriptArgs: string[] = [];
225 | 
226 |       // Extract the argument construction logic
227 |       const script = mockArgv[1];
228 |       const scriptArgs = mockArgv.slice(2);
229 | 
230 |       const nodeArgs = [
231 |         ...mockExecArgv,
232 |         ...additionalNodeArgs,
233 |         script,
234 |         ...additionalScriptArgs,
235 |         ...scriptArgs,
236 |       ];
237 | 
238 |       const expectedArgs = ['--trace-warnings', '/app/cli.js', 'start'];
239 | 
240 |       expect(nodeArgs).toEqual(expectedArgs);
241 |     });
242 | 
243 |     it('should handle complex argument patterns', () => {
244 |       // Test with various argument types including flags with values, boolean flags, etc.
245 |       const mockExecArgv = ['--max-old-space-size=8192'];
246 |       const mockArgv = [
247 |         '/usr/bin/node',
248 |         '/cli.js',
249 |         '--config=/path/to/config.json',
250 |         '--verbose',
251 |         'subcommand',
252 |         '--output',
253 |         'file.txt',
254 |       ];
255 |       const additionalNodeArgs = ['--inspect-brk=9230'];
256 |       const additionalScriptArgs = ['--model=gpt-4', '--temperature=0.7'];
257 | 
258 |       const script = mockArgv[1];
259 |       const scriptArgs = mockArgv.slice(2);
260 | 
261 |       const nodeArgs = [
262 |         ...mockExecArgv,
263 |         ...additionalNodeArgs,
264 |         script,
265 |         ...additionalScriptArgs,
266 |         ...scriptArgs,
267 |       ];
268 | 
269 |       const expectedArgs = [
270 |         '--max-old-space-size=8192',
271 |         '--inspect-brk=9230',
272 |         '/cli.js',
273 |         '--model=gpt-4',
274 |         '--temperature=0.7',
275 |         '--config=/path/to/config.json',
276 |         '--verbose',
277 |         'subcommand',
278 |         '--output',
279 |         'file.txt',
280 |       ];
281 | 
282 |       expect(nodeArgs).toEqual(expectedArgs);
283 |     });
284 | 
285 |     // Note: Additional integration tests for spawn behavior are complex due to module mocking
286 |     // limitations with ES modules. The core logic is tested in relaunchOnExitCode tests.
287 | 
288 |     it('should handle null exit code from child process', async () => {
289 |       process.argv = ['/usr/bin/node', '/app/cli.js'];
290 | 
291 |       const mockChild = createMockChildProcess(0, false); // Don't auto-close
292 |       mockedSpawn.mockImplementation(() => {
293 |         // Emit close with null code immediately
294 |         setImmediate(() => {
295 |           mockChild.emit('close', null);
296 |         });
297 |         return mockChild;
298 |       });
299 | 
300 |       // Start the relaunch process
301 |       const promise = relaunchAppInChildProcess([], []);
302 | 
303 |       await expect(promise).rejects.toThrow('PROCESS_EXIT_CALLED');
304 | 
305 |       // Should default to exit code 1
306 |       expect(processExitSpy).toHaveBeenCalledWith(1);
307 |     });
308 |   });
309 | });
310 | 
311 | /**
312 |  * Creates a mock child process that emits events asynchronously
313 |  */
314 | function createMockChildProcess(
315 |   exitCode: number = 0,
316 |   autoClose: boolean = false,
317 | ): ChildProcess {
318 |   const mockChild = new EventEmitter() as ChildProcess;
319 | 
320 |   Object.assign(mockChild, {
321 |     stdin: null,
322 |     stdout: null,
323 |     stderr: null,
324 |     stdio: [null, null, null],
325 |     pid: 12345,
326 |     killed: false,
327 |     exitCode: null,
328 |     signalCode: null,
329 |     spawnargs: [],
330 |     spawnfile: '',
331 |     kill: vi.fn(),
332 |     send: vi.fn(),
333 |     disconnect: vi.fn(),
334 |     unref: vi.fn(),
335 |     ref: vi.fn(),
336 |   });
337 | 
338 |   if (autoClose) {
339 |     setImmediate(() => {
340 |       mockChild.emit('close', exitCode);
341 |     });
342 |   }
343 | 
344 |   return mockChild;
345 | }
```

src/utils/relaunch.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { spawn } from 'node:child_process';
8 | import { RELAUNCH_EXIT_CODE } from './processUtils.js';
9 | 
10 | export async function relaunchOnExitCode(runner: () => Promise<number>) {
11 |   while (true) {
12 |     try {
13 |       const exitCode = await runner();
14 | 
15 |       if (exitCode !== RELAUNCH_EXIT_CODE) {
16 |         process.exit(exitCode);
17 |       }
18 |     } catch (error) {
19 |       process.stdin.resume();
20 |       console.error('Fatal error: Failed to relaunch the CLI process.', error);
21 |       process.exit(1);
22 |     }
23 |   }
24 | }
25 | 
26 | export async function relaunchAppInChildProcess(
27 |   additionalNodeArgs: string[],
28 |   additionalScriptArgs: string[],
29 | ) {
30 |   if (process.env['GEMINI_CLI_NO_RELAUNCH']) {
31 |     return;
32 |   }
33 | 
34 |   const runner = () => {
35 |     // process.argv is [node, script, ...args]
36 |     // We want to construct [ ...nodeArgs, script, ...scriptArgs]
37 |     const script = process.argv[1];
38 |     const scriptArgs = process.argv.slice(2);
39 | 
40 |     const nodeArgs = [
41 |       ...process.execArgv,
42 |       ...additionalNodeArgs,
43 |       script,
44 |       ...additionalScriptArgs,
45 |       ...scriptArgs,
46 |     ];
47 |     const newEnv = { ...process.env, GEMINI_CLI_NO_RELAUNCH: 'true' };
48 | 
49 |     // The parent process should not be reading from stdin while the child is running.
50 |     process.stdin.pause();
51 | 
52 |     const child = spawn(process.execPath, nodeArgs, {
53 |       stdio: 'inherit',
54 |       env: newEnv,
55 |     });
56 | 
57 |     return new Promise<number>((resolve, reject) => {
58 |       child.on('error', reject);
59 |       child.on('close', (code) => {
60 |         // Resume stdin before the parent process exits.
61 |         process.stdin.resume();
62 |         resolve(code ?? 1);
63 |       });
64 |     });
65 |   };
66 | 
67 |   await relaunchOnExitCode(runner);
68 | }
```

src/utils/resolvePath.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import * as os from 'node:os';
8 | import * as path from 'node:path';
9 | 
10 | export function resolvePath(p: string): string {
11 |   if (!p) {
12 |     return '';
13 |   }
14 |   let expandedPath = p;
15 |   if (p.toLowerCase().startsWith('%userprofile%')) {
16 |     expandedPath = os.homedir() + p.substring('%userprofile%'.length);
17 |   } else if (p === '~' || p.startsWith('~/')) {
18 |     expandedPath = os.homedir() + p.substring(1);
19 |   }
20 |   return path.normalize(expandedPath);
21 | }
```

src/utils/sandbox-macos-permissive-closed.sb
```
1 | (version 1)
2 | 
3 | ;; allow everything by default
4 | (allow default)
5 | 
6 | ;; deny all writes EXCEPT under specific paths
7 | (deny file-write*)
8 | (allow file-write*
9 |     (subpath (param "TARGET_DIR"))
10 |     (subpath (param "TMP_DIR"))
11 |     (subpath (param "CACHE_DIR"))
12 |     (subpath (string-append (param "HOME_DIR") "/.gemini"))
13 |     (subpath (string-append (param "HOME_DIR") "/.npm"))
14 |     (subpath (string-append (param "HOME_DIR") "/.cache"))
15 |     (subpath (string-append (param "HOME_DIR") "/.gitconfig"))
16 |     ;; Allow writes to included directories from --include-directories
17 |     (subpath (param "INCLUDE_DIR_0"))
18 |     (subpath (param "INCLUDE_DIR_1"))
19 |     (subpath (param "INCLUDE_DIR_2"))
20 |     (subpath (param "INCLUDE_DIR_3"))
21 |     (subpath (param "INCLUDE_DIR_4"))
22 |     (literal "/dev/stdout")
23 |     (literal "/dev/stderr")
24 |     (literal "/dev/null")
25 | )
26 | 
27 | ;; deny all inbound network traffic EXCEPT on debugger port
28 | (deny network-inbound)
29 | (allow network-inbound (local ip "localhost:9229"))
30 | 
31 | ;; deny all outbound network traffic
32 | (deny network-outbound)
```

src/utils/sandbox-macos-permissive-open.sb
```
1 | (version 1)
2 | 
3 | ;; allow everything by default
4 | (allow default)
5 | 
6 | ;; deny all writes EXCEPT under specific paths
7 | (deny file-write*)
8 | (allow file-write*
9 |     (subpath (param "TARGET_DIR"))
10 |     (subpath (param "TMP_DIR"))
11 |     (subpath (param "CACHE_DIR"))
12 |     (subpath (string-append (param "HOME_DIR") "/.gemini"))
13 |     (subpath (string-append (param "HOME_DIR") "/.npm"))
14 |     (subpath (string-append (param "HOME_DIR") "/.cache"))
15 |     (subpath (string-append (param "HOME_DIR") "/.gitconfig"))
16 |     ;; Allow writes to included directories from --include-directories
17 |     (subpath (param "INCLUDE_DIR_0"))
18 |     (subpath (param "INCLUDE_DIR_1"))
19 |     (subpath (param "INCLUDE_DIR_2"))
20 |     (subpath (param "INCLUDE_DIR_3"))
21 |     (subpath (param "INCLUDE_DIR_4"))
22 |     (literal "/dev/stdout")
23 |     (literal "/dev/stderr")
24 |     (literal "/dev/null")
25 | )
```

src/utils/sandbox-macos-permissive-proxied.sb
```
1 | (version 1)
2 | 
3 | ;; allow everything by default
4 | (allow default)
5 | 
6 | ;; deny all writes EXCEPT under specific paths
7 | (deny file-write*)
8 | (allow file-write*
9 |     (subpath (param "TARGET_DIR"))
10 |     (subpath (param "TMP_DIR"))
11 |     (subpath (param "CACHE_DIR"))
12 |     (subpath (string-append (param "HOME_DIR") "/.gemini"))
13 |     (subpath (string-append (param "HOME_DIR") "/.npm"))
14 |     (subpath (string-append (param "HOME_DIR") "/.cache"))
15 |     (subpath (string-append (param "HOME_DIR") "/.gitconfig"))
16 |     ;; Allow writes to included directories from --include-directories
17 |     (subpath (param "INCLUDE_DIR_0"))
18 |     (subpath (param "INCLUDE_DIR_1"))
19 |     (subpath (param "INCLUDE_DIR_2"))
20 |     (subpath (param "INCLUDE_DIR_3"))
21 |     (subpath (param "INCLUDE_DIR_4"))
22 |     (literal "/dev/stdout")
23 |     (literal "/dev/stderr")
24 |     (literal "/dev/null")
25 | )
26 | 
27 | ;; deny all inbound network traffic EXCEPT on debugger port
28 | (deny network-inbound)
29 | (allow network-inbound (local ip "localhost:9229"))
30 | 
31 | ;; deny all outbound network traffic EXCEPT through proxy on localhost:8877
32 | ;; set `GEMINI_SANDBOX_PROXY_COMMAND=<command>` to run proxy alongside sandbox
33 | ;; proxy must listen on :::8877 (see docs/examples/proxy-script.md)
34 | (deny network-outbound)
35 | (allow network-outbound (remote tcp "localhost:8877"))
36 | 
37 | (allow network-bind (local ip "*:*"))
```

src/utils/sandbox-macos-restrictive-closed.sb
```
1 | (version 1)
2 | 
3 | ;; deny everything by default
4 | (deny default)
5 | 
6 | ;; allow reading files from anywhere on host
7 | (allow file-read*)
8 | 
9 | ;; allow exec/fork (children inherit policy)
10 | (allow process-exec)
11 | (allow process-fork)
12 | 
13 | ;; allow signals to self, e.g. SIGPIPE on write to closed pipe
14 | (allow signal (target self))
15 | 
16 | ;; allow read access to specific information about system
17 | ;; from https://source.chromium.org/chromium/chromium/src/+/main:sandbox/policy/mac/common.sb;l=273-319;drc=7b3962fe2e5fc9e2ee58000dc8fbf3429d84d3bd
18 | (allow sysctl-read
19 |   (sysctl-name "hw.activecpu")
20 |   (sysctl-name "hw.busfrequency_compat")
21 |   (sysctl-name "hw.byteorder")
22 |   (sysctl-name "hw.cacheconfig")
23 |   (sysctl-name "hw.cachelinesize_compat")
24 |   (sysctl-name "hw.cpufamily")
25 |   (sysctl-name "hw.cpufrequency_compat")
26 |   (sysctl-name "hw.cputype")
27 |   (sysctl-name "hw.l1dcachesize_compat")
28 |   (sysctl-name "hw.l1icachesize_compat")
29 |   (sysctl-name "hw.l2cachesize_compat")
30 |   (sysctl-name "hw.l3cachesize_compat")
31 |   (sysctl-name "hw.logicalcpu_max")
32 |   (sysctl-name "hw.machine")
33 |   (sysctl-name "hw.ncpu")
34 |   (sysctl-name "hw.nperflevels")
35 |   (sysctl-name "hw.optional.arm.FEAT_BF16")
36 |   (sysctl-name "hw.optional.arm.FEAT_DotProd")
37 |   (sysctl-name "hw.optional.arm.FEAT_FCMA")
38 |   (sysctl-name "hw.optional.arm.FEAT_FHM")
39 |   (sysctl-name "hw.optional.arm.FEAT_FP16")
40 |   (sysctl-name "hw.optional.arm.FEAT_I8MM")
41 |   (sysctl-name "hw.optional.arm.FEAT_JSCVT")
42 |   (sysctl-name "hw.optional.arm.FEAT_LSE")
43 |   (sysctl-name "hw.optional.arm.FEAT_RDM")
44 |   (sysctl-name "hw.optional.arm.FEAT_SHA512")
45 |   (sysctl-name "hw.optional.armv8_2_sha512")
46 |   (sysctl-name "hw.packages")
47 |   (sysctl-name "hw.pagesize_compat")
48 |   (sysctl-name "hw.physicalcpu_max")
49 |   (sysctl-name "hw.tbfrequency_compat")
50 |   (sysctl-name "hw.vectorunit")
51 |   (sysctl-name "kern.hostname")
52 |   (sysctl-name "kern.maxfilesperproc")
53 |   (sysctl-name "kern.osproductversion")
54 |   (sysctl-name "kern.osrelease")
55 |   (sysctl-name "kern.ostype")
56 |   (sysctl-name "kern.osvariant_status")
57 |   (sysctl-name "kern.osversion")
58 |   (sysctl-name "kern.secure_kernel")
59 |   (sysctl-name "kern.usrstack64")
60 |   (sysctl-name "kern.version")
61 |   (sysctl-name "sysctl.proc_cputype")
62 |   (sysctl-name-prefix "hw.perflevel")
63 | )
64 | 
65 | ;; allow writes to specific paths
66 | (allow file-write*
67 |     (subpath (param "TARGET_DIR"))
68 |     (subpath (param "TMP_DIR"))
69 |     (subpath (param "CACHE_DIR"))
70 |     (subpath (string-append (param "HOME_DIR") "/.gemini"))
71 |     (subpath (string-append (param "HOME_DIR") "/.npm"))
72 |     (subpath (string-append (param "HOME_DIR") "/.cache"))
73 |     (subpath (string-append (param "HOME_DIR") "/.gitconfig"))
74 |     ;; Allow writes to included directories from --include-directories
75 |     (subpath (param "INCLUDE_DIR_0"))
76 |     (subpath (param "INCLUDE_DIR_1"))
77 |     (subpath (param "INCLUDE_DIR_2"))
78 |     (subpath (param "INCLUDE_DIR_3"))
79 |     (subpath (param "INCLUDE_DIR_4"))
80 |     (literal "/dev/stdout")
81 |     (literal "/dev/stderr")
82 |     (literal "/dev/null")
83 | )
84 | 
85 | ;; allow communication with sysmond for process listing (e.g. for pgrep)
86 | (allow mach-lookup (global-name "com.apple.sysmond"))
87 | 
88 | ;; enable terminal access required by ink
89 | ;; fixes setRawMode EPERM failure (at node:tty:81:24)
90 | (allow file-ioctl (regex #"^/dev/tty.*"))
91 | 
92 | ;; allow inbound network traffic on debugger port
93 | (allow network-inbound (local ip "localhost:9229"))
```

src/utils/sandbox-macos-restrictive-open.sb
```
1 | (version 1)
2 | 
3 | ;; deny everything by default
4 | (deny default)
5 | 
6 | ;; allow reading files from anywhere on host
7 | (allow file-read*)
8 | 
9 | ;; allow exec/fork (children inherit policy)
10 | (allow process-exec)
11 | (allow process-fork)
12 | 
13 | ;; allow signals to self, e.g. SIGPIPE on write to closed pipe
14 | (allow signal (target self))
15 | 
16 | ;; allow read access to specific information about system
17 | ;; from https://source.chromium.org/chromium/chromium/src/+/main:sandbox/policy/mac/common.sb;l=273-319;drc=7b3962fe2e5fc9e2ee58000dc8fbf3429d84d3bd
18 | (allow sysctl-read
19 |   (sysctl-name "hw.activecpu")
20 |   (sysctl-name "hw.busfrequency_compat")
21 |   (sysctl-name "hw.byteorder")
22 |   (sysctl-name "hw.cacheconfig")
23 |   (sysctl-name "hw.cachelinesize_compat")
24 |   (sysctl-name "hw.cpufamily")
25 |   (sysctl-name "hw.cpufrequency_compat")
26 |   (sysctl-name "hw.cputype")
27 |   (sysctl-name "hw.l1dcachesize_compat")
28 |   (sysctl-name "hw.l1icachesize_compat")
29 |   (sysctl-name "hw.l2cachesize_compat")
30 |   (sysctl-name "hw.l3cachesize_compat")
31 |   (sysctl-name "hw.logicalcpu_max")
32 |   (sysctl-name "hw.machine")
33 |   (sysctl-name "hw.ncpu")
34 |   (sysctl-name "hw.nperflevels")
35 |   (sysctl-name "hw.optional.arm.FEAT_BF16")
36 |   (sysctl-name "hw.optional.arm.FEAT_DotProd")
37 |   (sysctl-name "hw.optional.arm.FEAT_FCMA")
38 |   (sysctl-name "hw.optional.arm.FEAT_FHM")
39 |   (sysctl-name "hw.optional.arm.FEAT_FP16")
40 |   (sysctl-name "hw.optional.arm.FEAT_I8MM")
41 |   (sysctl-name "hw.optional.arm.FEAT_JSCVT")
42 |   (sysctl-name "hw.optional.arm.FEAT_LSE")
43 |   (sysctl-name "hw.optional.arm.FEAT_RDM")
44 |   (sysctl-name "hw.optional.arm.FEAT_SHA512")
45 |   (sysctl-name "hw.optional.armv8_2_sha512")
46 |   (sysctl-name "hw.packages")
47 |   (sysctl-name "hw.pagesize_compat")
48 |   (sysctl-name "hw.physicalcpu_max")
49 |   (sysctl-name "hw.tbfrequency_compat")
50 |   (sysctl-name "hw.vectorunit")
51 |   (sysctl-name "kern.hostname")
52 |   (sysctl-name "kern.maxfilesperproc")
53 |   (sysctl-name "kern.osproductversion")
54 |   (sysctl-name "kern.osrelease")
55 |   (sysctl-name "kern.ostype")
56 |   (sysctl-name "kern.osvariant_status")
57 |   (sysctl-name "kern.osversion")
58 |   (sysctl-name "kern.secure_kernel")
59 |   (sysctl-name "kern.usrstack64")
60 |   (sysctl-name "kern.version")
61 |   (sysctl-name "sysctl.proc_cputype")
62 |   (sysctl-name-prefix "hw.perflevel")
63 | )
64 | 
65 | ;; allow writes to specific paths
66 | (allow file-write*
67 |     (subpath (param "TARGET_DIR"))
68 |     (subpath (param "TMP_DIR"))
69 |     (subpath (param "CACHE_DIR"))
70 |     (subpath (string-append (param "HOME_DIR") "/.gemini"))
71 |     (subpath (string-append (param "HOME_DIR") "/.npm"))
72 |     (subpath (string-append (param "HOME_DIR") "/.cache"))
73 |     (subpath (string-append (param "HOME_DIR") "/.gitconfig"))
74 |     ;; Allow writes to included directories from --include-directories
75 |     (subpath (param "INCLUDE_DIR_0"))
76 |     (subpath (param "INCLUDE_DIR_1"))
77 |     (subpath (param "INCLUDE_DIR_2"))
78 |     (subpath (param "INCLUDE_DIR_3"))
79 |     (subpath (param "INCLUDE_DIR_4"))
80 |     (literal "/dev/stdout")
81 |     (literal "/dev/stderr")
82 |     (literal "/dev/null")
83 | )
84 | 
85 | ;; allow communication with sysmond for process listing (e.g. for pgrep)
86 | (allow mach-lookup (global-name "com.apple.sysmond"))
87 | 
88 | ;; enable terminal access required by ink
89 | ;; fixes setRawMode EPERM failure (at node:tty:81:24)
90 | (allow file-ioctl (regex #"^/dev/tty.*"))
91 | 
92 | ;; allow inbound network traffic on debugger port
93 | (allow network-inbound (local ip "localhost:9229"))
94 | 
95 | ;; allow all outbound network traffic
96 | (allow network-outbound)
```

src/utils/sandbox-macos-restrictive-proxied.sb
```
1 | (version 1)
2 | 
3 | ;; deny everything by default
4 | (deny default)
5 | 
6 | ;; allow reading files from anywhere on host
7 | (allow file-read*)
8 | 
9 | ;; allow exec/fork (children inherit policy)
10 | (allow process-exec)
11 | (allow process-fork)
12 | 
13 | ;; allow signals to self, e.g. SIGPIPE on write to closed pipe
14 | (allow signal (target self))
15 | 
16 | ;; allow read access to specific information about system
17 | ;; from https://source.chromium.org/chromium/chromium/src/+/main:sandbox/policy/mac/common.sb;l=273-319;drc=7b3962fe2e5fc9e2ee58000dc8fbf3429d84d3bd
18 | (allow sysctl-read
19 |   (sysctl-name "hw.activecpu")
20 |   (sysctl-name "hw.busfrequency_compat")
21 |   (sysctl-name "hw.byteorder")
22 |   (sysctl-name "hw.cacheconfig")
23 |   (sysctl-name "hw.cachelinesize_compat")
24 |   (sysctl-name "hw.cpufamily")
25 |   (sysctl-name "hw.cpufrequency_compat")
26 |   (sysctl-name "hw.cputype")
27 |   (sysctl-name "hw.l1dcachesize_compat")
28 |   (sysctl-name "hw.l1icachesize_compat")
29 |   (sysctl-name "hw.l2cachesize_compat")
30 |   (sysctl-name "hw.l3cachesize_compat")
31 |   (sysctl-name "hw.logicalcpu_max")
32 |   (sysctl-name "hw.machine")
33 |   (sysctl-name "hw.ncpu")
34 |   (sysctl-name "hw.nperflevels")
35 |   (sysctl-name "hw.optional.arm.FEAT_BF16")
36 |   (sysctl-name "hw.optional.arm.FEAT_DotProd")
37 |   (sysctl-name "hw.optional.arm.FEAT_FCMA")
38 |   (sysctl-name "hw.optional.arm.FEAT_FHM")
39 |   (sysctl-name "hw.optional.arm.FEAT_FP16")
40 |   (sysctl-name "hw.optional.arm.FEAT_I8MM")
41 |   (sysctl-name "hw.optional.arm.FEAT_JSCVT")
42 |   (sysctl-name "hw.optional.arm.FEAT_LSE")
43 |   (sysctl-name "hw.optional.arm.FEAT_RDM")
44 |   (sysctl-name "hw.optional.arm.FEAT_SHA512")
45 |   (sysctl-name "hw.optional.armv8_2_sha512")
46 |   (sysctl-name "hw.packages")
47 |   (sysctl-name "hw.pagesize_compat")
48 |   (sysctl-name "hw.physicalcpu_max")
49 |   (sysctl-name "hw.tbfrequency_compat")
50 |   (sysctl-name "hw.vectorunit")
51 |   (sysctl-name "kern.hostname")
52 |   (sysctl-name "kern.maxfilesperproc")
53 |   (sysctl-name "kern.osproductversion")
54 |   (sysctl-name "kern.osrelease")
55 |   (sysctl-name "kern.ostype")
56 |   (sysctl-name "kern.osvariant_status")
57 |   (sysctl-name "kern.osversion")
58 |   (sysctl-name "kern.secure_kernel")
59 |   (sysctl-name "kern.usrstack64")
60 |   (sysctl-name "kern.version")
61 |   (sysctl-name "sysctl.proc_cputype")
62 |   (sysctl-name-prefix "hw.perflevel")
63 | )
64 | 
65 | ;; allow writes to specific paths
66 | (allow file-write*
67 |     (subpath (param "TARGET_DIR"))
68 |     (subpath (param "TMP_DIR"))
69 |     (subpath (param "CACHE_DIR"))
70 |     (subpath (string-append (param "HOME_DIR") "/.gemini"))
71 |     (subpath (string-append (param "HOME_DIR") "/.npm"))
72 |     (subpath (string-append (param "HOME_DIR") "/.cache"))
73 |     (subpath (string-append (param "HOME_DIR") "/.gitconfig"))
74 |     ;; Allow writes to included directories from --include-directories
75 |     (subpath (param "INCLUDE_DIR_0"))
76 |     (subpath (param "INCLUDE_DIR_1"))
77 |     (subpath (param "INCLUDE_DIR_2"))
78 |     (subpath (param "INCLUDE_DIR_3"))
79 |     (subpath (param "INCLUDE_DIR_4"))
80 |     (literal "/dev/stdout")
81 |     (literal "/dev/stderr")
82 |     (literal "/dev/null")
83 | )
84 | 
85 | ;; allow communication with sysmond for process listing (e.g. for pgrep)
86 | (allow mach-lookup (global-name "com.apple.sysmond"))
87 | 
88 | ;; enable terminal access required by ink
89 | ;; fixes setRawMode EPERM failure (at node:tty:81:24)
90 | (allow file-ioctl (regex #"^/dev/tty.*"))
91 | 
92 | ;; allow inbound network traffic on debugger port
93 | (allow network-inbound (local ip "localhost:9229"))
94 | 
95 | ;; allow outbound network traffic through proxy on localhost:8877
96 | ;; set `GEMINI_SANDBOX_PROXY_COMMAND=<command>` to run proxy alongside sandbox
97 | ;; proxy must listen on :::8877 (see docs/examples/proxy-script.md)
98 | (allow network-outbound (remote tcp "localhost:8877"))
```

src/utils/sandbox.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { exec, execSync, spawn, type ChildProcess } from 'node:child_process';
8 | import os from 'node:os';
9 | import path from 'node:path';
10 | import fs from 'node:fs';
11 | import { readFile } from 'node:fs/promises';
12 | import { fileURLToPath } from 'node:url';
13 | import { quote, parse } from 'shell-quote';
14 | import {
15 |   USER_SETTINGS_DIR,
16 |   SETTINGS_DIRECTORY_NAME,
17 | } from '../config/settings.js';
18 | import { promisify } from 'node:util';
19 | import type { Config, SandboxConfig } from '@google/gemini-cli-core';
20 | import { FatalSandboxError } from '@google/gemini-cli-core';
21 | import { ConsolePatcher } from '../ui/utils/ConsolePatcher.js';
22 | import { randomBytes } from 'node:crypto';
23 | 
24 | const execAsync = promisify(exec);
25 | 
26 | function getContainerPath(hostPath: string): string {
27 |   if (os.platform() !== 'win32') {
28 |     return hostPath;
29 |   }
30 | 
31 |   const withForwardSlashes = hostPath.replace(/\\/g, '/');
32 |   const match = withForwardSlashes.match(/^([A-Z]):\/(.*)/i);
33 |   if (match) {
34 |     return `/${match[1].toLowerCase()}/${match[2]}`;
35 |   }
36 |   return hostPath;
37 | }
38 | 
39 | const LOCAL_DEV_SANDBOX_IMAGE_NAME = 'gemini-cli-sandbox';
40 | const SANDBOX_NETWORK_NAME = 'gemini-cli-sandbox';
41 | const SANDBOX_PROXY_NAME = 'gemini-cli-sandbox-proxy';
42 | const BUILTIN_SEATBELT_PROFILES = [
43 |   'permissive-open',
44 |   'permissive-closed',
45 |   'permissive-proxied',
46 |   'restrictive-open',
47 |   'restrictive-closed',
48 |   'restrictive-proxied',
49 | ];
50 | 
51 | /**
52 |  * Determines whether the sandbox container should be run with the current user's UID and GID.
53 |  * This is often necessary on Linux systems (especially Debian/Ubuntu based) when using
54 |  * rootful Docker without userns-remap configured, to avoid permission issues with
55 |  * mounted volumes.
56 |  *
57 |  * The behavior is controlled by the `SANDBOX_SET_UID_GID` environment variable:
58 |  * - If `SANDBOX_SET_UID_GID` is "1" or "true", this function returns `true`.
59 |  * - If `SANDBOX_SET_UID_GID` is "0" or "false", this function returns `false`.
60 |  * - If `SANDBOX_SET_UID_GID` is not set:
61 |  *   - On Debian/Ubuntu Linux, it defaults to `true`.
62 |  *   - On other OSes, or if OS detection fails, it defaults to `false`.
63 |  *
64 |  * For more context on running Docker containers as non-root, see:
65 |  * https://medium.com/redbubble/running-a-docker-container-as-a-non-root-user-7d2e00f8ee15
66 |  *
67 |  * @returns {Promise<boolean>} A promise that resolves to true if the current user's UID/GID should be used, false otherwise.
68 |  */
69 | async function shouldUseCurrentUserInSandbox(): Promise<boolean> {
70 |   const envVar = process.env['SANDBOX_SET_UID_GID']?.toLowerCase().trim();
71 | 
72 |   if (envVar === '1' || envVar === 'true') {
73 |     return true;
74 |   }
75 |   if (envVar === '0' || envVar === 'false') {
76 |     return false;
77 |   }
78 | 
79 |   // If environment variable is not explicitly set, check for Debian/Ubuntu Linux
80 |   if (os.platform() === 'linux') {
81 |     try {
82 |       const osReleaseContent = await readFile('/etc/os-release', 'utf8');
83 |       if (
84 |         osReleaseContent.includes('ID=debian') ||
85 |         osReleaseContent.includes('ID=ubuntu') ||
86 |         osReleaseContent.match(/^ID_LIKE=.*debian.*/m) || // Covers derivatives
87 |         osReleaseContent.match(/^ID_LIKE=.*ubuntu.*/m) // Covers derivatives
88 |       ) {
89 |         // note here and below we use console.error for informational messages on stderr
90 |         console.error(
91 |           'INFO: Defaulting to use current user UID/GID for Debian/Ubuntu-based Linux.',
92 |         );
93 |         return true;
94 |       }
95 |     } catch (_err) {
96 |       // Silently ignore if /etc/os-release is not found or unreadable.
97 |       // The default (false) will be applied in this case.
98 |       console.warn(
99 |         'Warning: Could not read /etc/os-release to auto-detect Debian/Ubuntu for UID/GID default.',
100 |       );
101 |     }
102 |   }
103 |   return false; // Default to false if no other condition is met
104 | }
105 | 
106 | // docker does not allow container names to contain ':' or '/', so we
107 | // parse those out to shorten the name
108 | function parseImageName(image: string): string {
109 |   const [fullName, tag] = image.split(':');
110 |   const name = fullName.split('/').at(-1) ?? 'unknown-image';
111 |   return tag ? `${name}-${tag}` : name;
112 | }
113 | 
114 | function ports(): string[] {
115 |   return (process.env['SANDBOX_PORTS'] ?? '')
116 |     .split(',')
117 |     .filter((p) => p.trim())
118 |     .map((p) => p.trim());
119 | }
120 | 
121 | function entrypoint(workdir: string, cliArgs: string[]): string[] {
122 |   const isWindows = os.platform() === 'win32';
123 |   const containerWorkdir = getContainerPath(workdir);
124 |   const shellCmds = [];
125 |   const pathSeparator = isWindows ? ';' : ':';
126 | 
127 |   let pathSuffix = '';
128 |   if (process.env['PATH']) {
129 |     const paths = process.env['PATH'].split(pathSeparator);
130 |     for (const p of paths) {
131 |       const containerPath = getContainerPath(p);
132 |       if (
133 |         containerPath.toLowerCase().startsWith(containerWorkdir.toLowerCase())
134 |       ) {
135 |         pathSuffix += `:${containerPath}`;
136 |       }
137 |     }
138 |   }
139 |   if (pathSuffix) {
140 |     shellCmds.push(`export PATH="$PATH${pathSuffix}";`);
141 |   }
142 | 
143 |   let pythonPathSuffix = '';
144 |   if (process.env['PYTHONPATH']) {
145 |     const paths = process.env['PYTHONPATH'].split(pathSeparator);
146 |     for (const p of paths) {
147 |       const containerPath = getContainerPath(p);
148 |       if (
149 |         containerPath.toLowerCase().startsWith(containerWorkdir.toLowerCase())
150 |       ) {
151 |         pythonPathSuffix += `:${containerPath}`;
152 |       }
153 |     }
154 |   }
155 |   if (pythonPathSuffix) {
156 |     shellCmds.push(`export PYTHONPATH="$PYTHONPATH${pythonPathSuffix}";`);
157 |   }
158 | 
159 |   const projectSandboxBashrc = path.join(
160 |     SETTINGS_DIRECTORY_NAME,
161 |     'sandbox.bashrc',
162 |   );
163 |   if (fs.existsSync(projectSandboxBashrc)) {
164 |     shellCmds.push(`source ${getContainerPath(projectSandboxBashrc)};`);
165 |   }
166 | 
167 |   ports().forEach((p) =>
168 |     shellCmds.push(
169 |       `socat TCP4-LISTEN:${p},bind=$(hostname -i),fork,reuseaddr TCP4:127.0.0.1:${p} 2> /dev/null &`,
170 |     ),
171 |   );
172 | 
173 |   const quotedCliArgs = cliArgs.slice(2).map((arg) => quote([arg]));
174 |   const cliCmd =
175 |     process.env['NODE_ENV'] === 'development'
176 |       ? process.env['DEBUG']
177 |         ? 'npm run debug --'
178 |         : 'npm rebuild && npm run start --'
179 |       : process.env['DEBUG']
180 |         ? `node --inspect-brk=0.0.0.0:${process.env['DEBUG_PORT'] || '9229'} $(which gemini)`
181 |         : 'gemini';
182 | 
183 |   const args = [...shellCmds, cliCmd, ...quotedCliArgs];
184 |   return ['bash', '-c', args.join(' ')];
185 | }
186 | 
187 | export async function start_sandbox(
188 |   config: SandboxConfig,
189 |   nodeArgs: string[] = [],
190 |   cliConfig?: Config,
191 |   cliArgs: string[] = [],
192 | ): Promise<number> {
193 |   const patcher = new ConsolePatcher({
194 |     debugMode: cliConfig?.getDebugMode() || !!process.env['DEBUG'],
195 |     stderr: true,
196 |   });
197 |   patcher.patch();
198 | 
199 |   try {
200 |     if (config.command === 'sandbox-exec') {
201 |       // disallow BUILD_SANDBOX
202 |       if (process.env['BUILD_SANDBOX']) {
203 |         throw new FatalSandboxError(
204 |           'Cannot BUILD_SANDBOX when using macOS Seatbelt',
205 |         );
206 |       }
207 | 
208 |       const profile = (process.env['SEATBELT_PROFILE'] ??= 'permissive-open');
209 |       let profileFile = fileURLToPath(
210 |         new URL(`sandbox-macos-${profile}.sb`, import.meta.url),
211 |       );
212 |       // if profile name is not recognized, then look for file under project settings directory
213 |       if (!BUILTIN_SEATBELT_PROFILES.includes(profile)) {
214 |         profileFile = path.join(
215 |           SETTINGS_DIRECTORY_NAME,
216 |           `sandbox-macos-${profile}.sb`,
217 |         );
218 |       }
219 |       if (!fs.existsSync(profileFile)) {
220 |         throw new FatalSandboxError(
221 |           `Missing macos seatbelt profile file '${profileFile}'`,
222 |         );
223 |       }
224 |       // Log on STDERR so it doesn't clutter the output on STDOUT
225 |       console.error(`using macos seatbelt (profile: ${profile}) ...`);
226 |       // if DEBUG is set, convert to --inspect-brk in NODE_OPTIONS
227 |       const nodeOptions = [
228 |         ...(process.env['DEBUG'] ? ['--inspect-brk'] : []),
229 |         ...nodeArgs,
230 |       ].join(' ');
231 | 
232 |       const args = [
233 |         '-D',
234 |         `TARGET_DIR=${fs.realpathSync(process.cwd())}`,
235 |         '-D',
236 |         `TMP_DIR=${fs.realpathSync(os.tmpdir())}`,
237 |         '-D',
238 |         `HOME_DIR=${fs.realpathSync(os.homedir())}`,
239 |         '-D',
240 |         `CACHE_DIR=${fs.realpathSync(execSync(`getconf DARWIN_USER_CACHE_DIR`).toString().trim())}`,
241 |       ];
242 | 
243 |       // Add included directories from the workspace context
244 |       // Always add 5 INCLUDE_DIR parameters to ensure .sb files can reference them
245 |       const MAX_INCLUDE_DIRS = 5;
246 |       const targetDir = fs.realpathSync(cliConfig?.getTargetDir() || '');
247 |       const includedDirs: string[] = [];
248 | 
249 |       if (cliConfig) {
250 |         const workspaceContext = cliConfig.getWorkspaceContext();
251 |         const directories = workspaceContext.getDirectories();
252 | 
253 |         // Filter out TARGET_DIR
254 |         for (const dir of directories) {
255 |           const realDir = fs.realpathSync(dir);
256 |           if (realDir !== targetDir) {
257 |             includedDirs.push(realDir);
258 |           }
259 |         }
260 |       }
261 | 
262 |       for (let i = 0; i < MAX_INCLUDE_DIRS; i++) {
263 |         let dirPath = '/dev/null'; // Default to a safe path that won't cause issues
264 | 
265 |         if (i < includedDirs.length) {
266 |           dirPath = includedDirs[i];
267 |         }
268 | 
269 |         args.push('-D', `INCLUDE_DIR_${i}=${dirPath}`);
270 |       }
271 | 
272 |       const finalArgv = cliArgs;
273 | 
274 |       args.push(
275 |         '-f',
276 |         profileFile,
277 |         'sh',
278 |         '-c',
279 |         [
280 |           `SANDBOX=sandbox-exec`,
281 |           `NODE_OPTIONS="${nodeOptions}"`,
282 |           ...finalArgv.map((arg) => quote([arg])),
283 |         ].join(' '),
284 |       );
285 |       // start and set up proxy if GEMINI_SANDBOX_PROXY_COMMAND is set
286 |       const proxyCommand = process.env['GEMINI_SANDBOX_PROXY_COMMAND'];
287 |       let proxyProcess: ChildProcess | undefined = undefined;
288 |       let sandboxProcess: ChildProcess | undefined = undefined;
289 |       const sandboxEnv = { ...process.env };
290 |       if (proxyCommand) {
291 |         const proxy =
292 |           process.env['HTTPS_PROXY'] ||
293 |           process.env['https_proxy'] ||
294 |           process.env['HTTP_PROXY'] ||
295 |           process.env['http_proxy'] ||
296 |           'http://localhost:8877';
297 |         sandboxEnv['HTTPS_PROXY'] = proxy;
298 |         sandboxEnv['https_proxy'] = proxy; // lower-case can be required, e.g. for curl
299 |         sandboxEnv['HTTP_PROXY'] = proxy;
300 |         sandboxEnv['http_proxy'] = proxy;
301 |         const noProxy = process.env['NO_PROXY'] || process.env['no_proxy'];
302 |         if (noProxy) {
303 |           sandboxEnv['NO_PROXY'] = noProxy;
304 |           sandboxEnv['no_proxy'] = noProxy;
305 |         }
306 |         proxyProcess = spawn(proxyCommand, {
307 |           stdio: ['ignore', 'pipe', 'pipe'],
308 |           shell: true,
309 |           detached: true,
310 |         });
311 |         // install handlers to stop proxy on exit/signal
[TRUNCATED]
```

src/utils/sessionCleanup.integration.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect, vi } from 'vitest';
8 | import { cleanupExpiredSessions } from './sessionCleanup.js';
9 | import type { Settings } from '../config/settings.js';
10 | import { SESSION_FILE_PREFIX, type Config } from '@google/gemini-cli-core';
11 | 
12 | // Create a mock config for integration testing
13 | function createTestConfig(): Config {
14 |   return {
15 |     storage: {
16 |       getProjectTempDir: () => '/tmp/nonexistent-test-dir',
17 |     },
18 |     getSessionId: () => 'test-session-id',
19 |     getDebugMode: () => false,
20 |     initialize: async () => undefined,
21 |   } as unknown as Config;
22 | }
23 | 
24 | describe('Session Cleanup Integration', () => {
25 |   it('should gracefully handle non-existent directories', async () => {
26 |     const config = createTestConfig();
27 |     const settings: Settings = {
28 |       general: {
29 |         sessionRetention: {
30 |           enabled: true,
31 |           maxAge: '30d',
32 |         },
33 |       },
34 |     };
35 | 
36 |     const result = await cleanupExpiredSessions(config, settings);
37 | 
38 |     // Should return empty result for non-existent directory
39 |     expect(result.disabled).toBe(false);
40 |     expect(result.scanned).toBe(0);
41 |     expect(result.deleted).toBe(0);
42 |     expect(result.skipped).toBe(0);
43 |     expect(result.failed).toBe(0);
44 |   });
45 | 
46 |   it('should not impact startup when disabled', async () => {
47 |     const config = createTestConfig();
48 |     const settings: Settings = {
49 |       general: {
50 |         sessionRetention: {
51 |           enabled: false,
52 |         },
53 |       },
54 |     };
55 | 
56 |     const result = await cleanupExpiredSessions(config, settings);
57 | 
58 |     expect(result.disabled).toBe(true);
59 |     expect(result.scanned).toBe(0);
60 |     expect(result.deleted).toBe(0);
61 |     expect(result.skipped).toBe(0);
62 |     expect(result.failed).toBe(0);
63 |   });
64 | 
65 |   it('should handle missing sessionRetention configuration', async () => {
66 |     // Create test session files to verify they are NOT deleted when config is missing
67 |     const fs = await import('node:fs/promises');
68 |     const path = await import('node:path');
69 |     const os = await import('node:os');
70 | 
71 |     const tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'gemini-test-'));
72 |     const chatsDir = path.join(tempDir, 'chats');
73 |     await fs.mkdir(chatsDir, { recursive: true });
74 | 
75 |     // Create an old session file that would normally be deleted
76 |     const oldDate = new Date(Date.now() - 60 * 24 * 60 * 60 * 1000); // 60 days ago
77 |     const sessionFile = path.join(
78 |       chatsDir,
79 |       `${SESSION_FILE_PREFIX}2024-01-01T10-00-00-test123.json`,
80 |     );
81 |     await fs.writeFile(
82 |       sessionFile,
83 |       JSON.stringify({
84 |         sessionId: 'test123',
85 |         messages: [],
86 |         startTime: oldDate.toISOString(),
87 |         lastUpdated: oldDate.toISOString(),
88 |       }),
89 |     );
90 | 
91 |     const config = createTestConfig();
92 |     config.storage.getProjectTempDir = vi.fn().mockReturnValue(tempDir);
93 | 
94 |     const settings: Settings = {};
95 | 
96 |     const result = await cleanupExpiredSessions(config, settings);
97 | 
98 |     expect(result.disabled).toBe(true);
99 |     expect(result.scanned).toBe(0); // Should not even scan when config is missing
100 |     expect(result.deleted).toBe(0);
101 |     expect(result.skipped).toBe(0);
102 |     expect(result.failed).toBe(0);
103 | 
104 |     // Verify the session file still exists (was not deleted)
105 |     const filesAfter = await fs.readdir(chatsDir);
106 |     expect(filesAfter).toContain(
107 |       `${SESSION_FILE_PREFIX}2024-01-01T10-00-00-test123.json`,
108 |     );
109 | 
110 |     // Cleanup
111 |     await fs.rm(tempDir, { recursive: true });
112 |   });
113 | 
114 |   it('should validate configuration and fail gracefully', async () => {
115 |     const errorSpy = vi.spyOn(console, 'error').mockImplementation(() => {});
116 |     const config = createTestConfig();
117 | 
118 |     const settings: Settings = {
119 |       general: {
120 |         sessionRetention: {
121 |           enabled: true,
122 |           maxAge: 'invalid-format',
123 |         },
124 |       },
125 |     };
126 | 
127 |     const result = await cleanupExpiredSessions(config, settings);
128 | 
129 |     expect(result.disabled).toBe(true);
130 |     expect(result.scanned).toBe(0);
131 |     expect(result.deleted).toBe(0);
132 |     expect(result.skipped).toBe(0);
133 |     expect(result.failed).toBe(0);
134 | 
135 |     // Verify error logging provides visibility into the validation failure
136 |     expect(errorSpy).toHaveBeenCalledWith(
137 |       expect.stringContaining(
138 |         'Session cleanup disabled: Error: Invalid retention period format',
139 |       ),
140 |     );
141 | 
142 |     errorSpy.mockRestore();
143 |   });
144 | 
145 |   it('should clean up expired sessions when they exist', async () => {
146 |     // Create a temporary directory with test sessions
147 |     const fs = await import('node:fs/promises');
148 |     const path = await import('node:path');
149 |     const os = await import('node:os');
150 | 
151 |     const tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'gemini-test-'));
152 |     const chatsDir = path.join(tempDir, 'chats');
153 |     await fs.mkdir(chatsDir, { recursive: true });
154 | 
155 |     // Create test session files with different ages
156 |     const now = new Date();
157 |     const oldDate = new Date(now.getTime() - 35 * 24 * 60 * 60 * 1000); // 35 days ago
158 |     const recentDate = new Date(now.getTime() - 5 * 24 * 60 * 60 * 1000); // 5 days ago
159 | 
160 |     // Create an old session file that should be deleted
161 |     const oldSessionFile = path.join(
162 |       chatsDir,
163 |       `${SESSION_FILE_PREFIX}2024-12-01T10-00-00-old12345.json`,
164 |     );
165 |     await fs.writeFile(
166 |       oldSessionFile,
167 |       JSON.stringify({
168 |         sessionId: 'old12345',
169 |         messages: [],
170 |         startTime: oldDate.toISOString(),
171 |         lastUpdated: oldDate.toISOString(),
172 |       }),
173 |     );
174 | 
175 |     // Create a recent session file that should be kept
176 |     const recentSessionFile = path.join(
177 |       chatsDir,
178 |       `${SESSION_FILE_PREFIX}2025-01-15T10-00-00-recent789.json`,
179 |     );
180 |     await fs.writeFile(
181 |       recentSessionFile,
182 |       JSON.stringify({
183 |         sessionId: 'recent789',
184 |         messages: [],
185 |         startTime: recentDate.toISOString(),
186 |         lastUpdated: recentDate.toISOString(),
187 |       }),
188 |     );
189 | 
190 |     // Create a current session file that should always be kept
191 |     const currentSessionFile = path.join(
192 |       chatsDir,
193 |       `${SESSION_FILE_PREFIX}2025-01-20T10-00-00-current123.json`,
194 |     );
195 |     await fs.writeFile(
196 |       currentSessionFile,
197 |       JSON.stringify({
198 |         sessionId: 'current123',
199 |         messages: [],
200 |         startTime: now.toISOString(),
201 |         lastUpdated: now.toISOString(),
202 |       }),
203 |     );
204 | 
205 |     // Configure test with real temp directory
206 |     const config: Config = {
207 |       storage: {
208 |         getProjectTempDir: () => tempDir,
209 |       },
210 |       getSessionId: () => 'current123',
211 |       getDebugMode: () => false,
212 |       initialize: async () => undefined,
213 |     } as unknown as Config;
214 | 
215 |     const settings: Settings = {
216 |       general: {
217 |         sessionRetention: {
218 |           enabled: true,
219 |           maxAge: '30d', // Keep sessions for 30 days
220 |         },
221 |       },
222 |     };
223 | 
224 |     try {
225 |       const result = await cleanupExpiredSessions(config, settings);
226 | 
227 |       // Verify the result
228 |       expect(result.disabled).toBe(false);
229 |       expect(result.scanned).toBe(3); // Should scan all 3 sessions
230 |       expect(result.deleted).toBe(1); // Should delete the old session (35 days old)
231 |       expect(result.skipped).toBe(2); // Should keep recent and current sessions
232 |       expect(result.failed).toBe(0);
233 | 
234 |       // Verify files on disk
235 |       const remainingFiles = await fs.readdir(chatsDir);
236 |       expect(remainingFiles).toHaveLength(2); // Only 2 files should remain
237 |       expect(remainingFiles).toContain(
238 |         `${SESSION_FILE_PREFIX}2025-01-15T10-00-00-recent789.json`,
239 |       );
240 |       expect(remainingFiles).toContain(
241 |         `${SESSION_FILE_PREFIX}2025-01-20T10-00-00-current123.json`,
242 |       );
243 |       expect(remainingFiles).not.toContain(
244 |         `${SESSION_FILE_PREFIX}2024-12-01T10-00-00-old12345.json`,
245 |       );
246 |     } finally {
247 |       // Clean up test directory
248 |       await fs.rm(tempDir, { recursive: true, force: true });
249 |     }
250 |   });
251 | });
```

src/utils/sessionCleanup.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
8 | import * as fs from 'node:fs/promises';
9 | import * as path from 'node:path';
10 | import { SESSION_FILE_PREFIX, type Config } from '@google/gemini-cli-core';
11 | import type { Settings } from '../config/settings.js';
12 | import { cleanupExpiredSessions } from './sessionCleanup.js';
13 | import { type SessionInfo, getAllSessionFiles } from './sessionUtils.js';
14 | 
15 | // Mock the fs module
16 | vi.mock('fs/promises');
17 | vi.mock('./sessionUtils.js', () => ({
18 |   getAllSessionFiles: vi.fn(),
19 | }));
20 | 
21 | const mockFs = vi.mocked(fs);
22 | const mockGetAllSessionFiles = vi.mocked(getAllSessionFiles);
23 | 
24 | // Create mock config
25 | function createMockConfig(overrides: Partial<Config> = {}): Config {
26 |   return {
27 |     storage: {
28 |       getProjectTempDir: vi.fn().mockReturnValue('/tmp/test-project'),
29 |     },
30 |     getSessionId: vi.fn().mockReturnValue('current123'),
31 |     getDebugMode: vi.fn().mockReturnValue(false),
32 |     initialize: vi.fn().mockResolvedValue(undefined),
33 |     ...overrides,
34 |   } as unknown as Config;
35 | }
36 | 
37 | // Create test session data
38 | function createTestSessions(): SessionInfo[] {
39 |   const now = new Date();
40 |   const oneWeekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
41 |   const twoWeeksAgo = new Date(now.getTime() - 14 * 24 * 60 * 60 * 1000);
42 |   const oneMonthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
43 | 
44 |   return [
45 |     {
46 |       id: 'current123',
47 |       fileName: `${SESSION_FILE_PREFIX}2025-01-20T10-30-00-current12.json`,
48 |       lastUpdated: now.toISOString(),
49 |       isCurrentSession: true,
50 |     },
51 |     {
52 |       id: 'recent456',
53 |       fileName: `${SESSION_FILE_PREFIX}2025-01-18T15-45-00-recent45.json`,
54 |       lastUpdated: oneWeekAgo.toISOString(),
55 |       isCurrentSession: false,
56 |     },
57 |     {
58 |       id: 'old789abc',
59 |       fileName: `${SESSION_FILE_PREFIX}2025-01-10T09-15-00-old789ab.json`,
60 |       lastUpdated: twoWeeksAgo.toISOString(),
61 |       isCurrentSession: false,
62 |     },
63 |     {
64 |       id: 'ancient12',
65 |       fileName: `${SESSION_FILE_PREFIX}2024-12-25T12-00-00-ancient1.json`,
66 |       lastUpdated: oneMonthAgo.toISOString(),
67 |       isCurrentSession: false,
68 |     },
69 |   ];
70 | }
71 | 
72 | describe('Session Cleanup', () => {
73 |   beforeEach(() => {
74 |     vi.clearAllMocks();
75 |     // By default, return all test sessions as valid
76 |     const sessions = createTestSessions();
77 |     mockGetAllSessionFiles.mockResolvedValue(
78 |       sessions.map((session) => ({
79 |         fileName: session.fileName,
80 |         sessionInfo: session,
81 |       })),
82 |     );
83 |   });
84 | 
85 |   afterEach(() => {
86 |     vi.restoreAllMocks();
87 |   });
88 | 
89 |   describe('cleanupExpiredSessions', () => {
90 |     it('should return early when cleanup is disabled', async () => {
91 |       const config = createMockConfig();
92 |       const settings: Settings = {
93 |         general: { sessionRetention: { enabled: false } },
94 |       };
95 | 
96 |       const result = await cleanupExpiredSessions(config, settings);
97 | 
98 |       expect(result.disabled).toBe(true);
99 |       expect(result.scanned).toBe(0);
100 |       expect(result.deleted).toBe(0);
101 |       expect(result.skipped).toBe(0);
102 |       expect(result.failed).toBe(0);
103 |     });
104 | 
105 |     it('should return early when sessionRetention is not configured', async () => {
106 |       const config = createMockConfig();
107 |       const settings: Settings = {};
108 | 
109 |       const result = await cleanupExpiredSessions(config, settings);
110 | 
111 |       expect(result.disabled).toBe(true);
112 |       expect(result.scanned).toBe(0);
113 |       expect(result.deleted).toBe(0);
114 |     });
115 | 
116 |     it('should handle invalid maxAge configuration', async () => {
117 |       const config = createMockConfig({
118 |         getDebugMode: vi.fn().mockReturnValue(true),
119 |       });
120 |       const settings: Settings = {
121 |         general: {
122 |           sessionRetention: {
123 |             enabled: true,
124 |             maxAge: 'invalid-format',
125 |           },
126 |         },
127 |       };
128 | 
129 |       const errorSpy = vi.spyOn(console, 'error').mockImplementation(() => {});
130 | 
131 |       const result = await cleanupExpiredSessions(config, settings);
132 | 
133 |       expect(result.disabled).toBe(true);
134 |       expect(result.scanned).toBe(0);
135 |       expect(result.deleted).toBe(0);
136 |       expect(errorSpy).toHaveBeenCalledWith(
137 |         expect.stringContaining(
138 |           'Session cleanup disabled: Error: Invalid retention period format',
139 |         ),
140 |       );
141 | 
142 |       errorSpy.mockRestore();
143 |     });
144 | 
145 |     it('should delete sessions older than maxAge', async () => {
146 |       const config = createMockConfig();
147 |       const settings: Settings = {
148 |         general: {
149 |           sessionRetention: {
150 |             enabled: true,
151 |             maxAge: '10d', // 10 days
152 |           },
153 |         },
154 |       };
155 | 
156 |       // Mock successful file operations
157 |       mockFs.access.mockResolvedValue(undefined);
158 |       mockFs.readFile.mockResolvedValue(
159 |         JSON.stringify({
160 |           sessionId: 'test',
161 |           messages: [],
162 |           startTime: '2025-01-01T00:00:00Z',
163 |           lastUpdated: '2025-01-01T00:00:00Z',
164 |         }),
165 |       );
166 |       mockFs.unlink.mockResolvedValue(undefined);
167 | 
168 |       const result = await cleanupExpiredSessions(config, settings);
169 | 
170 |       expect(result.disabled).toBe(false);
171 |       expect(result.scanned).toBe(4);
172 |       expect(result.deleted).toBe(2); // Should delete the 2-week-old and 1-month-old sessions
173 |       expect(result.skipped).toBe(2); // Current session + recent session should be skipped
174 |       expect(result.failed).toBe(0);
175 |     });
176 | 
177 |     it('should never delete current session', async () => {
178 |       const config = createMockConfig();
179 |       const settings: Settings = {
180 |         general: {
181 |           sessionRetention: {
182 |             enabled: true,
183 |             maxAge: '1d', // Very short retention
184 |           },
185 |         },
186 |       };
187 | 
188 |       // Mock successful file operations
189 |       mockFs.access.mockResolvedValue(undefined);
190 |       mockFs.readFile.mockResolvedValue(
191 |         JSON.stringify({
192 |           sessionId: 'test',
193 |           messages: [],
194 |           startTime: '2025-01-01T00:00:00Z',
195 |           lastUpdated: '2025-01-01T00:00:00Z',
196 |         }),
197 |       );
198 |       mockFs.unlink.mockResolvedValue(undefined);
199 | 
200 |       const result = await cleanupExpiredSessions(config, settings);
201 | 
202 |       // Should delete all sessions except the current one
203 |       expect(result.disabled).toBe(false);
204 |       expect(result.deleted).toBe(3);
205 | 
206 |       // Verify that unlink was never called with the current session file
207 |       const unlinkCalls = mockFs.unlink.mock.calls;
208 |       const currentSessionPath = path.join(
209 |         '/tmp/test-project',
210 |         'chats',
211 |         `${SESSION_FILE_PREFIX}2025-01-20T10-30-00-current12.json`,
212 |       );
213 |       expect(
214 |         unlinkCalls.find((call) => call[0] === currentSessionPath),
215 |       ).toBeUndefined();
216 |     });
217 | 
218 |     it('should handle count-based retention', async () => {
219 |       const config = createMockConfig();
220 |       const settings: Settings = {
221 |         general: {
222 |           sessionRetention: {
223 |             enabled: true,
224 |             maxCount: 2, // Keep only 2 most recent sessions
225 |           },
226 |         },
227 |       };
228 | 
229 |       // Mock successful file operations
230 |       mockFs.access.mockResolvedValue(undefined);
231 |       mockFs.readFile.mockResolvedValue(
232 |         JSON.stringify({
233 |           sessionId: 'test',
234 |           messages: [],
235 |           startTime: '2025-01-01T00:00:00Z',
236 |           lastUpdated: '2025-01-01T00:00:00Z',
237 |         }),
238 |       );
239 |       mockFs.unlink.mockResolvedValue(undefined);
240 | 
241 |       const result = await cleanupExpiredSessions(config, settings);
242 | 
243 |       expect(result.disabled).toBe(false);
244 |       expect(result.scanned).toBe(4);
245 |       expect(result.deleted).toBe(2); // Should delete 2 oldest sessions (after skipping the current one)
246 |       expect(result.skipped).toBe(2); // Current session + 1 recent session should be kept
247 |     });
248 | 
249 |     it('should handle file system errors gracefully', async () => {
250 |       const config = createMockConfig();
251 |       const settings: Settings = {
252 |         general: {
253 |           sessionRetention: {
254 |             enabled: true,
255 |             maxAge: '1d',
256 |           },
257 |         },
258 |       };
259 | 
260 |       // Mock file operations to succeed for access and readFile but fail for unlink
261 |       mockFs.access.mockResolvedValue(undefined);
262 |       mockFs.readFile.mockResolvedValue(
263 |         JSON.stringify({
264 |           sessionId: 'test',
265 |           messages: [],
266 |           startTime: '2025-01-01T00:00:00Z',
267 |           lastUpdated: '2025-01-01T00:00:00Z',
268 |         }),
269 |       );
270 |       mockFs.unlink.mockRejectedValue(new Error('Permission denied'));
271 | 
272 |       const result = await cleanupExpiredSessions(config, settings);
273 | 
274 |       expect(result.disabled).toBe(false);
275 |       expect(result.scanned).toBe(4);
276 |       expect(result.deleted).toBe(0);
277 |       expect(result.failed).toBeGreaterThan(0);
278 |     });
279 | 
280 |     it('should handle empty sessions directory', async () => {
281 |       const config = createMockConfig();
282 |       const settings: Settings = {
283 |         general: {
284 |           sessionRetention: {
285 |             enabled: true,
286 |             maxAge: '30d',
287 |           },
288 |         },
289 |       };
290 | 
291 |       mockGetAllSessionFiles.mockResolvedValue([]);
292 | 
293 |       const result = await cleanupExpiredSessions(config, settings);
294 | 
295 |       expect(result.disabled).toBe(false);
296 |       expect(result.scanned).toBe(0);
297 |       expect(result.deleted).toBe(0);
298 |       expect(result.skipped).toBe(0);
299 |       expect(result.failed).toBe(0);
300 |     });
301 | 
302 |     it('should handle global errors gracefully', async () => {
303 |       const config = createMockConfig();
304 |       const settings: Settings = {
305 |         general: {
306 |           sessionRetention: {
307 |             enabled: true,
308 |             maxAge: '30d',
309 |           },
310 |         },
311 |       };
312 | 
313 |       const errorSpy = vi.spyOn(console, 'error').mockImplementation(() => {});
314 | 
315 |       // Mock getSessionFiles to throw an error
316 |       mockGetAllSessionFiles.mockRejectedValue(
317 |         new Error('Directory access failed'),
318 |       );
319 | 
320 |       const result = await cleanupExpiredSessions(config, settings);
321 | 
322 |       expect(result.disabled).toBe(false);
323 |       expect(result.failed).toBe(1);
324 |       expect(errorSpy).toHaveBeenCalledWith(
325 |         'Session cleanup failed: Directory access failed',
326 |       );
327 | 
328 |       errorSpy.mockRestore();
329 |     });
330 | 
331 |     it('should respect minRetention configuration', async () => {
332 |       const config = createMockConfig();
333 |       const settings: Settings = {
334 |         general: {
335 |           sessionRetention: {
336 |             enabled: true,
337 |             maxAge: '12h', // Less than 1 day minimum
338 |             minRetention: '1d',
339 |           },
340 |         },
341 |       };
342 | 
343 |       const result = await cleanupExpiredSessions(config, settings);
344 | 
345 |       // Should disable cleanup due to minRetention violation
346 |       expect(result.disabled).toBe(true);
347 |       expect(result.scanned).toBe(0);
348 |       expect(result.deleted).toBe(0);
349 |     });
350 | 
351 |     it('should log debug information when enabled', async () => {
352 |       const config = createMockConfig({
353 |         getDebugMode: vi.fn().mockReturnValue(true),
354 |       });
355 |       const settings: Settings = {
356 |         general: {
357 |           sessionRetention: {
358 |             enabled: true,
359 |             maxAge: '10d',
360 |           },
361 |         },
362 |       };
363 | 
364 |       // Mock successful file operations
365 |       mockFs.access.mockResolvedValue(undefined);
366 |       mockFs.readFile.mockResolvedValue(
367 |         JSON.stringify({
368 |           sessionId: 'test',
369 |           messages: [],
370 |           startTime: '2025-01-01T00:00:00Z',
371 |           lastUpdated: '2025-01-01T00:00:00Z',
372 |         }),
373 |       );
374 |       mockFs.unlink.mockResolvedValue(undefined);
375 | 
376 |       const debugSpy = vi.spyOn(console, 'debug').mockImplementation(() => {});
377 | 
378 |       await cleanupExpiredSessions(config, settings);
379 | 
[TRUNCATED]
```

src/utils/sessionCleanup.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import * as fs from 'node:fs/promises';
8 | import * as path from 'node:path';
9 | import { type Config } from '@google/gemini-cli-core';
10 | import type { Settings, SessionRetentionSettings } from '../config/settings.js';
11 | import { getAllSessionFiles, type SessionFileEntry } from './sessionUtils.js';
12 | 
13 | // Constants
14 | export const DEFAULT_MIN_RETENTION = '1d' as string;
15 | const MIN_MAX_COUNT = 1;
16 | const MULTIPLIERS = {
17 |   h: 60 * 60 * 1000, // hours to ms
18 |   d: 24 * 60 * 60 * 1000, // days to ms
19 |   w: 7 * 24 * 60 * 60 * 1000, // weeks to ms
20 |   m: 30 * 24 * 60 * 60 * 1000, // months (30 days) to ms
21 | };
22 | 
23 | /**
24 |  * Result of session cleanup operation
25 |  */
26 | export interface CleanupResult {
27 |   disabled: boolean;
28 |   scanned: number;
29 |   deleted: number;
30 |   skipped: number;
31 |   failed: number;
32 | }
33 | 
34 | /**
35 |  * Main entry point for session cleanup during CLI startup
36 |  */
37 | export async function cleanupExpiredSessions(
38 |   config: Config,
39 |   settings: Settings,
40 | ): Promise<CleanupResult> {
41 |   const result: CleanupResult = {
42 |     disabled: false,
43 |     scanned: 0,
44 |     deleted: 0,
45 |     skipped: 0,
46 |     failed: 0,
47 |   };
48 | 
49 |   try {
50 |     // Early exit if cleanup is disabled
51 |     if (!settings.general?.sessionRetention?.enabled) {
52 |       return { ...result, disabled: true };
53 |     }
54 | 
55 |     const retentionConfig = settings.general.sessionRetention;
56 |     const chatsDir = path.join(config.storage.getProjectTempDir(), 'chats');
57 | 
58 |     // Validate retention configuration
59 |     const validationErrorMessage = validateRetentionConfig(
60 |       config,
61 |       retentionConfig,
62 |     );
63 |     if (validationErrorMessage) {
64 |       // Log validation errors to console for visibility
65 |       console.error(`Session cleanup disabled: ${validationErrorMessage}`);
66 |       return { ...result, disabled: true };
67 |     }
68 | 
69 |     // Get all session files (including corrupted ones) for this project
70 |     const allFiles = await getAllSessionFiles(chatsDir, config.getSessionId());
71 |     result.scanned = allFiles.length;
72 | 
73 |     if (allFiles.length === 0) {
74 |       return result;
75 |     }
76 | 
77 |     // Determine which sessions to delete (corrupted and expired)
78 |     const sessionsToDelete = await identifySessionsToDelete(
79 |       allFiles,
80 |       retentionConfig,
81 |     );
82 | 
83 |     // Delete all sessions that need to be deleted
84 |     for (const sessionToDelete of sessionsToDelete) {
85 |       try {
86 |         const sessionPath = path.join(chatsDir, sessionToDelete.fileName);
87 |         await fs.unlink(sessionPath);
88 | 
89 |         if (config.getDebugMode()) {
90 |           if (sessionToDelete.sessionInfo === null) {
91 |             console.debug(
92 |               `Deleted corrupted session file: ${sessionToDelete.fileName}`,
93 |             );
94 |           } else {
95 |             console.debug(
96 |               `Deleted expired session: ${sessionToDelete.sessionInfo.id} (${sessionToDelete.sessionInfo.lastUpdated})`,
97 |             );
98 |           }
99 |         }
100 |         result.deleted++;
101 |       } catch (error) {
102 |         // Ignore ENOENT errors (file already deleted)
103 |         if (
104 |           error instanceof Error &&
105 |           'code' in error &&
106 |           error.code === 'ENOENT'
107 |         ) {
108 |           // File already deleted, do nothing.
109 |         } else {
110 |           // Log error directly to console
111 |           const sessionId =
112 |             sessionToDelete.sessionInfo === null
113 |               ? sessionToDelete.fileName
114 |               : sessionToDelete.sessionInfo.id;
115 |           const errorMessage =
116 |             error instanceof Error ? error.message : 'Unknown error';
117 |           console.error(
118 |             `Failed to delete session ${sessionId}: ${errorMessage}`,
119 |           );
120 |           result.failed++;
121 |         }
122 |       }
123 |     }
124 | 
125 |     result.skipped = result.scanned - result.deleted - result.failed;
126 | 
127 |     if (config.getDebugMode() && result.deleted > 0) {
128 |       console.debug(
129 |         `Session cleanup: deleted ${result.deleted}, skipped ${result.skipped}, failed ${result.failed}`,
130 |       );
131 |     }
132 |   } catch (error) {
133 |     // Global error handler - don't let cleanup failures break startup
134 |     const errorMessage =
135 |       error instanceof Error ? error.message : 'Unknown error';
136 |     console.error(`Session cleanup failed: ${errorMessage}`);
137 |     result.failed++;
138 |   }
139 | 
140 |   return result;
141 | }
142 | 
143 | /**
144 |  * Identifies sessions that should be deleted (corrupted or expired based on retention policy)
145 |  */
146 | async function identifySessionsToDelete(
147 |   allFiles: SessionFileEntry[],
148 |   retentionConfig: SessionRetentionSettings,
149 | ): Promise<SessionFileEntry[]> {
150 |   const sessionsToDelete: SessionFileEntry[] = [];
151 | 
152 |   // All corrupted files should be deleted
153 |   sessionsToDelete.push(
154 |     ...allFiles.filter((entry) => entry.sessionInfo === null),
155 |   );
156 | 
157 |   // Now handle valid sessions based on retention policy
158 |   const validSessions = allFiles.filter((entry) => entry.sessionInfo !== null);
159 |   if (validSessions.length === 0) {
160 |     return sessionsToDelete;
161 |   }
162 | 
163 |   const now = new Date();
164 | 
165 |   // Calculate cutoff date for age-based retention
166 |   let cutoffDate: Date | null = null;
167 |   if (retentionConfig.maxAge) {
168 |     try {
169 |       const maxAgeMs = parseRetentionPeriod(retentionConfig.maxAge);
170 |       cutoffDate = new Date(now.getTime() - maxAgeMs);
171 |     } catch {
172 |       // This should not happen as validation should have caught it,
173 |       // but handle gracefully just in case
174 |       cutoffDate = null;
175 |     }
176 |   }
177 | 
178 |   // Sort valid sessions by lastUpdated (newest first) for count-based retention
179 |   const sortedValidSessions = [...validSessions].sort(
180 |     (a, b) =>
181 |       new Date(b.sessionInfo!.lastUpdated).getTime() -
182 |       new Date(a.sessionInfo!.lastUpdated).getTime(),
183 |   );
184 | 
185 |   // Separate deletable sessions from the active session
186 |   const deletableSessions = sortedValidSessions.filter(
187 |     (entry) => !entry.sessionInfo!.isCurrentSession,
188 |   );
189 | 
190 |   // Calculate how many deletable sessions to keep (accounting for the active session)
191 |   const hasActiveSession = sortedValidSessions.some(
192 |     (e) => e.sessionInfo!.isCurrentSession,
193 |   );
194 |   const maxDeletableSessions =
195 |     retentionConfig.maxCount && hasActiveSession
196 |       ? Math.max(0, retentionConfig.maxCount - 1)
197 |       : retentionConfig.maxCount;
198 | 
199 |   for (let i = 0; i < deletableSessions.length; i++) {
200 |     const entry = deletableSessions[i];
201 |     const session = entry.sessionInfo!;
202 | 
203 |     let shouldDelete = false;
204 | 
205 |     // Age-based retention check
206 |     if (cutoffDate && new Date(session.lastUpdated) < cutoffDate) {
207 |       shouldDelete = true;
208 |     }
209 | 
210 |     // Count-based retention check (keep only N most recent deletable sessions)
211 |     if (maxDeletableSessions !== undefined && i >= maxDeletableSessions) {
212 |       shouldDelete = true;
213 |     }
214 | 
215 |     if (shouldDelete) {
216 |       sessionsToDelete.push(entry);
217 |     }
218 |   }
219 | 
220 |   return sessionsToDelete;
221 | }
222 | 
223 | /**
224 |  * Parses retention period strings like "30d", "7d", "24h" into milliseconds
225 |  * @throws {Error} If the format is invalid
226 |  */
227 | function parseRetentionPeriod(period: string): number {
228 |   const match = period.match(/^(\d+)([dhwm])$/);
229 |   if (!match) {
230 |     throw new Error(
231 |       `Invalid retention period format: ${period}. Expected format: <number><unit> where unit is h, d, w, or m`,
232 |     );
233 |   }
234 | 
235 |   const value = parseInt(match[1], 10);
236 |   const unit = match[2];
237 | 
238 |   // Reject zero values as they're semantically invalid
239 |   if (value === 0) {
240 |     throw new Error(
241 |       `Invalid retention period: ${period}. Value must be greater than 0`,
242 |     );
243 |   }
244 | 
245 |   return value * MULTIPLIERS[unit as keyof typeof MULTIPLIERS];
246 | }
247 | 
248 | /**
249 |  * Validates retention configuration
250 |  */
251 | function validateRetentionConfig(
252 |   config: Config,
253 |   retentionConfig: SessionRetentionSettings,
254 | ): string | null {
255 |   if (!retentionConfig.enabled) {
256 |     return 'Retention not enabled';
257 |   }
258 | 
259 |   // Validate maxAge if provided
260 |   if (retentionConfig.maxAge) {
261 |     let maxAgeMs: number;
262 |     try {
263 |       maxAgeMs = parseRetentionPeriod(retentionConfig.maxAge);
264 |     } catch (error) {
265 |       return (error as Error | string).toString();
266 |     }
267 | 
268 |     // Enforce minimum retention period
269 |     const minRetention = retentionConfig.minRetention || DEFAULT_MIN_RETENTION;
270 |     let minRetentionMs: number;
271 |     try {
272 |       minRetentionMs = parseRetentionPeriod(minRetention);
273 |     } catch (error) {
274 |       // If minRetention format is invalid, fall back to default
275 |       if (config.getDebugMode()) {
276 |         console.error(`Failed to parse minRetention: ${error}`);
277 |       }
278 |       minRetentionMs = parseRetentionPeriod(DEFAULT_MIN_RETENTION);
279 |     }
280 | 
281 |     if (maxAgeMs < minRetentionMs) {
282 |       return `maxAge cannot be less than minRetention (${minRetention})`;
283 |     }
284 |   }
285 | 
286 |   // Validate maxCount if provided
287 |   if (retentionConfig.maxCount !== undefined) {
288 |     if (retentionConfig.maxCount < MIN_MAX_COUNT) {
289 |       return `maxCount must be at least ${MIN_MAX_COUNT}`;
290 |     }
291 |   }
292 | 
293 |   // At least one retention method must be specified
294 |   if (!retentionConfig.maxAge && retentionConfig.maxCount === undefined) {
295 |     return 'Either maxAge or maxCount must be specified';
296 |   }
297 | 
298 |   return null;
299 | }
```

src/utils/sessionUtils.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import {
8 |   SESSION_FILE_PREFIX,
9 |   type ConversationRecord,
10 | } from '@google/gemini-cli-core';
11 | import * as fs from 'node:fs/promises';
12 | import path from 'node:path';
13 | 
14 | /**
15 |  * Session information for display and selection purposes.
16 |  */
17 | export interface SessionInfo {
18 |   /** Unique session identifier (filename without .json) */
19 |   id: string;
20 |   /** Full filename including .json extension */
21 |   fileName: string;
22 |   /** ISO timestamp when session was last updated */
23 |   lastUpdated: string;
24 |   /** Whether this is the currently active session */
25 |   isCurrentSession: boolean;
26 | }
27 | 
28 | /**
29 |  * Represents a session file, which may be valid or corrupted.
30 |  */
31 | export interface SessionFileEntry {
32 |   /** Full filename including .json extension */
33 |   fileName: string;
34 |   /** Parsed session info if valid, null if corrupted */
35 |   sessionInfo: SessionInfo | null;
36 | }
37 | 
38 | /**
39 |  * Loads all session files (including corrupted ones) from the chats directory.
40 |  * @returns Array of session file entries, with sessionInfo null for corrupted files
41 |  */
42 | export const getAllSessionFiles = async (
43 |   chatsDir: string,
44 |   currentSessionId?: string,
45 | ): Promise<SessionFileEntry[]> => {
46 |   try {
47 |     const files = await fs.readdir(chatsDir);
48 |     const sessionFiles = files
49 |       .filter((f) => f.startsWith(SESSION_FILE_PREFIX) && f.endsWith('.json'))
50 |       .sort(); // Sort by filename, which includes timestamp
51 | 
52 |     const sessionPromises = sessionFiles.map(
53 |       async (file): Promise<SessionFileEntry> => {
54 |         const filePath = path.join(chatsDir, file);
55 |         try {
56 |           const content: ConversationRecord = JSON.parse(
57 |             await fs.readFile(filePath, 'utf8'),
58 |           );
59 | 
60 |           // Validate required fields
61 |           if (
62 |             !content.sessionId ||
63 |             !content.messages ||
64 |             !Array.isArray(content.messages) ||
65 |             !content.startTime ||
66 |             !content.lastUpdated
67 |           ) {
68 |             // Missing required fields - treat as corrupted
69 |             return { fileName: file, sessionInfo: null };
70 |           }
71 | 
72 |           const isCurrentSession = currentSessionId
73 |             ? file.includes(currentSessionId.slice(0, 8))
74 |             : false;
75 | 
76 |           const sessionInfo: SessionInfo = {
77 |             id: content.sessionId,
78 |             fileName: file,
79 |             lastUpdated: content.lastUpdated,
80 |             isCurrentSession,
81 |           };
82 | 
83 |           return { fileName: file, sessionInfo };
84 |         } catch {
85 |           // File is corrupted (can't read or parse JSON)
86 |           return { fileName: file, sessionInfo: null };
87 |         }
88 |       },
89 |     );
90 |     return await Promise.all(sessionPromises);
91 |   } catch (error) {
92 |     // It's expected that the directory might not exist, which is not an error.
93 |     if (error instanceof Error && 'code' in error && error.code === 'ENOENT') {
94 |       return [];
95 |     }
96 |     // For other errors (e.g., permissions), re-throw to be handled by the caller.
97 |     throw error;
98 |   }
99 | };
100 | 
101 | /**
102 |  * Loads all valid session files from the chats directory and converts them to SessionInfo.
103 |  * Corrupted files are automatically filtered out.
104 |  */
105 | export const getSessionFiles = async (
106 |   chatsDir: string,
107 |   currentSessionId?: string,
108 | ): Promise<SessionInfo[]> => {
109 |   const allFiles = await getAllSessionFiles(chatsDir, currentSessionId);
110 | 
111 |   // Filter out corrupted files and extract SessionInfo
112 |   const validSessions = allFiles
113 |     .filter(
114 |       (entry): entry is { fileName: string; sessionInfo: SessionInfo } =>
115 |         entry.sessionInfo !== null,
116 |     )
117 |     .map((entry) => entry.sessionInfo);
118 | 
119 |   return validSessions;
120 | };
```

src/utils/settingsUtils.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect } from 'vitest';
8 | import {
9 |   // Schema utilities
10 |   getSettingsByCategory,
11 |   getSettingDefinition,
12 |   requiresRestart,
13 |   getDefaultValue,
14 |   getRestartRequiredSettings,
15 |   getEffectiveValue,
16 |   getAllSettingKeys,
17 |   getSettingsByType,
18 |   getSettingsRequiringRestart,
19 |   isValidSettingKey,
20 |   getSettingCategory,
21 |   shouldShowInDialog,
22 |   getDialogSettingsByCategory,
23 |   getDialogSettingsByType,
24 |   getDialogSettingKeys,
25 |   // Business logic utilities
26 |   getSettingValue,
27 |   isSettingModified,
28 |   TEST_ONLY,
29 |   settingExistsInScope,
30 |   setPendingSettingValue,
31 |   hasRestartRequiredSettings,
32 |   getRestartRequiredFromModified,
33 |   getDisplayValue,
34 |   isDefaultValue,
35 |   isValueInherited,
36 |   getEffectiveDisplayValue,
37 | } from './settingsUtils.js';
38 | import {
39 |   getSettingsSchema,
40 |   type SettingDefinition,
41 |   type Settings,
42 |   type SettingsSchema,
43 |   type SettingsSchemaType,
44 | } from '../config/settingsSchema.js';
45 | 
46 | vi.mock('../config/settingsSchema.js', async (importOriginal) => {
47 |   const original =
48 |     await importOriginal<typeof import('../config/settingsSchema.js')>();
49 |   return {
50 |     ...original,
51 |     getSettingsSchema: vi.fn(),
52 |   };
53 | });
54 | 
55 | function makeMockSettings(settings: unknown): Settings {
56 |   return settings as Settings;
57 | }
58 | 
59 | describe('SettingsUtils', () => {
60 |   beforeEach(() => {
61 |     const SETTINGS_SCHEMA = {
62 |       mcpServers: {
63 |         type: 'object',
64 |         label: 'MCP Servers',
65 |         category: 'Advanced',
66 |         requiresRestart: true,
67 |         default: {} as Record<string, string>,
68 |         description: 'Configuration for MCP servers.',
69 |         showInDialog: false,
70 |       },
71 |       test: {
72 |         type: 'string',
73 |         label: 'Test',
74 |         category: 'Basic',
75 |         requiresRestart: false,
76 |         default: 'hello',
77 |         description: 'A test field',
78 |         showInDialog: true,
79 |       },
80 |       advanced: {
81 |         type: 'object',
82 |         label: 'Advanced',
83 |         category: 'Advanced',
84 |         requiresRestart: true,
85 |         default: {},
86 |         description: 'Advanced settings for power users.',
87 |         showInDialog: false,
88 |       },
89 |       ui: {
90 |         type: 'object',
91 |         label: 'UI',
92 |         category: 'UI',
93 |         requiresRestart: false,
94 |         default: {},
95 |         description: 'User interface settings.',
96 |         showInDialog: false,
97 |         properties: {
98 |           theme: {
99 |             type: 'string',
100 |             label: 'Theme',
101 |             category: 'UI',
102 |             requiresRestart: false,
103 |             default: undefined as string | undefined,
104 |             description: 'The color theme for the UI.',
105 |             showInDialog: false,
106 |           },
107 |           requiresRestart: {
108 |             type: 'boolean',
109 |             label: 'Requires Restart',
110 |             category: 'UI',
111 |             default: false,
112 |             requiresRestart: true,
113 |           },
114 |           accessibility: {
115 |             type: 'object',
116 |             label: 'Accessibility',
117 |             category: 'UI',
118 |             requiresRestart: true,
119 |             default: {},
120 |             description: 'Accessibility settings.',
121 |             showInDialog: false,
122 |             properties: {
123 |               disableLoadingPhrases: {
124 |                 type: 'boolean',
125 |                 label: 'Disable Loading Phrases',
126 |                 category: 'UI',
127 |                 requiresRestart: true,
128 |                 default: false,
129 |                 description: 'Disable loading phrases for accessibility',
130 |                 showInDialog: true,
131 |               },
132 |             },
133 |           },
134 |         },
135 |       },
136 |       tools: {
137 |         type: 'object',
138 |         label: 'Tools',
139 |         category: 'Tools',
140 |         requiresRestart: false,
141 |         default: {},
142 |         description: 'Tool settings.',
143 |         showInDialog: false,
144 |         properties: {
145 |           shell: {
146 |             type: 'object',
147 |             label: 'Shell',
148 |             category: 'Tools',
149 |             requiresRestart: false,
150 |             default: {},
151 |             description: 'Shell tool settings.',
152 |             showInDialog: false,
153 |             properties: {
154 |               pager: {
155 |                 type: 'string',
156 |                 label: 'Pager',
157 |                 category: 'Tools',
158 |                 requiresRestart: false,
159 |                 default: 'less',
160 |                 description: 'The pager to use for long output.',
161 |                 showInDialog: true,
162 |               },
163 |             },
164 |           },
165 |         },
166 |       },
167 |     } as const satisfies SettingsSchema;
168 | 
169 |     vi.mocked(getSettingsSchema).mockReturnValue(
170 |       SETTINGS_SCHEMA as unknown as SettingsSchemaType,
171 |     );
172 |   });
173 |   afterEach(() => {
174 |     TEST_ONLY.clearFlattenedSchema();
175 |     vi.clearAllMocks();
176 |     vi.resetAllMocks();
177 |   });
178 | 
179 |   describe('Schema Utilities', () => {
180 |     describe('getSettingsByCategory', () => {
181 |       it('should group settings by category', () => {
182 |         const categories = getSettingsByCategory();
183 |         expect(categories).toHaveProperty('Advanced');
184 |         expect(categories).toHaveProperty('Basic');
185 |       });
186 | 
187 |       it('should include key property in grouped settings', () => {
188 |         const categories = getSettingsByCategory();
189 | 
190 |         Object.entries(categories).forEach(([_category, settings]) => {
191 |           settings.forEach((setting) => {
192 |             expect(setting.key).toBeDefined();
193 |           });
194 |         });
195 |       });
196 |     });
197 | 
198 |     describe('getSettingDefinition', () => {
199 |       it('should return definition for valid setting', () => {
200 |         const definition = getSettingDefinition('ui.theme');
201 |         expect(definition).toBeDefined();
202 |         expect(definition?.label).toBe('Theme');
203 |       });
204 | 
205 |       it('should return undefined for invalid setting', () => {
206 |         const definition = getSettingDefinition('invalidSetting');
207 |         expect(definition).toBeUndefined();
208 |       });
209 |     });
210 | 
211 |     describe('requiresRestart', () => {
212 |       it('should return true for settings that require restart', () => {
213 |         expect(requiresRestart('ui.requiresRestart')).toBe(true);
214 |       });
215 | 
216 |       it('should return false for settings that do not require restart', () => {
217 |         expect(requiresRestart('ui.theme')).toBe(false);
218 |       });
219 | 
220 |       it('should return false for invalid settings', () => {
221 |         expect(requiresRestart('invalidSetting')).toBe(false);
222 |       });
223 |     });
224 | 
225 |     describe('getDefaultValue', () => {
226 |       it('should return correct default values', () => {
227 |         expect(getDefaultValue('test')).toBe('hello');
228 |         expect(getDefaultValue('ui.requiresRestart')).toBe(false);
229 |       });
230 | 
231 |       it('should return undefined for invalid settings', () => {
232 |         expect(getDefaultValue('invalidSetting')).toBeUndefined();
233 |       });
234 |     });
235 | 
236 |     describe('getRestartRequiredSettings', () => {
237 |       it('should return all settings that require restart', () => {
238 |         const restartSettings = getRestartRequiredSettings();
239 |         expect(restartSettings).toContain('mcpServers');
240 |         expect(restartSettings).toContain('ui.requiresRestart');
241 |       });
242 |     });
243 | 
244 |     describe('getEffectiveValue', () => {
245 |       it('should return value from settings when set', () => {
246 |         const settings = makeMockSettings({ ui: { requiresRestart: true } });
247 |         const mergedSettings = makeMockSettings({
248 |           ui: { requiresRestart: false },
249 |         });
250 | 
251 |         const value = getEffectiveValue(
252 |           'ui.requiresRestart',
253 |           settings,
254 |           mergedSettings,
255 |         );
256 |         expect(value).toBe(true);
257 |       });
258 | 
259 |       it('should return value from merged settings when not set in current scope', () => {
260 |         const settings = makeMockSettings({});
261 |         const mergedSettings = makeMockSettings({
262 |           ui: { requiresRestart: true },
263 |         });
264 | 
265 |         const value = getEffectiveValue(
266 |           'ui.requiresRestart',
267 |           settings,
268 |           mergedSettings,
269 |         );
270 |         expect(value).toBe(true);
271 |       });
272 | 
273 |       it('should return default value when not set anywhere', () => {
274 |         const settings = makeMockSettings({});
275 |         const mergedSettings = makeMockSettings({});
276 | 
277 |         const value = getEffectiveValue(
278 |           'ui.requiresRestart',
279 |           settings,
280 |           mergedSettings,
281 |         );
282 |         expect(value).toBe(false); // default value
283 |       });
284 | 
285 |       it('should handle nested settings correctly', () => {
286 |         const settings = makeMockSettings({
287 |           ui: { accessibility: { disableLoadingPhrases: true } },
288 |         });
289 |         const mergedSettings = makeMockSettings({
290 |           ui: { accessibility: { disableLoadingPhrases: false } },
291 |         });
292 | 
293 |         const value = getEffectiveValue(
294 |           'ui.accessibility.disableLoadingPhrases',
295 |           settings,
296 |           mergedSettings,
297 |         );
298 |         expect(value).toBe(true);
299 |       });
300 | 
301 |       it('should return undefined for invalid settings', () => {
302 |         const settings = makeMockSettings({});
303 |         const mergedSettings = makeMockSettings({});
304 | 
305 |         const value = getEffectiveValue(
306 |           'invalidSetting',
307 |           settings,
308 |           mergedSettings,
309 |         );
310 |         expect(value).toBeUndefined();
311 |       });
312 |     });
313 | 
314 |     describe('getAllSettingKeys', () => {
315 |       it('should return all setting keys', () => {
316 |         const keys = getAllSettingKeys();
317 |         expect(keys).toContain('test');
318 |         expect(keys).toContain('ui.accessibility.disableLoadingPhrases');
319 |       });
320 |     });
321 | 
322 |     describe('getSettingsByType', () => {
323 |       it('should return only boolean settings', () => {
324 |         const booleanSettings = getSettingsByType('boolean');
325 |         expect(booleanSettings.length).toBeGreaterThan(0);
326 |         booleanSettings.forEach((setting) => {
327 |           expect(setting.type).toBe('boolean');
328 |         });
329 |       });
330 |     });
331 | 
332 |     describe('getSettingsRequiringRestart', () => {
333 |       it('should return only settings that require restart', () => {
334 |         const restartSettings = getSettingsRequiringRestart();
335 |         expect(restartSettings.length).toBeGreaterThan(0);
336 |         restartSettings.forEach((setting) => {
337 |           expect(setting.requiresRestart).toBe(true);
338 |         });
339 |       });
340 |     });
341 | 
342 |     describe('isValidSettingKey', () => {
343 |       it('should return true for valid setting keys', () => {
344 |         expect(isValidSettingKey('ui.requiresRestart')).toBe(true);
345 |         expect(
346 |           isValidSettingKey('ui.accessibility.disableLoadingPhrases'),
347 |         ).toBe(true);
348 |       });
349 | 
350 |       it('should return false for invalid setting keys', () => {
351 |         expect(isValidSettingKey('invalidSetting')).toBe(false);
352 |         expect(isValidSettingKey('')).toBe(false);
353 |       });
354 |     });
355 | 
356 |     describe('getSettingCategory', () => {
357 |       it('should return correct category for valid settings', () => {
358 |         expect(getSettingCategory('ui.requiresRestart')).toBe('UI');
359 |         expect(
360 |           getSettingCategory('ui.accessibility.disableLoadingPhrases'),
361 |         ).toBe('UI');
362 |       });
363 | 
364 |       it('should return undefined for invalid settings', () => {
365 |         expect(getSettingCategory('invalidSetting')).toBeUndefined();
366 |       });
367 |     });
368 | 
369 |     describe('shouldShowInDialog', () => {
370 |       it('should return true for settings marked to show in dialog', () => {
371 |         expect(shouldShowInDialog('ui.requiresRestart')).toBe(true);
372 |         expect(shouldShowInDialog('general.vimMode')).toBe(true);
373 |         expect(shouldShowInDialog('ui.hideWindowTitle')).toBe(true);
374 |       });
375 | 
376 |       it('should return false for settings marked to hide from dialog', () => {
377 |         expect(shouldShowInDialog('ui.theme')).toBe(false);
378 |       });
379 | 
380 |       it('should return true for invalid settings (default behavior)', () => {
381 |         expect(shouldShowInDialog('invalidSetting')).toBe(true);
382 |       });
383 |     });
384 | 
385 |     describe('getDialogSettingsByCategory', () => {
386 |       it('should only return settings marked for dialog display', async () => {
387 |         const categories = getDialogSettingsByCategory();
388 | 
389 |         // Should include UI settings that are marked for dialog
390 |         expect(categories['UI']).toBeDefined();
391 |         const uiSettings = categories['UI'];
392 |         const uiKeys = uiSettings.map((s) => s.key);
393 |         expect(uiKeys).toContain('ui.requiresRestart');
394 |         expect(uiKeys).toContain('ui.accessibility.disableLoadingPhrases');
395 |         expect(uiKeys).not.toContain('ui.theme'); // This is now marked false
396 |       });
397 | 
398 |       it('should not include Advanced category settings', () => {
399 |         const categories = getDialogSettingsByCategory();
400 | 
401 |         // Advanced settings should be filtered out
402 |         expect(categories['Advanced']).toBeUndefined();
403 |       });
404 | 
405 |       it('should include settings with showInDialog=true', () => {
406 |         const categories = getDialogSettingsByCategory();
407 | 
408 |         const allSettings = Object.values(categories).flat();
409 |         const allKeys = allSettings.map((s) => s.key);
410 | 
411 |         expect(allKeys).toContain('test');
412 |         expect(allKeys).toContain('ui.requiresRestart');
413 |         expect(allKeys).not.toContain('ui.theme'); // Now hidden
414 |         expect(allKeys).not.toContain('general.preferredEditor'); // Now hidden
415 |       });
416 |     });
417 | 
418 |     describe('getDialogSettingsByType', () => {
[TRUNCATED]
```

src/utils/settingsUtils.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type {
8 |   Settings,
9 |   SettingScope,
10 |   LoadedSettings,
11 | } from '../config/settings.js';
12 | import type {
13 |   SettingDefinition,
14 |   SettingsSchema,
15 |   SettingsType,
16 |   SettingsValue,
17 | } from '../config/settingsSchema.js';
18 | import { getSettingsSchema } from '../config/settingsSchema.js';
19 | 
20 | // The schema is now nested, but many parts of the UI and logic work better
21 | // with a flattened structure and dot-notation keys. This section flattens the
22 | // schema into a map for easier lookups.
23 | 
24 | type FlattenedSchema = Record<string, SettingDefinition & { key: string }>;
25 | 
26 | function flattenSchema(schema: SettingsSchema, prefix = ''): FlattenedSchema {
27 |   let result: FlattenedSchema = {};
28 |   for (const key in schema) {
29 |     const newKey = prefix ? `${prefix}.${key}` : key;
30 |     const definition = schema[key];
31 |     result[newKey] = { ...definition, key: newKey };
32 |     if (definition.properties) {
33 |       result = { ...result, ...flattenSchema(definition.properties, newKey) };
34 |     }
35 |   }
36 |   return result;
37 | }
38 | 
39 | let _FLATTENED_SCHEMA: FlattenedSchema | undefined;
40 | 
41 | /** Returns a flattened schema, the first call is memoized for future requests. */
42 | export function getFlattenedSchema() {
43 |   return (
44 |     _FLATTENED_SCHEMA ??
45 |     (_FLATTENED_SCHEMA = flattenSchema(getSettingsSchema()))
46 |   );
47 | }
48 | 
49 | function clearFlattenedSchema() {
50 |   _FLATTENED_SCHEMA = undefined;
51 | }
52 | 
53 | /**
54 |  * Get all settings grouped by category
55 |  */
56 | export function getSettingsByCategory(): Record<
57 |   string,
58 |   Array<SettingDefinition & { key: string }>
59 | > {
60 |   const categories: Record<
61 |     string,
62 |     Array<SettingDefinition & { key: string }>
63 |   > = {};
64 | 
65 |   Object.values(getFlattenedSchema()).forEach((definition) => {
66 |     const category = definition.category;
67 |     if (!categories[category]) {
68 |       categories[category] = [];
69 |     }
70 |     categories[category].push(definition);
71 |   });
72 | 
73 |   return categories;
74 | }
75 | 
76 | /**
77 |  * Get a setting definition by key
78 |  */
79 | export function getSettingDefinition(
80 |   key: string,
81 | ): (SettingDefinition & { key: string }) | undefined {
82 |   return getFlattenedSchema()[key];
83 | }
84 | 
85 | /**
86 |  * Check if a setting requires restart
87 |  */
88 | export function requiresRestart(key: string): boolean {
89 |   return getFlattenedSchema()[key]?.requiresRestart ?? false;
90 | }
91 | 
92 | /**
93 |  * Get the default value for a setting
94 |  */
95 | export function getDefaultValue(key: string): SettingsValue {
96 |   return getFlattenedSchema()[key]?.default;
97 | }
98 | 
99 | /**
100 |  * Get all setting keys that require restart
101 |  */
102 | export function getRestartRequiredSettings(): string[] {
103 |   return Object.values(getFlattenedSchema())
104 |     .filter((definition) => definition.requiresRestart)
105 |     .map((definition) => definition.key);
106 | }
107 | 
108 | /**
109 |  * Recursively gets a value from a nested object using a key path array.
110 |  */
111 | export function getNestedValue(
112 |   obj: Record<string, unknown>,
113 |   path: string[],
114 | ): unknown {
115 |   const [first, ...rest] = path;
116 |   if (!first || !(first in obj)) {
117 |     return undefined;
118 |   }
119 |   const value = obj[first];
120 |   if (rest.length === 0) {
121 |     return value;
122 |   }
123 |   if (value && typeof value === 'object' && value !== null) {
124 |     return getNestedValue(value as Record<string, unknown>, rest);
125 |   }
126 |   return undefined;
127 | }
128 | 
129 | /**
130 |  * Get the effective value for a setting, considering inheritance from higher scopes
131 |  * Always returns a value (never undefined) - falls back to default if not set anywhere
132 |  */
133 | export function getEffectiveValue(
134 |   key: string,
135 |   settings: Settings,
136 |   mergedSettings: Settings,
137 | ): SettingsValue {
138 |   const definition = getSettingDefinition(key);
139 |   if (!definition) {
140 |     return undefined;
141 |   }
142 | 
143 |   const path = key.split('.');
144 | 
145 |   // Check the current scope's settings first
146 |   let value = getNestedValue(settings as Record<string, unknown>, path);
147 |   if (value !== undefined) {
148 |     return value as SettingsValue;
149 |   }
150 | 
151 |   // Check the merged settings for an inherited value
152 |   value = getNestedValue(mergedSettings as Record<string, unknown>, path);
153 |   if (value !== undefined) {
154 |     return value as SettingsValue;
155 |   }
156 | 
157 |   // Return default value if no value is set anywhere
158 |   return definition.default;
159 | }
160 | 
161 | /**
162 |  * Get all setting keys from the schema
163 |  */
164 | export function getAllSettingKeys(): string[] {
165 |   return Object.keys(getFlattenedSchema());
166 | }
167 | 
168 | /**
169 |  * Get settings by type
170 |  */
171 | export function getSettingsByType(
172 |   type: SettingsType,
173 | ): Array<SettingDefinition & { key: string }> {
174 |   return Object.values(getFlattenedSchema()).filter(
175 |     (definition) => definition.type === type,
176 |   );
177 | }
178 | 
179 | /**
180 |  * Get settings that require restart
181 |  */
182 | export function getSettingsRequiringRestart(): Array<
183 |   SettingDefinition & {
184 |     key: string;
185 |   }
186 | > {
187 |   return Object.values(getFlattenedSchema()).filter(
188 |     (definition) => definition.requiresRestart,
189 |   );
190 | }
191 | 
192 | /**
193 |  * Validate if a setting key exists in the schema
194 |  */
195 | export function isValidSettingKey(key: string): boolean {
196 |   return key in getFlattenedSchema();
197 | }
198 | 
199 | /**
200 |  * Get the category for a setting
201 |  */
202 | export function getSettingCategory(key: string): string | undefined {
203 |   return getFlattenedSchema()[key]?.category;
204 | }
205 | 
206 | /**
207 |  * Check if a setting should be shown in the settings dialog
208 |  */
209 | export function shouldShowInDialog(key: string): boolean {
210 |   return getFlattenedSchema()[key]?.showInDialog ?? true; // Default to true for backward compatibility
211 | }
212 | 
213 | /**
214 |  * Get all settings that should be shown in the dialog, grouped by category
215 |  */
216 | export function getDialogSettingsByCategory(): Record<
217 |   string,
218 |   Array<SettingDefinition & { key: string }>
219 | > {
220 |   const categories: Record<
221 |     string,
222 |     Array<SettingDefinition & { key: string }>
223 |   > = {};
224 | 
225 |   Object.values(getFlattenedSchema())
226 |     .filter((definition) => definition.showInDialog !== false)
227 |     .forEach((definition) => {
228 |       const category = definition.category;
229 |       if (!categories[category]) {
230 |         categories[category] = [];
231 |       }
232 |       categories[category].push(definition);
233 |     });
234 | 
235 |   return categories;
236 | }
237 | 
238 | /**
239 |  * Get settings by type that should be shown in the dialog
240 |  */
241 | export function getDialogSettingsByType(
242 |   type: SettingsType,
243 | ): Array<SettingDefinition & { key: string }> {
244 |   return Object.values(getFlattenedSchema()).filter(
245 |     (definition) =>
246 |       definition.type === type && definition.showInDialog !== false,
247 |   );
248 | }
249 | 
250 | /**
251 |  * Get all setting keys that should be shown in the dialog
252 |  */
253 | export function getDialogSettingKeys(): string[] {
254 |   return Object.values(getFlattenedSchema())
255 |     .filter((definition) => definition.showInDialog !== false)
256 |     .map((definition) => definition.key);
257 | }
258 | 
259 | // ============================================================================
260 | // BUSINESS LOGIC UTILITIES (Higher-level utilities for setting operations)
261 | // ============================================================================
262 | 
263 | /**
264 |  * Get the current value for a setting in a specific scope
265 |  * Always returns a value (never undefined) - falls back to default if not set anywhere
266 |  */
267 | export function getSettingValue(
268 |   key: string,
269 |   settings: Settings,
270 |   mergedSettings: Settings,
271 | ): boolean {
272 |   const definition = getSettingDefinition(key);
273 |   if (!definition) {
274 |     return false; // Default fallback for invalid settings
275 |   }
276 | 
277 |   const value = getEffectiveValue(key, settings, mergedSettings);
278 |   // Ensure we return a boolean value, converting from the more general type
279 |   if (typeof value === 'boolean') {
280 |     return value;
281 |   }
282 |   // Fall back to default value, ensuring it's a boolean
283 |   const defaultValue = definition.default;
284 |   if (typeof defaultValue === 'boolean') {
285 |     return defaultValue;
286 |   }
287 |   return false; // Final fallback
288 | }
289 | 
290 | /**
291 |  * Check if a setting value is modified from its default
292 |  */
293 | export function isSettingModified(key: string, value: boolean): boolean {
294 |   const defaultValue = getDefaultValue(key);
295 |   // Handle type comparison properly
296 |   if (typeof defaultValue === 'boolean') {
297 |     return value !== defaultValue;
298 |   }
299 |   // If default is not a boolean, consider it modified if value is true
300 |   return value === true;
301 | }
302 | 
303 | /**
304 |  * Check if a setting exists in the original settings file for a scope
305 |  */
306 | export function settingExistsInScope(
307 |   key: string,
308 |   scopeSettings: Settings,
309 | ): boolean {
310 |   const path = key.split('.');
311 |   const value = getNestedValue(scopeSettings as Record<string, unknown>, path);
312 |   return value !== undefined;
313 | }
314 | 
315 | /**
316 |  * Recursively sets a value in a nested object using a key path array.
317 |  */
318 | function setNestedValue(
319 |   obj: Record<string, unknown>,
320 |   path: string[],
321 |   value: unknown,
322 | ): Record<string, unknown> {
323 |   const [first, ...rest] = path;
324 |   if (!first) {
325 |     return obj;
326 |   }
327 | 
328 |   if (rest.length === 0) {
329 |     obj[first] = value;
330 |     return obj;
331 |   }
332 | 
333 |   if (!obj[first] || typeof obj[first] !== 'object') {
334 |     obj[first] = {};
335 |   }
336 | 
337 |   setNestedValue(obj[first] as Record<string, unknown>, rest, value);
338 |   return obj;
339 | }
340 | 
341 | /**
342 |  * Set a setting value in the pending settings
343 |  */
344 | export function setPendingSettingValue(
345 |   key: string,
346 |   value: boolean,
347 |   pendingSettings: Settings,
348 | ): Settings {
349 |   const path = key.split('.');
350 |   const newSettings = JSON.parse(JSON.stringify(pendingSettings));
351 |   setNestedValue(newSettings, path, value);
352 |   return newSettings;
353 | }
354 | 
355 | /**
356 |  * Generic setter: Set a setting value (boolean, number, string, etc.) in the pending settings
357 |  */
358 | export function setPendingSettingValueAny(
359 |   key: string,
360 |   value: SettingsValue,
361 |   pendingSettings: Settings,
362 | ): Settings {
363 |   const path = key.split('.');
364 |   const newSettings = structuredClone(pendingSettings);
365 |   setNestedValue(newSettings, path, value);
366 |   return newSettings;
367 | }
368 | 
369 | /**
370 |  * Check if any modified settings require a restart
371 |  */
372 | export function hasRestartRequiredSettings(
373 |   modifiedSettings: Set<string>,
374 | ): boolean {
375 |   return Array.from(modifiedSettings).some((key) => requiresRestart(key));
376 | }
377 | 
378 | /**
379 |  * Get the restart required settings from a set of modified settings
380 |  */
381 | export function getRestartRequiredFromModified(
382 |   modifiedSettings: Set<string>,
383 | ): string[] {
384 |   return Array.from(modifiedSettings).filter((key) => requiresRestart(key));
385 | }
386 | 
387 | /**
388 |  * Save modified settings to the appropriate scope
389 |  */
390 | export function saveModifiedSettings(
391 |   modifiedSettings: Set<string>,
392 |   pendingSettings: Settings,
393 |   loadedSettings: LoadedSettings,
[TRUNCATED]
```

src/utils/spawnWrapper.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { spawn } from 'node:child_process';
8 | 
9 | export const spawnWrapper = spawn;
```

src/utils/startupWarnings.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect, vi, beforeEach } from 'vitest';
8 | import { getStartupWarnings } from './startupWarnings.js';
9 | import * as fs from 'node:fs/promises';
10 | import { getErrorMessage } from '@google/gemini-cli-core';
11 | 
12 | vi.mock('node:fs/promises', { spy: true });
13 | vi.mock('@google/gemini-cli-core', async (importOriginal) => {
14 |   const actual =
15 |     await importOriginal<typeof import('@google/gemini-cli-core')>();
16 |   return {
17 |     ...actual,
18 |     getErrorMessage: vi.fn(),
19 |   };
20 | });
21 | 
22 | describe('startupWarnings', () => {
23 |   beforeEach(() => {
24 |     vi.resetAllMocks();
25 |   });
26 | 
27 |   it('should return warnings from the file and delete it', async () => {
28 |     const mockWarnings = 'Warning 1\nWarning 2';
29 |     vi.mocked(fs.access).mockResolvedValue();
30 |     vi.mocked(fs.readFile).mockResolvedValue(mockWarnings);
31 |     vi.mocked(fs.unlink).mockResolvedValue();
32 | 
33 |     const warnings = await getStartupWarnings();
34 | 
35 |     expect(fs.access).toHaveBeenCalled();
36 |     expect(fs.readFile).toHaveBeenCalled();
37 |     expect(fs.unlink).toHaveBeenCalled();
38 |     expect(warnings).toEqual(['Warning 1', 'Warning 2']);
39 |   });
40 | 
41 |   it('should return an empty array if the file does not exist', async () => {
42 |     const error = new Error('File not found');
43 |     (error as Error & { code: string }).code = 'ENOENT';
44 |     vi.mocked(fs.access).mockRejectedValue(error);
45 | 
46 |     const warnings = await getStartupWarnings();
47 | 
48 |     expect(warnings).toEqual([]);
49 |   });
50 | 
51 |   it('should return an error message if reading the file fails', async () => {
52 |     const error = new Error('Permission denied');
53 |     vi.mocked(fs.access).mockRejectedValue(error);
54 |     vi.mocked(getErrorMessage).mockReturnValue('Permission denied');
55 | 
56 |     const warnings = await getStartupWarnings();
57 | 
58 |     expect(warnings).toEqual([
59 |       'Error checking/reading warnings file: Permission denied',
60 |     ]);
61 |   });
62 | 
63 |   it('should return a warning if deleting the file fails', async () => {
64 |     const mockWarnings = 'Warning 1';
65 |     vi.mocked(fs.access).mockResolvedValue();
66 |     vi.mocked(fs.readFile).mockResolvedValue(mockWarnings);
67 |     vi.mocked(fs.unlink).mockRejectedValue(new Error('Permission denied'));
68 | 
69 |     const warnings = await getStartupWarnings();
70 | 
71 |     expect(warnings).toEqual([
72 |       'Warning 1',
73 |       'Warning: Could not delete temporary warnings file.',
74 |     ]);
75 |   });
76 | });
```

src/utils/startupWarnings.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import fs from 'node:fs/promises';
8 | import os from 'node:os';
9 | import { join as pathJoin } from 'node:path';
10 | import { getErrorMessage } from '@google/gemini-cli-core';
11 | 
12 | const warningsFilePath = pathJoin(os.tmpdir(), 'gemini-cli-warnings.txt');
13 | 
14 | export async function getStartupWarnings(): Promise<string[]> {
15 |   try {
16 |     await fs.access(warningsFilePath); // Check if file exists
17 |     const warningsContent = await fs.readFile(warningsFilePath, 'utf-8');
18 |     const warnings = warningsContent
19 |       .split('\n')
20 |       .filter((line) => line.trim() !== '');
21 |     try {
22 |       await fs.unlink(warningsFilePath);
23 |     } catch {
24 |       warnings.push('Warning: Could not delete temporary warnings file.');
25 |     }
26 |     return warnings;
27 |   } catch (err: unknown) {
28 |     // If fs.access throws, it means the file doesn't exist or is not accessible.
29 |     // This is not an error in the context of fetching warnings, so return empty.
30 |     // Only return an error message if it's not a "file not found" type error.
31 |     // However, the original logic returned an error message for any fs.existsSync failure.
32 |     // To maintain closer parity while making it async, we'll check the error code.
33 |     // ENOENT is "Error NO ENTry" (file not found).
34 |     if (err instanceof Error && 'code' in err && err.code === 'ENOENT') {
35 |       return []; // File not found, no warnings to return.
36 |     }
37 |     // For other errors (permissions, etc.), return the error message.
38 |     return [`Error checking/reading warnings file: ${getErrorMessage(err)}`];
39 |   }
40 | }
```

src/utils/updateEventEmitter.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { EventEmitter } from 'node:events';
8 | 
9 | /**
10 |  * A shared event emitter for application-wide communication
11 |  * between decoupled parts of the CLI.
12 |  */
13 | export const updateEventEmitter = new EventEmitter();
```

src/utils/userStartupWarnings.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
8 | import { getUserStartupWarnings } from './userStartupWarnings.js';
9 | import * as os from 'node:os';
10 | import fs from 'node:fs/promises';
11 | import path from 'node:path';
12 | 
13 | // Mock os.homedir to control the home directory in tests
14 | vi.mock('os', async (importOriginal) => {
15 |   const actualOs = await importOriginal<typeof os>();
16 |   return {
17 |     ...actualOs,
18 |     homedir: vi.fn(),
19 |   };
20 | });
21 | 
22 | describe('getUserStartupWarnings', () => {
23 |   let testRootDir: string;
24 |   let homeDir: string;
25 | 
26 |   beforeEach(async () => {
27 |     testRootDir = await fs.mkdtemp(path.join(os.tmpdir(), 'warnings-test-'));
28 |     homeDir = path.join(testRootDir, 'home');
29 |     await fs.mkdir(homeDir, { recursive: true });
30 |     vi.mocked(os.homedir).mockReturnValue(homeDir);
31 |   });
32 | 
33 |   afterEach(async () => {
34 |     await fs.rm(testRootDir, { recursive: true, force: true });
35 |     vi.clearAllMocks();
36 |   });
37 | 
38 |   describe('home directory check', () => {
39 |     it('should return a warning when running in home directory', async () => {
40 |       const warnings = await getUserStartupWarnings(homeDir);
41 |       expect(warnings).toContainEqual(
42 |         expect.stringContaining('home directory'),
43 |       );
44 |     });
45 | 
46 |     it('should not return a warning when running in a project directory', async () => {
47 |       const projectDir = path.join(testRootDir, 'project');
48 |       await fs.mkdir(projectDir);
49 |       const warnings = await getUserStartupWarnings(projectDir);
50 |       expect(warnings).not.toContainEqual(
51 |         expect.stringContaining('home directory'),
52 |       );
53 |     });
54 |   });
55 | 
56 |   describe('root directory check', () => {
57 |     it('should return a warning when running in a root directory', async () => {
58 |       const rootDir = path.parse(testRootDir).root;
59 |       const warnings = await getUserStartupWarnings(rootDir);
60 |       expect(warnings).toContainEqual(
61 |         expect.stringContaining('root directory'),
62 |       );
63 |       expect(warnings).toContainEqual(
64 |         expect.stringContaining('folder structure will be used'),
65 |       );
66 |     });
67 | 
68 |     it('should not return a warning when running in a non-root directory', async () => {
69 |       const projectDir = path.join(testRootDir, 'project');
70 |       await fs.mkdir(projectDir);
71 |       const warnings = await getUserStartupWarnings(projectDir);
72 |       expect(warnings).not.toContainEqual(
73 |         expect.stringContaining('root directory'),
74 |       );
75 |     });
76 |   });
77 | 
78 |   describe('error handling', () => {
79 |     it('should handle errors when checking directory', async () => {
80 |       const nonExistentPath = path.join(testRootDir, 'non-existent');
81 |       const warnings = await getUserStartupWarnings(nonExistentPath);
82 |       const expectedWarning =
83 |         'Could not verify the current directory due to a file system error.';
84 |       expect(warnings).toEqual([expectedWarning, expectedWarning]);
85 |     });
86 |   });
87 | });
```

src/utils/userStartupWarnings.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import fs from 'node:fs/promises';
8 | import * as os from 'node:os';
9 | import path from 'node:path';
10 | 
11 | type WarningCheck = {
12 |   id: string;
13 |   check: (workspaceRoot: string) => Promise<string | null>;
14 | };
15 | 
16 | // Individual warning checks
17 | const homeDirectoryCheck: WarningCheck = {
18 |   id: 'home-directory',
19 |   check: async (workspaceRoot: string) => {
20 |     try {
21 |       const [workspaceRealPath, homeRealPath] = await Promise.all([
22 |         fs.realpath(workspaceRoot),
23 |         fs.realpath(os.homedir()),
24 |       ]);
25 | 
26 |       if (workspaceRealPath === homeRealPath) {
27 |         return 'You are running Gemini CLI in your home directory. It is recommended to run in a project-specific directory.';
28 |       }
29 |       return null;
30 |     } catch (_err: unknown) {
31 |       return 'Could not verify the current directory due to a file system error.';
32 |     }
33 |   },
34 | };
35 | 
36 | const rootDirectoryCheck: WarningCheck = {
37 |   id: 'root-directory',
38 |   check: async (workspaceRoot: string) => {
39 |     try {
40 |       const workspaceRealPath = await fs.realpath(workspaceRoot);
41 |       const errorMessage =
42 |         'Warning: You are running Gemini CLI in the root directory. Your entire folder structure will be used for context. It is strongly recommended to run in a project-specific directory.';
43 | 
44 |       // Check for Unix root directory
45 |       if (path.dirname(workspaceRealPath) === workspaceRealPath) {
46 |         return errorMessage;
47 |       }
48 | 
49 |       return null;
50 |     } catch (_err: unknown) {
51 |       return 'Could not verify the current directory due to a file system error.';
52 |     }
53 |   },
54 | };
55 | 
56 | // All warning checks
57 | const WARNING_CHECKS: readonly WarningCheck[] = [
58 |   homeDirectoryCheck,
59 |   rootDirectoryCheck,
60 | ];
61 | 
62 | export async function getUserStartupWarnings(
63 |   workspaceRoot: string = process.cwd(),
64 | ): Promise<string[]> {
65 |   const results = await Promise.all(
66 |     WARNING_CHECKS.map((check) => check.check(workspaceRoot)),
67 |   );
68 |   return results.filter((msg) => msg !== null);
69 | }
```

src/utils/version.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { getPackageJson } from './package.js';
8 | 
9 | export async function getCliVersion(): Promise<string> {
10 |   const pkgJson = await getPackageJson();
11 |   return process.env['CLI_VERSION'] || pkgJson?.version || 'unknown';
12 | }
```

src/utils/windowTitle.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect, vi, beforeEach } from 'vitest';
8 | import { computeWindowTitle } from './windowTitle.js';
9 | 
10 | describe('computeWindowTitle', () => {
11 |   let originalEnv: NodeJS.ProcessEnv;
12 | 
13 |   beforeEach(() => {
14 |     originalEnv = process.env;
15 |     vi.stubEnv('CLI_TITLE', undefined);
16 |   });
17 | 
18 |   afterEach(() => {
19 |     process.env = originalEnv;
20 |   });
21 | 
22 |   it('should use default Gemini title when CLI_TITLE is not set', () => {
23 |     const result = computeWindowTitle('my-project');
24 |     expect(result).toBe('Gemini - my-project');
25 |   });
26 | 
27 |   it('should use CLI_TITLE environment variable when set', () => {
28 |     vi.stubEnv('CLI_TITLE', 'Custom Title');
29 |     const result = computeWindowTitle('my-project');
30 |     expect(result).toBe('Custom Title');
31 |   });
32 | 
33 |   it('should remove control characters from title', () => {
34 |     vi.stubEnv('CLI_TITLE', 'Title\x1b[31m with \x07 control chars');
35 |     const result = computeWindowTitle('my-project');
36 |     // The \x1b[31m (ANSI escape sequence) and \x07 (bell character) should be removed
37 |     expect(result).toBe('Title[31m with  control chars');
38 |   });
39 | 
40 |   it('should handle folder names with control characters', () => {
41 |     const result = computeWindowTitle('project\x07name');
42 |     expect(result).toBe('Gemini - projectname');
43 |   });
44 | 
45 |   it('should handle empty folder name', () => {
46 |     const result = computeWindowTitle('');
47 |     expect(result).toBe('Gemini - ');
48 |   });
49 | 
50 |   it('should handle folder names with spaces', () => {
51 |     const result = computeWindowTitle('my project');
52 |     expect(result).toBe('Gemini - my project');
53 |   });
54 | 
55 |   it('should handle folder names with special characters', () => {
56 |     const result = computeWindowTitle('project-name_v1.0');
57 |     expect(result).toBe('Gemini - project-name_v1.0');
58 |   });
59 | });
```

src/utils/windowTitle.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | /**
8 |  * Computes the window title for the Gemini CLI application.
9 |  *
10 |  * @param folderName - The name of the current folder/workspace to display in the title
11 |  * @returns The computed window title, either from CLI_TITLE environment variable or the default Gemini title
12 |  */
13 | export function computeWindowTitle(folderName: string): string {
14 |   const title = process.env['CLI_TITLE'] || `Gemini - ${folderName}`;
15 | 
16 |   // Remove control characters that could cause issues in terminal titles
17 |   return title.replace(
18 |     // eslint-disable-next-line no-control-regex
19 |     /[\x00-\x1F\x7F]/g,
20 |     '',
21 |   );
22 | }
```

src/zed-integration/acp.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | /* ACP defines a schema for a simple (experimental) JSON-RPC protocol that allows GUI applications to interact with agents. */
8 | 
9 | import { z } from 'zod';
10 | import * as schema from './schema.js';
11 | export * from './schema.js';
12 | 
13 | import type { WritableStream, ReadableStream } from 'node:stream/web';
14 | 
15 | export class AgentSideConnection implements Client {
16 |   #connection: Connection;
17 | 
18 |   constructor(
19 |     toAgent: (conn: Client) => Agent,
20 |     input: WritableStream<Uint8Array>,
21 |     output: ReadableStream<Uint8Array>,
22 |   ) {
23 |     const agent = toAgent(this);
24 | 
25 |     const handler = async (
26 |       method: string,
27 |       params: unknown,
28 |     ): Promise<unknown> => {
29 |       switch (method) {
30 |         case schema.AGENT_METHODS.initialize: {
31 |           const validatedParams = schema.initializeRequestSchema.parse(params);
32 |           return agent.initialize(validatedParams);
33 |         }
34 |         case schema.AGENT_METHODS.session_new: {
35 |           const validatedParams = schema.newSessionRequestSchema.parse(params);
36 |           return agent.newSession(validatedParams);
37 |         }
38 |         case schema.AGENT_METHODS.session_load: {
39 |           if (!agent.loadSession) {
40 |             throw RequestError.methodNotFound();
41 |           }
42 |           const validatedParams = schema.loadSessionRequestSchema.parse(params);
43 |           return agent.loadSession(validatedParams);
44 |         }
45 |         case schema.AGENT_METHODS.authenticate: {
46 |           const validatedParams =
47 |             schema.authenticateRequestSchema.parse(params);
48 |           return agent.authenticate(validatedParams);
49 |         }
50 |         case schema.AGENT_METHODS.session_prompt: {
51 |           const validatedParams = schema.promptRequestSchema.parse(params);
52 |           return agent.prompt(validatedParams);
53 |         }
54 |         case schema.AGENT_METHODS.session_cancel: {
55 |           const validatedParams = schema.cancelNotificationSchema.parse(params);
56 |           return agent.cancel(validatedParams);
57 |         }
58 |         default:
59 |           throw RequestError.methodNotFound(method);
60 |       }
61 |     };
62 | 
63 |     this.#connection = new Connection(handler, input, output);
64 |   }
65 | 
66 |   /**
67 |    * Streams new content to the client including text, tool calls, etc.
68 |    */
69 |   async sessionUpdate(params: schema.SessionNotification): Promise<void> {
70 |     return await this.#connection.sendNotification(
71 |       schema.CLIENT_METHODS.session_update,
72 |       params,
73 |     );
74 |   }
75 | 
76 |   /**
77 |    * Request permission before running a tool
78 |    *
79 |    * The agent specifies a series of permission options with different granularity,
80 |    * and the client returns the chosen one.
81 |    */
82 |   async requestPermission(
83 |     params: schema.RequestPermissionRequest,
84 |   ): Promise<schema.RequestPermissionResponse> {
85 |     return await this.#connection.sendRequest(
86 |       schema.CLIENT_METHODS.session_request_permission,
87 |       params,
88 |     );
89 |   }
90 | 
91 |   async readTextFile(
92 |     params: schema.ReadTextFileRequest,
93 |   ): Promise<schema.ReadTextFileResponse> {
94 |     return await this.#connection.sendRequest(
95 |       schema.CLIENT_METHODS.fs_read_text_file,
96 |       params,
97 |     );
98 |   }
99 | 
100 |   async writeTextFile(
101 |     params: schema.WriteTextFileRequest,
102 |   ): Promise<schema.WriteTextFileResponse> {
103 |     return await this.#connection.sendRequest(
104 |       schema.CLIENT_METHODS.fs_write_text_file,
105 |       params,
106 |     );
107 |   }
108 | }
109 | 
110 | type AnyMessage = AnyRequest | AnyResponse | AnyNotification;
111 | 
112 | type AnyRequest = {
113 |   jsonrpc: '2.0';
114 |   id: string | number;
115 |   method: string;
116 |   params?: unknown;
117 | };
118 | 
119 | type AnyResponse = {
120 |   jsonrpc: '2.0';
121 |   id: string | number;
122 | } & Result<unknown>;
123 | 
124 | type AnyNotification = {
125 |   jsonrpc: '2.0';
126 |   method: string;
127 |   params?: unknown;
128 | };
129 | 
130 | type Result<T> =
131 |   | {
132 |       result: T;
133 |     }
134 |   | {
135 |       error: ErrorResponse;
136 |     };
137 | 
138 | type ErrorResponse = {
139 |   code: number;
140 |   message: string;
141 |   data?: unknown;
142 | };
143 | 
144 | type PendingResponse = {
145 |   resolve: (response: unknown) => void;
146 |   reject: (error: ErrorResponse) => void;
147 | };
148 | 
149 | type MethodHandler = (method: string, params: unknown) => Promise<unknown>;
150 | 
151 | class Connection {
152 |   #pendingResponses: Map<string | number, PendingResponse> = new Map();
153 |   #nextRequestId: number = 0;
154 |   #handler: MethodHandler;
155 |   #peerInput: WritableStream<Uint8Array>;
156 |   #writeQueue: Promise<void> = Promise.resolve();
157 |   #textEncoder: TextEncoder;
158 | 
159 |   constructor(
160 |     handler: MethodHandler,
161 |     peerInput: WritableStream<Uint8Array>,
162 |     peerOutput: ReadableStream<Uint8Array>,
163 |   ) {
164 |     this.#handler = handler;
165 |     this.#peerInput = peerInput;
166 |     this.#textEncoder = new TextEncoder();
167 |     this.#receive(peerOutput);
168 |   }
169 | 
170 |   async #receive(output: ReadableStream<Uint8Array>) {
171 |     let content = '';
172 |     const decoder = new TextDecoder();
173 |     for await (const chunk of output) {
174 |       content += decoder.decode(chunk, { stream: true });
175 |       const lines = content.split('\n');
176 |       content = lines.pop() || '';
177 | 
178 |       for (const line of lines) {
179 |         const trimmedLine = line.trim();
180 | 
181 |         if (trimmedLine) {
182 |           const message = JSON.parse(trimmedLine);
183 |           this.#processMessage(message);
184 |         }
185 |       }
186 |     }
187 |   }
188 | 
189 |   async #processMessage(message: AnyMessage) {
190 |     if ('method' in message && 'id' in message) {
191 |       // It's a request
192 |       const response = await this.#tryCallHandler(
193 |         message.method,
194 |         message.params,
195 |       );
196 | 
197 |       await this.#sendMessage({
198 |         jsonrpc: '2.0',
199 |         id: message.id,
200 |         ...response,
201 |       });
202 |     } else if ('method' in message) {
203 |       // It's a notification
204 |       await this.#tryCallHandler(message.method, message.params);
205 |     } else if ('id' in message) {
206 |       // It's a response
207 |       this.#handleResponse(message as AnyResponse);
208 |     }
209 |   }
210 | 
211 |   async #tryCallHandler(
212 |     method: string,
213 |     params?: unknown,
214 |   ): Promise<Result<unknown>> {
215 |     try {
216 |       const result = await this.#handler(method, params);
217 |       return { result: result ?? null };
218 |     } catch (error: unknown) {
219 |       if (error instanceof RequestError) {
220 |         return error.toResult();
221 |       }
222 | 
223 |       if (error instanceof z.ZodError) {
224 |         return RequestError.invalidParams(
225 |           JSON.stringify(error.format(), undefined, 2),
226 |         ).toResult();
227 |       }
228 | 
229 |       let details;
230 | 
231 |       if (error instanceof Error) {
232 |         details = error.message;
233 |       } else if (
234 |         typeof error === 'object' &&
235 |         error != null &&
236 |         'message' in error &&
237 |         typeof error.message === 'string'
238 |       ) {
239 |         details = error.message;
240 |       }
241 | 
242 |       return RequestError.internalError(details).toResult();
243 |     }
244 |   }
245 | 
246 |   #handleResponse(response: AnyResponse) {
247 |     const pendingResponse = this.#pendingResponses.get(response.id);
248 |     if (pendingResponse) {
249 |       if ('result' in response) {
250 |         pendingResponse.resolve(response.result);
251 |       } else if ('error' in response) {
252 |         pendingResponse.reject(response.error);
253 |       }
254 |       this.#pendingResponses.delete(response.id);
255 |     }
256 |   }
257 | 
258 |   async sendRequest<Req, Resp>(method: string, params?: Req): Promise<Resp> {
259 |     const id = this.#nextRequestId++;
260 |     const responsePromise = new Promise((resolve, reject) => {
261 |       this.#pendingResponses.set(id, { resolve, reject });
262 |     });
263 |     await this.#sendMessage({ jsonrpc: '2.0', id, method, params });
264 |     return responsePromise as Promise<Resp>;
265 |   }
266 | 
267 |   async sendNotification<N>(method: string, params?: N): Promise<void> {
268 |     await this.#sendMessage({ jsonrpc: '2.0', method, params });
269 |   }
270 | 
271 |   async #sendMessage(json: AnyMessage) {
272 |     const content = JSON.stringify(json) + '\n';
273 |     this.#writeQueue = this.#writeQueue
274 |       .then(async () => {
275 |         const writer = this.#peerInput.getWriter();
276 |         try {
277 |           await writer.write(this.#textEncoder.encode(content));
278 |         } finally {
279 |           writer.releaseLock();
280 |         }
281 |       })
282 |       .catch((error) => {
283 |         // Continue processing writes on error
284 |         console.error('ACP write error:', error);
285 |       });
286 |     return this.#writeQueue;
287 |   }
288 | }
289 | 
290 | export class RequestError extends Error {
291 |   data?: { details?: string };
292 | 
293 |   constructor(
294 |     public code: number,
295 |     message: string,
296 |     details?: string,
297 |   ) {
298 |     super(message);
299 |     this.name = 'RequestError';
300 |     if (details) {
301 |       this.data = { details };
302 |     }
303 |   }
304 | 
305 |   static parseError(details?: string): RequestError {
306 |     return new RequestError(-32700, 'Parse error', details);
307 |   }
308 | 
309 |   static invalidRequest(details?: string): RequestError {
310 |     return new RequestError(-32600, 'Invalid request', details);
311 |   }
312 | 
313 |   static methodNotFound(details?: string): RequestError {
314 |     return new RequestError(-32601, 'Method not found', details);
315 |   }
316 | 
317 |   static invalidParams(details?: string): RequestError {
318 |     return new RequestError(-32602, 'Invalid params', details);
319 |   }
320 | 
321 |   static internalError(details?: string): RequestError {
322 |     return new RequestError(-32603, 'Internal error', details);
323 |   }
324 | 
325 |   static authRequired(details?: string): RequestError {
326 |     return new RequestError(-32000, 'Authentication required', details);
327 |   }
328 | 
329 |   toResult<T>(): Result<T> {
330 |     return {
331 |       error: {
332 |         code: this.code,
333 |         message: this.message,
334 |         data: this.data,
335 |       },
336 |     };
337 |   }
338 | }
339 | 
340 | export interface Client {
341 |   requestPermission(
342 |     params: schema.RequestPermissionRequest,
343 |   ): Promise<schema.RequestPermissionResponse>;
344 |   sessionUpdate(params: schema.SessionNotification): Promise<void>;
345 |   writeTextFile(
346 |     params: schema.WriteTextFileRequest,
347 |   ): Promise<schema.WriteTextFileResponse>;
348 |   readTextFile(
349 |     params: schema.ReadTextFileRequest,
350 |   ): Promise<schema.ReadTextFileResponse>;
351 | }
352 | 
353 | export interface Agent {
354 |   initialize(
355 |     params: schema.InitializeRequest,
356 |   ): Promise<schema.InitializeResponse>;
357 |   newSession(
358 |     params: schema.NewSessionRequest,
359 |   ): Promise<schema.NewSessionResponse>;
360 |   loadSession?(
361 |     params: schema.LoadSessionRequest,
362 |   ): Promise<schema.LoadSessionResponse>;
363 |   authenticate(params: schema.AuthenticateRequest): Promise<void>;
364 |   prompt(params: schema.PromptRequest): Promise<schema.PromptResponse>;
365 |   cancel(params: schema.CancelNotification): Promise<void>;
366 | }
```

src/zed-integration/fileSystemService.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type { FileSystemService } from '@google/gemini-cli-core';
8 | import type * as acp from './acp.js';
9 | 
10 | /**
11 |  * ACP client-based implementation of FileSystemService
12 |  */
13 | export class AcpFileSystemService implements FileSystemService {
14 |   constructor(
15 |     private readonly client: acp.Client,
16 |     private readonly sessionId: string,
17 |     private readonly capabilities: acp.FileSystemCapability,
18 |     private readonly fallback: FileSystemService,
19 |   ) {}
20 | 
21 |   async readTextFile(filePath: string): Promise<string> {
22 |     if (!this.capabilities.readTextFile) {
23 |       return this.fallback.readTextFile(filePath);
24 |     }
25 | 
26 |     const response = await this.client.readTextFile({
27 |       path: filePath,
28 |       sessionId: this.sessionId,
29 |       line: null,
30 |       limit: null,
31 |     });
32 | 
33 |     return response.content;
34 |   }
35 | 
36 |   async writeTextFile(filePath: string, content: string): Promise<void> {
37 |     if (!this.capabilities.writeTextFile) {
38 |       return this.fallback.writeTextFile(filePath, content);
39 |     }
40 | 
41 |     await this.client.writeTextFile({
42 |       path: filePath,
43 |       content,
44 |       sessionId: this.sessionId,
45 |     });
46 |   }
47 |   findFiles(fileName: string, searchPaths: readonly string[]): string[] {
48 |     return this.fallback.findFiles(fileName, searchPaths);
49 |   }
50 | }
```

src/zed-integration/schema.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { z } from 'zod';
8 | 
9 | export const AGENT_METHODS = {
10 |   authenticate: 'authenticate',
11 |   initialize: 'initialize',
12 |   session_cancel: 'session/cancel',
13 |   session_load: 'session/load',
14 |   session_new: 'session/new',
15 |   session_prompt: 'session/prompt',
16 | };
17 | 
18 | export const CLIENT_METHODS = {
19 |   fs_read_text_file: 'fs/read_text_file',
20 |   fs_write_text_file: 'fs/write_text_file',
21 |   session_request_permission: 'session/request_permission',
22 |   session_update: 'session/update',
23 | };
24 | 
25 | export const PROTOCOL_VERSION = 1;
26 | 
27 | export type WriteTextFileRequest = z.infer<typeof writeTextFileRequestSchema>;
28 | 
29 | export type ReadTextFileRequest = z.infer<typeof readTextFileRequestSchema>;
30 | 
31 | export type PermissionOptionKind = z.infer<typeof permissionOptionKindSchema>;
32 | 
33 | export type Role = z.infer<typeof roleSchema>;
34 | 
35 | export type TextResourceContents = z.infer<typeof textResourceContentsSchema>;
36 | 
37 | export type BlobResourceContents = z.infer<typeof blobResourceContentsSchema>;
38 | 
39 | export type ToolKind = z.infer<typeof toolKindSchema>;
40 | 
41 | export type ToolCallStatus = z.infer<typeof toolCallStatusSchema>;
42 | 
43 | export type WriteTextFileResponse = z.infer<typeof writeTextFileResponseSchema>;
44 | 
45 | export type ReadTextFileResponse = z.infer<typeof readTextFileResponseSchema>;
46 | 
47 | export type RequestPermissionOutcome = z.infer<
48 |   typeof requestPermissionOutcomeSchema
49 | >;
50 | 
51 | export type CancelNotification = z.infer<typeof cancelNotificationSchema>;
52 | 
53 | export type AuthenticateRequest = z.infer<typeof authenticateRequestSchema>;
54 | 
55 | export type AuthenticateResponse = z.infer<typeof authenticateResponseSchema>;
56 | 
57 | export type NewSessionResponse = z.infer<typeof newSessionResponseSchema>;
58 | 
59 | export type LoadSessionResponse = z.infer<typeof loadSessionResponseSchema>;
60 | 
61 | export type StopReason = z.infer<typeof stopReasonSchema>;
62 | 
63 | export type PromptResponse = z.infer<typeof promptResponseSchema>;
64 | 
65 | export type ToolCallLocation = z.infer<typeof toolCallLocationSchema>;
66 | 
67 | export type PlanEntry = z.infer<typeof planEntrySchema>;
68 | 
69 | export type PermissionOption = z.infer<typeof permissionOptionSchema>;
70 | 
71 | export type Annotations = z.infer<typeof annotationsSchema>;
72 | 
73 | export type RequestPermissionResponse = z.infer<
74 |   typeof requestPermissionResponseSchema
75 | >;
76 | 
77 | export type FileSystemCapability = z.infer<typeof fileSystemCapabilitySchema>;
78 | 
79 | export type EnvVariable = z.infer<typeof envVariableSchema>;
80 | 
81 | export type McpServer = z.infer<typeof mcpServerSchema>;
82 | 
83 | export type AgentCapabilities = z.infer<typeof agentCapabilitiesSchema>;
84 | 
85 | export type AuthMethod = z.infer<typeof authMethodSchema>;
86 | 
87 | export type PromptCapabilities = z.infer<typeof promptCapabilitiesSchema>;
88 | 
89 | export type ClientResponse = z.infer<typeof clientResponseSchema>;
90 | 
91 | export type ClientNotification = z.infer<typeof clientNotificationSchema>;
92 | 
93 | export type EmbeddedResourceResource = z.infer<
94 |   typeof embeddedResourceResourceSchema
95 | >;
96 | 
97 | export type NewSessionRequest = z.infer<typeof newSessionRequestSchema>;
98 | 
99 | export type LoadSessionRequest = z.infer<typeof loadSessionRequestSchema>;
100 | 
101 | export type InitializeResponse = z.infer<typeof initializeResponseSchema>;
102 | 
103 | export type ContentBlock = z.infer<typeof contentBlockSchema>;
104 | 
105 | export type ToolCallContent = z.infer<typeof toolCallContentSchema>;
106 | 
107 | export type ToolCall = z.infer<typeof toolCallSchema>;
108 | 
109 | export type ClientCapabilities = z.infer<typeof clientCapabilitiesSchema>;
110 | 
111 | export type PromptRequest = z.infer<typeof promptRequestSchema>;
112 | 
113 | export type SessionUpdate = z.infer<typeof sessionUpdateSchema>;
114 | 
115 | export type AgentResponse = z.infer<typeof agentResponseSchema>;
116 | 
117 | export type RequestPermissionRequest = z.infer<
118 |   typeof requestPermissionRequestSchema
119 | >;
120 | 
121 | export type InitializeRequest = z.infer<typeof initializeRequestSchema>;
122 | 
123 | export type SessionNotification = z.infer<typeof sessionNotificationSchema>;
124 | 
125 | export type ClientRequest = z.infer<typeof clientRequestSchema>;
126 | 
127 | export type AgentRequest = z.infer<typeof agentRequestSchema>;
128 | 
129 | export type AgentNotification = z.infer<typeof agentNotificationSchema>;
130 | 
131 | export const writeTextFileRequestSchema = z.object({
132 |   content: z.string(),
133 |   path: z.string(),
134 |   sessionId: z.string(),
135 | });
136 | 
137 | export const readTextFileRequestSchema = z.object({
138 |   limit: z.number().optional().nullable(),
139 |   line: z.number().optional().nullable(),
140 |   path: z.string(),
141 |   sessionId: z.string(),
142 | });
143 | 
144 | export const permissionOptionKindSchema = z.union([
145 |   z.literal('allow_once'),
146 |   z.literal('allow_always'),
147 |   z.literal('reject_once'),
148 |   z.literal('reject_always'),
149 | ]);
150 | 
151 | export const roleSchema = z.union([z.literal('assistant'), z.literal('user')]);
152 | 
153 | export const textResourceContentsSchema = z.object({
154 |   mimeType: z.string().optional().nullable(),
155 |   text: z.string(),
156 |   uri: z.string(),
157 | });
158 | 
159 | export const blobResourceContentsSchema = z.object({
160 |   blob: z.string(),
161 |   mimeType: z.string().optional().nullable(),
162 |   uri: z.string(),
163 | });
164 | 
165 | export const toolKindSchema = z.union([
166 |   z.literal('read'),
167 |   z.literal('edit'),
168 |   z.literal('delete'),
169 |   z.literal('move'),
170 |   z.literal('search'),
171 |   z.literal('execute'),
172 |   z.literal('think'),
173 |   z.literal('fetch'),
174 |   z.literal('other'),
175 | ]);
176 | 
177 | export const toolCallStatusSchema = z.union([
178 |   z.literal('pending'),
179 |   z.literal('in_progress'),
180 |   z.literal('completed'),
181 |   z.literal('failed'),
182 | ]);
183 | 
184 | export const writeTextFileResponseSchema = z.null();
185 | 
186 | export const readTextFileResponseSchema = z.object({
187 |   content: z.string(),
188 | });
189 | 
190 | export const requestPermissionOutcomeSchema = z.union([
191 |   z.object({
192 |     outcome: z.literal('cancelled'),
193 |   }),
194 |   z.object({
195 |     optionId: z.string(),
196 |     outcome: z.literal('selected'),
197 |   }),
198 | ]);
199 | 
200 | export const cancelNotificationSchema = z.object({
201 |   sessionId: z.string(),
202 | });
203 | 
204 | export const authenticateRequestSchema = z.object({
205 |   methodId: z.string(),
206 | });
207 | 
208 | export const authenticateResponseSchema = z.null();
209 | 
210 | export const newSessionResponseSchema = z.object({
211 |   sessionId: z.string(),
212 | });
213 | 
214 | export const loadSessionResponseSchema = z.null();
215 | 
216 | export const stopReasonSchema = z.union([
217 |   z.literal('end_turn'),
218 |   z.literal('max_tokens'),
219 |   z.literal('refusal'),
220 |   z.literal('cancelled'),
221 | ]);
222 | 
223 | export const promptResponseSchema = z.object({
224 |   stopReason: stopReasonSchema,
225 | });
226 | 
227 | export const toolCallLocationSchema = z.object({
228 |   line: z.number().optional().nullable(),
229 |   path: z.string(),
230 | });
231 | 
232 | export const planEntrySchema = z.object({
233 |   content: z.string(),
234 |   priority: z.union([z.literal('high'), z.literal('medium'), z.literal('low')]),
235 |   status: z.union([
236 |     z.literal('pending'),
237 |     z.literal('in_progress'),
238 |     z.literal('completed'),
239 |   ]),
240 | });
241 | 
242 | export const permissionOptionSchema = z.object({
243 |   kind: permissionOptionKindSchema,
244 |   name: z.string(),
245 |   optionId: z.string(),
246 | });
247 | 
248 | export const annotationsSchema = z.object({
249 |   audience: z.array(roleSchema).optional().nullable(),
250 |   lastModified: z.string().optional().nullable(),
251 |   priority: z.number().optional().nullable(),
252 | });
253 | 
254 | export const requestPermissionResponseSchema = z.object({
255 |   outcome: requestPermissionOutcomeSchema,
256 | });
257 | 
258 | export const fileSystemCapabilitySchema = z.object({
259 |   readTextFile: z.boolean(),
260 |   writeTextFile: z.boolean(),
261 | });
262 | 
263 | export const envVariableSchema = z.object({
264 |   name: z.string(),
265 |   value: z.string(),
266 | });
267 | 
268 | export const mcpServerSchema = z.object({
269 |   args: z.array(z.string()),
270 |   command: z.string(),
271 |   env: z.array(envVariableSchema),
272 |   name: z.string(),
273 | });
274 | 
275 | export const promptCapabilitiesSchema = z.object({
276 |   audio: z.boolean().optional(),
277 |   embeddedContext: z.boolean().optional(),
278 |   image: z.boolean().optional(),
279 | });
280 | 
281 | export const agentCapabilitiesSchema = z.object({
282 |   loadSession: z.boolean().optional(),
283 |   promptCapabilities: promptCapabilitiesSchema.optional(),
284 | });
285 | 
286 | export const authMethodSchema = z.object({
287 |   description: z.string().nullable(),
288 |   id: z.string(),
289 |   name: z.string(),
290 | });
291 | 
292 | export const clientResponseSchema = z.union([
293 |   writeTextFileResponseSchema,
294 |   readTextFileResponseSchema,
295 |   requestPermissionResponseSchema,
296 | ]);
297 | 
298 | export const clientNotificationSchema = cancelNotificationSchema;
299 | 
300 | export const embeddedResourceResourceSchema = z.union([
301 |   textResourceContentsSchema,
302 |   blobResourceContentsSchema,
303 | ]);
304 | 
305 | export const newSessionRequestSchema = z.object({
306 |   cwd: z.string(),
307 |   mcpServers: z.array(mcpServerSchema),
308 | });
309 | 
310 | export const loadSessionRequestSchema = z.object({
311 |   cwd: z.string(),
312 |   mcpServers: z.array(mcpServerSchema),
313 |   sessionId: z.string(),
314 | });
315 | 
316 | export const initializeResponseSchema = z.object({
317 |   agentCapabilities: agentCapabilitiesSchema,
318 |   authMethods: z.array(authMethodSchema),
319 |   protocolVersion: z.number(),
320 | });
321 | 
322 | export const contentBlockSchema = z.union([
323 |   z.object({
324 |     annotations: annotationsSchema.optional().nullable(),
325 |     text: z.string(),
326 |     type: z.literal('text'),
327 |   }),
328 |   z.object({
329 |     annotations: annotationsSchema.optional().nullable(),
330 |     data: z.string(),
331 |     mimeType: z.string(),
332 |     type: z.literal('image'),
333 |   }),
334 |   z.object({
335 |     annotations: annotationsSchema.optional().nullable(),
336 |     data: z.string(),
337 |     mimeType: z.string(),
338 |     type: z.literal('audio'),
339 |   }),
340 |   z.object({
341 |     annotations: annotationsSchema.optional().nullable(),
342 |     description: z.string().optional().nullable(),
343 |     mimeType: z.string().optional().nullable(),
344 |     name: z.string(),
345 |     size: z.number().optional().nullable(),
346 |     title: z.string().optional().nullable(),
347 |     type: z.literal('resource_link'),
348 |     uri: z.string(),
349 |   }),
350 |   z.object({
351 |     annotations: annotationsSchema.optional().nullable(),
352 |     resource: embeddedResourceResourceSchema,
353 |     type: z.literal('resource'),
354 |   }),
355 | ]);
356 | 
357 | export const toolCallContentSchema = z.union([
358 |   z.object({
359 |     content: contentBlockSchema,
360 |     type: z.literal('content'),
361 |   }),
362 |   z.object({
363 |     newText: z.string(),
364 |     oldText: z.string().nullable(),
365 |     path: z.string(),
366 |     type: z.literal('diff'),
367 |   }),
368 | ]);
369 | 
370 | export const toolCallSchema = z.object({
371 |   content: z.array(toolCallContentSchema).optional(),
372 |   kind: toolKindSchema,
373 |   locations: z.array(toolCallLocationSchema).optional(),
374 |   rawInput: z.unknown().optional(),
375 |   status: toolCallStatusSchema,
376 |   title: z.string(),
377 |   toolCallId: z.string(),
378 | });
379 | 
380 | export const clientCapabilitiesSchema = z.object({
381 |   fs: fileSystemCapabilitySchema,
382 | });
383 | 
384 | export const promptRequestSchema = z.object({
385 |   prompt: z.array(contentBlockSchema),
386 |   sessionId: z.string(),
387 | });
388 | 
389 | export const sessionUpdateSchema = z.union([
390 |   z.object({
391 |     content: contentBlockSchema,
392 |     sessionUpdate: z.literal('user_message_chunk'),
393 |   }),
[TRUNCATED]
```

src/zed-integration/zedIntegration.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type { WritableStream, ReadableStream } from 'node:stream/web';
8 | 
9 | import type {
10 |   Config,
11 |   GeminiChat,
12 |   ToolResult,
13 |   ToolCallConfirmationDetails,
14 |   GeminiCLIExtension,
15 | } from '@google/gemini-cli-core';
16 | import {
17 |   AuthType,
18 |   logToolCall,
19 |   convertToFunctionResponse,
20 |   ToolConfirmationOutcome,
21 |   clearCachedCredentialFile,
22 |   isNodeError,
23 |   getErrorMessage,
24 |   isWithinRoot,
25 |   getErrorStatus,
26 |   MCPServerConfig,
27 |   DiscoveredMCPTool,
28 |   StreamEventType,
29 |   ToolCallEvent,
30 |   DEFAULT_GEMINI_MODEL,
31 |   DEFAULT_GEMINI_MODEL_AUTO,
32 |   DEFAULT_GEMINI_FLASH_MODEL,
33 | } from '@google/gemini-cli-core';
34 | import * as acp from './acp.js';
35 | import { AcpFileSystemService } from './fileSystemService.js';
36 | import { Readable, Writable } from 'node:stream';
37 | import type { Content, Part, FunctionCall } from '@google/genai';
38 | import type { LoadedSettings } from '../config/settings.js';
39 | import { SettingScope } from '../config/settings.js';
40 | import * as fs from 'node:fs/promises';
41 | import * as path from 'node:path';
42 | import { z } from 'zod';
43 | 
44 | import { randomUUID } from 'node:crypto';
45 | import { ExtensionStorage } from '../config/extension.js';
46 | import type { CliArgs } from '../config/config.js';
47 | import { loadCliConfig } from '../config/config.js';
48 | import { ExtensionEnablementManager } from '../config/extensions/extensionEnablement.js';
49 | 
50 | /**
51 |  * Resolves the model to use based on the current configuration.
52 |  *
53 |  * If the model is set to "auto", it will use the flash model if in fallback
54 |  * mode, otherwise it will use the default model.
55 |  */
56 | export function resolveModel(model: string, isInFallbackMode: boolean): string {
57 |   if (model === DEFAULT_GEMINI_MODEL_AUTO) {
58 |     return isInFallbackMode ? DEFAULT_GEMINI_FLASH_MODEL : DEFAULT_GEMINI_MODEL;
59 |   }
60 |   return model;
61 | }
62 | 
63 | export async function runZedIntegration(
64 |   config: Config,
65 |   settings: LoadedSettings,
66 |   extensions: GeminiCLIExtension[],
67 |   argv: CliArgs,
68 | ) {
69 |   const stdout = Writable.toWeb(process.stdout) as WritableStream;
70 |   const stdin = Readable.toWeb(process.stdin) as ReadableStream<Uint8Array>;
71 | 
72 |   // Stdout is used to send messages to the client, so console.log/console.info
73 |   // messages to stderr so that they don't interfere with ACP.
74 |   console.log = console.error;
75 |   console.info = console.error;
76 |   console.debug = console.error;
77 | 
78 |   new acp.AgentSideConnection(
79 |     (client: acp.Client) =>
80 |       new GeminiAgent(config, settings, extensions, argv, client),
81 |     stdout,
82 |     stdin,
83 |   );
84 | }
85 | 
86 | class GeminiAgent {
87 |   private sessions: Map<string, Session> = new Map();
88 |   private clientCapabilities: acp.ClientCapabilities | undefined;
89 | 
90 |   constructor(
91 |     private config: Config,
92 |     private settings: LoadedSettings,
93 |     private extensions: GeminiCLIExtension[],
94 |     private argv: CliArgs,
95 |     private client: acp.Client,
96 |   ) {}
97 | 
98 |   async initialize(
99 |     args: acp.InitializeRequest,
100 |   ): Promise<acp.InitializeResponse> {
101 |     this.clientCapabilities = args.clientCapabilities;
102 |     const authMethods = [
103 |       {
104 |         id: AuthType.LOGIN_WITH_GOOGLE,
105 |         name: 'Log in with Google',
106 |         description: null,
107 |       },
108 |       {
109 |         id: AuthType.USE_GEMINI,
110 |         name: 'Use Gemini API key',
111 |         description:
112 |           'Requires setting the `GEMINI_API_KEY` environment variable',
113 |       },
114 |       {
115 |         id: AuthType.USE_VERTEX_AI,
116 |         name: 'Vertex AI',
117 |         description: null,
118 |       },
119 |     ];
120 | 
121 |     return {
122 |       protocolVersion: acp.PROTOCOL_VERSION,
123 |       authMethods,
124 |       agentCapabilities: {
125 |         loadSession: false,
126 |         promptCapabilities: {
127 |           image: true,
128 |           audio: true,
129 |           embeddedContext: true,
130 |         },
131 |       },
132 |     };
133 |   }
134 | 
135 |   async authenticate({ methodId }: acp.AuthenticateRequest): Promise<void> {
136 |     const method = z.nativeEnum(AuthType).parse(methodId);
137 | 
138 |     await clearCachedCredentialFile();
139 |     await this.config.refreshAuth(method);
140 |     this.settings.setValue(
141 |       SettingScope.User,
142 |       'security.auth.selectedType',
143 |       method,
144 |     );
145 |   }
146 | 
147 |   async newSession({
148 |     cwd,
149 |     mcpServers,
150 |   }: acp.NewSessionRequest): Promise<acp.NewSessionResponse> {
151 |     const sessionId = randomUUID();
152 |     const config = await this.newSessionConfig(sessionId, cwd, mcpServers);
153 | 
154 |     let isAuthenticated = false;
155 |     if (this.settings.merged.security?.auth?.selectedType) {
156 |       try {
157 |         await config.refreshAuth(
158 |           this.settings.merged.security.auth.selectedType,
159 |         );
160 |         isAuthenticated = true;
161 |       } catch (e) {
162 |         console.error(`Authentication failed: ${e}`);
163 |       }
164 |     }
165 | 
166 |     if (!isAuthenticated) {
167 |       throw acp.RequestError.authRequired();
168 |     }
169 | 
170 |     if (this.clientCapabilities?.fs) {
171 |       const acpFileSystemService = new AcpFileSystemService(
172 |         this.client,
173 |         sessionId,
174 |         this.clientCapabilities.fs,
175 |         config.getFileSystemService(),
176 |       );
177 |       config.setFileSystemService(acpFileSystemService);
178 |     }
179 | 
180 |     const geminiClient = config.getGeminiClient();
181 |     const chat = await geminiClient.startChat();
182 |     const session = new Session(sessionId, chat, config, this.client);
183 |     this.sessions.set(sessionId, session);
184 | 
185 |     return {
186 |       sessionId,
187 |     };
188 |   }
189 | 
190 |   async newSessionConfig(
191 |     sessionId: string,
192 |     cwd: string,
193 |     mcpServers: acp.McpServer[],
194 |   ): Promise<Config> {
195 |     const mergedMcpServers = { ...this.settings.merged.mcpServers };
196 | 
197 |     for (const { command, args, env: rawEnv, name } of mcpServers) {
198 |       const env: Record<string, string> = {};
199 |       for (const { name: envName, value } of rawEnv) {
200 |         env[envName] = value;
201 |       }
202 |       mergedMcpServers[name] = new MCPServerConfig(command, args, env, cwd);
203 |     }
204 | 
205 |     const settings = { ...this.settings.merged, mcpServers: mergedMcpServers };
206 | 
207 |     const config = await loadCliConfig(
208 |       settings,
209 |       this.extensions,
210 |       new ExtensionEnablementManager(
211 |         ExtensionStorage.getUserExtensionsDir(),
212 |         this.argv.extensions,
213 |       ),
214 |       sessionId,
215 |       this.argv,
216 |       cwd,
217 |     );
218 | 
219 |     await config.initialize();
220 |     return config;
221 |   }
222 | 
223 |   async cancel(params: acp.CancelNotification): Promise<void> {
224 |     const session = this.sessions.get(params.sessionId);
225 |     if (!session) {
226 |       throw new Error(`Session not found: ${params.sessionId}`);
227 |     }
228 |     await session.cancelPendingPrompt();
229 |   }
230 | 
231 |   async prompt(params: acp.PromptRequest): Promise<acp.PromptResponse> {
232 |     const session = this.sessions.get(params.sessionId);
233 |     if (!session) {
234 |       throw new Error(`Session not found: ${params.sessionId}`);
235 |     }
236 |     return session.prompt(params);
237 |   }
238 | }
239 | 
240 | class Session {
241 |   private pendingPrompt: AbortController | null = null;
242 | 
243 |   constructor(
244 |     private readonly id: string,
245 |     private readonly chat: GeminiChat,
246 |     private readonly config: Config,
247 |     private readonly client: acp.Client,
248 |   ) {}
249 | 
250 |   async cancelPendingPrompt(): Promise<void> {
251 |     if (!this.pendingPrompt) {
252 |       throw new Error('Not currently generating');
253 |     }
254 | 
255 |     this.pendingPrompt.abort();
256 |     this.pendingPrompt = null;
257 |   }
258 | 
259 |   async prompt(params: acp.PromptRequest): Promise<acp.PromptResponse> {
260 |     this.pendingPrompt?.abort();
261 |     const pendingSend = new AbortController();
262 |     this.pendingPrompt = pendingSend;
263 | 
264 |     const promptId = Math.random().toString(16).slice(2);
265 |     const chat = this.chat;
266 | 
267 |     const parts = await this.#resolvePrompt(params.prompt, pendingSend.signal);
268 | 
269 |     let nextMessage: Content | null = { role: 'user', parts };
270 | 
271 |     while (nextMessage !== null) {
272 |       if (pendingSend.signal.aborted) {
273 |         chat.addHistory(nextMessage);
274 |         return { stopReason: 'cancelled' };
275 |       }
276 | 
277 |       const functionCalls: FunctionCall[] = [];
278 | 
279 |       try {
280 |         const responseStream = await chat.sendMessageStream(
281 |           resolveModel(this.config.getModel(), this.config.isInFallbackMode()),
282 |           {
283 |             message: nextMessage?.parts ?? [],
284 |             config: {
285 |               abortSignal: pendingSend.signal,
286 |             },
287 |           },
288 |           promptId,
289 |         );
290 |         nextMessage = null;
291 | 
292 |         for await (const resp of responseStream) {
293 |           if (pendingSend.signal.aborted) {
294 |             return { stopReason: 'cancelled' };
295 |           }
296 | 
297 |           if (
298 |             resp.type === StreamEventType.CHUNK &&
299 |             resp.value.candidates &&
300 |             resp.value.candidates.length > 0
301 |           ) {
302 |             const candidate = resp.value.candidates[0];
303 |             for (const part of candidate.content?.parts ?? []) {
304 |               if (!part.text) {
305 |                 continue;
306 |               }
307 | 
308 |               const content: acp.ContentBlock = {
309 |                 type: 'text',
310 |                 text: part.text,
311 |               };
312 | 
313 |               this.sendUpdate({
314 |                 sessionUpdate: part.thought
315 |                   ? 'agent_thought_chunk'
316 |                   : 'agent_message_chunk',
317 |                 content,
318 |               });
319 |             }
320 |           }
321 | 
322 |           if (resp.type === StreamEventType.CHUNK && resp.value.functionCalls) {
323 |             functionCalls.push(...resp.value.functionCalls);
324 |           }
325 |         }
326 |       } catch (error) {
327 |         if (getErrorStatus(error) === 429) {
328 |           throw new acp.RequestError(
329 |             429,
330 |             'Rate limit exceeded. Try again later.',
331 |           );
332 |         }
333 | 
334 |         throw error;
335 |       }
336 | 
337 |       if (functionCalls.length > 0) {
338 |         const toolResponseParts: Part[] = [];
339 | 
340 |         for (const fc of functionCalls) {
341 |           const response = await this.runTool(pendingSend.signal, promptId, fc);
342 |           toolResponseParts.push(...response);
343 |         }
344 | 
345 |         nextMessage = { role: 'user', parts: toolResponseParts };
346 |       }
347 |     }
348 | 
349 |     return { stopReason: 'end_turn' };
350 |   }
351 | 
352 |   private async sendUpdate(update: acp.SessionUpdate): Promise<void> {
353 |     const params: acp.SessionNotification = {
354 |       sessionId: this.id,
355 |       update,
356 |     };
357 | 
358 |     await this.client.sessionUpdate(params);
359 |   }
360 | 
361 |   private async runTool(
362 |     abortSignal: AbortSignal,
363 |     promptId: string,
364 |     fc: FunctionCall,
365 |   ): Promise<Part[]> {
366 |     const callId = fc.id ?? `${fc.name}-${Date.now()}`;
367 |     const args = (fc.args ?? {}) as Record<string, unknown>;
368 | 
369 |     const startTime = Date.now();
370 | 
371 |     const errorResponse = (error: Error) => {
372 |       const durationMs = Date.now() - startTime;
373 |       logToolCall(
374 |         this.config,
375 |         new ToolCallEvent(
376 |           undefined,
377 |           fc.name ?? '',
378 |           args,
379 |           durationMs,
380 |           false,
381 |           promptId,
382 |           typeof tool !== 'undefined' && tool instanceof DiscoveredMCPTool
383 |             ? 'mcp'
384 |             : 'native',
385 |           error.message,
386 |         ),
387 |       );
388 | 
389 |       return [
390 |         {
391 |           functionResponse: {
392 |             id: callId,
393 |             name: fc.name ?? '',
394 |             response: { error: error.message },
395 |           },
396 |         },
397 |       ];
398 |     };
399 | 
400 |     if (!fc.name) {
401 |       return errorResponse(new Error('Missing function name'));
402 |     }
403 | 
404 |     const toolRegistry = this.config.getToolRegistry();
405 |     const tool = toolRegistry.getTool(fc.name as string);
406 | 
407 |     if (!tool) {
408 |       return errorResponse(
[TRUNCATED]
```

src/commands/extensions/disable.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { type CommandModule } from 'yargs';
8 | import { disableExtension } from '../../config/extension.js';
9 | import { SettingScope } from '../../config/settings.js';
10 | import { getErrorMessage } from '../../utils/errors.js';
11 | 
12 | interface DisableArgs {
13 |   name: string;
14 |   scope?: string;
15 | }
16 | 
17 | export function handleDisable(args: DisableArgs) {
18 |   try {
19 |     if (args.scope?.toLowerCase() === 'workspace') {
20 |       disableExtension(args.name, SettingScope.Workspace);
21 |     } else {
22 |       disableExtension(args.name, SettingScope.User);
23 |     }
24 |     console.log(
25 |       `Extension "${args.name}" successfully disabled for scope "${args.scope}".`,
26 |     );
27 |   } catch (error) {
28 |     console.error(getErrorMessage(error));
29 |     process.exit(1);
30 |   }
31 | }
32 | 
33 | export const disableCommand: CommandModule = {
34 |   command: 'disable [--scope] <name>',
35 |   describe: 'Disables an extension.',
36 |   builder: (yargs) =>
37 |     yargs
38 |       .positional('name', {
39 |         describe: 'The name of the extension to disable.',
40 |         type: 'string',
41 |       })
42 |       .option('scope', {
43 |         describe: 'The scope to disable the extenison in.',
44 |         type: 'string',
45 |         default: SettingScope.User,
46 |       })
47 |       .check((argv) => {
48 |         if (
49 |           argv.scope &&
50 |           !Object.values(SettingScope)
51 |             .map((s) => s.toLowerCase())
52 |             .includes((argv.scope as string).toLowerCase())
53 |         ) {
54 |           throw new Error(
55 |             `Invalid scope: ${argv.scope}. Please use one of ${Object.values(
56 |               SettingScope,
57 |             )
58 |               .map((s) => s.toLowerCase())
59 |               .join(', ')}.`,
60 |           );
61 |         }
62 |         return true;
63 |       }),
64 |   handler: (argv) => {
65 |     handleDisable({
66 |       name: argv['name'] as string,
67 |       scope: argv['scope'] as string,
68 |     });
69 |   },
70 | };
```

src/commands/extensions/enable.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { type CommandModule } from 'yargs';
8 | import { FatalConfigError, getErrorMessage } from '@google/gemini-cli-core';
9 | import { enableExtension } from '../../config/extension.js';
10 | import { SettingScope } from '../../config/settings.js';
11 | 
12 | interface EnableArgs {
13 |   name: string;
14 |   scope?: string;
15 | }
16 | 
17 | export function handleEnable(args: EnableArgs) {
18 |   try {
19 |     if (args.scope?.toLowerCase() === 'workspace') {
20 |       enableExtension(args.name, SettingScope.Workspace);
21 |     } else {
22 |       enableExtension(args.name, SettingScope.User);
23 |     }
24 |     if (args.scope) {
25 |       console.log(
26 |         `Extension "${args.name}" successfully enabled for scope "${args.scope}".`,
27 |       );
28 |     } else {
29 |       console.log(
30 |         `Extension "${args.name}" successfully enabled in all scopes.`,
31 |       );
32 |     }
33 |   } catch (error) {
34 |     throw new FatalConfigError(getErrorMessage(error));
35 |   }
36 | }
37 | 
38 | export const enableCommand: CommandModule = {
39 |   command: 'enable [--scope] <name>',
40 |   describe: 'Enables an extension.',
41 |   builder: (yargs) =>
42 |     yargs
43 |       .positional('name', {
44 |         describe: 'The name of the extension to enable.',
45 |         type: 'string',
46 |       })
47 |       .option('scope', {
48 |         describe:
49 |           'The scope to enable the extenison in. If not set, will be enabled in all scopes.',
50 |         type: 'string',
51 |       })
52 |       .check((argv) => {
53 |         if (
54 |           argv.scope &&
55 |           !Object.values(SettingScope)
56 |             .map((s) => s.toLowerCase())
57 |             .includes((argv.scope as string).toLowerCase())
58 |         ) {
59 |           throw new Error(
60 |             `Invalid scope: ${argv.scope}. Please use one of ${Object.values(
61 |               SettingScope,
62 |             )
63 |               .map((s) => s.toLowerCase())
64 |               .join(', ')}.`,
65 |           );
66 |         }
67 |         return true;
68 |       }),
69 |   handler: (argv) => {
70 |     handleEnable({
71 |       name: argv['name'] as string,
72 |       scope: argv['scope'] as string,
73 |     });
74 |   },
75 | };
```

src/commands/extensions/install.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect, vi, type MockInstance } from 'vitest';
8 | import { handleInstall, installCommand } from './install.js';
9 | import yargs from 'yargs';
10 | 
11 | const mockInstallOrUpdateExtension = vi.hoisted(() => vi.fn());
12 | const mockRequestConsentNonInteractive = vi.hoisted(() => vi.fn());
13 | const mockStat = vi.hoisted(() => vi.fn());
14 | 
15 | vi.mock('../../config/extension.js', () => ({
16 |   installOrUpdateExtension: mockInstallOrUpdateExtension,
17 |   requestConsentNonInteractive: mockRequestConsentNonInteractive,
18 | }));
19 | 
20 | vi.mock('../../utils/errors.js', () => ({
21 |   getErrorMessage: vi.fn((error: Error) => error.message),
22 | }));
23 | 
24 | vi.mock('node:fs/promises', () => ({
25 |   stat: mockStat,
26 |   default: {
27 |     stat: mockStat,
28 |   },
29 | }));
30 | 
31 | describe('extensions install command', () => {
32 |   it('should fail if no source is provided', () => {
33 |     const validationParser = yargs([]).command(installCommand).fail(false);
34 |     expect(() => validationParser.parse('install')).toThrow(
35 |       'Not enough non-option arguments: got 0, need at least 1',
36 |     );
37 |   });
38 | });
39 | 
40 | describe('handleInstall', () => {
41 |   let consoleLogSpy: MockInstance;
42 |   let consoleErrorSpy: MockInstance;
43 |   let processSpy: MockInstance;
44 | 
45 |   beforeEach(() => {
46 |     consoleLogSpy = vi.spyOn(console, 'log');
47 |     consoleErrorSpy = vi.spyOn(console, 'error');
48 |     processSpy = vi
49 |       .spyOn(process, 'exit')
50 |       .mockImplementation(() => undefined as never);
51 |   });
52 | 
53 |   afterEach(() => {
54 |     mockInstallOrUpdateExtension.mockClear();
55 |     mockRequestConsentNonInteractive.mockClear();
56 |     mockStat.mockClear();
57 |     vi.resetAllMocks();
58 |   });
59 | 
60 |   it('should install an extension from a http source', async () => {
61 |     mockInstallOrUpdateExtension.mockResolvedValue('http-extension');
62 | 
63 |     await handleInstall({
64 |       source: 'http://google.com',
65 |     });
66 | 
67 |     expect(consoleLogSpy).toHaveBeenCalledWith(
68 |       'Extension "http-extension" installed successfully and enabled.',
69 |     );
70 |   });
71 | 
72 |   it('should install an extension from a https source', async () => {
73 |     mockInstallOrUpdateExtension.mockResolvedValue('https-extension');
74 | 
75 |     await handleInstall({
76 |       source: 'https://google.com',
77 |     });
78 | 
79 |     expect(consoleLogSpy).toHaveBeenCalledWith(
80 |       'Extension "https-extension" installed successfully and enabled.',
81 |     );
82 |   });
83 | 
84 |   it('should install an extension from a git source', async () => {
85 |     mockInstallOrUpdateExtension.mockResolvedValue('git-extension');
86 | 
87 |     await handleInstall({
88 |       source: 'git@some-url',
89 |     });
90 | 
91 |     expect(consoleLogSpy).toHaveBeenCalledWith(
92 |       'Extension "git-extension" installed successfully and enabled.',
93 |     );
94 |   });
95 | 
96 |   it('throws an error from an unknown source', async () => {
97 |     mockStat.mockRejectedValue(new Error('ENOENT: no such file or directory'));
98 |     await handleInstall({
99 |       source: 'test://google.com',
100 |     });
101 | 
102 |     expect(consoleErrorSpy).toHaveBeenCalledWith('Install source not found.');
103 |     expect(processSpy).toHaveBeenCalledWith(1);
104 |   });
105 | 
106 |   it('should install an extension from a sso source', async () => {
107 |     mockInstallOrUpdateExtension.mockResolvedValue('sso-extension');
108 | 
109 |     await handleInstall({
110 |       source: 'sso://google.com',
111 |     });
112 | 
113 |     expect(consoleLogSpy).toHaveBeenCalledWith(
114 |       'Extension "sso-extension" installed successfully and enabled.',
115 |     );
116 |   });
117 | 
118 |   it('should install an extension from a local path', async () => {
119 |     mockInstallOrUpdateExtension.mockResolvedValue('local-extension');
120 |     mockStat.mockResolvedValue({});
121 |     await handleInstall({
122 |       source: '/some/path',
123 |     });
124 | 
125 |     expect(consoleLogSpy).toHaveBeenCalledWith(
126 |       'Extension "local-extension" installed successfully and enabled.',
127 |     );
128 |   });
129 | 
130 |   it('should throw an error if install extension fails', async () => {
131 |     mockInstallOrUpdateExtension.mockRejectedValue(
132 |       new Error('Install extension failed'),
133 |     );
134 | 
135 |     await handleInstall({ source: 'git@some-url' });
136 | 
137 |     expect(consoleErrorSpy).toHaveBeenCalledWith('Install extension failed');
138 |     expect(processSpy).toHaveBeenCalledWith(1);
139 |   });
140 | });
```

src/commands/extensions/install.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type { CommandModule } from 'yargs';
8 | import {
9 |   installOrUpdateExtension,
10 |   requestConsentNonInteractive,
11 | } from '../../config/extension.js';
12 | import type { ExtensionInstallMetadata } from '@google/gemini-cli-core';
13 | import { getErrorMessage } from '../../utils/errors.js';
14 | import { stat } from 'node:fs/promises';
15 | 
16 | interface InstallArgs {
17 |   source: string;
18 |   ref?: string;
19 |   autoUpdate?: boolean;
20 |   allowPreRelease?: boolean;
21 | }
22 | 
23 | export async function handleInstall(args: InstallArgs) {
24 |   try {
25 |     let installMetadata: ExtensionInstallMetadata;
26 |     const { source } = args;
27 |     if (
28 |       source.startsWith('http://') ||
29 |       source.startsWith('https://') ||
30 |       source.startsWith('git@') ||
31 |       source.startsWith('sso://')
32 |     ) {
33 |       installMetadata = {
34 |         source,
35 |         type: 'git',
36 |         ref: args.ref,
37 |         autoUpdate: args.autoUpdate,
38 |         allowPreRelease: args.allowPreRelease,
39 |       };
40 |     } else {
41 |       if (args.ref || args.autoUpdate) {
42 |         throw new Error(
43 |           '--ref and --auto-update are not applicable for local extensions.',
44 |         );
45 |       }
46 |       try {
47 |         await stat(source);
48 |         installMetadata = {
49 |           source,
50 |           type: 'local',
51 |         };
52 |       } catch {
53 |         throw new Error('Install source not found.');
54 |       }
55 |     }
56 | 
57 |     const name = await installOrUpdateExtension(
58 |       installMetadata,
59 |       requestConsentNonInteractive,
60 |     );
61 |     console.log(`Extension "${name}" installed successfully and enabled.`);
62 |   } catch (error) {
63 |     console.error(getErrorMessage(error));
64 |     process.exit(1);
65 |   }
66 | }
67 | 
68 | export const installCommand: CommandModule = {
69 |   command: 'install <source> [--auto-update] [--pre-release]',
70 |   describe: 'Installs an extension from a git repository URL or a local path.',
71 |   builder: (yargs) =>
72 |     yargs
73 |       .positional('source', {
74 |         describe: 'The github URL or local path of the extension to install.',
75 |         type: 'string',
76 |         demandOption: true,
77 |       })
78 |       .option('ref', {
79 |         describe: 'The git ref to install from.',
80 |         type: 'string',
81 |       })
82 |       .option('auto-update', {
83 |         describe: 'Enable auto-update for this extension.',
84 |         type: 'boolean',
85 |       })
86 |       .option('pre-release', {
87 |         describe: 'Enable pre-release versions for this extension.',
88 |         type: 'boolean',
89 |       })
90 |       .check((argv) => {
91 |         if (!argv.source) {
92 |           throw new Error('The source argument must be provided.');
93 |         }
94 |         return true;
95 |       }),
96 |   handler: async (argv) => {
97 |     await handleInstall({
98 |       source: argv['source'] as string,
99 |       ref: argv['ref'] as string | undefined,
100 |       autoUpdate: argv['auto-update'] as boolean | undefined,
101 |       allowPreRelease: argv['pre-release'] as boolean | undefined,
102 |     });
103 |   },
104 | };
```

src/commands/extensions/link.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type { CommandModule } from 'yargs';
8 | import {
9 |   installOrUpdateExtension,
10 |   requestConsentNonInteractive,
11 | } from '../../config/extension.js';
12 | import type { ExtensionInstallMetadata } from '@google/gemini-cli-core';
13 | 
14 | import { getErrorMessage } from '../../utils/errors.js';
15 | 
16 | interface InstallArgs {
17 |   path: string;
18 | }
19 | 
20 | export async function handleLink(args: InstallArgs) {
21 |   try {
22 |     const installMetadata: ExtensionInstallMetadata = {
23 |       source: args.path,
24 |       type: 'link',
25 |     };
26 |     const extensionName = await installOrUpdateExtension(
27 |       installMetadata,
28 |       requestConsentNonInteractive,
29 |     );
30 |     console.log(
31 |       `Extension "${extensionName}" linked successfully and enabled.`,
32 |     );
33 |   } catch (error) {
34 |     console.error(getErrorMessage(error));
35 |     process.exit(1);
36 |   }
37 | }
38 | 
39 | export const linkCommand: CommandModule = {
40 |   command: 'link <path>',
41 |   describe:
42 |     'Links an extension from a local path. Updates made to the local path will always be reflected.',
43 |   builder: (yargs) =>
44 |     yargs
45 |       .positional('path', {
46 |         describe: 'The name of the extension to link.',
47 |         type: 'string',
48 |       })
49 |       .check((_) => true),
50 |   handler: async (argv) => {
51 |     await handleLink({
52 |       path: argv['path'] as string,
53 |     });
54 |   },
55 | };
```

src/commands/extensions/list.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type { CommandModule } from 'yargs';
8 | import { loadUserExtensions, toOutputString } from '../../config/extension.js';
9 | import { getErrorMessage } from '../../utils/errors.js';
10 | 
11 | export async function handleList() {
12 |   try {
13 |     const extensions = loadUserExtensions();
14 |     if (extensions.length === 0) {
15 |       console.log('No extensions installed.');
16 |       return;
17 |     }
18 |     console.log(
19 |       extensions
20 |         .map((extension, _): string => toOutputString(extension, process.cwd()))
21 |         .join('\n\n'),
22 |     );
23 |   } catch (error) {
24 |     console.error(getErrorMessage(error));
25 |     process.exit(1);
26 |   }
27 | }
28 | 
29 | export const listCommand: CommandModule = {
30 |   command: 'list',
31 |   describe: 'Lists installed extensions.',
32 |   builder: (yargs) => yargs,
33 |   handler: async () => {
34 |     await handleList();
35 |   },
36 | };
```

src/commands/extensions/new.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect, vi, beforeEach } from 'vitest';
8 | import { newCommand } from './new.js';
9 | import yargs from 'yargs';
10 | import * as fsPromises from 'node:fs/promises';
11 | import path from 'node:path';
12 | 
13 | vi.mock('node:fs/promises');
14 | 
15 | const mockedFs = vi.mocked(fsPromises);
16 | 
17 | describe('extensions new command', () => {
18 |   beforeEach(() => {
19 |     vi.resetAllMocks();
20 | 
21 |     const fakeFiles = [
22 |       { name: 'context', isDirectory: () => true },
23 |       { name: 'custom-commands', isDirectory: () => true },
24 |       { name: 'mcp-server', isDirectory: () => true },
25 |     ];
26 |     // eslint-disable-next-line @typescript-eslint/no-explicit-any
27 |     mockedFs.readdir.mockResolvedValue(fakeFiles as any);
28 |   });
29 | 
30 |   it('should fail if no path is provided', async () => {
31 |     const parser = yargs([]).command(newCommand).fail(false).locale('en');
32 |     await expect(parser.parseAsync('new')).rejects.toThrow(
33 |       'Not enough non-option arguments: got 0, need at least 1',
34 |     );
35 |   });
36 | 
37 |   it('should create directory when no template is provided', async () => {
38 |     mockedFs.access.mockRejectedValue(new Error('ENOENT'));
39 |     mockedFs.mkdir.mockResolvedValue(undefined);
40 | 
41 |     const parser = yargs([]).command(newCommand).fail(false);
42 | 
43 |     await parser.parseAsync('new /some/path');
44 | 
45 |     expect(mockedFs.mkdir).toHaveBeenCalledWith('/some/path', {
46 |       recursive: true,
47 |     });
48 |     expect(mockedFs.cp).not.toHaveBeenCalled();
49 |   });
50 | 
51 |   it('should create directory and copy files when path does not exist', async () => {
52 |     mockedFs.access.mockRejectedValue(new Error('ENOENT'));
53 |     mockedFs.mkdir.mockResolvedValue(undefined);
54 |     mockedFs.cp.mockResolvedValue(undefined);
55 | 
56 |     const parser = yargs([]).command(newCommand).fail(false);
57 | 
58 |     await parser.parseAsync('new /some/path context');
59 | 
60 |     expect(mockedFs.mkdir).toHaveBeenCalledWith('/some/path', {
61 |       recursive: true,
62 |     });
63 |     expect(mockedFs.cp).toHaveBeenCalledWith(
64 |       expect.stringContaining(path.normalize('context/context')),
65 |       path.normalize('/some/path/context'),
66 |       { recursive: true },
67 |     );
68 |     expect(mockedFs.cp).toHaveBeenCalledWith(
69 |       expect.stringContaining(path.normalize('context/custom-commands')),
70 |       path.normalize('/some/path/custom-commands'),
71 |       { recursive: true },
72 |     );
73 |     expect(mockedFs.cp).toHaveBeenCalledWith(
74 |       expect.stringContaining(path.normalize('context/mcp-server')),
75 |       path.normalize('/some/path/mcp-server'),
76 |       { recursive: true },
77 |     );
78 |   });
79 | 
80 |   it('should throw an error if the path already exists', async () => {
81 |     mockedFs.access.mockResolvedValue(undefined);
82 |     const parser = yargs([]).command(newCommand).fail(false);
83 | 
84 |     await expect(parser.parseAsync('new /some/path context')).rejects.toThrow(
85 |       'Path already exists: /some/path',
86 |     );
87 | 
88 |     expect(mockedFs.mkdir).not.toHaveBeenCalled();
89 |     expect(mockedFs.cp).not.toHaveBeenCalled();
90 |   });
91 | });
```

src/commands/extensions/new.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { access, cp, mkdir, readdir, writeFile } from 'node:fs/promises';
8 | import { join, dirname, basename } from 'node:path';
9 | import type { CommandModule } from 'yargs';
10 | import { fileURLToPath } from 'node:url';
11 | import { getErrorMessage } from '../../utils/errors.js';
12 | 
13 | interface NewArgs {
14 |   path: string;
15 |   template?: string;
16 | }
17 | 
18 | const __filename = fileURLToPath(import.meta.url);
19 | const __dirname = dirname(__filename);
20 | 
21 | const EXAMPLES_PATH = join(__dirname, 'examples');
22 | 
23 | async function pathExists(path: string) {
24 |   try {
25 |     await access(path);
26 |     return true;
27 |   } catch (_e) {
28 |     return false;
29 |   }
30 | }
31 | 
32 | async function createDirectory(path: string) {
33 |   if (await pathExists(path)) {
34 |     throw new Error(`Path already exists: ${path}`);
35 |   }
36 |   await mkdir(path, { recursive: true });
37 | }
38 | 
39 | async function copyDirectory(template: string, path: string) {
40 |   await createDirectory(path);
41 | 
42 |   const examplePath = join(EXAMPLES_PATH, template);
43 |   const entries = await readdir(examplePath, { withFileTypes: true });
44 |   for (const entry of entries) {
45 |     const srcPath = join(examplePath, entry.name);
46 |     const destPath = join(path, entry.name);
47 |     await cp(srcPath, destPath, { recursive: true });
48 |   }
49 | }
50 | 
51 | async function handleNew(args: NewArgs) {
52 |   try {
53 |     if (args.template) {
54 |       await copyDirectory(args.template, args.path);
55 |       console.log(
56 |         `Successfully created new extension from template "${args.template}" at ${args.path}.`,
57 |       );
58 |     } else {
59 |       await createDirectory(args.path);
60 |       const extensionName = basename(args.path);
61 |       const manifest = {
62 |         name: extensionName,
63 |         version: '1.0.0',
64 |       };
65 |       await writeFile(
66 |         join(args.path, 'gemini-extension.json'),
67 |         JSON.stringify(manifest, null, 2),
68 |       );
69 |       console.log(`Successfully created new extension at ${args.path}.`);
70 |     }
71 |     console.log(
72 |       `You can install this using "gemini extensions link ${args.path}" to test it out.`,
73 |     );
74 |   } catch (error) {
75 |     console.error(getErrorMessage(error));
76 |     throw error;
77 |   }
78 | }
79 | 
80 | async function getBoilerplateChoices() {
81 |   const entries = await readdir(EXAMPLES_PATH, { withFileTypes: true });
82 |   return entries
83 |     .filter((entry) => entry.isDirectory())
84 |     .map((entry) => entry.name);
85 | }
86 | 
87 | export const newCommand: CommandModule = {
88 |   command: 'new <path> [template]',
89 |   describe: 'Create a new extension from a boilerplate example.',
90 |   builder: async (yargs) => {
91 |     const choices = await getBoilerplateChoices();
92 |     return yargs
93 |       .positional('path', {
94 |         describe: 'The path to create the extension in.',
95 |         type: 'string',
96 |       })
97 |       .positional('template', {
98 |         describe: 'The boilerplate template to use.',
99 |         type: 'string',
100 |         choices,
101 |       });
102 |   },
103 |   handler: async (args) => {
104 |     await handleNew({
105 |       path: args['path'] as string,
106 |       template: args['template'] as string | undefined,
107 |     });
108 |   },
109 | };
```

src/commands/extensions/uninstall.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect } from 'vitest';
8 | import { uninstallCommand } from './uninstall.js';
9 | import yargs from 'yargs';
10 | 
11 | describe('extensions uninstall command', () => {
12 |   it('should fail if no source is provided', () => {
13 |     const validationParser = yargs([])
14 |       .command(uninstallCommand)
15 |       .fail(false)
16 |       .locale('en');
17 |     expect(() => validationParser.parse('uninstall')).toThrow(
18 |       'Not enough non-option arguments: got 0, need at least 1',
19 |     );
20 |   });
21 | });
```

src/commands/extensions/uninstall.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type { CommandModule } from 'yargs';
8 | import { uninstallExtension } from '../../config/extension.js';
9 | import { getErrorMessage } from '../../utils/errors.js';
10 | 
11 | interface UninstallArgs {
12 |   name: string; // can be extension name or source URL.
13 | }
14 | 
15 | export async function handleUninstall(args: UninstallArgs) {
16 |   try {
17 |     await uninstallExtension(args.name, false);
18 |     console.log(`Extension "${args.name}" successfully uninstalled.`);
19 |   } catch (error) {
20 |     console.error(getErrorMessage(error));
21 |     process.exit(1);
22 |   }
23 | }
24 | 
25 | export const uninstallCommand: CommandModule = {
26 |   command: 'uninstall <name>',
27 |   describe: 'Uninstalls an extension.',
28 |   builder: (yargs) =>
29 |     yargs
30 |       .positional('name', {
31 |         describe: 'The name or source path of the extension to uninstall.',
32 |         type: 'string',
33 |       })
34 |       .check((argv) => {
35 |         if (!argv.name) {
36 |           throw new Error(
37 |             'Please include the name of the extension to uninstall as a positional argument.',
38 |           );
39 |         }
40 |         return true;
41 |       }),
42 |   handler: async (argv) => {
43 |     await handleUninstall({
44 |       name: argv['name'] as string,
45 |     });
46 |   },
47 | };
```

src/commands/extensions/update.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type { CommandModule } from 'yargs';
8 | import {
9 |   loadExtensions,
10 |   annotateActiveExtensions,
11 |   ExtensionStorage,
12 |   requestConsentNonInteractive,
13 | } from '../../config/extension.js';
14 | import {
15 |   updateAllUpdatableExtensions,
16 |   type ExtensionUpdateInfo,
17 |   checkForAllExtensionUpdates,
18 |   updateExtension,
19 | } from '../../config/extensions/update.js';
20 | import { checkForExtensionUpdate } from '../../config/extensions/github.js';
21 | import { getErrorMessage } from '../../utils/errors.js';
22 | import { ExtensionUpdateState } from '../../ui/state/extensions.js';
23 | import { ExtensionEnablementManager } from '../../config/extensions/extensionEnablement.js';
24 | 
25 | interface UpdateArgs {
26 |   name?: string;
27 |   all?: boolean;
28 | }
29 | 
30 | const updateOutput = (info: ExtensionUpdateInfo) =>
31 |   `Extension "${info.name}" successfully updated: ${info.originalVersion} → ${info.updatedVersion}.`;
32 | 
33 | export async function handleUpdate(args: UpdateArgs) {
34 |   const workingDir = process.cwd();
35 |   const extensionEnablementManager = new ExtensionEnablementManager(
36 |     ExtensionStorage.getUserExtensionsDir(),
37 |     // Force enable named extensions, otherwise we will only update the enabled
38 |     // ones.
39 |     args.name ? [args.name] : [],
40 |   );
41 |   const allExtensions = loadExtensions(extensionEnablementManager);
42 |   const extensions = annotateActiveExtensions(
43 |     allExtensions,
44 |     workingDir,
45 |     extensionEnablementManager,
46 |   );
47 |   if (args.name) {
48 |     try {
49 |       const extension = extensions.find(
50 |         (extension) => extension.name === args.name,
51 |       );
52 |       if (!extension) {
53 |         console.log(`Extension "${args.name}" not found.`);
54 |         return;
55 |       }
56 |       if (!extension.installMetadata) {
57 |         console.log(
58 |           `Unable to install extension "${args.name}" due to missing install metadata`,
59 |         );
60 |         return;
61 |       }
62 |       const updateState = await checkForExtensionUpdate(extension);
63 |       if (updateState !== ExtensionUpdateState.UPDATE_AVAILABLE) {
64 |         console.log(`Extension "${args.name}" is already up to date.`);
65 |         return;
66 |       }
67 |       // TODO(chrstnb): we should list extensions if the requested extension is not installed.
68 |       const updatedExtensionInfo = (await updateExtension(
69 |         extension,
70 |         workingDir,
71 |         requestConsentNonInteractive,
72 |         updateState,
73 |         () => {},
74 |       ))!;
75 |       if (
76 |         updatedExtensionInfo.originalVersion !==
77 |         updatedExtensionInfo.updatedVersion
78 |       ) {
79 |         console.log(
80 |           `Extension "${args.name}" successfully updated: ${updatedExtensionInfo.originalVersion} → ${updatedExtensionInfo.updatedVersion}.`,
81 |         );
82 |       } else {
83 |         console.log(`Extension "${args.name}" is already up to date.`);
84 |       }
85 |     } catch (error) {
86 |       console.error(getErrorMessage(error));
87 |     }
88 |   }
89 |   if (args.all) {
90 |     try {
91 |       const extensionState = new Map();
92 |       await checkForAllExtensionUpdates(
93 |         extensions,
94 |         (action) => {
95 |           if (action.type === 'SET_STATE') {
96 |             extensionState.set(action.payload.name, {
97 |               status: action.payload.state,
98 |             });
99 |           }
100 |         },
101 |         workingDir,
102 |       );
103 |       let updateInfos = await updateAllUpdatableExtensions(
104 |         workingDir,
105 |         requestConsentNonInteractive,
106 |         extensions,
107 |         extensionState,
108 |         () => {},
109 |       );
110 |       updateInfos = updateInfos.filter(
111 |         (info) => info.originalVersion !== info.updatedVersion,
112 |       );
113 |       if (updateInfos.length === 0) {
114 |         console.log('No extensions to update.');
115 |         return;
116 |       }
117 |       console.log(updateInfos.map((info) => updateOutput(info)).join('\n'));
118 |     } catch (error) {
119 |       console.error(getErrorMessage(error));
120 |     }
121 |   }
122 | }
123 | 
124 | export const updateCommand: CommandModule = {
125 |   command: 'update [<name>] [--all]',
126 |   describe:
127 |     'Updates all extensions or a named extension to the latest version.',
128 |   builder: (yargs) =>
129 |     yargs
130 |       .positional('name', {
131 |         describe: 'The name of the extension to update.',
132 |         type: 'string',
133 |       })
134 |       .option('all', {
135 |         describe: 'Update all extensions.',
136 |         type: 'boolean',
137 |       })
138 |       .conflicts('name', 'all')
139 |       .check((argv) => {
140 |         if (!argv.all && !argv.name) {
141 |           throw new Error('Either an extension name or --all must be provided');
142 |         }
143 |         return true;
144 |       }),
145 |   handler: async (argv) => {
146 |     await handleUpdate({
147 |       name: argv['name'] as string | undefined,
148 |       all: argv['all'] as boolean | undefined,
149 |     });
150 |   },
151 | };
```

src/commands/mcp/add.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import yargs from 'yargs';
8 | import { addCommand } from './add.js';
9 | import { loadSettings, SettingScope } from '../../config/settings.js';
10 | 
11 | vi.mock('fs/promises', () => ({
12 |   readFile: vi.fn(),
13 |   writeFile: vi.fn(),
14 | }));
15 | 
16 | vi.mock('os', () => {
17 |   const homedir = vi.fn(() => '/home/user');
18 |   return {
19 |     default: {
20 |       homedir,
21 |     },
22 |     homedir,
23 |   };
24 | });
25 | 
26 | vi.mock('../../config/settings.js', async () => {
27 |   const actual = await vi.importActual('../../config/settings.js');
28 |   return {
29 |     ...actual,
30 |     loadSettings: vi.fn(),
31 |   };
32 | });
33 | 
34 | const mockedLoadSettings = loadSettings as vi.Mock;
35 | 
36 | describe('mcp add command', () => {
37 |   let parser: yargs.Argv;
38 |   let mockSetValue: vi.Mock;
39 |   let mockConsoleError: vi.Mock;
40 | 
41 |   beforeEach(() => {
42 |     vi.resetAllMocks();
43 |     const yargsInstance = yargs([]).command(addCommand);
44 |     parser = yargsInstance;
45 |     mockSetValue = vi.fn();
46 |     mockConsoleError = vi.fn();
47 |     vi.spyOn(console, 'error').mockImplementation(mockConsoleError);
48 |     mockedLoadSettings.mockReturnValue({
49 |       forScope: () => ({ settings: {} }),
50 |       setValue: mockSetValue,
51 |       workspace: { path: '/path/to/project' },
52 |       user: { path: '/home/user' },
53 |     });
54 |   });
55 | 
56 |   it('should add a stdio server to project settings', async () => {
57 |     await parser.parseAsync(
58 |       'add my-server /path/to/server arg1 arg2 -e FOO=bar',
59 |     );
60 | 
61 |     expect(mockSetValue).toHaveBeenCalledWith(
62 |       SettingScope.Workspace,
63 |       'mcpServers',
64 |       {
65 |         'my-server': {
66 |           command: '/path/to/server',
67 |           args: ['arg1', 'arg2'],
68 |           env: { FOO: 'bar' },
69 |         },
70 |       },
71 |     );
72 |   });
73 | 
74 |   it('should add an sse server to user settings', async () => {
75 |     await parser.parseAsync(
76 |       'add --transport sse sse-server https://example.com/sse-endpoint --scope user -H "X-API-Key: your-key"',
77 |     );
78 | 
79 |     expect(mockSetValue).toHaveBeenCalledWith(SettingScope.User, 'mcpServers', {
80 |       'sse-server': {
81 |         url: 'https://example.com/sse-endpoint',
82 |         headers: { 'X-API-Key': 'your-key' },
83 |       },
84 |     });
85 |   });
86 | 
87 |   it('should add an http server to project settings', async () => {
88 |     await parser.parseAsync(
89 |       'add --transport http http-server https://example.com/mcp -H "Authorization: Bearer your-token"',
90 |     );
91 | 
92 |     expect(mockSetValue).toHaveBeenCalledWith(
93 |       SettingScope.Workspace,
94 |       'mcpServers',
95 |       {
96 |         'http-server': {
97 |           httpUrl: 'https://example.com/mcp',
98 |           headers: { Authorization: 'Bearer your-token' },
99 |         },
100 |       },
101 |     );
102 |   });
103 | 
104 |   it('should handle MCP server args with -- separator', async () => {
105 |     await parser.parseAsync(
106 |       'add my-server npx -- -y http://example.com/some-package',
107 |     );
108 | 
109 |     expect(mockSetValue).toHaveBeenCalledWith(
110 |       SettingScope.Workspace,
111 |       'mcpServers',
112 |       {
113 |         'my-server': {
114 |           command: 'npx',
115 |           args: ['-y', 'http://example.com/some-package'],
116 |         },
117 |       },
118 |     );
119 |   });
120 | 
121 |   it('should handle unknown options as MCP server args', async () => {
122 |     await parser.parseAsync(
123 |       'add test-server npx -y http://example.com/some-package',
124 |     );
125 | 
126 |     expect(mockSetValue).toHaveBeenCalledWith(
127 |       SettingScope.Workspace,
128 |       'mcpServers',
129 |       {
130 |         'test-server': {
131 |           command: 'npx',
132 |           args: ['-y', 'http://example.com/some-package'],
133 |         },
134 |       },
135 |     );
136 |   });
137 | 
138 |   describe('when handling scope and directory', () => {
139 |     const serverName = 'test-server';
140 |     const command = 'echo';
141 | 
142 |     const setupMocks = (cwd: string, workspacePath: string) => {
143 |       vi.spyOn(process, 'cwd').mockReturnValue(cwd);
144 |       mockedLoadSettings.mockReturnValue({
145 |         forScope: () => ({ settings: {} }),
146 |         setValue: mockSetValue,
147 |         workspace: { path: workspacePath },
148 |         user: { path: '/home/user' },
149 |       });
150 |     };
151 | 
152 |     describe('when in a project directory', () => {
153 |       beforeEach(() => {
154 |         setupMocks('/path/to/project', '/path/to/project');
155 |       });
156 | 
157 |       it('should use project scope by default', async () => {
158 |         await parser.parseAsync(`add ${serverName} ${command}`);
159 |         expect(mockSetValue).toHaveBeenCalledWith(
160 |           SettingScope.Workspace,
161 |           'mcpServers',
162 |           expect.any(Object),
163 |         );
164 |       });
165 | 
166 |       it('should use project scope when --scope=project is used', async () => {
167 |         await parser.parseAsync(`add --scope project ${serverName} ${command}`);
168 |         expect(mockSetValue).toHaveBeenCalledWith(
169 |           SettingScope.Workspace,
170 |           'mcpServers',
171 |           expect.any(Object),
172 |         );
173 |       });
174 | 
175 |       it('should use user scope when --scope=user is used', async () => {
176 |         await parser.parseAsync(`add --scope user ${serverName} ${command}`);
177 |         expect(mockSetValue).toHaveBeenCalledWith(
178 |           SettingScope.User,
179 |           'mcpServers',
180 |           expect.any(Object),
181 |         );
182 |       });
183 |     });
184 | 
185 |     describe('when in a subdirectory of a project', () => {
186 |       beforeEach(() => {
187 |         setupMocks('/path/to/project/subdir', '/path/to/project');
188 |       });
189 | 
190 |       it('should use project scope by default', async () => {
191 |         await parser.parseAsync(`add ${serverName} ${command}`);
192 |         expect(mockSetValue).toHaveBeenCalledWith(
193 |           SettingScope.Workspace,
194 |           'mcpServers',
195 |           expect.any(Object),
196 |         );
197 |       });
198 |     });
199 | 
200 |     describe('when in the home directory', () => {
201 |       beforeEach(() => {
202 |         setupMocks('/home/user', '/home/user');
203 |       });
204 | 
205 |       it('should show an error by default', async () => {
206 |         const mockProcessExit = vi
207 |           .spyOn(process, 'exit')
208 |           .mockImplementation((() => {
209 |             throw new Error('process.exit called');
210 |           }) as (code?: number) => never);
211 | 
212 |         await expect(
213 |           parser.parseAsync(`add ${serverName} ${command}`),
214 |         ).rejects.toThrow('process.exit called');
215 | 
216 |         expect(mockConsoleError).toHaveBeenCalledWith(
217 |           'Error: Please use --scope user to edit settings in the home directory.',
218 |         );
219 |         expect(mockProcessExit).toHaveBeenCalledWith(1);
220 |         expect(mockSetValue).not.toHaveBeenCalled();
221 |       });
222 | 
223 |       it('should show an error when --scope=project is used explicitly', async () => {
224 |         const mockProcessExit = vi
225 |           .spyOn(process, 'exit')
226 |           .mockImplementation((() => {
227 |             throw new Error('process.exit called');
228 |           }) as (code?: number) => never);
229 | 
230 |         await expect(
231 |           parser.parseAsync(`add --scope project ${serverName} ${command}`),
232 |         ).rejects.toThrow('process.exit called');
233 | 
234 |         expect(mockConsoleError).toHaveBeenCalledWith(
235 |           'Error: Please use --scope user to edit settings in the home directory.',
236 |         );
237 |         expect(mockProcessExit).toHaveBeenCalledWith(1);
238 |         expect(mockSetValue).not.toHaveBeenCalled();
239 |       });
240 | 
241 |       it('should use user scope when --scope=user is used', async () => {
242 |         await parser.parseAsync(`add --scope user ${serverName} ${command}`);
243 |         expect(mockSetValue).toHaveBeenCalledWith(
244 |           SettingScope.User,
245 |           'mcpServers',
246 |           expect.any(Object),
247 |         );
248 |         expect(mockConsoleError).not.toHaveBeenCalled();
249 |       });
250 |     });
251 | 
252 |     describe('when in a subdirectory of home (not a project)', () => {
253 |       beforeEach(() => {
254 |         setupMocks('/home/user/some/dir', '/home/user/some/dir');
255 |       });
256 | 
257 |       it('should use project scope by default', async () => {
258 |         await parser.parseAsync(`add ${serverName} ${command}`);
259 |         expect(mockSetValue).toHaveBeenCalledWith(
260 |           SettingScope.Workspace,
261 |           'mcpServers',
262 |           expect.any(Object),
263 |         );
264 |       });
265 | 
266 |       it('should write to the WORKSPACE scope, not the USER scope', async () => {
267 |         await parser.parseAsync(`add my-new-server echo`);
268 | 
269 |         // We expect setValue to be called once.
270 |         expect(mockSetValue).toHaveBeenCalledTimes(1);
271 | 
272 |         // We get the scope that setValue was called with.
273 |         const calledScope = mockSetValue.mock.calls[0][0];
274 | 
275 |         // We assert that the scope was Workspace, not User.
276 |         expect(calledScope).toBe(SettingScope.Workspace);
277 |       });
278 |     });
279 | 
280 |     describe('when outside of home (not a project)', () => {
281 |       beforeEach(() => {
282 |         setupMocks('/tmp/foo', '/tmp/foo');
283 |       });
284 | 
285 |       it('should use project scope by default', async () => {
286 |         await parser.parseAsync(`add ${serverName} ${command}`);
287 |         expect(mockSetValue).toHaveBeenCalledWith(
288 |           SettingScope.Workspace,
289 |           'mcpServers',
290 |           expect.any(Object),
291 |         );
292 |       });
293 |     });
294 |   });
295 | 
296 |   describe('when updating an existing server', () => {
297 |     const serverName = 'existing-server';
298 |     const initialCommand = 'echo old';
299 |     const updatedCommand = 'echo';
300 |     const updatedArgs = ['new'];
301 | 
302 |     beforeEach(() => {
303 |       mockedLoadSettings.mockReturnValue({
304 |         forScope: () => ({
305 |           settings: {
306 |             mcpServers: {
307 |               [serverName]: {
308 |                 command: initialCommand,
309 |               },
310 |             },
311 |           },
312 |         }),
313 |         setValue: mockSetValue,
314 |         workspace: { path: '/path/to/project' },
315 |         user: { path: '/home/user' },
316 |       });
317 |     });
318 | 
319 |     it('should update the existing server in the project scope', async () => {
320 |       await parser.parseAsync(
321 |         `add ${serverName} ${updatedCommand} ${updatedArgs.join(' ')}`,
322 |       );
323 |       expect(mockSetValue).toHaveBeenCalledWith(
324 |         SettingScope.Workspace,
325 |         'mcpServers',
326 |         expect.objectContaining({
327 |           [serverName]: expect.objectContaining({
328 |             command: updatedCommand,
329 |             args: updatedArgs,
330 |           }),
331 |         }),
332 |       );
333 |     });
334 | 
335 |     it('should update the existing server in the user scope', async () => {
336 |       await parser.parseAsync(
337 |         `add --scope user ${serverName} ${updatedCommand} ${updatedArgs.join(' ')}`,
338 |       );
339 |       expect(mockSetValue).toHaveBeenCalledWith(
340 |         SettingScope.User,
341 |         'mcpServers',
342 |         expect.objectContaining({
343 |           [serverName]: expect.objectContaining({
344 |             command: updatedCommand,
345 |             args: updatedArgs,
346 |           }),
347 |         }),
348 |       );
349 |     });
350 |   });
351 | });
```

src/commands/mcp/add.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | // File for 'gemini mcp add' command
8 | import type { CommandModule } from 'yargs';
9 | import { loadSettings, SettingScope } from '../../config/settings.js';
10 | import type { MCPServerConfig } from '@google/gemini-cli-core';
11 | 
12 | async function addMcpServer(
13 |   name: string,
14 |   commandOrUrl: string,
15 |   args: Array<string | number> | undefined,
16 |   options: {
17 |     scope: string;
18 |     transport: string;
19 |     env: string[] | undefined;
20 |     header: string[] | undefined;
21 |     timeout?: number;
22 |     trust?: boolean;
23 |     description?: string;
24 |     includeTools?: string[];
25 |     excludeTools?: string[];
26 |   },
27 | ) {
28 |   const {
29 |     scope,
30 |     transport,
31 |     env,
32 |     header,
33 |     timeout,
34 |     trust,
35 |     description,
36 |     includeTools,
37 |     excludeTools,
38 |   } = options;
39 | 
40 |   const settings = loadSettings(process.cwd());
41 |   const inHome = settings.workspace.path === settings.user.path;
42 | 
43 |   if (scope === 'project' && inHome) {
44 |     console.error(
45 |       'Error: Please use --scope user to edit settings in the home directory.',
46 |     );
47 |     process.exit(1);
48 |   }
49 | 
50 |   const settingsScope =
51 |     scope === 'user' ? SettingScope.User : SettingScope.Workspace;
52 | 
53 |   let newServer: Partial<MCPServerConfig> = {};
54 | 
55 |   const headers = header?.reduce(
56 |     (acc, curr) => {
57 |       const [key, ...valueParts] = curr.split(':');
58 |       const value = valueParts.join(':').trim();
59 |       if (key.trim() && value) {
60 |         acc[key.trim()] = value;
61 |       }
62 |       return acc;
63 |     },
64 |     {} as Record<string, string>,
65 |   );
66 | 
67 |   switch (transport) {
68 |     case 'sse':
69 |       newServer = {
70 |         url: commandOrUrl,
71 |         headers,
72 |         timeout,
73 |         trust,
74 |         description,
75 |         includeTools,
76 |         excludeTools,
77 |       };
78 |       break;
79 |     case 'http':
80 |       newServer = {
81 |         httpUrl: commandOrUrl,
82 |         headers,
83 |         timeout,
84 |         trust,
85 |         description,
86 |         includeTools,
87 |         excludeTools,
88 |       };
89 |       break;
90 |     case 'stdio':
91 |     default:
92 |       newServer = {
93 |         command: commandOrUrl,
94 |         args: args?.map(String),
95 |         env: env?.reduce(
96 |           (acc, curr) => {
97 |             const [key, value] = curr.split('=');
98 |             if (key && value) {
99 |               acc[key] = value;
100 |             }
101 |             return acc;
102 |           },
103 |           {} as Record<string, string>,
104 |         ),
105 |         timeout,
106 |         trust,
107 |         description,
108 |         includeTools,
109 |         excludeTools,
110 |       };
111 |       break;
112 |   }
113 | 
114 |   const existingSettings = settings.forScope(settingsScope).settings;
115 |   const mcpServers = existingSettings.mcpServers || {};
116 | 
117 |   const isExistingServer = !!mcpServers[name];
118 |   if (isExistingServer) {
119 |     console.log(
120 |       `MCP server "${name}" is already configured within ${scope} settings.`,
121 |     );
122 |   }
123 | 
124 |   mcpServers[name] = newServer as MCPServerConfig;
125 | 
126 |   settings.setValue(settingsScope, 'mcpServers', mcpServers);
127 | 
128 |   if (isExistingServer) {
129 |     console.log(`MCP server "${name}" updated in ${scope} settings.`);
130 |   } else {
131 |     console.log(
132 |       `MCP server "${name}" added to ${scope} settings. (${transport})`,
133 |     );
134 |   }
135 | }
136 | 
137 | export const addCommand: CommandModule = {
138 |   command: 'add <name> <commandOrUrl> [args...]',
139 |   describe: 'Add a server',
140 |   builder: (yargs) =>
141 |     yargs
142 |       .usage('Usage: gemini mcp add [options] <name> <commandOrUrl> [args...]')
143 |       .parserConfiguration({
144 |         'unknown-options-as-args': true, // Pass unknown options as server args
145 |         'populate--': true, // Populate server args after -- separator
146 |       })
147 |       .positional('name', {
148 |         describe: 'Name of the server',
149 |         type: 'string',
150 |         demandOption: true,
151 |       })
152 |       .positional('commandOrUrl', {
153 |         describe: 'Command (stdio) or URL (sse, http)',
154 |         type: 'string',
155 |         demandOption: true,
156 |       })
157 |       .option('scope', {
158 |         alias: 's',
159 |         describe: 'Configuration scope (user or project)',
160 |         type: 'string',
161 |         default: 'project',
162 |         choices: ['user', 'project'],
163 |       })
164 |       .option('transport', {
165 |         alias: 't',
166 |         describe: 'Transport type (stdio, sse, http)',
167 |         type: 'string',
168 |         default: 'stdio',
169 |         choices: ['stdio', 'sse', 'http'],
170 |       })
171 |       .option('env', {
172 |         alias: 'e',
173 |         describe: 'Set environment variables (e.g. -e KEY=value)',
174 |         type: 'array',
175 |         string: true,
176 |       })
177 |       .option('header', {
178 |         alias: 'H',
179 |         describe:
180 |           'Set HTTP headers for SSE and HTTP transports (e.g. -H "X-Api-Key: abc123" -H "Authorization: Bearer abc123")',
181 |         type: 'array',
182 |         string: true,
183 |       })
184 |       .option('timeout', {
185 |         describe: 'Set connection timeout in milliseconds',
186 |         type: 'number',
187 |       })
188 |       .option('trust', {
189 |         describe:
190 |           'Trust the server (bypass all tool call confirmation prompts)',
191 |         type: 'boolean',
192 |       })
193 |       .option('description', {
194 |         describe: 'Set the description for the server',
195 |         type: 'string',
196 |       })
197 |       .option('include-tools', {
198 |         describe: 'A comma-separated list of tools to include',
199 |         type: 'array',
200 |         string: true,
201 |       })
202 |       .option('exclude-tools', {
203 |         describe: 'A comma-separated list of tools to exclude',
204 |         type: 'array',
205 |         string: true,
206 |       })
207 |       .middleware((argv) => {
208 |         // Handle -- separator args as server args if present
209 |         if (argv['--']) {
210 |           const existingArgs = (argv['args'] as Array<string | number>) || [];
211 |           argv['args'] = [...existingArgs, ...(argv['--'] as string[])];
212 |         }
213 |       }),
214 |   handler: async (argv) => {
215 |     await addMcpServer(
216 |       argv['name'] as string,
217 |       argv['commandOrUrl'] as string,
218 |       argv['args'] as Array<string | number>,
219 |       {
220 |         scope: argv['scope'] as string,
221 |         transport: argv['transport'] as string,
222 |         env: argv['env'] as string[],
223 |         header: argv['header'] as string[],
224 |         timeout: argv['timeout'] as number | undefined,
225 |         trust: argv['trust'] as boolean | undefined,
226 |         description: argv['description'] as string | undefined,
227 |         includeTools: argv['includeTools'] as string[] | undefined,
228 |         excludeTools: argv['excludeTools'] as string[] | undefined,
229 |       },
230 |     );
231 |   },
232 | };
```

src/commands/mcp/list.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { vi, describe, it, expect, beforeEach, afterEach } from 'vitest';
8 | import { listMcpServers } from './list.js';
9 | import { loadSettings } from '../../config/settings.js';
10 | import { ExtensionStorage, loadExtensions } from '../../config/extension.js';
11 | import { createTransport } from '@google/gemini-cli-core';
12 | import { Client } from '@modelcontextprotocol/sdk/client/index.js';
13 | 
14 | vi.mock('../../config/settings.js', () => ({
15 |   loadSettings: vi.fn(),
16 | }));
17 | vi.mock('../../config/extension.js', () => ({
18 |   loadExtensions: vi.fn(),
19 |   ExtensionStorage: {
20 |     getUserExtensionsDir: vi.fn(),
21 |   },
22 | }));
23 | vi.mock('@google/gemini-cli-core', () => ({
24 |   createTransport: vi.fn(),
25 |   MCPServerStatus: {
26 |     CONNECTED: 'CONNECTED',
27 |     CONNECTING: 'CONNECTING',
28 |     DISCONNECTED: 'DISCONNECTED',
29 |   },
30 |   Storage: vi.fn().mockImplementation((_cwd: string) => ({
31 |     getGlobalSettingsPath: () => '/tmp/gemini/settings.json',
32 |     getWorkspaceSettingsPath: () => '/tmp/gemini/workspace-settings.json',
33 |     getProjectTempDir: () => '/test/home/.gemini/tmp/mocked_hash',
34 |   })),
35 |   GEMINI_CONFIG_DIR: '.gemini',
36 |   getErrorMessage: (e: unknown) => (e instanceof Error ? e.message : String(e)),
37 | }));
38 | vi.mock('@modelcontextprotocol/sdk/client/index.js');
39 | 
40 | const mockedExtensionStorage = ExtensionStorage as vi.Mock;
41 | const mockedLoadSettings = loadSettings as vi.Mock;
42 | const mockedLoadExtensions = loadExtensions as vi.Mock;
43 | const mockedCreateTransport = createTransport as vi.Mock;
44 | const MockedClient = Client as vi.Mock;
45 | 
46 | interface MockClient {
47 |   connect: vi.Mock;
48 |   ping: vi.Mock;
49 |   close: vi.Mock;
50 | }
51 | 
52 | interface MockTransport {
53 |   close: vi.Mock;
54 | }
55 | 
56 | describe('mcp list command', () => {
57 |   let consoleSpy: vi.SpyInstance;
58 |   let mockClient: MockClient;
59 |   let mockTransport: MockTransport;
60 | 
61 |   beforeEach(() => {
62 |     vi.resetAllMocks();
63 | 
64 |     consoleSpy = vi.spyOn(console, 'log').mockImplementation(() => {});
65 | 
66 |     mockTransport = { close: vi.fn() };
67 |     mockClient = {
68 |       connect: vi.fn(),
69 |       ping: vi.fn(),
70 |       close: vi.fn(),
71 |     };
72 | 
73 |     MockedClient.mockImplementation(() => mockClient);
74 |     mockedCreateTransport.mockResolvedValue(mockTransport);
75 |     mockedLoadExtensions.mockReturnValue([]);
76 |     mockedExtensionStorage.getUserExtensionsDir.mockReturnValue(
77 |       '/mocked/extensions/dir',
78 |     );
79 |   });
80 | 
81 |   afterEach(() => {
82 |     consoleSpy.mockRestore();
83 |   });
84 | 
85 |   it('should display message when no servers configured', async () => {
86 |     mockedLoadSettings.mockReturnValue({ merged: { mcpServers: {} } });
87 | 
88 |     await listMcpServers();
89 | 
90 |     expect(consoleSpy).toHaveBeenCalledWith('No MCP servers configured.');
91 |   });
92 | 
93 |   it('should display different server types with connected status', async () => {
94 |     mockedLoadSettings.mockReturnValue({
95 |       merged: {
96 |         mcpServers: {
97 |           'stdio-server': { command: '/path/to/server', args: ['arg1'] },
98 |           'sse-server': { url: 'https://example.com/sse' },
99 |           'http-server': { httpUrl: 'https://example.com/http' },
100 |         },
101 |       },
102 |     });
103 | 
104 |     mockClient.connect.mockResolvedValue(undefined);
105 |     mockClient.ping.mockResolvedValue(undefined);
106 | 
107 |     await listMcpServers();
108 | 
109 |     expect(consoleSpy).toHaveBeenCalledWith('Configured MCP servers:\n');
110 |     expect(consoleSpy).toHaveBeenCalledWith(
111 |       expect.stringContaining(
112 |         'stdio-server: /path/to/server arg1 (stdio) - Connected',
113 |       ),
114 |     );
115 |     expect(consoleSpy).toHaveBeenCalledWith(
116 |       expect.stringContaining(
117 |         'sse-server: https://example.com/sse (sse) - Connected',
118 |       ),
119 |     );
120 |     expect(consoleSpy).toHaveBeenCalledWith(
121 |       expect.stringContaining(
122 |         'http-server: https://example.com/http (http) - Connected',
123 |       ),
124 |     );
125 |   });
126 | 
127 |   it('should display disconnected status when connection fails', async () => {
128 |     mockedLoadSettings.mockReturnValue({
129 |       merged: {
130 |         mcpServers: {
131 |           'test-server': { command: '/test/server' },
132 |         },
133 |       },
134 |     });
135 | 
136 |     mockClient.connect.mockRejectedValue(new Error('Connection failed'));
137 | 
138 |     await listMcpServers();
139 | 
140 |     expect(consoleSpy).toHaveBeenCalledWith(
141 |       expect.stringContaining(
142 |         'test-server: /test/server  (stdio) - Disconnected',
143 |       ),
144 |     );
145 |   });
146 | 
147 |   it('should merge extension servers with config servers', async () => {
148 |     mockedLoadSettings.mockReturnValue({
149 |       merged: {
150 |         mcpServers: { 'config-server': { command: '/config/server' } },
151 |       },
152 |     });
153 | 
154 |     mockedLoadExtensions.mockReturnValue([
155 |       {
156 |         name: 'test-extension',
157 |         mcpServers: { 'extension-server': { command: '/ext/server' } },
158 |       },
159 |     ]);
160 | 
161 |     mockClient.connect.mockResolvedValue(undefined);
162 |     mockClient.ping.mockResolvedValue(undefined);
163 | 
164 |     await listMcpServers();
165 | 
166 |     expect(consoleSpy).toHaveBeenCalledWith(
167 |       expect.stringContaining(
168 |         'config-server: /config/server  (stdio) - Connected',
169 |       ),
170 |     );
171 |     expect(consoleSpy).toHaveBeenCalledWith(
172 |       expect.stringContaining(
173 |         'extension-server: /ext/server  (stdio) - Connected',
174 |       ),
175 |     );
176 |   });
177 | });
```

src/commands/mcp/list.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | // File for 'gemini mcp list' command
8 | import type { CommandModule } from 'yargs';
9 | import { loadSettings } from '../../config/settings.js';
10 | import type { MCPServerConfig } from '@google/gemini-cli-core';
11 | import { MCPServerStatus, createTransport } from '@google/gemini-cli-core';
12 | import { Client } from '@modelcontextprotocol/sdk/client/index.js';
13 | import { ExtensionStorage, loadExtensions } from '../../config/extension.js';
14 | import { ExtensionEnablementManager } from '../../config/extensions/extensionEnablement.js';
15 | 
16 | const COLOR_GREEN = '\u001b[32m';
17 | const COLOR_YELLOW = '\u001b[33m';
18 | const COLOR_RED = '\u001b[31m';
19 | const RESET_COLOR = '\u001b[0m';
20 | 
21 | async function getMcpServersFromConfig(): Promise<
22 |   Record<string, MCPServerConfig>
23 | > {
24 |   const settings = loadSettings();
25 |   const extensions = loadExtensions(
26 |     new ExtensionEnablementManager(ExtensionStorage.getUserExtensionsDir()),
27 |   );
28 |   const mcpServers = { ...(settings.merged.mcpServers || {}) };
29 |   for (const extension of extensions) {
30 |     Object.entries(extension.mcpServers || {}).forEach(([key, server]) => {
31 |       if (mcpServers[key]) {
32 |         return;
33 |       }
34 |       mcpServers[key] = {
35 |         ...server,
36 |         extensionName: extension.name,
37 |       };
38 |     });
39 |   }
40 |   return mcpServers;
41 | }
42 | 
43 | async function testMCPConnection(
44 |   serverName: string,
45 |   config: MCPServerConfig,
46 | ): Promise<MCPServerStatus> {
47 |   const client = new Client({
48 |     name: 'mcp-test-client',
49 |     version: '0.0.1',
50 |   });
51 | 
52 |   let transport;
53 |   try {
54 |     // Use the same transport creation logic as core
55 |     transport = await createTransport(serverName, config, false);
56 |   } catch (_error) {
57 |     await client.close();
58 |     return MCPServerStatus.DISCONNECTED;
59 |   }
60 | 
61 |   try {
62 |     // Attempt actual MCP connection with short timeout
63 |     await client.connect(transport, { timeout: 5000 }); // 5s timeout
64 | 
65 |     // Test basic MCP protocol by pinging the server
66 |     await client.ping();
67 | 
68 |     await client.close();
69 |     return MCPServerStatus.CONNECTED;
70 |   } catch (_error) {
71 |     await transport.close();
72 |     return MCPServerStatus.DISCONNECTED;
73 |   }
74 | }
75 | 
76 | async function getServerStatus(
77 |   serverName: string,
78 |   server: MCPServerConfig,
79 | ): Promise<MCPServerStatus> {
80 |   // Test all server types by attempting actual connection
81 |   return await testMCPConnection(serverName, server);
82 | }
83 | 
84 | export async function listMcpServers(): Promise<void> {
85 |   const mcpServers = await getMcpServersFromConfig();
86 |   const serverNames = Object.keys(mcpServers);
87 | 
88 |   if (serverNames.length === 0) {
89 |     console.log('No MCP servers configured.');
90 |     return;
91 |   }
92 | 
93 |   console.log('Configured MCP servers:\n');
94 | 
95 |   for (const serverName of serverNames) {
96 |     const server = mcpServers[serverName];
97 | 
98 |     const status = await getServerStatus(serverName, server);
99 | 
100 |     let statusIndicator = '';
101 |     let statusText = '';
102 |     switch (status) {
103 |       case MCPServerStatus.CONNECTED:
104 |         statusIndicator = COLOR_GREEN + '✓' + RESET_COLOR;
105 |         statusText = 'Connected';
106 |         break;
107 |       case MCPServerStatus.CONNECTING:
108 |         statusIndicator = COLOR_YELLOW + '…' + RESET_COLOR;
109 |         statusText = 'Connecting';
110 |         break;
111 |       case MCPServerStatus.DISCONNECTED:
112 |       default:
113 |         statusIndicator = COLOR_RED + '✗' + RESET_COLOR;
114 |         statusText = 'Disconnected';
115 |         break;
116 |     }
117 | 
118 |     let serverInfo = `${serverName}: `;
119 |     if (server.httpUrl) {
120 |       serverInfo += `${server.httpUrl} (http)`;
121 |     } else if (server.url) {
122 |       serverInfo += `${server.url} (sse)`;
123 |     } else if (server.command) {
124 |       serverInfo += `${server.command} ${server.args?.join(' ') || ''} (stdio)`;
125 |     }
126 | 
127 |     console.log(`${statusIndicator} ${serverInfo} - ${statusText}`);
128 |   }
129 | }
130 | 
131 | export const listCommand: CommandModule = {
132 |   command: 'list',
133 |   describe: 'List all configured MCP servers',
134 |   handler: async () => {
135 |     await listMcpServers();
136 |   },
137 | };
```

src/commands/mcp/remove.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { vi, describe, it, expect, beforeEach, afterEach } from 'vitest';
8 | import yargs from 'yargs';
9 | import { SettingScope, type LoadedSettings } from '../../config/settings.js';
10 | import { removeCommand } from './remove.js';
11 | import * as fs from 'node:fs';
12 | import * as path from 'node:path';
13 | import * as os from 'node:os';
14 | 
15 | vi.mock('fs/promises', () => ({
16 |   readFile: vi.fn(),
17 |   writeFile: vi.fn(),
18 | }));
19 | 
20 | describe('mcp remove command', () => {
21 |   describe('unit tests with mocks', () => {
22 |     let parser: yargs.Argv;
23 |     let mockSetValue: vi.Mock;
24 |     let mockSettings: Record<string, unknown>;
25 | 
26 |     beforeEach(async () => {
27 |       vi.resetAllMocks();
28 | 
29 |       mockSetValue = vi.fn();
30 |       mockSettings = {
31 |         mcpServers: {
32 |           'test-server': {
33 |             command: 'echo "hello"',
34 |           },
35 |         },
36 |       };
37 | 
38 |       vi.spyOn(
39 |         await import('../../config/settings.js'),
40 |         'loadSettings',
41 |       ).mockReturnValue({
42 |         forScope: () => ({ settings: mockSettings }),
43 |         setValue: mockSetValue,
44 |       } as Partial<LoadedSettings> as LoadedSettings);
45 | 
46 |       const yargsInstance = yargs([]).command(removeCommand);
47 |       parser = yargsInstance;
48 |     });
49 | 
50 |     it('should remove a server from project settings', async () => {
51 |       await parser.parseAsync('remove test-server');
52 | 
53 |       expect(mockSetValue).toHaveBeenCalledWith(
54 |         SettingScope.Workspace,
55 |         'mcpServers',
56 |         {},
57 |       );
58 |     });
59 | 
60 |     it('should show a message if server not found', async () => {
61 |       const consoleSpy = vi.spyOn(console, 'log').mockImplementation(() => {});
62 |       await parser.parseAsync('remove non-existent-server');
63 | 
64 |       expect(mockSetValue).not.toHaveBeenCalled();
65 |       expect(consoleSpy).toHaveBeenCalledWith(
66 |         'Server "non-existent-server" not found in project settings.',
67 |       );
68 |     });
69 |   });
70 | 
71 |   describe('integration tests with real file I/O', () => {
72 |     let tempDir: string;
73 |     let settingsDir: string;
74 |     let settingsPath: string;
75 |     let parser: yargs.Argv;
76 |     let cwdSpy: ReturnType<typeof vi.spyOn>;
77 | 
78 |     beforeEach(() => {
79 |       vi.resetAllMocks();
80 |       vi.restoreAllMocks();
81 | 
82 |       tempDir = fs.mkdtempSync(path.join(os.tmpdir(), 'mcp-remove-test-'));
83 |       settingsDir = path.join(tempDir, '.gemini');
84 |       settingsPath = path.join(settingsDir, 'settings.json');
85 |       fs.mkdirSync(settingsDir, { recursive: true });
86 | 
87 |       cwdSpy = vi.spyOn(process, 'cwd').mockReturnValue(tempDir);
88 | 
89 |       parser = yargs([]).command(removeCommand);
90 |     });
91 | 
92 |     afterEach(() => {
93 |       cwdSpy.mockRestore();
94 | 
95 |       if (fs.existsSync(tempDir)) {
96 |         fs.rmSync(tempDir, { recursive: true, force: true });
97 |       }
98 |     });
99 | 
100 |     it('should actually remove a server from the settings file', async () => {
101 |       const originalContent = `{
102 |         "mcpServers": {
103 |           "server-to-keep": {
104 |             "command": "node",
105 |             "args": ["keep.js"]
106 |           },
107 |           "server-to-remove": {
108 |             "command": "node",
109 |             "args": ["remove.js"]
110 |           }
111 |         }
112 |       }`;
113 |       fs.writeFileSync(settingsPath, originalContent, 'utf-8');
114 | 
115 |       const consoleSpy = vi.spyOn(console, 'log').mockImplementation(() => {});
116 |       await parser.parseAsync('remove server-to-remove');
117 | 
118 |       const updatedContent = fs.readFileSync(settingsPath, 'utf-8');
119 |       expect(updatedContent).toContain('"server-to-keep"');
120 |       expect(updatedContent).not.toContain('"server-to-remove"');
121 | 
122 |       expect(consoleSpy).toHaveBeenCalledWith(
123 |         'Server "server-to-remove" removed from project settings.',
124 |       );
125 | 
126 |       consoleSpy.mockRestore();
127 |     });
128 | 
129 |     it('should preserve comments when removing a server', async () => {
130 |       const originalContent = `{
131 |         "mcpServers": {
132 |           // Server to keep
133 |           "context7": {
134 |             "command": "node",
135 |             "args": ["server.js"]
136 |           },
137 |           // Server to remove
138 |           "oldServer": {
139 |             "command": "old",
140 |             "args": ["old.js"]
141 |           }
142 |         }
143 |       }`;
144 |       fs.writeFileSync(settingsPath, originalContent, 'utf-8');
145 | 
146 |       const consoleSpy = vi.spyOn(console, 'log').mockImplementation(() => {});
147 |       await parser.parseAsync('remove oldServer');
148 | 
149 |       const updatedContent = fs.readFileSync(settingsPath, 'utf-8');
150 |       expect(updatedContent).toContain('// Server to keep');
151 |       expect(updatedContent).toContain('"context7"');
152 |       expect(updatedContent).not.toContain('"oldServer"');
153 |       expect(updatedContent).toContain('// Server to remove');
154 | 
155 |       consoleSpy.mockRestore();
156 |     });
157 | 
158 |     it('should handle removing the only server', async () => {
159 |       const originalContent = `{
160 |         "mcpServers": {
161 |           "only-server": {
162 |             "command": "node",
163 |             "args": ["server.js"]
164 |           }
165 |         }
166 |       }`;
167 |       fs.writeFileSync(settingsPath, originalContent, 'utf-8');
168 | 
169 |       const consoleSpy = vi.spyOn(console, 'log').mockImplementation(() => {});
170 |       await parser.parseAsync('remove only-server');
171 | 
172 |       const updatedContent = fs.readFileSync(settingsPath, 'utf-8');
173 |       expect(updatedContent).toContain('"mcpServers"');
174 |       expect(updatedContent).not.toContain('"only-server"');
175 |       expect(updatedContent).toMatch(/"mcpServers"\s*:\s*\{\s*\}/);
176 | 
177 |       consoleSpy.mockRestore();
178 |     });
179 | 
180 |     it('should preserve other settings when removing a server', async () => {
181 |       // Create settings file with other settings
182 |       // Note: "model" will be migrated to "model": { "name": ... } format
183 |       const originalContent = `{
184 |         "model": {
185 |           "name": "gemini-2.5-pro"
186 |         },
187 |         "mcpServers": {
188 |           "server1": {
189 |             "command": "node",
190 |             "args": ["s1.js"]
191 |           },
192 |           "server2": {
193 |             "command": "node",
194 |             "args": ["s2.js"]
195 |           }
196 |         },
197 |         "ui": {
198 |           "theme": "dark"
199 |         }
200 |       }`;
201 |       fs.writeFileSync(settingsPath, originalContent, 'utf-8');
202 | 
203 |       const consoleSpy = vi.spyOn(console, 'log').mockImplementation(() => {});
204 |       await parser.parseAsync('remove server1');
205 | 
206 |       const updatedContent = fs.readFileSync(settingsPath, 'utf-8');
207 |       expect(updatedContent).toContain('"model"');
208 |       expect(updatedContent).toContain('"gemini-2.5-pro"');
209 |       expect(updatedContent).toContain('"server2"');
210 |       expect(updatedContent).toContain('"ui"');
211 |       expect(updatedContent).toContain('"theme": "dark"');
212 |       expect(updatedContent).not.toContain('"server1"');
213 | 
214 |       consoleSpy.mockRestore();
215 |     });
216 |   });
217 | });
```

src/commands/mcp/remove.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | // File for 'gemini mcp remove' command
8 | import type { CommandModule } from 'yargs';
9 | import { loadSettings, SettingScope } from '../../config/settings.js';
10 | 
11 | async function removeMcpServer(
12 |   name: string,
13 |   options: {
14 |     scope: string;
15 |   },
16 | ) {
17 |   const { scope } = options;
18 |   const settingsScope =
19 |     scope === 'user' ? SettingScope.User : SettingScope.Workspace;
20 |   const settings = loadSettings();
21 | 
22 |   const existingSettings = settings.forScope(settingsScope).settings;
23 |   const mcpServers = existingSettings.mcpServers || {};
24 | 
25 |   if (!mcpServers[name]) {
26 |     console.log(`Server "${name}" not found in ${scope} settings.`);
27 |     return;
28 |   }
29 | 
30 |   delete mcpServers[name];
31 | 
32 |   settings.setValue(settingsScope, 'mcpServers', mcpServers);
33 | 
34 |   console.log(`Server "${name}" removed from ${scope} settings.`);
35 | }
36 | 
37 | export const removeCommand: CommandModule = {
38 |   command: 'remove <name>',
39 |   describe: 'Remove a server',
40 |   builder: (yargs) =>
41 |     yargs
42 |       .usage('Usage: gemini mcp remove [options] <name>')
43 |       .positional('name', {
44 |         describe: 'Name of the server',
45 |         type: 'string',
46 |         demandOption: true,
47 |       })
48 |       .option('scope', {
49 |         alias: 's',
50 |         describe: 'Configuration scope (user or project)',
51 |         type: 'string',
52 |         default: 'project',
53 |         choices: ['user', 'project'],
54 |       }),
55 |   handler: async (argv) => {
56 |     await removeMcpServer(argv['name'] as string, {
57 |       scope: argv['scope'] as string,
58 |     });
59 |   },
60 | };
```

src/config/extensions/extensionEnablement.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import * as path from 'node:path';
8 | import fs from 'node:fs';
9 | import os from 'node:os';
10 | import { afterEach, beforeEach, describe, expect, it } from 'vitest';
11 | import { ExtensionEnablementManager, Override } from './extensionEnablement.js';
12 | import type { GeminiCLIExtension } from '@google/gemini-cli-core';
13 | 
14 | // Helper to create a temporary directory for testing
15 | function createTestDir() {
16 |   const dirPath = fs.mkdtempSync(path.join(os.tmpdir(), 'gemini-test-'));
17 |   return {
18 |     path: dirPath,
19 |     cleanup: () => fs.rmSync(dirPath, { recursive: true, force: true }),
20 |   };
21 | }
22 | 
23 | let testDir: { path: string; cleanup: () => void };
24 | let configDir: string;
25 | let manager: ExtensionEnablementManager;
26 | 
27 | describe('ExtensionEnablementManager', () => {
28 |   beforeEach(() => {
29 |     testDir = createTestDir();
30 |     configDir = path.join(testDir.path, '.gemini');
31 |     manager = new ExtensionEnablementManager(configDir);
32 |   });
33 | 
34 |   afterEach(() => {
35 |     testDir.cleanup();
36 |     // Reset the singleton instance for test isolation
37 |     // eslint-disable-next-line @typescript-eslint/no-explicit-any
38 |     (ExtensionEnablementManager as any).instance = undefined;
39 |   });
40 | 
41 |   describe('isEnabled', () => {
42 |     it('should return true if extension is not configured', () => {
43 |       expect(manager.isEnabled('ext-test', '/any/path')).toBe(true);
44 |     });
45 | 
46 |     it('should return true if no overrides match', () => {
47 |       manager.disable('ext-test', false, '/another/path');
48 |       expect(manager.isEnabled('ext-test', '/any/path')).toBe(true);
49 |     });
50 | 
51 |     it('should enable a path based on an override rule', () => {
52 |       manager.disable('ext-test', true, '/');
53 |       manager.enable('ext-test', true, '/home/user/projects/');
54 |       expect(manager.isEnabled('ext-test', '/home/user/projects/my-app')).toBe(
55 |         true,
56 |       );
57 |     });
58 | 
59 |     it('should disable a path based on a disable override rule', () => {
60 |       manager.enable('ext-test', true, '/');
61 |       manager.disable('ext-test', true, '/home/user/projects/');
62 |       expect(manager.isEnabled('ext-test', '/home/user/projects/my-app')).toBe(
63 |         false,
64 |       );
65 |     });
66 | 
67 |     it('should respect the last matching rule (enable wins)', () => {
68 |       manager.disable('ext-test', true, '/home/user/projects/');
69 |       manager.enable('ext-test', false, '/home/user/projects/my-app');
70 |       expect(manager.isEnabled('ext-test', '/home/user/projects/my-app')).toBe(
71 |         true,
72 |       );
73 |     });
74 | 
75 |     it('should respect the last matching rule (disable wins)', () => {
76 |       manager.enable('ext-test', true, '/home/user/projects/');
77 |       manager.disable('ext-test', false, '/home/user/projects/my-app');
78 |       expect(manager.isEnabled('ext-test', '/home/user/projects/my-app')).toBe(
79 |         false,
80 |       );
81 |     });
82 | 
83 |     it('should handle', () => {
84 |       manager.enable('ext-test', true, '/home/user/projects');
85 |       manager.disable('ext-test', false, '/home/user/projects/my-app');
86 |       expect(manager.isEnabled('ext-test', '/home/user/projects/my-app')).toBe(
87 |         false,
88 |       );
89 |       expect(
90 |         manager.isEnabled('ext-test', '/home/user/projects/something-else'),
91 |       ).toBe(true);
92 |     });
93 |   });
94 | 
95 |   describe('includeSubdirs', () => {
96 |     it('should add a glob when enabling with includeSubdirs', () => {
97 |       manager.enable('ext-test', true, '/path/to/dir');
98 |       const config = manager.readConfig();
99 |       expect(config['ext-test'].overrides).toContain('/path/to/dir/*');
100 |     });
101 | 
102 |     it('should not add a glob when enabling without includeSubdirs', () => {
103 |       manager.enable('ext-test', false, '/path/to/dir');
104 |       const config = manager.readConfig();
105 |       expect(config['ext-test'].overrides).toContain('/path/to/dir/');
106 |       expect(config['ext-test'].overrides).not.toContain('/path/to/dir/*');
107 |     });
108 | 
109 |     it('should add a glob when disabling with includeSubdirs', () => {
110 |       manager.disable('ext-test', true, '/path/to/dir');
111 |       const config = manager.readConfig();
112 |       expect(config['ext-test'].overrides).toContain('!/path/to/dir/*');
113 |     });
114 | 
115 |     it('should remove conflicting glob rule when enabling without subdirs', () => {
116 |       manager.enable('ext-test', true, '/path/to/dir'); // Adds /path/to/dir*
117 |       manager.enable('ext-test', false, '/path/to/dir'); // Should remove the glob
118 |       const config = manager.readConfig();
119 |       expect(config['ext-test'].overrides).toContain('/path/to/dir/');
120 |       expect(config['ext-test'].overrides).not.toContain('/path/to/dir/*');
121 |     });
122 | 
123 |     it('should remove conflicting non-glob rule when enabling with subdirs', () => {
124 |       manager.enable('ext-test', false, '/path/to/dir'); // Adds /path/to/dir
125 |       manager.enable('ext-test', true, '/path/to/dir'); // Should remove the non-glob
126 |       const config = manager.readConfig();
127 |       expect(config['ext-test'].overrides).toContain('/path/to/dir/*');
128 |       expect(config['ext-test'].overrides).not.toContain('/path/to/dir/');
129 |     });
130 | 
131 |     it('should remove conflicting rules when disabling', () => {
132 |       manager.enable('ext-test', true, '/path/to/dir'); // enabled with glob
133 |       manager.disable('ext-test', false, '/path/to/dir'); // disabled without
134 |       const config = manager.readConfig();
135 |       expect(config['ext-test'].overrides).toContain('!/path/to/dir/');
136 |       expect(config['ext-test'].overrides).not.toContain('/path/to/dir/*');
137 |     });
138 | 
139 |     it('should correctly evaluate isEnabled with subdirs', () => {
140 |       manager.disable('ext-test', true, '/');
141 |       manager.enable('ext-test', true, '/path/to/dir');
142 |       expect(manager.isEnabled('ext-test', '/path/to/dir/')).toBe(true);
143 |       expect(manager.isEnabled('ext-test', '/path/to/dir/sub/')).toBe(true);
144 |       expect(manager.isEnabled('ext-test', '/path/to/another/')).toBe(false);
145 |     });
146 | 
147 |     it('should correctly evaluate isEnabled without subdirs', () => {
148 |       manager.disable('ext-test', true, '/*');
149 |       manager.enable('ext-test', false, '/path/to/dir');
150 |       expect(manager.isEnabled('ext-test', '/path/to/dir')).toBe(true);
151 |       expect(manager.isEnabled('ext-test', '/path/to/dir/sub')).toBe(false);
152 |     });
153 |   });
154 | 
155 |   describe('pruning child rules', () => {
156 |     it('should remove child rules when enabling a parent with subdirs', () => {
157 |       // Pre-existing rules for children
158 |       manager.enable('ext-test', false, '/path/to/dir/subdir1');
159 |       manager.disable('ext-test', true, '/path/to/dir/subdir2');
160 |       manager.enable('ext-test', false, '/path/to/another/dir');
161 | 
162 |       // Enable the parent directory
163 |       manager.enable('ext-test', true, '/path/to/dir');
164 | 
165 |       const config = manager.readConfig();
166 |       const overrides = config['ext-test'].overrides;
167 | 
168 |       // The new parent rule should be present
169 |       expect(overrides).toContain(`/path/to/dir/*`);
170 | 
171 |       // Child rules should be removed
172 |       expect(overrides).not.toContain('/path/to/dir/subdir1/');
173 |       expect(overrides).not.toContain(`!/path/to/dir/subdir2/*`);
174 | 
175 |       // Unrelated rules should remain
176 |       expect(overrides).toContain('/path/to/another/dir/');
177 |     });
178 | 
179 |     it('should remove child rules when disabling a parent with subdirs', () => {
180 |       // Pre-existing rules for children
181 |       manager.enable('ext-test', false, '/path/to/dir/subdir1');
182 |       manager.disable('ext-test', true, '/path/to/dir/subdir2');
183 |       manager.enable('ext-test', false, '/path/to/another/dir');
184 | 
185 |       // Disable the parent directory
186 |       manager.disable('ext-test', true, '/path/to/dir');
187 | 
188 |       const config = manager.readConfig();
189 |       const overrides = config['ext-test'].overrides;
190 | 
191 |       // The new parent rule should be present
192 |       expect(overrides).toContain(`!/path/to/dir/*`);
193 | 
194 |       // Child rules should be removed
195 |       expect(overrides).not.toContain('/path/to/dir/subdir1/');
196 |       expect(overrides).not.toContain(`!/path/to/dir/subdir2/*`);
197 | 
198 |       // Unrelated rules should remain
199 |       expect(overrides).toContain('/path/to/another/dir/');
200 |     });
201 | 
202 |     it('should not remove child rules if includeSubdirs is false', () => {
203 |       manager.enable('ext-test', false, '/path/to/dir/subdir1');
204 |       manager.enable('ext-test', false, '/path/to/dir'); // Not including subdirs
205 | 
206 |       const config = manager.readConfig();
207 |       const overrides = config['ext-test'].overrides;
208 | 
209 |       expect(overrides).toContain('/path/to/dir/subdir1/');
210 |       expect(overrides).toContain('/path/to/dir/');
211 |     });
212 |   });
213 | 
214 |   it('should enable a path based on an enable override', () => {
215 |     manager.disable('ext-test', true, '/Users/chrstn');
216 |     manager.enable('ext-test', true, '/Users/chrstn/gemini-cli');
217 | 
218 |     expect(manager.isEnabled('ext-test', '/Users/chrstn/gemini-cli')).toBe(
219 |       true,
220 |     );
221 |   });
222 | 
223 |   it('should ignore subdirs', () => {
224 |     manager.disable('ext-test', false, '/Users/chrstn');
225 |     expect(manager.isEnabled('ext-test', '/Users/chrstn/gemini-cli')).toBe(
226 |       true,
227 |     );
228 |   });
229 | 
230 |   describe('extension overrides (-e <name>)', () => {
231 |     beforeEach(() => {
232 |       manager = new ExtensionEnablementManager(configDir, ['ext-test']);
233 |     });
234 | 
235 |     it('can enable extensions, case-insensitive', () => {
236 |       manager.disable('ext-test', true, '/');
237 |       expect(manager.isEnabled('ext-test', '/')).toBe(true);
238 |       expect(manager.isEnabled('Ext-Test', '/')).toBe(true);
239 |       // Double check that it would have been disabled otherwise
240 |       expect(
241 |         new ExtensionEnablementManager(configDir).isEnabled('ext-test', '/'),
242 |       ).toBe(false);
243 |     });
244 | 
245 |     it('disable all other extensions', () => {
246 |       manager = new ExtensionEnablementManager(configDir, ['ext-test']);
247 |       manager.enable('ext-test-2', true, '/');
248 |       expect(manager.isEnabled('ext-test-2', '/')).toBe(false);
249 |       // Double check that it would have been enabled otherwise
250 |       expect(
251 |         new ExtensionEnablementManager(configDir).isEnabled('ext-test-2', '/'),
252 |       ).toBe(true);
253 |     });
254 | 
255 |     it('none disables all extensions', () => {
256 |       manager = new ExtensionEnablementManager(configDir, ['none']);
257 |       manager.enable('ext-test', true, '/');
258 |       expect(manager.isEnabled('ext-test', '/path/to/dir')).toBe(false);
259 |       // Double check that it would have been enabled otherwise
260 |       expect(
261 |         new ExtensionEnablementManager(configDir).isEnabled('ext-test', '/'),
262 |       ).toBe(true);
263 |     });
264 |   });
265 | 
266 |   describe('validateExtensionOverrides', () => {
267 |     let consoleErrorSpy: ReturnType<typeof vi.spyOn>;
268 | 
269 |     beforeEach(() => {
270 |       consoleErrorSpy = vi.spyOn(console, 'error').mockImplementation(() => {});
271 |     });
272 | 
273 |     afterEach(() => {
274 |       consoleErrorSpy.mockRestore();
275 |     });
276 | 
277 |     it('should not log an error if enabledExtensionNamesOverride is empty', () => {
278 |       const manager = new ExtensionEnablementManager(configDir, []);
279 |       manager.validateExtensionOverrides([]);
280 |       expect(consoleErrorSpy).not.toHaveBeenCalled();
281 |     });
282 | 
283 |     it('should not log an error if all enabledExtensionNamesOverride are valid', () => {
284 |       const manager = new ExtensionEnablementManager(configDir, [
285 |         'ext-one',
286 |         'ext-two',
287 |       ]);
288 |       const extensions = [
[TRUNCATED]
```

src/config/extensions/extensionEnablement.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import fs from 'node:fs';
8 | import path from 'node:path';
9 | import type { GeminiCLIExtension } from '@google/gemini-cli-core';
10 | 
11 | export interface ExtensionEnablementConfig {
12 |   overrides: string[];
13 | }
14 | 
15 | export interface AllExtensionsEnablementConfig {
16 |   [extensionName: string]: ExtensionEnablementConfig;
17 | }
18 | 
19 | export class Override {
20 |   constructor(
21 |     public baseRule: string,
22 |     public isDisable: boolean,
23 |     public includeSubdirs: boolean,
24 |   ) {}
25 | 
26 |   static fromInput(inputRule: string, includeSubdirs: boolean): Override {
27 |     const isDisable = inputRule.startsWith('!');
28 |     let baseRule = isDisable ? inputRule.substring(1) : inputRule;
29 |     baseRule = ensureLeadingAndTrailingSlash(baseRule);
30 |     return new Override(baseRule, isDisable, includeSubdirs);
31 |   }
32 | 
33 |   static fromFileRule(fileRule: string): Override {
34 |     const isDisable = fileRule.startsWith('!');
35 |     let baseRule = isDisable ? fileRule.substring(1) : fileRule;
36 |     const includeSubdirs = baseRule.endsWith('*');
37 |     baseRule = includeSubdirs
38 |       ? baseRule.substring(0, baseRule.length - 1)
39 |       : baseRule;
40 |     return new Override(baseRule, isDisable, includeSubdirs);
41 |   }
42 | 
43 |   conflictsWith(other: Override): boolean {
44 |     if (this.baseRule === other.baseRule) {
45 |       return (
46 |         this.includeSubdirs !== other.includeSubdirs ||
47 |         this.isDisable !== other.isDisable
48 |       );
49 |     }
50 |     return false;
51 |   }
52 | 
53 |   isEqualTo(other: Override): boolean {
54 |     return (
55 |       this.baseRule === other.baseRule &&
56 |       this.includeSubdirs === other.includeSubdirs &&
57 |       this.isDisable === other.isDisable
58 |     );
59 |   }
60 | 
61 |   asRegex(): RegExp {
62 |     return globToRegex(`${this.baseRule}${this.includeSubdirs ? '*' : ''}`);
63 |   }
64 | 
65 |   isChildOf(parent: Override) {
66 |     if (!parent.includeSubdirs) {
67 |       return false;
68 |     }
69 |     return parent.asRegex().test(this.baseRule);
70 |   }
71 | 
72 |   output(): string {
73 |     return `${this.isDisable ? '!' : ''}${this.baseRule}${this.includeSubdirs ? '*' : ''}`;
74 |   }
75 | 
76 |   matchesPath(path: string) {
77 |     return this.asRegex().test(path);
78 |   }
79 | }
80 | 
81 | const ensureLeadingAndTrailingSlash = function (dirPath: string): string {
82 |   // Normalize separators to forward slashes for consistent matching across platforms.
83 |   let result = dirPath.replace(/\\/g, '/');
84 |   if (result.charAt(0) !== '/') {
85 |     result = '/' + result;
86 |   }
87 |   if (result.charAt(result.length - 1) !== '/') {
88 |     result = result + '/';
89 |   }
90 |   return result;
91 | };
92 | 
93 | /**
94 |  * Converts a glob pattern to a RegExp object.
95 |  * This is a simplified implementation that supports `*`.
96 |  *
97 |  * @param glob The glob pattern to convert.
98 |  * @returns A RegExp object.
99 |  */
100 | function globToRegex(glob: string): RegExp {
101 |   const regexString = glob
102 |     .replace(/[.+?^${}()|[\]\\]/g, '\\$&') // Escape special regex characters
103 |     .replace(/(\/?)\*/g, '($1.*)?'); // Convert * to optional group
104 | 
105 |   return new RegExp(`^${regexString}$`);
106 | }
107 | 
108 | export class ExtensionEnablementManager {
109 |   private configFilePath: string;
110 |   private configDir: string;
111 |   // If non-empty, this overrides all other extension configuration and enables
112 |   // only the ones in this list.
113 |   private enabledExtensionNamesOverride: string[];
114 | 
115 |   constructor(configDir: string, enabledExtensionNames?: string[]) {
116 |     this.configDir = configDir;
117 |     this.configFilePath = path.join(configDir, 'extension-enablement.json');
118 |     this.enabledExtensionNamesOverride =
119 |       enabledExtensionNames?.map((name) => name.toLowerCase()) ?? [];
120 |   }
121 | 
122 |   validateExtensionOverrides(extensions: GeminiCLIExtension[]) {
123 |     for (const name of this.enabledExtensionNamesOverride) {
124 |       if (name === 'none') continue;
125 |       if (
126 |         !extensions.some((ext) => ext.name.toLowerCase() === name.toLowerCase())
127 |       ) {
128 |         console.error(`Extension not found: ${name}`);
129 |       }
130 |     }
131 |   }
132 | 
133 |   /**
134 |    * Determines if an extension is enabled based on its name and the current
135 |    * path. The last matching rule in the overrides list wins.
136 |    *
137 |    * @param extensionName The name of the extension.
138 |    * @param currentPath The absolute path of the current working directory.
139 |    * @returns True if the extension is enabled, false otherwise.
140 |    */
141 |   isEnabled(extensionName: string, currentPath: string): boolean {
142 |     // If we have a single override called 'none', this disables all extensions.
143 |     // Typically, this comes from the user passing `-e none`.
144 |     if (
145 |       this.enabledExtensionNamesOverride.length === 1 &&
146 |       this.enabledExtensionNamesOverride[0] === 'none'
147 |     ) {
148 |       return false;
149 |     }
150 | 
151 |     // If we have explicit overrides, only enable those extensions.
152 |     if (this.enabledExtensionNamesOverride.length > 0) {
153 |       // When checking against overrides ONLY, we use a case insensitive match.
154 |       // The override names are already lowercased in the constructor.
155 |       return this.enabledExtensionNamesOverride.includes(
156 |         extensionName.toLocaleLowerCase(),
157 |       );
158 |     }
159 | 
160 |     // Otherwise, we use the configuration settings
161 |     const config = this.readConfig();
162 |     const extensionConfig = config[extensionName];
163 |     // Extensions are enabled by default.
164 |     let enabled = true;
165 |     const allOverrides = extensionConfig?.overrides ?? [];
166 |     for (const rule of allOverrides) {
167 |       const override = Override.fromFileRule(rule);
168 |       if (override.matchesPath(ensureLeadingAndTrailingSlash(currentPath))) {
169 |         enabled = !override.isDisable;
170 |       }
171 |     }
172 |     return enabled;
173 |   }
174 | 
175 |   readConfig(): AllExtensionsEnablementConfig {
176 |     try {
177 |       const content = fs.readFileSync(this.configFilePath, 'utf-8');
178 |       return JSON.parse(content);
179 |     } catch (error) {
180 |       if (
181 |         error instanceof Error &&
182 |         'code' in error &&
183 |         error.code === 'ENOENT'
184 |       ) {
185 |         return {};
186 |       }
187 |       console.error('Error reading extension enablement config:', error);
188 |       return {};
189 |     }
190 |   }
191 | 
192 |   writeConfig(config: AllExtensionsEnablementConfig): void {
193 |     fs.mkdirSync(this.configDir, { recursive: true });
194 |     fs.writeFileSync(this.configFilePath, JSON.stringify(config, null, 2));
195 |   }
196 | 
197 |   enable(
198 |     extensionName: string,
199 |     includeSubdirs: boolean,
200 |     scopePath: string,
201 |   ): void {
202 |     const config = this.readConfig();
203 |     if (!config[extensionName]) {
204 |       config[extensionName] = { overrides: [] };
205 |     }
206 |     const override = Override.fromInput(scopePath, includeSubdirs);
207 |     const overrides = config[extensionName].overrides.filter((rule) => {
208 |       const fileOverride = Override.fromFileRule(rule);
209 |       if (
210 |         fileOverride.conflictsWith(override) ||
211 |         fileOverride.isEqualTo(override)
212 |       ) {
213 |         return false; // Remove conflicts and equivalent values.
214 |       }
215 |       return !fileOverride.isChildOf(override);
216 |     });
217 |     overrides.push(override.output());
218 |     config[extensionName].overrides = overrides;
219 |     this.writeConfig(config);
220 |   }
221 | 
222 |   disable(
223 |     extensionName: string,
224 |     includeSubdirs: boolean,
225 |     scopePath: string,
226 |   ): void {
227 |     this.enable(extensionName, includeSubdirs, `!${scopePath}`);
228 |   }
229 | 
230 |   remove(extensionName: string): void {
231 |     const config = this.readConfig();
232 |     if (config[extensionName]) {
233 |       delete config[extensionName];
234 |       this.writeConfig(config);
235 |     }
236 |   }
237 | }
```

src/config/extensions/github.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';
8 | import {
9 |   checkForExtensionUpdate,
10 |   cloneFromGit,
11 |   extractFile,
12 |   findReleaseAsset,
13 |   fetchReleaseFromGithub,
14 |   parseGitHubRepoForReleases,
15 | } from './github.js';
16 | import { simpleGit, type SimpleGit } from 'simple-git';
17 | import { ExtensionUpdateState } from '../../ui/state/extensions.js';
18 | import * as os from 'node:os';
19 | import * as fs from 'node:fs/promises';
20 | import * as fsSync from 'node:fs';
21 | import * as path from 'node:path';
22 | import * as tar from 'tar';
23 | import * as archiver from 'archiver';
24 | import type { GeminiCLIExtension } from '@google/gemini-cli-core';
25 | 
26 | const mockPlatform = vi.hoisted(() => vi.fn());
27 | const mockArch = vi.hoisted(() => vi.fn());
28 | vi.mock('node:os', async (importOriginal) => {
29 |   const actual = await importOriginal<typeof os>();
30 |   return {
31 |     ...actual,
32 |     platform: mockPlatform,
33 |     arch: mockArch,
34 |   };
35 | });
36 | 
37 | vi.mock('simple-git');
38 | 
39 | const fetchJsonMock = vi.hoisted(() => vi.fn());
40 | vi.mock('./github_fetch.js', async (importOriginal) => {
41 |   const actual = await importOriginal<typeof import('./github_fetch.js')>();
42 |   return {
43 |     ...actual,
44 |     fetchJson: fetchJsonMock,
45 |   };
46 | });
47 | 
48 | describe('git extension helpers', () => {
49 |   afterEach(() => {
50 |     vi.restoreAllMocks();
51 |   });
52 | 
53 |   describe('cloneFromGit', () => {
54 |     const mockGit = {
55 |       clone: vi.fn(),
56 |       getRemotes: vi.fn(),
57 |       fetch: vi.fn(),
58 |       checkout: vi.fn(),
59 |     };
60 | 
61 |     beforeEach(() => {
62 |       vi.mocked(simpleGit).mockReturnValue(mockGit as unknown as SimpleGit);
63 |     });
64 | 
65 |     it('should clone, fetch and checkout a repo', async () => {
66 |       const installMetadata = {
67 |         source: 'http://my-repo.com',
68 |         ref: 'my-ref',
69 |         type: 'git' as const,
70 |       };
71 |       const destination = '/dest';
72 |       mockGit.getRemotes.mockResolvedValue([
73 |         { name: 'origin', refs: { fetch: 'http://my-repo.com' } },
74 |       ]);
75 | 
76 |       await cloneFromGit(installMetadata, destination);
77 | 
78 |       expect(mockGit.clone).toHaveBeenCalledWith('http://my-repo.com', './', [
79 |         '--depth',
80 |         '1',
81 |       ]);
82 |       expect(mockGit.getRemotes).toHaveBeenCalledWith(true);
83 |       expect(mockGit.fetch).toHaveBeenCalledWith('origin', 'my-ref');
84 |       expect(mockGit.checkout).toHaveBeenCalledWith('FETCH_HEAD');
85 |     });
86 | 
87 |     it('should use HEAD if ref is not provided', async () => {
88 |       const installMetadata = {
89 |         source: 'http://my-repo.com',
90 |         type: 'git' as const,
91 |       };
92 |       const destination = '/dest';
93 |       mockGit.getRemotes.mockResolvedValue([
94 |         { name: 'origin', refs: { fetch: 'http://my-repo.com' } },
95 |       ]);
96 | 
97 |       await cloneFromGit(installMetadata, destination);
98 | 
99 |       expect(mockGit.fetch).toHaveBeenCalledWith('origin', 'HEAD');
100 |     });
101 | 
102 |     it('should throw if no remotes are found', async () => {
103 |       const installMetadata = {
104 |         source: 'http://my-repo.com',
105 |         type: 'git' as const,
106 |       };
107 |       const destination = '/dest';
108 |       mockGit.getRemotes.mockResolvedValue([]);
109 | 
110 |       await expect(cloneFromGit(installMetadata, destination)).rejects.toThrow(
111 |         'Failed to clone Git repository from http://my-repo.com',
112 |       );
113 |     });
114 | 
115 |     it('should throw on clone error', async () => {
116 |       const installMetadata = {
117 |         source: 'http://my-repo.com',
118 |         type: 'git' as const,
119 |       };
120 |       const destination = '/dest';
121 |       mockGit.clone.mockRejectedValue(new Error('clone failed'));
122 | 
123 |       await expect(cloneFromGit(installMetadata, destination)).rejects.toThrow(
124 |         'Failed to clone Git repository from http://my-repo.com',
125 |       );
126 |     });
127 |   });
128 | 
129 |   describe('checkForExtensionUpdate', () => {
130 |     const mockGit = {
131 |       getRemotes: vi.fn(),
132 |       listRemote: vi.fn(),
133 |       revparse: vi.fn(),
134 |     };
135 | 
136 |     beforeEach(() => {
137 |       vi.mocked(simpleGit).mockReturnValue(mockGit as unknown as SimpleGit);
138 |     });
139 | 
140 |     it('should return NOT_UPDATABLE for non-git extensions', async () => {
141 |       const extension: GeminiCLIExtension = {
142 |         name: 'test',
143 |         path: '/ext',
144 |         version: '1.0.0',
145 |         isActive: true,
146 |         installMetadata: {
147 |           type: 'link',
148 |           source: '',
149 |         },
150 |         contextFiles: [],
151 |       };
152 |       const result = await checkForExtensionUpdate(extension);
153 |       expect(result).toBe(ExtensionUpdateState.NOT_UPDATABLE);
154 |     });
155 | 
156 |     it('should return ERROR if no remotes found', async () => {
157 |       const extension: GeminiCLIExtension = {
158 |         name: 'test',
159 |         path: '/ext',
160 |         version: '1.0.0',
161 |         isActive: true,
162 |         installMetadata: {
163 |           type: 'git',
164 |           source: '',
165 |         },
166 |         contextFiles: [],
167 |       };
168 |       mockGit.getRemotes.mockResolvedValue([]);
169 |       const result = await checkForExtensionUpdate(extension);
170 |       expect(result).toBe(ExtensionUpdateState.ERROR);
171 |     });
172 | 
173 |     it('should return UPDATE_AVAILABLE when remote hash is different', async () => {
174 |       const extension: GeminiCLIExtension = {
175 |         name: 'test',
176 |         path: '/ext',
177 |         version: '1.0.0',
178 |         isActive: true,
179 |         installMetadata: {
180 |           type: 'git',
181 |           source: 'my/ext',
182 |         },
183 |         contextFiles: [],
184 |       };
185 |       mockGit.getRemotes.mockResolvedValue([
186 |         { name: 'origin', refs: { fetch: 'http://my-repo.com' } },
187 |       ]);
188 |       mockGit.listRemote.mockResolvedValue('remote-hash\tHEAD');
189 |       mockGit.revparse.mockResolvedValue('local-hash');
190 | 
191 |       const result = await checkForExtensionUpdate(extension);
192 |       expect(result).toBe(ExtensionUpdateState.UPDATE_AVAILABLE);
193 |     });
194 | 
195 |     it('should return UP_TO_DATE when remote and local hashes are the same', async () => {
196 |       const extension: GeminiCLIExtension = {
197 |         name: 'test',
198 |         path: '/ext',
199 |         version: '1.0.0',
200 |         isActive: true,
201 |         installMetadata: {
202 |           type: 'git',
203 |           source: 'my/ext',
204 |         },
205 |         contextFiles: [],
206 |       };
207 |       mockGit.getRemotes.mockResolvedValue([
208 |         { name: 'origin', refs: { fetch: 'http://my-repo.com' } },
209 |       ]);
210 |       mockGit.listRemote.mockResolvedValue('same-hash\tHEAD');
211 |       mockGit.revparse.mockResolvedValue('same-hash');
212 | 
213 |       const result = await checkForExtensionUpdate(extension);
214 |       expect(result).toBe(ExtensionUpdateState.UP_TO_DATE);
215 |     });
216 | 
217 |     it('should return ERROR on git error', async () => {
218 |       const extension: GeminiCLIExtension = {
219 |         name: 'test',
220 |         path: '/ext',
221 |         version: '1.0.0',
222 |         isActive: true,
223 |         installMetadata: {
224 |           type: 'git',
225 |           source: 'my/ext',
226 |         },
227 |         contextFiles: [],
228 |       };
229 |       mockGit.getRemotes.mockRejectedValue(new Error('git error'));
230 | 
231 |       const result = await checkForExtensionUpdate(extension);
232 |       expect(result).toBe(ExtensionUpdateState.ERROR);
233 |     });
234 |   });
235 | 
236 |   describe('fetchReleaseFromGithub', () => {
237 |     it('should fetch the latest release if allowPreRelease is true', async () => {
238 |       const releases = [{ tag_name: 'v1.0.0-alpha' }, { tag_name: 'v0.9.0' }];
239 |       fetchJsonMock.mockResolvedValueOnce(releases);
240 | 
241 |       const result = await fetchReleaseFromGithub(
242 |         'owner',
243 |         'repo',
244 |         undefined,
245 |         true,
246 |       );
247 | 
248 |       expect(fetchJsonMock).toHaveBeenCalledWith(
249 |         'https://api.github.com/repos/owner/repo/releases?per_page=1',
250 |       );
251 |       expect(result).toEqual(releases[0]);
252 |     });
253 | 
254 |     it('should fetch the latest release if allowPreRelease is false', async () => {
255 |       const release = { tag_name: 'v0.9.0' };
256 |       fetchJsonMock.mockResolvedValueOnce(release);
257 | 
258 |       const result = await fetchReleaseFromGithub(
259 |         'owner',
260 |         'repo',
261 |         undefined,
262 |         false,
263 |       );
264 | 
265 |       expect(fetchJsonMock).toHaveBeenCalledWith(
266 |         'https://api.github.com/repos/owner/repo/releases/latest',
267 |       );
268 |       expect(result).toEqual(release);
269 |     });
270 | 
271 |     it('should fetch a release by tag if ref is provided', async () => {
272 |       const release = { tag_name: 'v0.9.0' };
273 |       fetchJsonMock.mockResolvedValueOnce(release);
274 | 
275 |       const result = await fetchReleaseFromGithub('owner', 'repo', 'v0.9.0');
276 | 
277 |       expect(fetchJsonMock).toHaveBeenCalledWith(
278 |         'https://api.github.com/repos/owner/repo/releases/tags/v0.9.0',
279 |       );
280 |       expect(result).toEqual(release);
281 |     });
282 | 
283 |     it('should fetch latest stable release if allowPreRelease is undefined', async () => {
284 |       const release = { tag_name: 'v0.9.0' };
285 |       fetchJsonMock.mockResolvedValueOnce(release);
286 | 
287 |       const result = await fetchReleaseFromGithub('owner', 'repo');
288 | 
289 |       expect(fetchJsonMock).toHaveBeenCalledWith(
290 |         'https://api.github.com/repos/owner/repo/releases/latest',
291 |       );
292 |       expect(result).toEqual(release);
293 |     });
294 |   });
295 | 
296 |   describe('findReleaseAsset', () => {
297 |     const assets = [
298 |       { name: 'darwin.arm64.extension.tar.gz', browser_download_url: 'url1' },
299 |       { name: 'darwin.x64.extension.tar.gz', browser_download_url: 'url2' },
300 |       { name: 'linux.x64.extension.tar.gz', browser_download_url: 'url3' },
301 |       { name: 'win32.x64.extension.tar.gz', browser_download_url: 'url4' },
302 |       { name: 'extension-generic.tar.gz', browser_download_url: 'url5' },
303 |     ];
304 | 
305 |     it('should find asset matching platform and architecture', () => {
306 |       mockPlatform.mockReturnValue('darwin');
307 |       mockArch.mockReturnValue('arm64');
308 |       const result = findReleaseAsset(assets);
309 |       expect(result).toEqual(assets[0]);
310 |     });
311 | 
312 |     it('should find asset matching platform if arch does not match', () => {
313 |       mockPlatform.mockReturnValue('linux');
314 |       mockArch.mockReturnValue('arm64');
315 |       const result = findReleaseAsset(assets);
316 |       expect(result).toEqual(assets[2]);
317 |     });
318 | 
319 |     it('should return undefined if no matching asset is found', () => {
320 |       mockPlatform.mockReturnValue('sunos');
321 |       mockArch.mockReturnValue('x64');
322 |       const result = findReleaseAsset(assets);
323 |       expect(result).toBeUndefined();
324 |     });
325 | 
326 |     it('should find generic asset if it is the only one', () => {
327 |       const singleAsset = [
328 |         { name: 'extension.tar.gz', browser_download_url: 'url' },
329 |       ];
330 |       mockPlatform.mockReturnValue('darwin');
331 |       mockArch.mockReturnValue('arm64');
332 |       const result = findReleaseAsset(singleAsset);
333 |       expect(result).toEqual(singleAsset[0]);
334 |     });
335 | 
336 |     it('should return undefined if multiple generic assets exist', () => {
337 |       const multipleGenericAssets = [
338 |         { name: 'extension-1.tar.gz', browser_download_url: 'url1' },
339 |         { name: 'extension-2.tar.gz', browser_download_url: 'url2' },
340 |       ];
341 |       mockPlatform.mockReturnValue('darwin');
342 |       mockArch.mockReturnValue('arm64');
343 |       const result = findReleaseAsset(multipleGenericAssets);
344 |       expect(result).toBeUndefined();
345 |     });
346 |   });
347 | 
348 |   describe('parseGitHubRepoForReleases', () => {
349 |     it('should parse owner and repo from a full GitHub URL', () => {
350 |       const source = 'https://github.com/owner/repo.git';
351 |       const { owner, repo } = parseGitHubRepoForReleases(source);
352 |       expect(owner).toBe('owner');
353 |       expect(repo).toBe('repo');
354 |     });
355 | 
356 |     it('should parse owner and repo from a full GitHub URL without .git', () => {
357 |       const source = 'https://github.com/owner/repo';
358 |       const { owner, repo } = parseGitHubRepoForReleases(source);
[TRUNCATED]
```

src/config/extensions/github.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { simpleGit } from 'simple-git';
8 | import { getErrorMessage } from '../../utils/errors.js';
9 | import type {
10 |   ExtensionInstallMetadata,
11 |   GeminiCLIExtension,
12 | } from '@google/gemini-cli-core';
13 | import { ExtensionUpdateState } from '../../ui/state/extensions.js';
14 | import * as os from 'node:os';
15 | import * as https from 'node:https';
16 | import * as fs from 'node:fs';
17 | import * as path from 'node:path';
18 | import { EXTENSIONS_CONFIG_FILENAME, loadExtension } from '../extension.js';
19 | import * as tar from 'tar';
20 | import extract from 'extract-zip';
21 | import { fetchJson, getGitHubToken } from './github_fetch.js';
22 | 
23 | /**
24 |  * Clones a Git repository to a specified local path.
25 |  * @param installMetadata The metadata for the extension to install.
26 |  * @param destination The destination path to clone the repository to.
27 |  */
28 | export async function cloneFromGit(
29 |   installMetadata: ExtensionInstallMetadata,
30 |   destination: string,
31 | ): Promise<void> {
32 |   try {
33 |     const git = simpleGit(destination);
34 |     let sourceUrl = installMetadata.source;
35 |     const token = getGitHubToken();
36 |     if (token) {
37 |       try {
38 |         const parsedUrl = new URL(sourceUrl);
39 |         if (
40 |           parsedUrl.protocol === 'https:' &&
41 |           parsedUrl.hostname === 'github.com'
42 |         ) {
43 |           if (!parsedUrl.username) {
44 |             parsedUrl.username = token;
45 |           }
46 |           sourceUrl = parsedUrl.toString();
47 |         }
48 |       } catch {
49 |         // If source is not a valid URL, we don't inject the token.
50 |         // We let git handle the source as is.
51 |       }
52 |     }
53 |     await git.clone(sourceUrl, './', ['--depth', '1']);
54 | 
55 |     const remotes = await git.getRemotes(true);
56 |     if (remotes.length === 0) {
57 |       throw new Error(
58 |         `Unable to find any remotes for repo ${installMetadata.source}`,
59 |       );
60 |     }
61 | 
62 |     const refToFetch = installMetadata.ref || 'HEAD';
63 | 
64 |     await git.fetch(remotes[0].name, refToFetch);
65 | 
66 |     // After fetching, checkout FETCH_HEAD to get the content of the fetched ref.
67 |     // This results in a detached HEAD state, which is fine for this purpose.
68 |     await git.checkout('FETCH_HEAD');
69 |   } catch (error) {
70 |     throw new Error(
71 |       `Failed to clone Git repository from ${installMetadata.source} ${getErrorMessage(error)}`,
72 |       {
73 |         cause: error,
74 |       },
75 |     );
76 |   }
77 | }
78 | 
79 | export function parseGitHubRepoForReleases(source: string): {
80 |   owner: string;
81 |   repo: string;
82 | } {
83 |   // Default to a github repo path, so `source` can be just an org/repo
84 |   const parsedUrl = URL.parse(source, 'https://github.com');
85 |   // The pathname should be "/owner/repo".
86 |   const parts = parsedUrl?.pathname
87 |     .substring(1)
88 |     .split('/')
89 |     // Remove the empty segments, fixes trailing slashes
90 |     .filter((part) => part !== '');
91 |   if (parts?.length !== 2 || parsedUrl?.host !== 'github.com') {
92 |     throw new Error(
93 |       `Invalid GitHub repository source: ${source}. Expected "owner/repo" or a github repo uri.`,
94 |     );
95 |   }
96 |   const owner = parts[0];
97 |   const repo = parts[1].replace('.git', '');
98 | 
99 |   if (owner.startsWith('git@github.com')) {
100 |     throw new Error(
101 |       `GitHub release-based extensions are not supported for SSH. You must use an HTTPS URI with a personal access token to download releases from private repositories. You can set your personal access token in the GITHUB_TOKEN environment variable and install the extension via SSH.`,
102 |     );
103 |   }
104 | 
105 |   return { owner, repo };
106 | }
107 | 
108 | export async function fetchReleaseFromGithub(
109 |   owner: string,
110 |   repo: string,
111 |   ref?: string,
112 |   allowPreRelease?: boolean,
113 | ): Promise<GithubReleaseData> {
114 |   if (ref) {
115 |     return await fetchJson(
116 |       `https://api.github.com/repos/${owner}/${repo}/releases/tags/${ref}`,
117 |     );
118 |   }
119 | 
120 |   if (!allowPreRelease) {
121 |     // Grab the release that is tagged as the "latest", github does not allow
122 |     // this to be a pre-release so we can blindly grab it.
123 |     return await fetchJson(
124 |       `https://api.github.com/repos/${owner}/${repo}/releases/latest`,
125 |     );
126 |   }
127 | 
128 |   // If pre-releases are allowed, we just grab the most recent release.
129 |   const releases = await fetchJson<GithubReleaseData[]>(
130 |     `https://api.github.com/repos/${owner}/${repo}/releases?per_page=1`,
131 |   );
132 |   if (releases.length === 0) {
133 |     throw new Error('No releases found');
134 |   }
135 |   return releases[0];
136 | }
137 | 
138 | export async function checkForExtensionUpdate(
139 |   extension: GeminiCLIExtension,
140 |   cwd: string = process.cwd(),
141 | ): Promise<ExtensionUpdateState> {
142 |   const installMetadata = extension.installMetadata;
143 |   if (installMetadata?.type === 'local') {
144 |     const newExtension = loadExtension({
145 |       extensionDir: installMetadata.source,
146 |       workspaceDir: cwd,
147 |     });
148 |     if (!newExtension) {
149 |       console.error(
150 |         `Failed to check for update for local extension "${extension.name}". Could not load extension from source path: ${installMetadata.source}`,
151 |       );
152 |       return ExtensionUpdateState.ERROR;
153 |     }
154 |     if (newExtension.version !== extension.version) {
155 |       return ExtensionUpdateState.UPDATE_AVAILABLE;
156 |     }
157 |     return ExtensionUpdateState.UP_TO_DATE;
158 |   }
159 |   if (
160 |     !installMetadata ||
161 |     (installMetadata.type !== 'git' &&
162 |       installMetadata.type !== 'github-release')
163 |   ) {
164 |     return ExtensionUpdateState.NOT_UPDATABLE;
165 |   }
166 |   try {
167 |     if (installMetadata.type === 'git') {
168 |       const git = simpleGit(extension.path);
169 |       const remotes = await git.getRemotes(true);
170 |       if (remotes.length === 0) {
171 |         console.error('No git remotes found.');
172 |         return ExtensionUpdateState.ERROR;
173 |       }
174 |       const remoteUrl = remotes[0].refs.fetch;
175 |       if (!remoteUrl) {
176 |         console.error(`No fetch URL found for git remote ${remotes[0].name}.`);
177 |         return ExtensionUpdateState.ERROR;
178 |       }
179 | 
180 |       // Determine the ref to check on the remote.
181 |       const refToCheck = installMetadata.ref || 'HEAD';
182 | 
183 |       const lsRemoteOutput = await git.listRemote([remoteUrl, refToCheck]);
184 | 
185 |       if (typeof lsRemoteOutput !== 'string' || lsRemoteOutput.trim() === '') {
186 |         console.error(`Git ref ${refToCheck} not found.`);
187 |         return ExtensionUpdateState.ERROR;
188 |       }
189 | 
190 |       const remoteHash = lsRemoteOutput.split('\t')[0];
191 |       const localHash = await git.revparse(['HEAD']);
192 | 
193 |       if (!remoteHash) {
194 |         console.error(
195 |           `Unable to parse hash from git ls-remote output "${lsRemoteOutput}"`,
196 |         );
197 |         return ExtensionUpdateState.ERROR;
198 |       }
199 |       if (remoteHash === localHash) {
200 |         return ExtensionUpdateState.UP_TO_DATE;
201 |       }
202 |       return ExtensionUpdateState.UPDATE_AVAILABLE;
203 |     } else {
204 |       const { source, releaseTag } = installMetadata;
205 |       if (!source) {
206 |         console.error(`No "source" provided for extension.`);
207 |         return ExtensionUpdateState.ERROR;
208 |       }
209 |       const { owner, repo } = parseGitHubRepoForReleases(source);
210 | 
211 |       const releaseData = await fetchReleaseFromGithub(
212 |         owner,
213 |         repo,
214 |         installMetadata.ref,
215 |         installMetadata.allowPreRelease,
216 |       );
217 |       if (releaseData.tag_name !== releaseTag) {
218 |         return ExtensionUpdateState.UPDATE_AVAILABLE;
219 |       }
220 |       return ExtensionUpdateState.UP_TO_DATE;
221 |     }
222 |   } catch (error) {
223 |     console.error(
224 |       `Failed to check for updates for extension "${installMetadata.source}": ${getErrorMessage(error)}`,
225 |     );
226 |     return ExtensionUpdateState.ERROR;
227 |   }
228 | }
229 | export interface GitHubDownloadResult {
230 |   tagName: string;
231 |   type: 'git' | 'github-release';
232 | }
233 | export async function downloadFromGitHubRelease(
234 |   installMetadata: ExtensionInstallMetadata,
235 |   destination: string,
236 | ): Promise<GitHubDownloadResult> {
237 |   const { source, ref, allowPreRelease: preRelease } = installMetadata;
238 |   const { owner, repo } = parseGitHubRepoForReleases(source);
239 | 
240 |   try {
241 |     const releaseData = await fetchReleaseFromGithub(
242 |       owner,
243 |       repo,
244 |       ref,
245 |       preRelease,
246 |     );
247 |     if (!releaseData) {
248 |       throw new Error(
249 |         `No release data found for ${owner}/${repo} at tag ${ref}`,
250 |       );
251 |     }
252 | 
253 |     const asset = findReleaseAsset(releaseData.assets);
254 |     let archiveUrl: string | undefined;
255 |     let isTar = false;
256 |     let isZip = false;
257 |     if (asset) {
258 |       archiveUrl = asset.browser_download_url;
259 |     } else {
260 |       if (releaseData.tarball_url) {
261 |         archiveUrl = releaseData.tarball_url;
262 |         isTar = true;
263 |       } else if (releaseData.zipball_url) {
264 |         archiveUrl = releaseData.zipball_url;
265 |         isZip = true;
266 |       }
267 |     }
268 |     if (!archiveUrl) {
269 |       throw new Error(
270 |         `No assets found for release with tag ${releaseData.tag_name}`,
271 |       );
272 |     }
273 |     let downloadedAssetPath = path.join(
274 |       destination,
275 |       path.basename(new URL(archiveUrl).pathname),
276 |     );
277 |     if (isTar && !downloadedAssetPath.endsWith('.tar.gz')) {
278 |       downloadedAssetPath += '.tar.gz';
279 |     } else if (isZip && !downloadedAssetPath.endsWith('.zip')) {
280 |       downloadedAssetPath += '.zip';
281 |     }
282 | 
283 |     await downloadFile(archiveUrl, downloadedAssetPath);
284 | 
285 |     await extractFile(downloadedAssetPath, destination);
286 | 
287 |     // For regular github releases, the repository is put inside of a top level
288 |     // directory. In this case we should see exactly two file in the destination
289 |     // dir, the archive and the directory. If we see that, validate that the
290 |     // dir has a gemini extension configuration file and then move all files
291 |     // from the directory up one level into the destination directory.
292 |     const entries = await fs.promises.readdir(destination, {
293 |       withFileTypes: true,
294 |     });
295 |     if (entries.length === 2) {
296 |       const lonelyDir = entries.find((entry) => entry.isDirectory());
297 |       if (
298 |         lonelyDir &&
299 |         fs.existsSync(
300 |           path.join(destination, lonelyDir.name, EXTENSIONS_CONFIG_FILENAME),
301 |         )
302 |       ) {
303 |         const dirPathToExtract = path.join(destination, lonelyDir.name);
304 |         const extractedDirFiles = await fs.promises.readdir(dirPathToExtract);
305 |         for (const file of extractedDirFiles) {
306 |           await fs.promises.rename(
307 |             path.join(dirPathToExtract, file),
308 |             path.join(destination, file),
309 |           );
310 |         }
311 |         await fs.promises.rmdir(dirPathToExtract);
312 |       }
313 |     }
314 | 
315 |     await fs.promises.unlink(downloadedAssetPath);
316 |     return {
317 |       tagName: releaseData.tag_name,
318 |       type: 'github-release',
319 |     };
320 |   } catch (error) {
321 |     throw new Error(
322 |       `Failed to download release from ${installMetadata.source}: ${getErrorMessage(error)}`,
323 |     );
324 |   }
325 | }
326 | 
327 | interface GithubReleaseData {
328 |   assets: Asset[];
329 |   tag_name: string;
330 |   tarball_url?: string;
331 |   zipball_url?: string;
332 | }
333 | 
334 | interface Asset {
335 |   name: string;
336 |   browser_download_url: string;
337 | }
338 | 
339 | export function findReleaseAsset(assets: Asset[]): Asset | undefined {
[TRUNCATED]
```

src/config/extensions/github_fetch.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import * as https from 'node:https';
8 | 
9 | export function getGitHubToken(): string | undefined {
10 |   return process.env['GITHUB_TOKEN'];
11 | }
12 | 
13 | export async function fetchJson<T>(url: string): Promise<T> {
14 |   const headers: { 'User-Agent': string; Authorization?: string } = {
15 |     'User-Agent': 'gemini-cli',
16 |   };
17 |   const token = getGitHubToken();
18 |   if (token) {
19 |     headers.Authorization = `token ${token}`;
20 |   }
21 |   return new Promise((resolve, reject) => {
22 |     https
23 |       .get(url, { headers }, (res) => {
24 |         if (res.statusCode !== 200) {
25 |           return reject(
26 |             new Error(`Request failed with status code ${res.statusCode}`),
27 |           );
28 |         }
29 |         const chunks: Buffer[] = [];
30 |         res.on('data', (chunk) => chunks.push(chunk));
31 |         res.on('end', () => {
32 |           const data = Buffer.concat(chunks).toString();
33 |           resolve(JSON.parse(data) as T);
34 |         });
35 |       })
36 |       .on('error', reject);
37 |   });
38 | }
```

src/config/extensions/update.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { vi } from 'vitest';
8 | import * as fs from 'node:fs';
9 | import * as os from 'node:os';
10 | import * as path from 'node:path';
11 | import {
12 |   EXTENSIONS_CONFIG_FILENAME,
13 |   ExtensionStorage,
14 |   INSTALL_METADATA_FILENAME,
15 |   annotateActiveExtensions,
16 |   loadExtension,
17 | } from '../extension.js';
18 | import { checkForAllExtensionUpdates, updateExtension } from './update.js';
19 | import { GEMINI_DIR } from '@google/gemini-cli-core';
20 | import { isWorkspaceTrusted } from '../trustedFolders.js';
21 | import { ExtensionUpdateState } from '../../ui/state/extensions.js';
22 | import { createExtension } from '../../test-utils/createExtension.js';
23 | import { ExtensionEnablementManager } from './extensionEnablement.js';
24 | 
25 | const mockGit = {
26 |   clone: vi.fn(),
27 |   getRemotes: vi.fn(),
28 |   fetch: vi.fn(),
29 |   checkout: vi.fn(),
30 |   listRemote: vi.fn(),
31 |   revparse: vi.fn(),
32 |   // Not a part of the actual API, but we need to use this to do the correct
33 |   // file system interactions.
34 |   path: vi.fn(),
35 | };
36 | 
37 | vi.mock('simple-git', () => ({
38 |   simpleGit: vi.fn((path: string) => {
39 |     mockGit.path.mockReturnValue(path);
40 |     return mockGit;
41 |   }),
42 | }));
43 | 
44 | vi.mock('os', async (importOriginal) => {
45 |   const mockedOs = await importOriginal<typeof os>();
46 |   return {
47 |     ...mockedOs,
48 |     homedir: vi.fn(),
49 |   };
50 | });
51 | 
52 | vi.mock('../trustedFolders.js', async (importOriginal) => {
53 |   const actual = await importOriginal<typeof import('../trustedFolders.js')>();
54 |   return {
55 |     ...actual,
56 |     isWorkspaceTrusted: vi.fn(),
57 |   };
58 | });
59 | 
60 | const mockLogExtensionInstallEvent = vi.hoisted(() => vi.fn());
61 | const mockLogExtensionUninstall = vi.hoisted(() => vi.fn());
62 | 
63 | vi.mock('@google/gemini-cli-core', async (importOriginal) => {
64 |   const actual =
65 |     await importOriginal<typeof import('@google/gemini-cli-core')>();
66 |   return {
67 |     ...actual,
68 |     logExtensionInstallEvent: mockLogExtensionInstallEvent,
69 |     logExtensionUninstall: mockLogExtensionUninstall,
70 |     ExtensionInstallEvent: vi.fn(),
71 |     ExtensionUninstallEvent: vi.fn(),
72 |   };
73 | });
74 | 
75 | describe('update tests', () => {
76 |   let tempHomeDir: string;
77 |   let tempWorkspaceDir: string;
78 |   let userExtensionsDir: string;
79 | 
80 |   beforeEach(() => {
81 |     tempHomeDir = fs.mkdtempSync(
82 |       path.join(os.tmpdir(), 'gemini-cli-test-home-'),
83 |     );
84 |     tempWorkspaceDir = fs.mkdtempSync(
85 |       path.join(tempHomeDir, 'gemini-cli-test-workspace-'),
86 |     );
87 |     vi.mocked(os.homedir).mockReturnValue(tempHomeDir);
88 |     userExtensionsDir = path.join(tempHomeDir, GEMINI_DIR, 'extensions');
89 |     // Clean up before each test
90 |     fs.rmSync(userExtensionsDir, { recursive: true, force: true });
91 |     fs.mkdirSync(userExtensionsDir, { recursive: true });
92 |     vi.mocked(isWorkspaceTrusted).mockReturnValue({
93 |       isTrusted: true,
94 |       source: 'file',
95 |     });
96 |     vi.spyOn(process, 'cwd').mockReturnValue(tempWorkspaceDir);
97 |     Object.values(mockGit).forEach((fn) => fn.mockReset());
98 |   });
99 | 
100 |   afterEach(() => {
101 |     fs.rmSync(tempHomeDir, { recursive: true, force: true });
102 |     fs.rmSync(tempWorkspaceDir, { recursive: true, force: true });
103 |   });
104 | 
105 |   describe('updateExtension', () => {
106 |     it('should update a git-installed extension', async () => {
107 |       const gitUrl = 'https://github.com/google/gemini-extensions.git';
108 |       const extensionName = 'gemini-extensions';
109 |       const targetExtDir = path.join(userExtensionsDir, extensionName);
110 |       const metadataPath = path.join(targetExtDir, INSTALL_METADATA_FILENAME);
111 | 
112 |       fs.mkdirSync(targetExtDir, { recursive: true });
113 |       fs.writeFileSync(
114 |         path.join(targetExtDir, EXTENSIONS_CONFIG_FILENAME),
115 |         JSON.stringify({ name: extensionName, version: '1.0.0' }),
116 |       );
117 |       fs.writeFileSync(
118 |         metadataPath,
119 |         JSON.stringify({ source: gitUrl, type: 'git' }),
120 |       );
121 | 
122 |       mockGit.clone.mockImplementation(async (_, destination) => {
123 |         fs.mkdirSync(path.join(mockGit.path(), destination), {
124 |           recursive: true,
125 |         });
126 |         fs.writeFileSync(
127 |           path.join(mockGit.path(), destination, EXTENSIONS_CONFIG_FILENAME),
128 |           JSON.stringify({ name: extensionName, version: '1.1.0' }),
129 |         );
130 |       });
131 |       mockGit.getRemotes.mockResolvedValue([{ name: 'origin' }]);
132 |       const extension = annotateActiveExtensions(
133 |         [
134 |           loadExtension({
135 |             extensionDir: targetExtDir,
136 |             workspaceDir: tempWorkspaceDir,
137 |           })!,
138 |         ],
139 |         process.cwd(),
140 |         new ExtensionEnablementManager(ExtensionStorage.getUserExtensionsDir()),
141 |       )[0];
142 |       const updateInfo = await updateExtension(
143 |         extension,
144 |         tempHomeDir,
145 |         async (_) => true,
146 |         ExtensionUpdateState.UPDATE_AVAILABLE,
147 |         () => {},
148 |       );
149 | 
150 |       expect(updateInfo).toEqual({
151 |         name: 'gemini-extensions',
152 |         originalVersion: '1.0.0',
153 |         updatedVersion: '1.1.0',
154 |       });
155 | 
156 |       const updatedConfig = JSON.parse(
157 |         fs.readFileSync(
158 |           path.join(targetExtDir, EXTENSIONS_CONFIG_FILENAME),
159 |           'utf-8',
160 |         ),
161 |       );
162 |       expect(updatedConfig.version).toBe('1.1.0');
163 |     });
164 | 
165 |     it('should call setExtensionUpdateState with UPDATING and then UPDATED_NEEDS_RESTART on success', async () => {
166 |       const extensionName = 'test-extension';
167 |       const extensionDir = createExtension({
168 |         extensionsDir: userExtensionsDir,
169 |         name: extensionName,
170 |         version: '1.0.0',
171 |         installMetadata: {
172 |           source: 'https://some.git/repo',
173 |           type: 'git',
174 |         },
175 |       });
176 | 
177 |       mockGit.clone.mockImplementation(async (_, destination) => {
178 |         fs.mkdirSync(path.join(mockGit.path(), destination), {
179 |           recursive: true,
180 |         });
181 |         fs.writeFileSync(
182 |           path.join(mockGit.path(), destination, EXTENSIONS_CONFIG_FILENAME),
183 |           JSON.stringify({ name: extensionName, version: '1.1.0' }),
184 |         );
185 |       });
186 |       mockGit.getRemotes.mockResolvedValue([{ name: 'origin' }]);
187 | 
188 |       const dispatch = vi.fn();
189 |       const extension = annotateActiveExtensions(
190 |         [
191 |           loadExtension({
192 |             extensionDir,
193 |             workspaceDir: tempWorkspaceDir,
194 |           })!,
195 |         ],
196 |         process.cwd(),
197 |         new ExtensionEnablementManager(ExtensionStorage.getUserExtensionsDir()),
198 |       )[0];
199 |       await updateExtension(
200 |         extension,
201 |         tempHomeDir,
202 |         async (_) => true,
203 |         ExtensionUpdateState.UPDATE_AVAILABLE,
204 |         dispatch,
205 |       );
206 | 
207 |       expect(dispatch).toHaveBeenCalledWith({
208 |         type: 'SET_STATE',
209 |         payload: {
210 |           name: extensionName,
211 |           state: ExtensionUpdateState.UPDATING,
212 |         },
213 |       });
214 |       expect(dispatch).toHaveBeenCalledWith({
215 |         type: 'SET_STATE',
216 |         payload: {
217 |           name: extensionName,
218 |           state: ExtensionUpdateState.UPDATED_NEEDS_RESTART,
219 |         },
220 |       });
221 |     });
222 | 
223 |     it('should call setExtensionUpdateState with ERROR on failure', async () => {
224 |       const extensionName = 'test-extension';
225 |       const extensionDir = createExtension({
226 |         extensionsDir: userExtensionsDir,
227 |         name: extensionName,
228 |         version: '1.0.0',
229 |         installMetadata: {
230 |           source: 'https://some.git/repo',
231 |           type: 'git',
232 |         },
233 |       });
234 | 
235 |       mockGit.clone.mockRejectedValue(new Error('Git clone failed'));
236 |       mockGit.getRemotes.mockResolvedValue([{ name: 'origin' }]);
237 | 
238 |       const dispatch = vi.fn();
239 |       const extension = annotateActiveExtensions(
240 |         [
241 |           loadExtension({
242 |             extensionDir,
243 |             workspaceDir: tempWorkspaceDir,
244 |           })!,
245 |         ],
246 |         process.cwd(),
247 |         new ExtensionEnablementManager(ExtensionStorage.getUserExtensionsDir()),
248 |       )[0];
249 |       await expect(
250 |         updateExtension(
251 |           extension,
252 |           tempHomeDir,
253 |           async (_) => true,
254 |           ExtensionUpdateState.UPDATE_AVAILABLE,
255 |           dispatch,
256 |         ),
257 |       ).rejects.toThrow();
258 | 
259 |       expect(dispatch).toHaveBeenCalledWith({
260 |         type: 'SET_STATE',
261 |         payload: {
262 |           name: extensionName,
263 |           state: ExtensionUpdateState.UPDATING,
264 |         },
265 |       });
266 |       expect(dispatch).toHaveBeenCalledWith({
267 |         type: 'SET_STATE',
268 |         payload: {
269 |           name: extensionName,
270 |           state: ExtensionUpdateState.ERROR,
271 |         },
272 |       });
273 |     });
274 |   });
275 | 
276 |   describe('checkForAllExtensionUpdates', () => {
277 |     it('should return UpdateAvailable for a git extension with updates', async () => {
278 |       const extensionDir = createExtension({
279 |         extensionsDir: userExtensionsDir,
280 |         name: 'test-extension',
281 |         version: '1.0.0',
282 |         installMetadata: {
283 |           source: 'https://some.git/repo',
284 |           type: 'git',
285 |         },
286 |       });
287 |       const extension = annotateActiveExtensions(
288 |         [
289 |           loadExtension({
290 |             extensionDir,
291 |             workspaceDir: tempWorkspaceDir,
292 |           })!,
293 |         ],
294 |         process.cwd(),
295 |         new ExtensionEnablementManager(ExtensionStorage.getUserExtensionsDir()),
296 |       )[0];
297 | 
298 |       mockGit.getRemotes.mockResolvedValue([
299 |         { name: 'origin', refs: { fetch: 'https://some.git/repo' } },
300 |       ]);
301 |       mockGit.listRemote.mockResolvedValue('remoteHash	HEAD');
302 |       mockGit.revparse.mockResolvedValue('localHash');
303 | 
304 |       const dispatch = vi.fn();
305 |       await checkForAllExtensionUpdates(
306 |         [extension],
307 |         dispatch,
308 |         tempWorkspaceDir,
309 |       );
310 |       expect(dispatch).toHaveBeenCalledWith({
311 |         type: 'SET_STATE',
312 |         payload: {
313 |           name: 'test-extension',
314 |           state: ExtensionUpdateState.UPDATE_AVAILABLE,
315 |         },
316 |       });
317 |     });
318 | 
319 |     it('should return UpToDate for a git extension with no updates', async () => {
320 |       const extensionDir = createExtension({
321 |         extensionsDir: userExtensionsDir,
322 |         name: 'test-extension',
323 |         version: '1.0.0',
324 |         installMetadata: {
325 |           source: 'https://some.git/repo',
326 |           type: 'git',
327 |         },
328 |       });
329 |       const extension = annotateActiveExtensions(
330 |         [
331 |           loadExtension({
332 |             extensionDir,
333 |             workspaceDir: tempWorkspaceDir,
334 |           })!,
335 |         ],
336 |         process.cwd(),
337 |         new ExtensionEnablementManager(ExtensionStorage.getUserExtensionsDir()),
338 |       )[0];
339 | 
340 |       mockGit.getRemotes.mockResolvedValue([
341 |         { name: 'origin', refs: { fetch: 'https://some.git/repo' } },
342 |       ]);
343 |       mockGit.listRemote.mockResolvedValue('sameHash	HEAD');
344 |       mockGit.revparse.mockResolvedValue('sameHash');
345 | 
346 |       const dispatch = vi.fn();
347 |       await checkForAllExtensionUpdates(
348 |         [extension],
349 |         dispatch,
350 |         tempWorkspaceDir,
351 |       );
352 |       expect(dispatch).toHaveBeenCalledWith({
353 |         type: 'SET_STATE',
354 |         payload: {
355 |           name: 'test-extension',
356 |           state: ExtensionUpdateState.UP_TO_DATE,
357 |         },
358 |       });
359 |     });
360 | 
361 |     it('should return UpToDate for a local extension with no updates', async () => {
362 |       const localExtensionSourcePath = path.join(tempHomeDir, 'local-source');
363 |       const sourceExtensionDir = createExtension({
364 |         extensionsDir: localExtensionSourcePath,
365 |         name: 'my-local-ext',
366 |         version: '1.0.0',
367 |       });
368 | 
369 |       const installedExtensionDir = createExtension({
370 |         extensionsDir: userExtensionsDir,
371 |         name: 'local-extension',
372 |         version: '1.0.0',
373 |         installMetadata: { source: sourceExtensionDir, type: 'local' },
374 |       });
375 |       const extension = annotateActiveExtensions(
376 |         [
377 |           loadExtension({
378 |             extensionDir: installedExtensionDir,
379 |             workspaceDir: tempWorkspaceDir,
380 |           })!,
381 |         ],
382 |         process.cwd(),
383 |         new ExtensionEnablementManager(ExtensionStorage.getUserExtensionsDir()),
384 |       )[0];
385 |       const dispatch = vi.fn();
386 |       await checkForAllExtensionUpdates(
387 |         [extension],
388 |         dispatch,
389 |         tempWorkspaceDir,
390 |       );
391 |       expect(dispatch).toHaveBeenCalledWith({
392 |         type: 'SET_STATE',
393 |         payload: {
394 |           name: 'local-extension',
395 |           state: ExtensionUpdateState.UP_TO_DATE,
396 |         },
397 |       });
398 |     });
399 | 
400 |     it('should return UpdateAvailable for a local extension with updates', async () => {
401 |       const localExtensionSourcePath = path.join(tempHomeDir, 'local-source');
402 |       const sourceExtensionDir = createExtension({
403 |         extensionsDir: localExtensionSourcePath,
404 |         name: 'my-local-ext',
405 |         version: '1.1.0',
406 |       });
407 | 
408 |       const installedExtensionDir = createExtension({
409 |         extensionsDir: userExtensionsDir,
410 |         name: 'local-extension',
411 |         version: '1.0.0',
412 |         installMetadata: { source: sourceExtensionDir, type: 'local' },
[TRUNCATED]
```

src/config/extensions/update.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import {
8 |   type ExtensionUpdateAction,
9 |   ExtensionUpdateState,
10 |   type ExtensionUpdateStatus,
11 | } from '../../ui/state/extensions.js';
12 | import {
13 |   copyExtension,
14 |   installOrUpdateExtension,
15 |   loadExtension,
16 |   loadInstallMetadata,
17 |   ExtensionStorage,
18 |   loadExtensionConfig,
19 | } from '../extension.js';
20 | import { checkForExtensionUpdate } from './github.js';
21 | import type { GeminiCLIExtension } from '@google/gemini-cli-core';
22 | import * as fs from 'node:fs';
23 | import { getErrorMessage } from '../../utils/errors.js';
24 | 
25 | export interface ExtensionUpdateInfo {
26 |   name: string;
27 |   originalVersion: string;
28 |   updatedVersion: string;
29 | }
30 | 
31 | export async function updateExtension(
32 |   extension: GeminiCLIExtension,
33 |   cwd: string = process.cwd(),
34 |   requestConsent: (consent: string) => Promise<boolean>,
35 |   currentState: ExtensionUpdateState,
36 |   dispatchExtensionStateUpdate: (action: ExtensionUpdateAction) => void,
37 | ): Promise<ExtensionUpdateInfo | undefined> {
38 |   if (currentState === ExtensionUpdateState.UPDATING) {
39 |     return undefined;
40 |   }
41 |   dispatchExtensionStateUpdate({
42 |     type: 'SET_STATE',
43 |     payload: { name: extension.name, state: ExtensionUpdateState.UPDATING },
44 |   });
45 |   const installMetadata = loadInstallMetadata(extension.path);
46 | 
47 |   if (!installMetadata?.type) {
48 |     dispatchExtensionStateUpdate({
49 |       type: 'SET_STATE',
50 |       payload: { name: extension.name, state: ExtensionUpdateState.ERROR },
51 |     });
52 |     throw new Error(
53 |       `Extension ${extension.name} cannot be updated, type is unknown.`,
54 |     );
55 |   }
56 |   if (installMetadata?.type === 'link') {
57 |     dispatchExtensionStateUpdate({
58 |       type: 'SET_STATE',
59 |       payload: { name: extension.name, state: ExtensionUpdateState.UP_TO_DATE },
60 |     });
61 |     throw new Error(`Extension is linked so does not need to be updated`);
62 |   }
63 |   const originalVersion = extension.version;
64 | 
65 |   const tempDir = await ExtensionStorage.createTmpDir();
66 |   try {
67 |     const previousExtensionConfig = await loadExtensionConfig({
68 |       extensionDir: extension.path,
69 |       workspaceDir: cwd,
70 |     });
71 |     await installOrUpdateExtension(
72 |       installMetadata,
73 |       requestConsent,
74 |       cwd,
75 |       previousExtensionConfig,
76 |     );
77 | 
78 |     const updatedExtensionStorage = new ExtensionStorage(extension.name);
79 |     const updatedExtension = loadExtension({
80 |       extensionDir: updatedExtensionStorage.getExtensionDir(),
81 |       workspaceDir: cwd,
82 |     });
83 |     if (!updatedExtension) {
84 |       dispatchExtensionStateUpdate({
85 |         type: 'SET_STATE',
86 |         payload: { name: extension.name, state: ExtensionUpdateState.ERROR },
87 |       });
88 |       throw new Error('Updated extension not found after installation.');
89 |     }
90 |     const updatedVersion = updatedExtension.version;
91 |     dispatchExtensionStateUpdate({
92 |       type: 'SET_STATE',
93 |       payload: {
94 |         name: extension.name,
95 |         state: ExtensionUpdateState.UPDATED_NEEDS_RESTART,
96 |       },
97 |     });
98 |     return {
99 |       name: extension.name,
100 |       originalVersion,
101 |       updatedVersion,
102 |     };
103 |   } catch (e) {
104 |     console.error(
105 |       `Error updating extension, rolling back. ${getErrorMessage(e)}`,
106 |     );
107 |     dispatchExtensionStateUpdate({
108 |       type: 'SET_STATE',
109 |       payload: { name: extension.name, state: ExtensionUpdateState.ERROR },
110 |     });
111 |     await copyExtension(tempDir, extension.path);
112 |     throw e;
113 |   } finally {
114 |     await fs.promises.rm(tempDir, { recursive: true, force: true });
115 |   }
116 | }
117 | 
118 | export async function updateAllUpdatableExtensions(
119 |   cwd: string = process.cwd(),
120 |   requestConsent: (consent: string) => Promise<boolean>,
121 |   extensions: GeminiCLIExtension[],
122 |   extensionsState: Map<string, ExtensionUpdateStatus>,
123 |   dispatch: (action: ExtensionUpdateAction) => void,
124 | ): Promise<ExtensionUpdateInfo[]> {
125 |   return (
126 |     await Promise.all(
127 |       extensions
128 |         .filter(
129 |           (extension) =>
130 |             extensionsState.get(extension.name)?.status ===
131 |             ExtensionUpdateState.UPDATE_AVAILABLE,
132 |         )
133 |         .map((extension) =>
134 |           updateExtension(
135 |             extension,
136 |             cwd,
137 |             requestConsent,
138 |             extensionsState.get(extension.name)!.status,
139 |             dispatch,
140 |           ),
141 |         ),
142 |     )
143 |   ).filter((updateInfo) => !!updateInfo);
144 | }
145 | 
146 | export interface ExtensionUpdateCheckResult {
147 |   state: ExtensionUpdateState;
148 |   error?: string;
149 | }
150 | 
151 | export async function checkForAllExtensionUpdates(
152 |   extensions: GeminiCLIExtension[],
153 |   dispatch: (action: ExtensionUpdateAction) => void,
154 |   cwd: string = process.cwd(),
155 | ): Promise<void> {
156 |   dispatch({ type: 'BATCH_CHECK_START' });
157 |   const promises: Array<Promise<void>> = [];
158 |   for (const extension of extensions) {
159 |     if (!extension.installMetadata) {
160 |       dispatch({
161 |         type: 'SET_STATE',
162 |         payload: {
163 |           name: extension.name,
164 |           state: ExtensionUpdateState.NOT_UPDATABLE,
165 |         },
166 |       });
167 |       continue;
168 |     }
169 |     dispatch({
170 |       type: 'SET_STATE',
171 |       payload: {
172 |         name: extension.name,
173 |         state: ExtensionUpdateState.CHECKING_FOR_UPDATES,
174 |       },
175 |     });
176 |     promises.push(
177 |       checkForExtensionUpdate(extension, cwd).then((state) =>
178 |         dispatch({
179 |           type: 'SET_STATE',
180 |           payload: { name: extension.name, state },
181 |         }),
182 |       ),
183 |     );
184 |   }
185 |   await Promise.all(promises);
186 |   dispatch({ type: 'BATCH_CHECK_END' });
187 | }
```

src/config/extensions/variableSchema.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | export interface VariableDefinition {
8 |   type: 'string';
9 |   description: string;
10 |   default?: string;
11 |   required?: boolean;
12 | }
13 | 
14 | export interface VariableSchema {
15 |   [key: string]: VariableDefinition;
16 | }
17 | 
18 | export interface LoadExtensionContext {
19 |   extensionDir: string;
20 |   workspaceDir: string;
21 | }
22 | 
23 | const PATH_SEPARATOR_DEFINITION = {
24 |   type: 'string',
25 |   description: 'The path separator.',
26 | } as const;
27 | 
28 | export const VARIABLE_SCHEMA = {
29 |   extensionPath: {
30 |     type: 'string',
31 |     description: 'The path of the extension in the filesystem.',
32 |   },
33 |   workspacePath: {
34 |     type: 'string',
35 |     description: 'The absolute path of the current workspace.',
36 |   },
37 |   '/': PATH_SEPARATOR_DEFINITION,
38 |   pathSeparator: PATH_SEPARATOR_DEFINITION,
39 | } as const;
```

src/config/extensions/variables.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { expect, describe, it } from 'vitest';
8 | import { hydrateString } from './variables.js';
9 | 
10 | describe('hydrateString', () => {
11 |   it('should replace a single variable', () => {
12 |     const context = {
13 |       extensionPath: 'path/my-extension',
14 |     };
15 |     const result = hydrateString('Hello, ${extensionPath}!', context);
16 |     expect(result).toBe('Hello, path/my-extension!');
17 |   });
18 | });
```

src/config/extensions/variables.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { type VariableSchema, VARIABLE_SCHEMA } from './variableSchema.js';
8 | 
9 | export type JsonObject = { [key: string]: JsonValue };
10 | export type JsonArray = JsonValue[];
11 | export type JsonValue =
12 |   | string
13 |   | number
14 |   | boolean
15 |   | null
16 |   | JsonObject
17 |   | JsonArray;
18 | 
19 | export type VariableContext = {
20 |   [key in keyof typeof VARIABLE_SCHEMA]?: string;
21 | };
22 | 
23 | export function validateVariables(
24 |   variables: VariableContext,
25 |   schema: VariableSchema,
26 | ) {
27 |   for (const key in schema) {
28 |     const definition = schema[key];
29 |     if (definition.required && !variables[key as keyof VariableContext]) {
30 |       throw new Error(`Missing required variable: ${key}`);
31 |     }
32 |   }
33 | }
34 | 
35 | export function hydrateString(str: string, context: VariableContext): string {
36 |   validateVariables(context, VARIABLE_SCHEMA);
37 |   const regex = /\${(.*?)}/g;
38 |   return str.replace(regex, (match, key) =>
39 |     context[key as keyof VariableContext] == null
40 |       ? match
41 |       : (context[key as keyof VariableContext] as string),
42 |   );
43 | }
44 | 
45 | export function recursivelyHydrateStrings(
46 |   obj: JsonValue,
47 |   values: VariableContext,
48 | ): JsonValue {
49 |   if (typeof obj === 'string') {
50 |     return hydrateString(obj, values);
51 |   }
52 |   if (Array.isArray(obj)) {
53 |     return obj.map((item) => recursivelyHydrateStrings(item, values));
54 |   }
55 |   if (typeof obj === 'object' && obj !== null) {
56 |     const newObj: JsonObject = {};
57 |     for (const key in obj) {
58 |       if (Object.prototype.hasOwnProperty.call(obj, key)) {
59 |         newObj[key] = recursivelyHydrateStrings(obj[key], values);
60 |       }
61 |     }
62 |     return newObj;
63 |   }
64 |   return obj;
65 | }
```

src/services/prompt-processors/argumentProcessor.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { DefaultArgumentProcessor } from './argumentProcessor.js';
8 | import { createMockCommandContext } from '../../test-utils/mockCommandContext.js';
9 | import { describe, it, expect } from 'vitest';
10 | 
11 | describe('Argument Processors', () => {
12 |   describe('DefaultArgumentProcessor', () => {
13 |     const processor = new DefaultArgumentProcessor();
14 | 
15 |     it('should append the full command if args are provided', async () => {
16 |       const prompt = [{ text: 'Parse the command.' }];
17 |       const context = createMockCommandContext({
18 |         invocation: {
19 |           raw: '/mycommand arg1 "arg two"',
20 |           name: 'mycommand',
21 |           args: 'arg1 "arg two"',
22 |         },
23 |       });
24 |       const result = await processor.process(prompt, context);
25 |       expect(result).toEqual([
26 |         { text: 'Parse the command.\n\n/mycommand arg1 "arg two"' },
27 |       ]);
28 |     });
29 | 
30 |     it('should NOT append the full command if no args are provided', async () => {
31 |       const prompt = [{ text: 'Parse the command.' }];
32 |       const context = createMockCommandContext({
33 |         invocation: {
34 |           raw: '/mycommand',
35 |           name: 'mycommand',
36 |           args: '',
37 |         },
38 |       });
39 |       const result = await processor.process(prompt, context);
40 |       expect(result).toEqual([{ text: 'Parse the command.' }]);
41 |     });
42 |   });
43 | });
```

src/services/prompt-processors/argumentProcessor.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { appendToLastTextPart } from '@google/gemini-cli-core';
8 | import type { IPromptProcessor, PromptPipelineContent } from './types.js';
9 | import type { CommandContext } from '../../ui/commands/types.js';
10 | 
11 | /**
12 |  * Appends the user's full command invocation to the prompt if arguments are
13 |  * provided, allowing the model to perform its own argument parsing.
14 |  *
15 |  * This processor is only used if the prompt does NOT contain {{args}}.
16 |  */
17 | export class DefaultArgumentProcessor implements IPromptProcessor {
18 |   async process(
19 |     prompt: PromptPipelineContent,
20 |     context: CommandContext,
21 |   ): Promise<PromptPipelineContent> {
22 |     if (context.invocation?.args) {
23 |       return appendToLastTextPart(prompt, context.invocation.raw);
24 |     }
25 |     return prompt;
26 |   }
27 | }
```

src/services/prompt-processors/atFileProcessor.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect, beforeEach, vi } from 'vitest';
8 | import { createMockCommandContext } from '../../test-utils/mockCommandContext.js';
9 | import { type CommandContext } from '../../ui/commands/types.js';
10 | import { AtFileProcessor } from './atFileProcessor.js';
11 | import { MessageType } from '../../ui/types.js';
12 | import type { Config } from '@google/gemini-cli-core';
13 | import type { PartUnion } from '@google/genai';
14 | 
15 | // Mock the core dependency
16 | const mockReadPathFromWorkspace = vi.hoisted(() => vi.fn());
17 | vi.mock('@google/gemini-cli-core', async (importOriginal) => {
18 |   const original = await importOriginal<object>();
19 |   return {
20 |     ...original,
21 |     readPathFromWorkspace: mockReadPathFromWorkspace,
22 |   };
23 | });
24 | 
25 | describe('AtFileProcessor', () => {
26 |   let context: CommandContext;
27 |   let mockConfig: Config;
28 | 
29 |   beforeEach(() => {
30 |     vi.clearAllMocks();
31 | 
32 |     mockConfig = {
33 |       // The processor only passes the config through, so we don't need a full mock.
34 |     } as unknown as Config;
35 | 
36 |     context = createMockCommandContext({
37 |       services: {
38 |         config: mockConfig,
39 |       },
40 |     });
41 | 
42 |     // Default mock success behavior: return content wrapped in a text part.
43 |     mockReadPathFromWorkspace.mockImplementation(
44 |       async (path: string): Promise<PartUnion[]> => [
45 |         { text: `content of ${path}` },
46 |       ],
47 |     );
48 |   });
49 | 
50 |   it('should not change the prompt if no @{ trigger is present', async () => {
51 |     const processor = new AtFileProcessor();
52 |     const prompt: PartUnion[] = [{ text: 'This is a simple prompt.' }];
53 |     const result = await processor.process(prompt, context);
54 |     expect(result).toEqual(prompt);
55 |     expect(mockReadPathFromWorkspace).not.toHaveBeenCalled();
56 |   });
57 | 
58 |   it('should not change the prompt if config service is missing', async () => {
59 |     const processor = new AtFileProcessor();
60 |     const prompt: PartUnion[] = [{ text: 'Analyze @{file.txt}' }];
61 |     const contextWithoutConfig = createMockCommandContext({
62 |       services: {
63 |         config: null,
64 |       },
65 |     });
66 |     const result = await processor.process(prompt, contextWithoutConfig);
67 |     expect(result).toEqual(prompt);
68 |     expect(mockReadPathFromWorkspace).not.toHaveBeenCalled();
69 |   });
70 | 
71 |   describe('Parsing Logic', () => {
72 |     it('should replace a single valid @{path/to/file.txt} placeholder', async () => {
73 |       const processor = new AtFileProcessor();
74 |       const prompt: PartUnion[] = [
75 |         { text: 'Analyze this file: @{path/to/file.txt}' },
76 |       ];
77 |       const result = await processor.process(prompt, context);
78 |       expect(mockReadPathFromWorkspace).toHaveBeenCalledWith(
79 |         'path/to/file.txt',
80 |         mockConfig,
81 |       );
82 |       expect(result).toEqual([
83 |         { text: 'Analyze this file: ' },
84 |         { text: 'content of path/to/file.txt' },
85 |       ]);
86 |     });
87 | 
88 |     it('should replace multiple different @{...} placeholders', async () => {
89 |       const processor = new AtFileProcessor();
90 |       const prompt: PartUnion[] = [
91 |         { text: 'Compare @{file1.js} with @{file2.js}' },
92 |       ];
93 |       const result = await processor.process(prompt, context);
94 |       expect(mockReadPathFromWorkspace).toHaveBeenCalledTimes(2);
95 |       expect(mockReadPathFromWorkspace).toHaveBeenCalledWith(
96 |         'file1.js',
97 |         mockConfig,
98 |       );
99 |       expect(mockReadPathFromWorkspace).toHaveBeenCalledWith(
100 |         'file2.js',
101 |         mockConfig,
102 |       );
103 |       expect(result).toEqual([
104 |         { text: 'Compare ' },
105 |         { text: 'content of file1.js' },
106 |         { text: ' with ' },
107 |         { text: 'content of file2.js' },
108 |       ]);
109 |     });
110 | 
111 |     it('should handle placeholders at the beginning, middle, and end', async () => {
112 |       const processor = new AtFileProcessor();
113 |       const prompt: PartUnion[] = [
114 |         { text: '@{start.txt} in the @{middle.txt} and @{end.txt}' },
115 |       ];
116 |       const result = await processor.process(prompt, context);
117 |       expect(result).toEqual([
118 |         { text: 'content of start.txt' },
119 |         { text: ' in the ' },
120 |         { text: 'content of middle.txt' },
121 |         { text: ' and ' },
122 |         { text: 'content of end.txt' },
123 |       ]);
124 |     });
125 | 
126 |     it('should correctly parse paths that contain balanced braces', async () => {
127 |       const processor = new AtFileProcessor();
128 |       const prompt: PartUnion[] = [
129 |         { text: 'Analyze @{path/with/{braces}/file.txt}' },
130 |       ];
131 |       const result = await processor.process(prompt, context);
132 |       expect(mockReadPathFromWorkspace).toHaveBeenCalledWith(
133 |         'path/with/{braces}/file.txt',
134 |         mockConfig,
135 |       );
136 |       expect(result).toEqual([
137 |         { text: 'Analyze ' },
138 |         { text: 'content of path/with/{braces}/file.txt' },
139 |       ]);
140 |     });
141 | 
142 |     it('should throw an error if the prompt contains an unclosed trigger', async () => {
143 |       const processor = new AtFileProcessor();
144 |       const prompt: PartUnion[] = [{ text: 'Hello @{world' }];
145 |       // The new parser throws an error for unclosed injections.
146 |       await expect(processor.process(prompt, context)).rejects.toThrow(
147 |         /Unclosed injection/,
148 |       );
149 |     });
150 |   });
151 | 
152 |   describe('Integration and Error Handling', () => {
153 |     it('should leave the placeholder unmodified if readPathFromWorkspace throws', async () => {
154 |       const processor = new AtFileProcessor();
155 |       const prompt: PartUnion[] = [
156 |         { text: 'Analyze @{not-found.txt} and @{good-file.txt}' },
157 |       ];
158 |       mockReadPathFromWorkspace.mockImplementation(async (path: string) => {
159 |         if (path === 'not-found.txt') {
160 |           throw new Error('File not found');
161 |         }
162 |         return [{ text: `content of ${path}` }];
163 |       });
164 | 
165 |       const result = await processor.process(prompt, context);
166 |       expect(result).toEqual([
167 |         { text: 'Analyze ' },
168 |         { text: '@{not-found.txt}' }, // Placeholder is preserved as a text part
169 |         { text: ' and ' },
170 |         { text: 'content of good-file.txt' },
171 |       ]);
172 |     });
173 |   });
174 | 
175 |   describe('UI Feedback', () => {
176 |     it('should call ui.addItem with an ERROR on failure', async () => {
177 |       const processor = new AtFileProcessor();
178 |       const prompt: PartUnion[] = [{ text: 'Analyze @{bad-file.txt}' }];
179 |       mockReadPathFromWorkspace.mockRejectedValue(new Error('Access denied'));
180 | 
181 |       await processor.process(prompt, context);
182 | 
183 |       expect(context.ui.addItem).toHaveBeenCalledTimes(1);
184 |       expect(context.ui.addItem).toHaveBeenCalledWith(
185 |         {
186 |           type: MessageType.ERROR,
187 |           text: "Failed to inject content for '@{bad-file.txt}': Access denied",
188 |         },
189 |         expect.any(Number),
190 |       );
191 |     });
192 | 
193 |     it('should call ui.addItem with a WARNING if the file was ignored', async () => {
194 |       const processor = new AtFileProcessor();
195 |       const prompt: PartUnion[] = [{ text: 'Analyze @{ignored.txt}' }];
196 |       // Simulate an ignored file by returning an empty array.
197 |       mockReadPathFromWorkspace.mockResolvedValue([]);
198 | 
199 |       const result = await processor.process(prompt, context);
200 | 
201 |       // The placeholder should be removed, resulting in only the prefix.
202 |       expect(result).toEqual([{ text: 'Analyze ' }]);
203 | 
204 |       expect(context.ui.addItem).toHaveBeenCalledTimes(1);
205 |       expect(context.ui.addItem).toHaveBeenCalledWith(
206 |         {
207 |           type: MessageType.INFO,
208 |           text: "File '@{ignored.txt}' was ignored by .gitignore or .geminiignore and was not included in the prompt.",
209 |         },
210 |         expect.any(Number),
211 |       );
212 |     });
213 | 
214 |     it('should NOT call ui.addItem on success', async () => {
215 |       const processor = new AtFileProcessor();
216 |       const prompt: PartUnion[] = [{ text: 'Analyze @{good-file.txt}' }];
217 |       await processor.process(prompt, context);
218 |       expect(context.ui.addItem).not.toHaveBeenCalled();
219 |     });
220 |   });
221 | });
```

src/services/prompt-processors/atFileProcessor.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import {
8 |   flatMapTextParts,
9 |   readPathFromWorkspace,
10 | } from '@google/gemini-cli-core';
11 | import type { CommandContext } from '../../ui/commands/types.js';
12 | import { MessageType } from '../../ui/types.js';
13 | import {
14 |   AT_FILE_INJECTION_TRIGGER,
15 |   type IPromptProcessor,
16 |   type PromptPipelineContent,
17 | } from './types.js';
18 | import { extractInjections } from './injectionParser.js';
19 | 
20 | export class AtFileProcessor implements IPromptProcessor {
21 |   constructor(private readonly commandName?: string) {}
22 | 
23 |   async process(
24 |     input: PromptPipelineContent,
25 |     context: CommandContext,
26 |   ): Promise<PromptPipelineContent> {
27 |     const config = context.services.config;
28 |     if (!config) {
29 |       return input;
30 |     }
31 | 
32 |     return flatMapTextParts(input, async (text) => {
33 |       if (!text.includes(AT_FILE_INJECTION_TRIGGER)) {
34 |         return [{ text }];
35 |       }
36 | 
37 |       const injections = extractInjections(
38 |         text,
39 |         AT_FILE_INJECTION_TRIGGER,
40 |         this.commandName,
41 |       );
42 |       if (injections.length === 0) {
43 |         return [{ text }];
44 |       }
45 | 
46 |       const output: PromptPipelineContent = [];
47 |       let lastIndex = 0;
48 | 
49 |       for (const injection of injections) {
50 |         const prefix = text.substring(lastIndex, injection.startIndex);
51 |         if (prefix) {
52 |           output.push({ text: prefix });
53 |         }
54 | 
55 |         const pathStr = injection.content;
56 |         try {
57 |           const fileContentParts = await readPathFromWorkspace(pathStr, config);
58 |           if (fileContentParts.length === 0) {
59 |             const uiMessage = `File '@{${pathStr}}' was ignored by .gitignore or .geminiignore and was not included in the prompt.`;
60 |             context.ui.addItem(
61 |               { type: MessageType.INFO, text: uiMessage },
62 |               Date.now(),
63 |             );
64 |           }
65 |           output.push(...fileContentParts);
66 |         } catch (error) {
67 |           const message =
68 |             error instanceof Error ? error.message : String(error);
69 |           const uiMessage = `Failed to inject content for '@{${pathStr}}': ${message}`;
70 | 
71 |           console.error(
72 |             `[AtFileProcessor] ${uiMessage}. Leaving placeholder in prompt.`,
73 |           );
74 |           context.ui.addItem(
75 |             { type: MessageType.ERROR, text: uiMessage },
76 |             Date.now(),
77 |           );
78 | 
79 |           const placeholder = text.substring(
80 |             injection.startIndex,
81 |             injection.endIndex,
82 |           );
83 |           output.push({ text: placeholder });
84 |         }
85 |         lastIndex = injection.endIndex;
86 |       }
87 | 
88 |       const suffix = text.substring(lastIndex);
89 |       if (suffix) {
90 |         output.push({ text: suffix });
91 |       }
92 | 
93 |       return output;
94 |     });
95 |   }
96 | }
```

src/services/prompt-processors/injectionParser.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect } from 'vitest';
8 | import { extractInjections } from './injectionParser.js';
9 | 
10 | describe('extractInjections', () => {
11 |   const SHELL_TRIGGER = '!{';
12 |   const AT_FILE_TRIGGER = '@{';
13 | 
14 |   describe('Basic Functionality', () => {
15 |     it('should return an empty array if no trigger is present', () => {
16 |       const prompt = 'This is a simple prompt without injections.';
17 |       const result = extractInjections(prompt, SHELL_TRIGGER);
18 |       expect(result).toEqual([]);
19 |     });
20 | 
21 |     it('should extract a single, simple injection', () => {
22 |       const prompt = 'Run this command: !{ls -la}';
23 |       const result = extractInjections(prompt, SHELL_TRIGGER);
24 |       expect(result).toEqual([
25 |         {
26 |           content: 'ls -la',
27 |           startIndex: 18,
28 |           endIndex: 27,
29 |         },
30 |       ]);
31 |     });
32 | 
33 |     it('should extract multiple injections', () => {
34 |       const prompt = 'First: !{cmd1}, Second: !{cmd2}';
35 |       const result = extractInjections(prompt, SHELL_TRIGGER);
36 |       expect(result).toHaveLength(2);
37 |       expect(result[0]).toEqual({
38 |         content: 'cmd1',
39 |         startIndex: 7,
40 |         endIndex: 14,
41 |       });
42 |       expect(result[1]).toEqual({
43 |         content: 'cmd2',
44 |         startIndex: 24,
45 |         endIndex: 31,
46 |       });
47 |     });
48 | 
49 |     it('should handle different triggers (e.g., @{)', () => {
50 |       const prompt = 'Read this file: @{path/to/file.txt}';
51 |       const result = extractInjections(prompt, AT_FILE_TRIGGER);
52 |       expect(result).toEqual([
53 |         {
54 |           content: 'path/to/file.txt',
55 |           startIndex: 16,
56 |           endIndex: 35,
57 |         },
58 |       ]);
59 |     });
60 |   });
61 | 
62 |   describe('Positioning and Edge Cases', () => {
63 |     it('should handle injections at the start and end of the prompt', () => {
64 |       const prompt = '!{start} middle text !{end}';
65 |       const result = extractInjections(prompt, SHELL_TRIGGER);
66 |       expect(result).toHaveLength(2);
67 |       expect(result[0]).toEqual({
68 |         content: 'start',
69 |         startIndex: 0,
70 |         endIndex: 8,
71 |       });
72 |       expect(result[1]).toEqual({
73 |         content: 'end',
74 |         startIndex: 21,
75 |         endIndex: 27,
76 |       });
77 |     });
78 | 
79 |     it('should handle adjacent injections', () => {
80 |       const prompt = '!{A}!{B}';
81 |       const result = extractInjections(prompt, SHELL_TRIGGER);
82 |       expect(result).toHaveLength(2);
83 |       expect(result[0]).toEqual({ content: 'A', startIndex: 0, endIndex: 4 });
84 |       expect(result[1]).toEqual({ content: 'B', startIndex: 4, endIndex: 8 });
85 |     });
86 | 
87 |     it('should handle empty injections', () => {
88 |       const prompt = 'Empty: !{}';
89 |       const result = extractInjections(prompt, SHELL_TRIGGER);
90 |       expect(result).toEqual([
91 |         {
92 |           content: '',
93 |           startIndex: 7,
94 |           endIndex: 10,
95 |         },
96 |       ]);
97 |     });
98 | 
99 |     it('should trim whitespace within the content', () => {
100 |       const prompt = '!{  \n command with space  \t }';
101 |       const result = extractInjections(prompt, SHELL_TRIGGER);
102 |       expect(result).toEqual([
103 |         {
104 |           content: 'command with space',
105 |           startIndex: 0,
106 |           endIndex: 29,
107 |         },
108 |       ]);
109 |     });
110 | 
111 |     it('should ignore similar patterns that are not the exact trigger', () => {
112 |       const prompt = 'Not a trigger: !(cmd) or {cmd} or ! {cmd}';
113 |       const result = extractInjections(prompt, SHELL_TRIGGER);
114 |       expect(result).toEqual([]);
115 |     });
116 | 
117 |     it('should ignore extra closing braces before the trigger', () => {
118 |       const prompt = 'Ignore this } then !{run}';
119 |       const result = extractInjections(prompt, SHELL_TRIGGER);
120 |       expect(result).toEqual([
121 |         {
122 |           content: 'run',
123 |           startIndex: 19,
124 |           endIndex: 25,
125 |         },
126 |       ]);
127 |     });
128 | 
129 |     it('should stop parsing at the first balanced closing brace (non-greedy)', () => {
130 |       // This tests that the parser doesn't greedily consume extra closing braces
131 |       const prompt = 'Run !{ls -l}} extra braces';
132 |       const result = extractInjections(prompt, SHELL_TRIGGER);
133 |       expect(result).toEqual([
134 |         {
135 |           content: 'ls -l',
136 |           startIndex: 4,
137 |           endIndex: 12,
138 |         },
139 |       ]);
140 |     });
141 |   });
142 | 
143 |   describe('Nested Braces (Balanced)', () => {
144 |     it('should correctly parse content with simple nested braces (e.g., JSON)', () => {
145 |       const prompt = `Send JSON: !{curl -d '{"key": "value"}'}`;
146 |       const result = extractInjections(prompt, SHELL_TRIGGER);
147 |       expect(result).toHaveLength(1);
148 |       expect(result[0].content).toBe(`curl -d '{"key": "value"}'`);
149 |     });
150 | 
151 |     it('should correctly parse content with shell constructs (e.g., awk)', () => {
152 |       const prompt = `Process text: !{awk '{print $1}' file.txt}`;
153 |       const result = extractInjections(prompt, SHELL_TRIGGER);
154 |       expect(result).toHaveLength(1);
155 |       expect(result[0].content).toBe(`awk '{print $1}' file.txt`);
156 |     });
157 | 
158 |     it('should correctly parse multiple levels of nesting', () => {
159 |       const prompt = `!{level1 {level2 {level3}} suffix}`;
160 |       const result = extractInjections(prompt, SHELL_TRIGGER);
161 |       expect(result).toHaveLength(1);
162 |       expect(result[0].content).toBe(`level1 {level2 {level3}} suffix`);
163 |       expect(result[0].endIndex).toBe(prompt.length);
164 |     });
165 | 
166 |     it('should correctly parse paths containing balanced braces', () => {
167 |       const prompt = 'Analyze @{path/with/{braces}/file.txt}';
168 |       const result = extractInjections(prompt, AT_FILE_TRIGGER);
169 |       expect(result).toHaveLength(1);
170 |       expect(result[0].content).toBe('path/with/{braces}/file.txt');
171 |     });
172 | 
173 |     it('should correctly handle an injection containing the trigger itself', () => {
174 |       // This works because the parser counts braces, it doesn't look for the trigger again until the current one is closed.
175 |       const prompt = '!{echo "The trigger is !{ confusing }"}';
176 |       const expectedContent = 'echo "The trigger is !{ confusing }"';
177 |       const result = extractInjections(prompt, SHELL_TRIGGER);
178 |       expect(result).toHaveLength(1);
179 |       expect(result[0].content).toBe(expectedContent);
180 |     });
181 |   });
182 | 
183 |   describe('Error Handling (Unbalanced/Unclosed)', () => {
184 |     it('should throw an error for a simple unclosed injection', () => {
185 |       const prompt = 'This prompt has !{an unclosed trigger';
186 |       expect(() => extractInjections(prompt, SHELL_TRIGGER)).toThrow(
187 |         /Invalid syntax: Unclosed injection starting at index 16 \('!{'\)/,
188 |       );
189 |     });
190 | 
191 |     it('should throw an error if the prompt ends inside a nested block', () => {
192 |       const prompt = 'This fails: !{outer {inner';
193 |       expect(() => extractInjections(prompt, SHELL_TRIGGER)).toThrow(
194 |         /Invalid syntax: Unclosed injection starting at index 12 \('!{'\)/,
195 |       );
196 |     });
197 | 
198 |     it('should include the context name in the error message if provided', () => {
199 |       const prompt = 'Failing !{command';
200 |       const contextName = 'test-command';
201 |       expect(() =>
202 |         extractInjections(prompt, SHELL_TRIGGER, contextName),
203 |       ).toThrow(
204 |         /Invalid syntax in command 'test-command': Unclosed injection starting at index 8/,
205 |       );
206 |     });
207 | 
208 |     it('should throw if content contains unbalanced braces (e.g., missing closing)', () => {
209 |       // This is functionally the same as an unclosed injection from the parser's perspective.
210 |       const prompt = 'Analyze @{path/with/braces{example.txt}';
211 |       expect(() => extractInjections(prompt, AT_FILE_TRIGGER)).toThrow(
212 |         /Invalid syntax: Unclosed injection starting at index 8 \('@{'\)/,
213 |       );
214 |     });
215 | 
216 |     it('should clearly state that unbalanced braces in content are not supported in the error', () => {
217 |       const prompt = 'Analyze @{path/with/braces{example.txt}';
218 |       expect(() => extractInjections(prompt, AT_FILE_TRIGGER)).toThrow(
219 |         /Paths or commands with unbalanced braces are not supported directly/,
220 |       );
221 |     });
222 |   });
223 | });
```

src/services/prompt-processors/injectionParser.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | /**
8 |  * Represents a single detected injection site in a prompt string.
9 |  */
10 | export interface Injection {
11 |   /** The content extracted from within the braces (e.g., the command or path), trimmed. */
12 |   content: string;
13 |   /** The starting index of the injection (inclusive, points to the start of the trigger). */
14 |   startIndex: number;
15 |   /** The ending index of the injection (exclusive, points after the closing '}'). */
16 |   endIndex: number;
17 | }
18 | 
19 | /**
20 |  * Iteratively parses a prompt string to extract injections (e.g., !{...} or @{...}),
21 |  * correctly handling nested braces within the content.
22 |  *
23 |  * This parser relies on simple brace counting and does not support escaping.
24 |  *
25 |  * @param prompt The prompt string to parse.
26 |  * @param trigger The opening trigger sequence (e.g., '!{', '@{').
27 |  * @param contextName Optional context name (e.g., command name) for error messages.
28 |  * @returns An array of extracted Injection objects.
29 |  * @throws Error if an unclosed injection is found.
30 |  */
31 | export function extractInjections(
32 |   prompt: string,
33 |   trigger: string,
34 |   contextName?: string,
35 | ): Injection[] {
36 |   const injections: Injection[] = [];
37 |   let index = 0;
38 | 
39 |   while (index < prompt.length) {
40 |     const startIndex = prompt.indexOf(trigger, index);
41 | 
42 |     if (startIndex === -1) {
43 |       break;
44 |     }
45 | 
46 |     let currentIndex = startIndex + trigger.length;
47 |     let braceCount = 1;
48 |     let foundEnd = false;
49 | 
50 |     while (currentIndex < prompt.length) {
51 |       const char = prompt[currentIndex];
52 | 
53 |       if (char === '{') {
54 |         braceCount++;
55 |       } else if (char === '}') {
56 |         braceCount--;
57 |         if (braceCount === 0) {
58 |           const injectionContent = prompt.substring(
59 |             startIndex + trigger.length,
60 |             currentIndex,
61 |           );
62 |           const endIndex = currentIndex + 1;
63 | 
64 |           injections.push({
65 |             content: injectionContent.trim(),
66 |             startIndex,
67 |             endIndex,
68 |           });
69 | 
70 |           index = endIndex;
71 |           foundEnd = true;
72 |           break;
73 |         }
74 |       }
75 |       currentIndex++;
76 |     }
77 | 
78 |     // Check if the inner loop finished without finding the closing brace.
79 |     if (!foundEnd) {
80 |       const contextInfo = contextName ? ` in command '${contextName}'` : '';
81 |       // Enforce strict parsing (Comment 1) and clarify limitations (Comment 2).
82 |       throw new Error(
83 |         `Invalid syntax${contextInfo}: Unclosed injection starting at index ${startIndex} ('${trigger}'). Ensure braces are balanced. Paths or commands with unbalanced braces are not supported directly.`,
84 |       );
85 |     }
86 |   }
87 | 
88 |   return injections;
89 | }
```

src/services/prompt-processors/shellProcessor.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect, beforeEach, vi, type Mock } from 'vitest';
8 | import { ConfirmationRequiredError, ShellProcessor } from './shellProcessor.js';
9 | import { createMockCommandContext } from '../../test-utils/mockCommandContext.js';
10 | import type { CommandContext } from '../../ui/commands/types.js';
11 | import type { Config } from '@google/gemini-cli-core';
12 | import { ApprovalMode } from '@google/gemini-cli-core';
13 | import os from 'node:os';
14 | import { quote } from 'shell-quote';
15 | import { createPartFromText } from '@google/genai';
16 | import type { PromptPipelineContent } from './types.js';
17 | 
18 | // Helper function to determine the expected escaped string based on the current OS,
19 | // mirroring the logic in the actual `escapeShellArg` implementation.
20 | function getExpectedEscapedArgForPlatform(arg: string): string {
21 |   if (os.platform() === 'win32') {
22 |     const comSpec = (process.env['ComSpec'] || 'cmd.exe').toLowerCase();
23 |     const isPowerShell =
24 |       comSpec.endsWith('powershell.exe') || comSpec.endsWith('pwsh.exe');
25 | 
26 |     if (isPowerShell) {
27 |       return `'${arg.replace(/'/g, "''")}'`;
28 |     } else {
29 |       return `"${arg.replace(/"/g, '""')}"`;
30 |     }
31 |   } else {
32 |     return quote([arg]);
33 |   }
34 | }
35 | 
36 | // Helper to create PromptPipelineContent
37 | function createPromptPipelineContent(text: string): PromptPipelineContent {
38 |   return [createPartFromText(text)];
39 | }
40 | 
41 | const mockCheckCommandPermissions = vi.hoisted(() => vi.fn());
42 | const mockShellExecute = vi.hoisted(() => vi.fn());
43 | 
44 | vi.mock('@google/gemini-cli-core', async (importOriginal) => {
45 |   const original = await importOriginal<object>();
46 |   return {
47 |     ...original,
48 |     checkCommandPermissions: mockCheckCommandPermissions,
49 |     ShellExecutionService: {
50 |       execute: mockShellExecute,
51 |     },
52 |   };
53 | });
54 | 
55 | const SUCCESS_RESULT = {
56 |   output: 'default shell output',
57 |   exitCode: 0,
58 |   error: null,
59 |   aborted: false,
60 |   signal: null,
61 | };
62 | 
63 | describe('ShellProcessor', () => {
64 |   let context: CommandContext;
65 |   let mockConfig: Partial<Config>;
66 | 
67 |   beforeEach(() => {
68 |     vi.clearAllMocks();
69 | 
70 |     mockConfig = {
71 |       getTargetDir: vi.fn().mockReturnValue('/test/dir'),
72 |       getApprovalMode: vi.fn().mockReturnValue(ApprovalMode.DEFAULT),
73 |       getEnableInteractiveShell: vi.fn().mockReturnValue(false),
74 |       getShellExecutionConfig: vi.fn().mockReturnValue({}),
75 |     };
76 | 
77 |     context = createMockCommandContext({
78 |       invocation: {
79 |         raw: '/cmd default args',
80 |         name: 'cmd',
81 |         args: 'default args',
82 |       },
83 |       services: {
84 |         config: mockConfig as Config,
85 |       },
86 |       session: {
87 |         sessionShellAllowlist: new Set(),
88 |       },
89 |     });
90 | 
91 |     mockShellExecute.mockReturnValue({
92 |       result: Promise.resolve(SUCCESS_RESULT),
93 |     });
94 | 
95 |     mockCheckCommandPermissions.mockReturnValue({
96 |       allAllowed: true,
97 |       disallowedCommands: [],
98 |     });
99 |   });
100 | 
101 |   it('should throw an error if config is missing', async () => {
102 |     const processor = new ShellProcessor('test-command');
103 |     const prompt: PromptPipelineContent = createPromptPipelineContent('!{ls}');
104 |     const contextWithoutConfig = createMockCommandContext({
105 |       services: {
106 |         config: null,
107 |       },
108 |     });
109 | 
110 |     await expect(
111 |       processor.process(prompt, contextWithoutConfig),
112 |     ).rejects.toThrow(/Security configuration not loaded/);
113 |   });
114 | 
115 |   it('should not change the prompt if no shell injections are present', async () => {
116 |     const processor = new ShellProcessor('test-command');
117 |     const prompt: PromptPipelineContent = createPromptPipelineContent(
118 |       'This is a simple prompt with no injections.',
119 |     );
120 |     const result = await processor.process(prompt, context);
121 |     expect(result).toEqual(prompt);
122 |     expect(mockShellExecute).not.toHaveBeenCalled();
123 |   });
124 | 
125 |   it('should process a single valid shell injection if allowed', async () => {
126 |     const processor = new ShellProcessor('test-command');
127 |     const prompt: PromptPipelineContent = createPromptPipelineContent(
128 |       'The current status is: !{git status}',
129 |     );
130 |     mockCheckCommandPermissions.mockReturnValue({
131 |       allAllowed: true,
132 |       disallowedCommands: [],
133 |     });
134 |     mockShellExecute.mockReturnValue({
135 |       result: Promise.resolve({ ...SUCCESS_RESULT, output: 'On branch main' }),
136 |     });
137 | 
138 |     const result = await processor.process(prompt, context);
139 | 
140 |     expect(mockCheckCommandPermissions).toHaveBeenCalledWith(
141 |       'git status',
142 |       expect.any(Object),
143 |       context.session.sessionShellAllowlist,
144 |     );
145 |     expect(mockShellExecute).toHaveBeenCalledWith(
146 |       'git status',
147 |       expect.any(String),
148 |       expect.any(Function),
149 |       expect.any(Object),
150 |       false,
151 |       expect.any(Object),
152 |     );
153 |     expect(result).toEqual([{ text: 'The current status is: On branch main' }]);
154 |   });
155 | 
156 |   it('should process multiple valid shell injections if all are allowed', async () => {
157 |     const processor = new ShellProcessor('test-command');
158 |     const prompt: PromptPipelineContent = createPromptPipelineContent(
159 |       '!{git status} in !{pwd}',
160 |     );
161 |     mockCheckCommandPermissions.mockReturnValue({
162 |       allAllowed: true,
163 |       disallowedCommands: [],
164 |     });
165 | 
166 |     mockShellExecute
167 |       .mockReturnValueOnce({
168 |         result: Promise.resolve({
169 |           ...SUCCESS_RESULT,
170 |           output: 'On branch main',
171 |         }),
172 |       })
173 |       .mockReturnValueOnce({
174 |         result: Promise.resolve({ ...SUCCESS_RESULT, output: '/usr/home' }),
175 |       });
176 | 
177 |     const result = await processor.process(prompt, context);
178 | 
179 |     expect(mockCheckCommandPermissions).toHaveBeenCalledTimes(2);
180 |     expect(mockShellExecute).toHaveBeenCalledTimes(2);
181 |     expect(result).toEqual([{ text: 'On branch main in /usr/home' }]);
182 |   });
183 | 
184 |   it('should throw ConfirmationRequiredError if a command is not allowed in default mode', async () => {
185 |     const processor = new ShellProcessor('test-command');
186 |     const prompt: PromptPipelineContent = createPromptPipelineContent(
187 |       'Do something dangerous: !{rm -rf /}',
188 |     );
189 |     mockCheckCommandPermissions.mockReturnValue({
190 |       allAllowed: false,
191 |       disallowedCommands: ['rm -rf /'],
192 |     });
193 | 
194 |     await expect(processor.process(prompt, context)).rejects.toThrow(
195 |       ConfirmationRequiredError,
196 |     );
197 |   });
198 | 
199 |   it('should NOT throw ConfirmationRequiredError if a command is not allowed but approval mode is YOLO', async () => {
200 |     const processor = new ShellProcessor('test-command');
201 |     const prompt: PromptPipelineContent = createPromptPipelineContent(
202 |       'Do something dangerous: !{rm -rf /}',
203 |     );
204 |     mockCheckCommandPermissions.mockReturnValue({
205 |       allAllowed: false,
206 |       disallowedCommands: ['rm -rf /'],
207 |     });
208 |     // Override the approval mode for this test
209 |     (mockConfig.getApprovalMode as Mock).mockReturnValue(ApprovalMode.YOLO);
210 |     mockShellExecute.mockReturnValue({
211 |       result: Promise.resolve({ ...SUCCESS_RESULT, output: 'deleted' }),
212 |     });
213 | 
214 |     const result = await processor.process(prompt, context);
215 | 
216 |     // It should proceed with execution
217 |     expect(mockShellExecute).toHaveBeenCalledWith(
218 |       'rm -rf /',
219 |       expect.any(String),
220 |       expect.any(Function),
221 |       expect.any(Object),
222 |       false,
223 |       expect.any(Object),
224 |     );
225 |     expect(result).toEqual([{ text: 'Do something dangerous: deleted' }]);
226 |   });
227 | 
228 |   it('should still throw an error for a hard-denied command even in YOLO mode', async () => {
229 |     const processor = new ShellProcessor('test-command');
230 |     const prompt: PromptPipelineContent = createPromptPipelineContent(
231 |       'Do something forbidden: !{reboot}',
232 |     );
233 |     mockCheckCommandPermissions.mockReturnValue({
234 |       allAllowed: false,
235 |       disallowedCommands: ['reboot'],
236 |       isHardDenial: true, // This is the key difference
237 |       blockReason: 'System commands are blocked',
238 |     });
239 |     // Set approval mode to YOLO
240 |     (mockConfig.getApprovalMode as Mock).mockReturnValue(ApprovalMode.YOLO);
241 | 
242 |     await expect(processor.process(prompt, context)).rejects.toThrow(
243 |       /Blocked command: "reboot". Reason: System commands are blocked/,
244 |     );
245 | 
246 |     // Ensure it never tried to execute
247 |     expect(mockShellExecute).not.toHaveBeenCalled();
248 |   });
249 | 
250 |   it('should throw ConfirmationRequiredError with the correct command', async () => {
251 |     const processor = new ShellProcessor('test-command');
252 |     const prompt: PromptPipelineContent = createPromptPipelineContent(
253 |       'Do something dangerous: !{rm -rf /}',
254 |     );
255 |     mockCheckCommandPermissions.mockReturnValue({
256 |       allAllowed: false,
257 |       disallowedCommands: ['rm -rf /'],
258 |     });
259 | 
260 |     try {
261 |       await processor.process(prompt, context);
262 |       // Fail if it doesn't throw
263 |       expect(true).toBe(false);
264 |     } catch (e) {
265 |       expect(e).toBeInstanceOf(ConfirmationRequiredError);
266 |       if (e instanceof ConfirmationRequiredError) {
267 |         expect(e.commandsToConfirm).toEqual(['rm -rf /']);
268 |       }
269 |     }
270 | 
271 |     expect(mockShellExecute).not.toHaveBeenCalled();
272 |   });
273 | 
274 |   it('should throw ConfirmationRequiredError with multiple commands if multiple are disallowed', async () => {
275 |     const processor = new ShellProcessor('test-command');
276 |     const prompt: PromptPipelineContent = createPromptPipelineContent(
277 |       '!{cmd1} and !{cmd2}',
278 |     );
279 |     mockCheckCommandPermissions.mockImplementation((cmd) => {
280 |       if (cmd === 'cmd1') {
281 |         return { allAllowed: false, disallowedCommands: ['cmd1'] };
282 |       }
283 |       if (cmd === 'cmd2') {
284 |         return { allAllowed: false, disallowedCommands: ['cmd2'] };
285 |       }
286 |       return { allAllowed: true, disallowedCommands: [] };
287 |     });
288 | 
289 |     try {
290 |       await processor.process(prompt, context);
291 |       // Fail if it doesn't throw
292 |       expect(true).toBe(false);
293 |     } catch (e) {
294 |       expect(e).toBeInstanceOf(ConfirmationRequiredError);
295 |       if (e instanceof ConfirmationRequiredError) {
296 |         expect(e.commandsToConfirm).toEqual(['cmd1', 'cmd2']);
297 |       }
298 |     }
299 |   });
300 | 
301 |   it('should not execute any commands if at least one requires confirmation', async () => {
302 |     const processor = new ShellProcessor('test-command');
303 |     const prompt: PromptPipelineContent = createPromptPipelineContent(
304 |       'First: !{echo "hello"}, Second: !{rm -rf /}',
305 |     );
306 | 
307 |     mockCheckCommandPermissions.mockImplementation((cmd) => {
308 |       if (cmd.includes('rm')) {
309 |         return { allAllowed: false, disallowedCommands: [cmd] };
310 |       }
311 |       return { allAllowed: true, disallowedCommands: [] };
312 |     });
313 | 
314 |     await expect(processor.process(prompt, context)).rejects.toThrow(
315 |       ConfirmationRequiredError,
316 |     );
317 | 
318 |     // Ensure no commands were executed because the pipeline was halted.
319 |     expect(mockShellExecute).not.toHaveBeenCalled();
320 |   });
321 | 
322 |   it('should only request confirmation for disallowed commands in a mixed prompt', async () => {
323 |     const processor = new ShellProcessor('test-command');
324 |     const prompt: PromptPipelineContent = createPromptPipelineContent(
325 |       'Allowed: !{ls -l}, Disallowed: !{rm -rf /}',
326 |     );
327 | 
328 |     mockCheckCommandPermissions.mockImplementation((cmd) => ({
329 |       allAllowed: !cmd.includes('rm'),
330 |       disallowedCommands: cmd.includes('rm') ? [cmd] : [],
331 |     }));
332 | 
333 |     try {
334 |       await processor.process(prompt, context);
335 |       expect.fail('Should have thrown ConfirmationRequiredError');
336 |     } catch (e) {
337 |       expect(e).toBeInstanceOf(ConfirmationRequiredError);
338 |       if (e instanceof ConfirmationRequiredError) {
339 |         expect(e.commandsToConfirm).toEqual(['rm -rf /']);
340 |       }
341 |     }
342 |   });
343 | 
344 |   it('should execute all commands if they are on the session allowlist', async () => {
345 |     const processor = new ShellProcessor('test-command');
346 |     const prompt: PromptPipelineContent = createPromptPipelineContent(
347 |       'Run !{cmd1} and !{cmd2}',
348 |     );
349 | 
350 |     // Add commands to the session allowlist
351 |     context.session.sessionShellAllowlist = new Set(['cmd1', 'cmd2']);
352 | 
353 |     // checkCommandPermissions should now pass for these
354 |     mockCheckCommandPermissions.mockReturnValue({
355 |       allAllowed: true,
356 |       disallowedCommands: [],
357 |     });
358 | 
359 |     mockShellExecute
360 |       .mockReturnValueOnce({
361 |         result: Promise.resolve({ ...SUCCESS_RESULT, output: 'output1' }),
362 |       })
363 |       .mockReturnValueOnce({
364 |         result: Promise.resolve({ ...SUCCESS_RESULT, output: 'output2' }),
365 |       });
366 | 
367 |     const result = await processor.process(prompt, context);
368 | 
[TRUNCATED]
```

src/services/prompt-processors/shellProcessor.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import {
8 |   ApprovalMode,
9 |   checkCommandPermissions,
10 |   escapeShellArg,
11 |   getShellConfiguration,
12 |   ShellExecutionService,
13 |   flatMapTextParts,
14 | } from '@google/gemini-cli-core';
15 | 
16 | import type { CommandContext } from '../../ui/commands/types.js';
17 | import type { IPromptProcessor, PromptPipelineContent } from './types.js';
18 | import {
19 |   SHELL_INJECTION_TRIGGER,
20 |   SHORTHAND_ARGS_PLACEHOLDER,
21 | } from './types.js';
22 | import { extractInjections, type Injection } from './injectionParser.js';
23 | import { themeManager } from '../../ui/themes/theme-manager.js';
24 | 
25 | export class ConfirmationRequiredError extends Error {
26 |   constructor(
27 |     message: string,
28 |     public commandsToConfirm: string[],
29 |   ) {
30 |     super(message);
31 |     this.name = 'ConfirmationRequiredError';
32 |   }
33 | }
34 | 
35 | /**
36 |  * Represents a single detected shell injection site in the prompt,
37 |  * after resolution of arguments. Extends the base Injection interface.
38 |  */
39 | interface ResolvedShellInjection extends Injection {
40 |   /** The command after {{args}} has been escaped and substituted. */
41 |   resolvedCommand?: string;
42 | }
43 | 
44 | /**
45 |  * Handles prompt interpolation, including shell command execution (`!{...}`)
46 |  * and context-aware argument injection (`{{args}}`).
47 |  *
48 |  * This processor ensures that:
49 |  * 1. `{{args}}` outside `!{...}` are replaced with raw input.
50 |  * 2. `{{args}}` inside `!{...}` are replaced with shell-escaped input.
51 |  * 3. Shell commands are executed securely after argument substitution.
52 |  * 4. Parsing correctly handles nested braces.
53 |  */
54 | export class ShellProcessor implements IPromptProcessor {
55 |   constructor(private readonly commandName: string) {}
56 | 
57 |   async process(
58 |     prompt: PromptPipelineContent,
59 |     context: CommandContext,
60 |   ): Promise<PromptPipelineContent> {
61 |     return flatMapTextParts(prompt, (text) =>
62 |       this.processString(text, context),
63 |     );
64 |   }
65 | 
66 |   private async processString(
67 |     prompt: string,
68 |     context: CommandContext,
69 |   ): Promise<PromptPipelineContent> {
70 |     const userArgsRaw = context.invocation?.args || '';
71 | 
72 |     if (!prompt.includes(SHELL_INJECTION_TRIGGER)) {
73 |       return [
74 |         { text: prompt.replaceAll(SHORTHAND_ARGS_PLACEHOLDER, userArgsRaw) },
75 |       ];
76 |     }
77 | 
78 |     const config = context.services.config;
79 |     if (!config) {
80 |       throw new Error(
81 |         `Security configuration not loaded. Cannot verify shell command permissions for '${this.commandName}'. Aborting.`,
82 |       );
83 |     }
84 |     const { sessionShellAllowlist } = context.session;
85 | 
86 |     const injections = extractInjections(
87 |       prompt,
88 |       SHELL_INJECTION_TRIGGER,
89 |       this.commandName,
90 |     );
91 | 
92 |     // If extractInjections found no closed blocks (and didn't throw), treat as raw.
93 |     if (injections.length === 0) {
94 |       return [
95 |         { text: prompt.replaceAll(SHORTHAND_ARGS_PLACEHOLDER, userArgsRaw) },
96 |       ];
97 |     }
98 | 
99 |     const { shell } = getShellConfiguration();
100 |     const userArgsEscaped = escapeShellArg(userArgsRaw, shell);
101 | 
102 |     const resolvedInjections: ResolvedShellInjection[] = injections.map(
103 |       (injection) => {
104 |         const command = injection.content;
105 | 
106 |         if (command === '') {
107 |           return { ...injection, resolvedCommand: undefined };
108 |         }
109 | 
110 |         const resolvedCommand = command.replaceAll(
111 |           SHORTHAND_ARGS_PLACEHOLDER,
112 |           userArgsEscaped,
113 |         );
114 |         return { ...injection, resolvedCommand };
115 |       },
116 |     );
117 | 
118 |     const commandsToConfirm = new Set<string>();
119 |     for (const injection of resolvedInjections) {
120 |       const command = injection.resolvedCommand;
121 | 
122 |       if (!command) continue;
123 | 
124 |       // Security check on the final, escaped command string.
125 |       const { allAllowed, disallowedCommands, blockReason, isHardDenial } =
126 |         checkCommandPermissions(command, config, sessionShellAllowlist);
127 | 
128 |       if (!allAllowed) {
129 |         if (isHardDenial) {
130 |           throw new Error(
131 |             `${this.commandName} cannot be run. Blocked command: "${command}". Reason: ${blockReason || 'Blocked by configuration.'}`,
132 |           );
133 |         }
134 | 
135 |         // If not a hard denial, respect YOLO mode and auto-approve.
136 |         if (config.getApprovalMode() !== ApprovalMode.YOLO) {
137 |           disallowedCommands.forEach((uc) => commandsToConfirm.add(uc));
138 |         }
139 |       }
140 |     }
141 | 
142 |     // Handle confirmation requirements.
143 |     if (commandsToConfirm.size > 0) {
144 |       throw new ConfirmationRequiredError(
145 |         'Shell command confirmation required',
146 |         Array.from(commandsToConfirm),
147 |       );
148 |     }
149 | 
150 |     let processedPrompt = '';
151 |     let lastIndex = 0;
152 | 
153 |     for (const injection of resolvedInjections) {
154 |       // Append the text segment BEFORE the injection, substituting {{args}} with RAW input.
155 |       const segment = prompt.substring(lastIndex, injection.startIndex);
156 |       processedPrompt += segment.replaceAll(
157 |         SHORTHAND_ARGS_PLACEHOLDER,
158 |         userArgsRaw,
159 |       );
160 | 
161 |       // Execute the resolved command (which already has ESCAPED input).
162 |       if (injection.resolvedCommand) {
163 |         const activeTheme = themeManager.getActiveTheme();
164 |         const shellExecutionConfig = {
165 |           ...config.getShellExecutionConfig(),
166 |           defaultFg: activeTheme.colors.Foreground,
167 |           defaultBg: activeTheme.colors.Background,
168 |         };
169 |         const { result } = await ShellExecutionService.execute(
170 |           injection.resolvedCommand,
171 |           config.getTargetDir(),
172 |           () => {},
173 |           new AbortController().signal,
174 |           config.getEnableInteractiveShell(),
175 |           shellExecutionConfig,
176 |         );
177 | 
178 |         const executionResult = await result;
179 | 
180 |         // Handle Spawn Errors
181 |         if (executionResult.error && !executionResult.aborted) {
182 |           throw new Error(
183 |             `Failed to start shell command in '${this.commandName}': ${executionResult.error.message}. Command: ${injection.resolvedCommand}`,
184 |           );
185 |         }
186 | 
187 |         // Append the output, making stderr explicit for the model.
188 |         processedPrompt += executionResult.output;
189 | 
190 |         // Append a status message if the command did not succeed.
191 |         if (executionResult.aborted) {
192 |           processedPrompt += `\n[Shell command '${injection.resolvedCommand}' aborted]`;
193 |         } else if (
194 |           executionResult.exitCode !== 0 &&
195 |           executionResult.exitCode !== null
196 |         ) {
197 |           processedPrompt += `\n[Shell command '${injection.resolvedCommand}' exited with code ${executionResult.exitCode}]`;
198 |         } else if (executionResult.signal !== null) {
199 |           processedPrompt += `\n[Shell command '${injection.resolvedCommand}' terminated by signal ${executionResult.signal}]`;
200 |         }
201 |       }
202 | 
203 |       lastIndex = injection.endIndex;
204 |     }
205 | 
206 |     // Append the remaining text AFTER the last injection, substituting {{args}} with RAW input.
207 |     const finalSegment = prompt.substring(lastIndex);
208 |     processedPrompt += finalSegment.replaceAll(
209 |       SHORTHAND_ARGS_PLACEHOLDER,
210 |       userArgsRaw,
211 |     );
212 | 
213 |     return [{ text: processedPrompt }];
214 |   }
215 | }
```

src/services/prompt-processors/types.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type { CommandContext } from '../../ui/commands/types.js';
8 | import type { PartUnion } from '@google/genai';
9 | 
10 | /**
11 |  * Defines the input/output type for prompt processors.
12 |  */
13 | export type PromptPipelineContent = PartUnion[];
14 | 
15 | /**
16 |  * Defines the interface for a prompt processor, a module that can transform
17 |  * a prompt string before it is sent to the model. Processors are chained
18 |  * together to create a processing pipeline.
19 |  */
20 | export interface IPromptProcessor {
21 |   /**
22 |    * Processes a prompt input (which may contain text and multi-modal parts),
23 |    * applying a specific transformation as part of a pipeline.
24 |    *
25 |    * @param prompt The current state of the prompt string. This may have been
26 |    *   modified by previous processors in the pipeline.
27 |    * @param context The full command context, providing access to invocation
28 |    *   details (like `context.invocation.raw` and `context.invocation.args`),
29 |    *   application services, and UI handlers.
30 |    * @returns A promise that resolves to the transformed prompt string, which
31 |    *   will be passed to the next processor or, if it's the last one, sent to the model.
32 |    */
33 |   process(
34 |     prompt: PromptPipelineContent,
35 |     context: CommandContext,
36 |   ): Promise<PromptPipelineContent>;
37 | }
38 | 
39 | /**
40 |  * The placeholder string for shorthand argument injection in custom commands.
41 |  * When used outside of !{...}, arguments are injected raw.
42 |  * When used inside !{...}, arguments are shell-escaped.
43 |  */
44 | export const SHORTHAND_ARGS_PLACEHOLDER = '{{args}}';
45 | 
46 | /**
47 |  * The trigger string for shell command injection in custom commands.
48 |  */
49 | export const SHELL_INJECTION_TRIGGER = '!{';
50 | 
51 | /**
52 |  * The trigger string for at file injection in custom commands.
53 |  */
54 | export const AT_FILE_INJECTION_TRIGGER = '@{';
```

src/ui/auth/AuthDialog.test.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { renderWithProviders } from '../../test-utils/render.js';
8 | import {
9 |   describe,
10 |   it,
11 |   expect,
12 |   vi,
13 |   beforeEach,
14 |   afterEach,
15 |   type Mock,
16 | } from 'vitest';
17 | import { AuthDialog } from './AuthDialog.js';
18 | import { AuthType, type Config } from '@google/gemini-cli-core';
19 | import type { LoadedSettings } from '../../config/settings.js';
20 | import { SettingScope } from '../../config/settings.js';
21 | import { AuthState } from '../types.js';
22 | import { RadioButtonSelect } from '../components/shared/RadioButtonSelect.js';
23 | import { useKeypress } from '../hooks/useKeypress.js';
24 | import { validateAuthMethodWithSettings } from './useAuth.js';
25 | import { runExitCleanup } from '../../utils/cleanup.js';
26 | import { clearCachedCredentialFile } from '@google/gemini-cli-core';
27 | import { Text } from 'ink';
28 | 
29 | // Mocks
30 | vi.mock('@google/gemini-cli-core', async (importOriginal) => {
31 |   const actual =
32 |     await importOriginal<typeof import('@google/gemini-cli-core')>();
33 |   return {
34 |     ...actual,
35 |     clearCachedCredentialFile: vi.fn(),
36 |   };
37 | });
38 | 
39 | vi.mock('../../utils/cleanup.js', () => ({
40 |   runExitCleanup: vi.fn(),
41 | }));
42 | 
43 | vi.mock('./useAuth.js', () => ({
44 |   validateAuthMethodWithSettings: vi.fn(),
45 | }));
46 | 
47 | vi.mock('../hooks/useKeypress.js', () => ({
48 |   useKeypress: vi.fn(),
49 | }));
50 | 
51 | vi.mock('../components/shared/RadioButtonSelect.js', () => ({
52 |   RadioButtonSelect: vi.fn(({ items, initialIndex }) => (
53 |     <>
54 |       {items.map((item: { value: string; label: string }, index: number) => (
55 |         <Text key={item.value}>
56 |           {index === initialIndex ? '(selected)' : '(not selected)'}{' '}
57 |           {item.label}
58 |         </Text>
59 |       ))}
60 |     </>
61 |   )),
62 | }));
63 | 
64 | const mockedUseKeypress = useKeypress as Mock;
65 | const mockedRadioButtonSelect = RadioButtonSelect as Mock;
66 | const mockedValidateAuthMethod = validateAuthMethodWithSettings as Mock;
67 | const mockedRunExitCleanup = runExitCleanup as Mock;
68 | const mockedClearCachedCredentialFile = clearCachedCredentialFile as Mock;
69 | 
70 | describe('AuthDialog', () => {
71 |   let props: {
72 |     config: Config;
73 |     settings: LoadedSettings;
74 |     setAuthState: (state: AuthState) => void;
75 |     authError: string | null;
76 |     onAuthError: (error: string) => void;
77 |   };
78 |   const originalEnv = { ...process.env };
79 | 
80 |   beforeEach(() => {
81 |     vi.resetAllMocks();
82 |     process.env = {};
83 | 
84 |     props = {
85 |       config: {
86 |         isBrowserLaunchSuppressed: vi.fn().mockReturnValue(false),
87 |       } as unknown as Config,
88 |       settings: {
89 |         merged: {
90 |           security: {
91 |             auth: {},
92 |           },
93 |         },
94 |         setValue: vi.fn(),
95 |       } as unknown as LoadedSettings,
96 |       setAuthState: vi.fn(),
97 |       authError: null,
98 |       onAuthError: vi.fn(),
99 |     };
100 |   });
101 | 
102 |   afterEach(() => {
103 |     process.env = originalEnv;
104 |   });
105 | 
106 |   it('shows Cloud Shell option when in Cloud Shell environment', () => {
107 |     process.env['CLOUD_SHELL'] = 'true';
108 |     renderWithProviders(<AuthDialog {...props} />);
109 |     const items = mockedRadioButtonSelect.mock.calls[0][0].items;
110 |     expect(items).toContainEqual({
111 |       label: 'Use Cloud Shell user credentials',
112 |       value: AuthType.CLOUD_SHELL,
113 |       key: AuthType.CLOUD_SHELL,
114 |     });
115 |   });
116 | 
117 |   it('filters auth types when enforcedType is set', () => {
118 |     props.settings.merged.security!.auth!.enforcedType = AuthType.USE_GEMINI;
119 |     renderWithProviders(<AuthDialog {...props} />);
120 |     const items = mockedRadioButtonSelect.mock.calls[0][0].items;
121 |     expect(items).toHaveLength(1);
122 |     expect(items[0].value).toBe(AuthType.USE_GEMINI);
123 |   });
124 | 
125 |   it('sets initial index to 0 when enforcedType is set', () => {
126 |     props.settings.merged.security!.auth!.enforcedType = AuthType.USE_GEMINI;
127 |     renderWithProviders(<AuthDialog {...props} />);
128 |     const { initialIndex } = mockedRadioButtonSelect.mock.calls[0][0];
129 |     expect(initialIndex).toBe(0);
130 |   });
131 | 
132 |   it('selects initial auth type from settings', () => {
133 |     props.settings.merged.security!.auth!.selectedType = AuthType.USE_VERTEX_AI;
134 |     renderWithProviders(<AuthDialog {...props} />);
135 |     const { items, initialIndex } = mockedRadioButtonSelect.mock.calls[0][0];
136 |     expect(items[initialIndex].value).toBe(AuthType.USE_VERTEX_AI);
137 |   });
138 | 
139 |   it('selects initial auth type from GEMINI_DEFAULT_AUTH_TYPE env var', () => {
140 |     process.env['GEMINI_DEFAULT_AUTH_TYPE'] = AuthType.USE_GEMINI;
141 |     renderWithProviders(<AuthDialog {...props} />);
142 |     const { items, initialIndex } = mockedRadioButtonSelect.mock.calls[0][0];
143 |     expect(items[initialIndex].value).toBe(AuthType.USE_GEMINI);
144 |   });
145 | 
146 |   it('selects initial auth type from GEMINI_API_KEY env var', () => {
147 |     process.env['GEMINI_API_KEY'] = 'test-key';
148 |     renderWithProviders(<AuthDialog {...props} />);
149 |     const { items, initialIndex } = mockedRadioButtonSelect.mock.calls[0][0];
150 |     expect(items[initialIndex].value).toBe(AuthType.USE_GEMINI);
151 |   });
152 | 
153 |   it('defaults to Login with Google', () => {
154 |     renderWithProviders(<AuthDialog {...props} />);
155 |     const { items, initialIndex } = mockedRadioButtonSelect.mock.calls[0][0];
156 |     expect(items[initialIndex].value).toBe(AuthType.LOGIN_WITH_GOOGLE);
157 |   });
158 | 
159 |   describe('handleAuthSelect', () => {
160 |     it('calls onAuthError if validation fails', () => {
161 |       mockedValidateAuthMethod.mockReturnValue('Invalid method');
162 |       renderWithProviders(<AuthDialog {...props} />);
163 |       const { onSelect: handleAuthSelect } =
164 |         mockedRadioButtonSelect.mock.calls[0][0];
165 |       handleAuthSelect(AuthType.USE_GEMINI);
166 | 
167 |       expect(mockedValidateAuthMethod).toHaveBeenCalledWith(
168 |         AuthType.USE_GEMINI,
169 |         props.settings,
170 |       );
171 |       expect(props.onAuthError).toHaveBeenCalledWith('Invalid method');
172 |       expect(props.settings.setValue).not.toHaveBeenCalled();
173 |     });
174 | 
175 |     it('calls onSelect if validation passes', async () => {
176 |       mockedValidateAuthMethod.mockReturnValue(null);
177 |       renderWithProviders(<AuthDialog {...props} />);
178 |       const { onSelect: handleAuthSelect } =
179 |         mockedRadioButtonSelect.mock.calls[0][0];
180 |       await handleAuthSelect(AuthType.USE_GEMINI);
181 | 
182 |       expect(mockedValidateAuthMethod).toHaveBeenCalledWith(
183 |         AuthType.USE_GEMINI,
184 |         props.settings,
185 |       );
186 |       expect(props.onAuthError).not.toHaveBeenCalled();
187 |       expect(mockedClearCachedCredentialFile).toHaveBeenCalled();
188 |       expect(props.settings.setValue).toHaveBeenCalledWith(
189 |         SettingScope.User,
190 |         'security.auth.selectedType',
191 |         AuthType.USE_GEMINI,
192 |       );
193 |       expect(props.setAuthState).toHaveBeenCalledWith(
194 |         AuthState.Unauthenticated,
195 |       );
196 |     });
197 | 
198 |     it('exits process for Login with Google when browser is suppressed', async () => {
199 |       const exitSpy = vi
200 |         .spyOn(process, 'exit')
201 |         .mockImplementation(() => undefined as never);
202 |       const logSpy = vi.spyOn(console, 'log').mockImplementation(() => {});
203 |       vi.mocked(props.config.isBrowserLaunchSuppressed).mockReturnValue(true);
204 |       mockedValidateAuthMethod.mockReturnValue(null);
205 | 
206 |       renderWithProviders(<AuthDialog {...props} />);
207 |       const { onSelect: handleAuthSelect } =
208 |         mockedRadioButtonSelect.mock.calls[0][0];
209 |       await handleAuthSelect(AuthType.LOGIN_WITH_GOOGLE);
210 | 
211 |       expect(mockedRunExitCleanup).toHaveBeenCalled();
212 |       expect(logSpy).toHaveBeenCalledWith(
213 |         expect.stringContaining('Please restart Gemini CLI'),
214 |       );
215 |       expect(exitSpy).toHaveBeenCalledWith(0);
216 | 
217 |       exitSpy.mockRestore();
218 |       logSpy.mockRestore();
219 |     });
220 |   });
221 | 
222 |   it('displays authError when provided', () => {
223 |     props.authError = 'Something went wrong';
224 |     const { lastFrame } = renderWithProviders(<AuthDialog {...props} />);
225 |     expect(lastFrame()).toContain('Something went wrong');
226 |   });
227 | 
228 |   describe('useKeypress', () => {
229 |     it('does nothing on escape if authError is present', () => {
230 |       props.authError = 'Some error';
231 |       renderWithProviders(<AuthDialog {...props} />);
232 |       const keypressHandler = mockedUseKeypress.mock.calls[0][0];
233 |       keypressHandler({ name: 'escape' });
234 |       expect(props.onAuthError).not.toHaveBeenCalled();
235 |       expect(props.setAuthState).not.toHaveBeenCalled();
236 |     });
237 | 
238 |     it('calls onAuthError on escape if no auth method is set', () => {
239 |       props.settings.merged.security!.auth!.selectedType = undefined;
240 |       renderWithProviders(<AuthDialog {...props} />);
241 |       const keypressHandler = mockedUseKeypress.mock.calls[0][0];
242 |       keypressHandler({ name: 'escape' });
243 |       expect(props.onAuthError).toHaveBeenCalledWith(
244 |         'You must select an auth method to proceed. Press Ctrl+C twice to exit.',
245 |       );
246 |     });
247 | 
248 |     it('calls onSelect(undefined) on escape if auth method is set', () => {
249 |       props.settings.merged.security!.auth!.selectedType = AuthType.USE_GEMINI;
250 |       renderWithProviders(<AuthDialog {...props} />);
251 |       const keypressHandler = mockedUseKeypress.mock.calls[0][0];
252 |       keypressHandler({ name: 'escape' });
253 |       expect(props.setAuthState).toHaveBeenCalledWith(
254 |         AuthState.Unauthenticated,
255 |       );
256 |       expect(props.settings.setValue).not.toHaveBeenCalled();
257 |     });
258 |   });
259 | });
```

src/ui/auth/AuthDialog.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type React from 'react';
8 | import { useCallback } from 'react';
9 | import { Box, Text } from 'ink';
10 | import { theme } from '../semantic-colors.js';
11 | import { RadioButtonSelect } from '../components/shared/RadioButtonSelect.js';
12 | import type { LoadedSettings } from '../../config/settings.js';
13 | import { SettingScope } from '../../config/settings.js';
14 | import {
15 |   AuthType,
16 |   clearCachedCredentialFile,
17 |   type Config,
18 | } from '@google/gemini-cli-core';
19 | import { useKeypress } from '../hooks/useKeypress.js';
20 | import { AuthState } from '../types.js';
21 | import { runExitCleanup } from '../../utils/cleanup.js';
22 | import { validateAuthMethodWithSettings } from './useAuth.js';
23 | 
24 | interface AuthDialogProps {
25 |   config: Config;
26 |   settings: LoadedSettings;
27 |   setAuthState: (state: AuthState) => void;
28 |   authError: string | null;
29 |   onAuthError: (error: string) => void;
30 | }
31 | 
32 | export function AuthDialog({
33 |   config,
34 |   settings,
35 |   setAuthState,
36 |   authError,
37 |   onAuthError,
38 | }: AuthDialogProps): React.JSX.Element {
39 |   let items = [
40 |     {
41 |       label: 'Login with Google',
42 |       value: AuthType.LOGIN_WITH_GOOGLE,
43 |       key: AuthType.LOGIN_WITH_GOOGLE,
44 |     },
45 |     ...(process.env['CLOUD_SHELL'] === 'true'
46 |       ? [
47 |           {
48 |             label: 'Use Cloud Shell user credentials',
49 |             value: AuthType.CLOUD_SHELL,
50 |             key: AuthType.CLOUD_SHELL,
51 |           },
52 |         ]
53 |       : []),
54 |     {
55 |       label: 'Use Gemini API Key',
56 |       value: AuthType.USE_GEMINI,
57 |       key: AuthType.USE_GEMINI,
58 |     },
59 |     {
60 |       label: 'Vertex AI',
61 |       value: AuthType.USE_VERTEX_AI,
62 |       key: AuthType.USE_VERTEX_AI,
63 |     },
64 |   ];
65 | 
66 |   if (settings.merged.security?.auth?.enforcedType) {
67 |     items = items.filter(
68 |       (item) => item.value === settings.merged.security?.auth?.enforcedType,
69 |     );
70 |   }
71 | 
72 |   let defaultAuthType = null;
73 |   const defaultAuthTypeEnv = process.env['GEMINI_DEFAULT_AUTH_TYPE'];
74 |   if (
75 |     defaultAuthTypeEnv &&
76 |     Object.values(AuthType).includes(defaultAuthTypeEnv as AuthType)
77 |   ) {
78 |     defaultAuthType = defaultAuthTypeEnv as AuthType;
79 |   }
80 | 
81 |   let initialAuthIndex = items.findIndex((item) => {
82 |     if (settings.merged.security?.auth?.selectedType) {
83 |       return item.value === settings.merged.security.auth.selectedType;
84 |     }
85 | 
86 |     if (defaultAuthType) {
87 |       return item.value === defaultAuthType;
88 |     }
89 | 
90 |     if (process.env['GEMINI_API_KEY']) {
91 |       return item.value === AuthType.USE_GEMINI;
92 |     }
93 | 
94 |     return item.value === AuthType.LOGIN_WITH_GOOGLE;
95 |   });
96 |   if (settings.merged.security?.auth?.enforcedType) {
97 |     initialAuthIndex = 0;
98 |   }
99 | 
100 |   const onSelect = useCallback(
101 |     async (authType: AuthType | undefined, scope: SettingScope) => {
102 |       if (authType) {
103 |         await clearCachedCredentialFile();
104 | 
105 |         settings.setValue(scope, 'security.auth.selectedType', authType);
106 |         if (
107 |           authType === AuthType.LOGIN_WITH_GOOGLE &&
108 |           config.isBrowserLaunchSuppressed()
109 |         ) {
110 |           runExitCleanup();
111 |           console.log(
112 |             `
113 | ----------------------------------------------------------------
114 | Logging in with Google... Please restart Gemini CLI to continue.
115 | ----------------------------------------------------------------
116 |             `,
117 |           );
118 |           process.exit(0);
119 |         }
120 |       }
121 |       setAuthState(AuthState.Unauthenticated);
122 |     },
123 |     [settings, config, setAuthState],
124 |   );
125 | 
126 |   const handleAuthSelect = (authMethod: AuthType) => {
127 |     const error = validateAuthMethodWithSettings(authMethod, settings);
128 |     if (error) {
129 |       onAuthError(error);
130 |     } else {
131 |       onSelect(authMethod, SettingScope.User);
132 |     }
133 |   };
134 | 
135 |   useKeypress(
136 |     (key) => {
137 |       if (key.name === 'escape') {
138 |         // Prevent exit if there is an error message.
139 |         // This means they user is not authenticated yet.
140 |         if (authError) {
141 |           return;
142 |         }
143 |         if (settings.merged.security?.auth?.selectedType === undefined) {
144 |           // Prevent exiting if no auth method is set
145 |           onAuthError(
146 |             'You must select an auth method to proceed. Press Ctrl+C twice to exit.',
147 |           );
148 |           return;
149 |         }
150 |         onSelect(undefined, SettingScope.User);
151 |       }
152 |     },
153 |     { isActive: true },
154 |   );
155 | 
156 |   return (
157 |     <Box
158 |       borderStyle="round"
159 |       borderColor={theme.border.default}
160 |       flexDirection="column"
161 |       padding={1}
162 |       width="100%"
163 |     >
164 |       <Text bold color={theme.text.primary}>
165 |         Get started
166 |       </Text>
167 |       <Box marginTop={1}>
168 |         <Text color={theme.text.primary}>
169 |           How would you like to authenticate for this project?
170 |         </Text>
171 |       </Box>
172 |       <Box marginTop={1}>
173 |         <RadioButtonSelect
174 |           items={items}
175 |           initialIndex={initialAuthIndex}
176 |           onSelect={handleAuthSelect}
177 |         />
178 |       </Box>
179 |       {authError && (
180 |         <Box marginTop={1}>
181 |           <Text color={theme.status.error}>{authError}</Text>
182 |         </Box>
183 |       )}
184 |       <Box marginTop={1}>
185 |         <Text color={theme.text.secondary}>(Use Enter to select)</Text>
186 |       </Box>
187 |       <Box marginTop={1}>
188 |         <Text color={theme.text.primary}>
189 |           Terms of Services and Privacy Notice for Gemini CLI
190 |         </Text>
191 |       </Box>
192 |       <Box marginTop={1}>
193 |         <Text color={theme.text.link}>
194 |           {
195 |             'https://github.com/google-gemini/gemini-cli/blob/main/docs/tos-privacy.md'
196 |           }
197 |         </Text>
198 |       </Box>
199 |     </Box>
200 |   );
201 | }
```

src/ui/auth/AuthInProgress.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type React from 'react';
8 | import { useState, useEffect } from 'react';
9 | import { Box, Text } from 'ink';
10 | import { CliSpinner } from '../components/CliSpinner.js';
11 | import { theme } from '../semantic-colors.js';
12 | import { useKeypress } from '../hooks/useKeypress.js';
13 | 
14 | interface AuthInProgressProps {
15 |   onTimeout: () => void;
16 | }
17 | 
18 | export function AuthInProgress({
19 |   onTimeout,
20 | }: AuthInProgressProps): React.JSX.Element {
21 |   const [timedOut, setTimedOut] = useState(false);
22 | 
23 |   useKeypress(
24 |     (key) => {
25 |       if (key.name === 'escape' || (key.ctrl && key.name === 'c')) {
26 |         onTimeout();
27 |       }
28 |     },
29 |     { isActive: true },
30 |   );
31 | 
32 |   useEffect(() => {
33 |     const timer = setTimeout(() => {
34 |       setTimedOut(true);
35 |       onTimeout();
36 |     }, 180000);
37 | 
38 |     return () => clearTimeout(timer);
39 |   }, [onTimeout]);
40 | 
41 |   return (
42 |     <Box
43 |       borderStyle="round"
44 |       borderColor={theme.border.default}
45 |       flexDirection="column"
46 |       padding={1}
47 |       width="100%"
48 |     >
49 |       {timedOut ? (
50 |         <Text color={theme.status.error}>
51 |           Authentication timed out. Please try again.
52 |         </Text>
53 |       ) : (
54 |         <Box>
55 |           <Text>
56 |             <CliSpinner type="dots" /> Waiting for auth... (Press ESC or CTRL+C
57 |             to cancel)
58 |           </Text>
59 |         </Box>
60 |       )}
61 |     </Box>
62 |   );
63 | }
```

src/ui/auth/useAuth.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { useState, useEffect, useCallback } from 'react';
8 | import type { LoadedSettings } from '../../config/settings.js';
9 | import { AuthType, type Config } from '@google/gemini-cli-core';
10 | import { getErrorMessage } from '@google/gemini-cli-core';
11 | import { AuthState } from '../types.js';
12 | import { validateAuthMethod } from '../../config/auth.js';
13 | 
14 | export function validateAuthMethodWithSettings(
15 |   authType: AuthType,
16 |   settings: LoadedSettings,
17 | ): string | null {
18 |   const enforcedType = settings.merged.security?.auth?.enforcedType;
19 |   if (enforcedType && enforcedType !== authType) {
20 |     return `Authentication is enforced to be ${enforcedType}, but you are currently using ${authType}.`;
21 |   }
22 |   if (settings.merged.security?.auth?.useExternal) {
23 |     return null;
24 |   }
25 |   return validateAuthMethod(authType);
26 | }
27 | 
28 | export const useAuthCommand = (settings: LoadedSettings, config: Config) => {
29 |   const [authState, setAuthState] = useState<AuthState>(
30 |     AuthState.Unauthenticated,
31 |   );
32 | 
33 |   const [authError, setAuthError] = useState<string | null>(null);
34 | 
35 |   const onAuthError = useCallback(
36 |     (error: string) => {
37 |       setAuthError(error);
38 |       setAuthState(AuthState.Updating);
39 |     },
40 |     [setAuthError, setAuthState],
41 |   );
42 | 
43 |   useEffect(() => {
44 |     (async () => {
45 |       if (authState !== AuthState.Unauthenticated) {
46 |         return;
47 |       }
48 | 
49 |       const authType = settings.merged.security?.auth?.selectedType;
50 |       if (!authType) {
51 |         if (process.env['GEMINI_API_KEY']) {
52 |           onAuthError(
53 |             'Existing API key detected (GEMINI_API_KEY). Select "Gemini API Key" option to use it.',
54 |           );
55 |         } else {
56 |           onAuthError('No authentication method selected.');
57 |         }
58 |         return;
59 |       }
60 |       const error = validateAuthMethodWithSettings(authType, settings);
61 |       if (error) {
62 |         onAuthError(error);
63 |         return;
64 |       }
65 | 
66 |       const defaultAuthType = process.env['GEMINI_DEFAULT_AUTH_TYPE'];
67 |       if (
68 |         defaultAuthType &&
69 |         !Object.values(AuthType).includes(defaultAuthType as AuthType)
70 |       ) {
71 |         onAuthError(
72 |           `Invalid value for GEMINI_DEFAULT_AUTH_TYPE: "${defaultAuthType}". ` +
73 |             `Valid values are: ${Object.values(AuthType).join(', ')}.`,
74 |         );
75 |         return;
76 |       }
77 | 
78 |       try {
79 |         await config.refreshAuth(authType);
80 | 
81 |         console.log(`Authenticated via "${authType}".`);
82 |         setAuthError(null);
83 |         setAuthState(AuthState.Authenticated);
84 |       } catch (e) {
85 |         onAuthError(`Failed to login. Message: ${getErrorMessage(e)}`);
86 |       }
87 |     })();
88 |   }, [settings, config, authState, setAuthState, setAuthError, onAuthError]);
89 | 
90 |   return {
91 |     authState,
92 |     setAuthState,
93 |     authError,
94 |     onAuthError,
95 |   };
96 | };
```

src/ui/commands/aboutCommand.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect, beforeEach, vi, afterEach } from 'vitest';
8 | import { aboutCommand } from './aboutCommand.js';
9 | import { type CommandContext } from './types.js';
10 | import { createMockCommandContext } from '../../test-utils/mockCommandContext.js';
11 | import * as versionUtils from '../../utils/version.js';
12 | import { MessageType } from '../types.js';
13 | import { IdeClient } from '@google/gemini-cli-core';
14 | 
15 | vi.mock('@google/gemini-cli-core', async (importOriginal) => {
16 |   const actual =
17 |     await importOriginal<typeof import('@google/gemini-cli-core')>();
18 |   return {
19 |     ...actual,
20 |     IdeClient: {
21 |       getInstance: vi.fn().mockResolvedValue({
22 |         getDetectedIdeDisplayName: vi.fn().mockReturnValue('test-ide'),
23 |       }),
24 |     },
25 |   };
26 | });
27 | 
28 | vi.mock('../../utils/version.js', () => ({
29 |   getCliVersion: vi.fn(),
30 | }));
31 | 
32 | describe('aboutCommand', () => {
33 |   let mockContext: CommandContext;
34 |   const originalPlatform = process.platform;
35 |   const originalEnv = { ...process.env };
36 | 
37 |   beforeEach(() => {
38 |     mockContext = createMockCommandContext({
39 |       services: {
40 |         config: {
41 |           getModel: vi.fn(),
42 |           getIdeMode: vi.fn().mockReturnValue(true),
43 |         },
44 |         settings: {
45 |           merged: {
46 |             security: {
47 |               auth: {
48 |                 selectedType: 'test-auth',
49 |               },
50 |             },
51 |           },
52 |         },
53 |       },
54 |       ui: {
55 |         addItem: vi.fn(),
56 |       },
57 |     } as unknown as CommandContext);
58 | 
59 |     vi.mocked(versionUtils.getCliVersion).mockResolvedValue('test-version');
60 |     vi.spyOn(mockContext.services.config!, 'getModel').mockReturnValue(
61 |       'test-model',
62 |     );
63 |     process.env['GOOGLE_CLOUD_PROJECT'] = 'test-gcp-project';
64 |     Object.defineProperty(process, 'platform', {
65 |       value: 'test-os',
66 |     });
67 |   });
68 | 
69 |   afterEach(() => {
70 |     vi.unstubAllEnvs();
71 |     Object.defineProperty(process, 'platform', {
72 |       value: originalPlatform,
73 |     });
74 |     process.env = originalEnv;
75 |     vi.clearAllMocks();
76 |   });
77 | 
78 |   it('should have the correct name and description', () => {
79 |     expect(aboutCommand.name).toBe('about');
80 |     expect(aboutCommand.description).toBe('show version info');
81 |   });
82 | 
83 |   it('should call addItem with all version info', async () => {
84 |     process.env['SANDBOX'] = '';
85 |     if (!aboutCommand.action) {
86 |       throw new Error('The about command must have an action.');
87 |     }
88 | 
89 |     await aboutCommand.action(mockContext, '');
90 | 
91 |     expect(mockContext.ui.addItem).toHaveBeenCalledWith(
92 |       {
93 |         type: MessageType.ABOUT,
94 |         cliVersion: 'test-version',
95 |         osVersion: 'test-os',
96 |         sandboxEnv: 'no sandbox',
97 |         modelVersion: 'test-model',
98 |         selectedAuthType: 'test-auth',
99 |         gcpProject: 'test-gcp-project',
100 |         ideClient: 'test-ide',
101 |       },
102 |       expect.any(Number),
103 |     );
104 |   });
105 | 
106 |   it('should show the correct sandbox environment variable', async () => {
107 |     process.env['SANDBOX'] = 'gemini-sandbox';
108 |     if (!aboutCommand.action) {
109 |       throw new Error('The about command must have an action.');
110 |     }
111 | 
112 |     await aboutCommand.action(mockContext, '');
113 | 
114 |     expect(mockContext.ui.addItem).toHaveBeenCalledWith(
115 |       expect.objectContaining({
116 |         sandboxEnv: 'gemini-sandbox',
117 |       }),
118 |       expect.any(Number),
119 |     );
120 |   });
121 | 
122 |   it('should show sandbox-exec profile when applicable', async () => {
123 |     process.env['SANDBOX'] = 'sandbox-exec';
124 |     process.env['SEATBELT_PROFILE'] = 'test-profile';
125 |     if (!aboutCommand.action) {
126 |       throw new Error('The about command must have an action.');
127 |     }
128 | 
129 |     await aboutCommand.action(mockContext, '');
130 | 
131 |     expect(mockContext.ui.addItem).toHaveBeenCalledWith(
132 |       expect.objectContaining({
133 |         sandboxEnv: 'sandbox-exec (test-profile)',
134 |       }),
135 |       expect.any(Number),
136 |     );
137 |   });
138 | 
139 |   it('should not show ide client when it is not detected', async () => {
140 |     vi.mocked(IdeClient.getInstance).mockResolvedValue({
141 |       getDetectedIdeDisplayName: vi.fn().mockReturnValue(undefined),
142 |     } as unknown as IdeClient);
143 | 
144 |     process.env['SANDBOX'] = '';
145 |     if (!aboutCommand.action) {
146 |       throw new Error('The about command must have an action.');
147 |     }
148 | 
149 |     await aboutCommand.action(mockContext, '');
150 | 
151 |     expect(mockContext.ui.addItem).toHaveBeenCalledWith(
152 |       expect.objectContaining({
153 |         type: MessageType.ABOUT,
154 |         cliVersion: 'test-version',
155 |         osVersion: 'test-os',
156 |         sandboxEnv: 'no sandbox',
157 |         modelVersion: 'test-model',
158 |         selectedAuthType: 'test-auth',
159 |         gcpProject: 'test-gcp-project',
160 |         ideClient: '',
161 |       }),
162 |       expect.any(Number),
163 |     );
164 |   });
165 | });
```

src/ui/commands/aboutCommand.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { getCliVersion } from '../../utils/version.js';
8 | import type { CommandContext, SlashCommand } from './types.js';
9 | import { CommandKind } from './types.js';
10 | import process from 'node:process';
11 | import { MessageType, type HistoryItemAbout } from '../types.js';
12 | import { IdeClient } from '@google/gemini-cli-core';
13 | 
14 | export const aboutCommand: SlashCommand = {
15 |   name: 'about',
16 |   description: 'show version info',
17 |   kind: CommandKind.BUILT_IN,
18 |   action: async (context) => {
19 |     const osVersion = process.platform;
20 |     let sandboxEnv = 'no sandbox';
21 |     if (process.env['SANDBOX'] && process.env['SANDBOX'] !== 'sandbox-exec') {
22 |       sandboxEnv = process.env['SANDBOX'];
23 |     } else if (process.env['SANDBOX'] === 'sandbox-exec') {
24 |       sandboxEnv = `sandbox-exec (${
25 |         process.env['SEATBELT_PROFILE'] || 'unknown'
26 |       })`;
27 |     }
28 |     const modelVersion = context.services.config?.getModel() || 'Unknown';
29 |     const cliVersion = await getCliVersion();
30 |     const selectedAuthType =
31 |       context.services.settings.merged.security?.auth?.selectedType || '';
32 |     const gcpProject = process.env['GOOGLE_CLOUD_PROJECT'] || '';
33 |     const ideClient = await getIdeClientName(context);
34 | 
35 |     const aboutItem: Omit<HistoryItemAbout, 'id'> = {
36 |       type: MessageType.ABOUT,
37 |       cliVersion,
38 |       osVersion,
39 |       sandboxEnv,
40 |       modelVersion,
41 |       selectedAuthType,
42 |       gcpProject,
43 |       ideClient,
44 |     };
45 | 
46 |     context.ui.addItem(aboutItem, Date.now());
47 |   },
48 | };
49 | 
50 | async function getIdeClientName(context: CommandContext) {
51 |   if (!context.services.config?.getIdeMode()) {
52 |     return '';
53 |   }
54 |   const ideClient = await IdeClient.getInstance();
55 |   return ideClient?.getDetectedIdeDisplayName() ?? '';
56 | }
```

src/ui/commands/authCommand.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect, beforeEach } from 'vitest';
8 | import { authCommand } from './authCommand.js';
9 | import { type CommandContext } from './types.js';
10 | import { createMockCommandContext } from '../../test-utils/mockCommandContext.js';
11 | 
12 | describe('authCommand', () => {
13 |   let mockContext: CommandContext;
14 | 
15 |   beforeEach(() => {
16 |     mockContext = createMockCommandContext();
17 |   });
18 | 
19 |   it('should return a dialog action to open the auth dialog', () => {
20 |     if (!authCommand.action) {
21 |       throw new Error('The auth command must have an action.');
22 |     }
23 | 
24 |     const result = authCommand.action(mockContext, '');
25 | 
26 |     expect(result).toEqual({
27 |       type: 'dialog',
28 |       dialog: 'auth',
29 |     });
30 |   });
31 | 
32 |   it('should have the correct name and description', () => {
33 |     expect(authCommand.name).toBe('auth');
34 |     expect(authCommand.description).toBe('change the auth method');
35 |   });
36 | });
```

src/ui/commands/authCommand.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type { OpenDialogActionReturn, SlashCommand } from './types.js';
8 | import { CommandKind } from './types.js';
9 | 
10 | export const authCommand: SlashCommand = {
11 |   name: 'auth',
12 |   description: 'change the auth method',
13 |   kind: CommandKind.BUILT_IN,
14 |   action: (_context, _args): OpenDialogActionReturn => ({
15 |     type: 'dialog',
16 |     dialog: 'auth',
17 |   }),
18 | };
```

src/ui/commands/bugCommand.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
8 | import open from 'open';
9 | import { bugCommand } from './bugCommand.js';
10 | import { createMockCommandContext } from '../../test-utils/mockCommandContext.js';
11 | import { getCliVersion } from '../../utils/version.js';
12 | import { GIT_COMMIT_INFO } from '../../generated/git-commit.js';
13 | import { formatMemoryUsage } from '../utils/formatters.js';
14 | 
15 | // Mock dependencies
16 | vi.mock('open');
17 | vi.mock('../../utils/version.js');
18 | vi.mock('../utils/formatters.js');
19 | vi.mock('@google/gemini-cli-core', async (importOriginal) => {
20 |   const actual =
21 |     await importOriginal<typeof import('@google/gemini-cli-core')>();
22 |   return {
23 |     ...actual,
24 |     IdeClient: {
25 |       getInstance: () => ({
26 |         getDetectedIdeDisplayName: vi.fn().mockReturnValue('VSCode'),
27 |       }),
28 |     },
29 |     sessionId: 'test-session-id',
30 |   };
31 | });
32 | vi.mock('node:process', () => ({
33 |   default: {
34 |     platform: 'test-platform',
35 |     version: 'v20.0.0',
36 |     // Keep other necessary process properties if needed by other parts of the code
37 |     env: process.env,
38 |     memoryUsage: () => ({ rss: 0 }),
39 |   },
40 | }));
41 | 
42 | describe('bugCommand', () => {
43 |   beforeEach(() => {
44 |     vi.mocked(getCliVersion).mockResolvedValue('0.1.0');
45 |     vi.mocked(formatMemoryUsage).mockReturnValue('100 MB');
46 |     vi.stubEnv('SANDBOX', 'gemini-test');
47 |   });
48 | 
49 |   afterEach(() => {
50 |     vi.unstubAllEnvs();
51 |     vi.clearAllMocks();
52 |   });
53 | 
54 |   it('should generate the default GitHub issue URL', async () => {
55 |     const mockContext = createMockCommandContext({
56 |       services: {
57 |         config: {
58 |           getModel: () => 'gemini-pro',
59 |           getBugCommand: () => undefined,
60 |           getIdeMode: () => true,
61 |         },
62 |       },
63 |     });
64 | 
65 |     if (!bugCommand.action) throw new Error('Action is not defined');
66 |     await bugCommand.action(mockContext, 'A test bug');
67 | 
68 |     const expectedInfo = `
69 | * **CLI Version:** 0.1.0
70 | * **Git Commit:** ${GIT_COMMIT_INFO}
71 | * **Session ID:** test-session-id
72 | * **Operating System:** test-platform v20.0.0
73 | * **Sandbox Environment:** test
74 | * **Model Version:** gemini-pro
75 | * **Memory Usage:** 100 MB
76 | * **IDE Client:** VSCode
77 | `;
78 |     const expectedUrl =
79 |       'https://github.com/google-gemini/gemini-cli/issues/new?template=bug_report.yml&title=A%20test%20bug&info=' +
80 |       encodeURIComponent(expectedInfo);
81 | 
82 |     expect(open).toHaveBeenCalledWith(expectedUrl);
83 |   });
84 | 
85 |   it('should use a custom URL template from config if provided', async () => {
86 |     const customTemplate =
87 |       'https://internal.bug-tracker.com/new?desc={title}&details={info}';
88 |     const mockContext = createMockCommandContext({
89 |       services: {
90 |         config: {
91 |           getModel: () => 'gemini-pro',
92 |           getBugCommand: () => ({ urlTemplate: customTemplate }),
93 |           getIdeMode: () => true,
94 |         },
95 |       },
96 |     });
97 | 
98 |     if (!bugCommand.action) throw new Error('Action is not defined');
99 |     await bugCommand.action(mockContext, 'A custom bug');
100 | 
101 |     const expectedInfo = `
102 | * **CLI Version:** 0.1.0
103 | * **Git Commit:** ${GIT_COMMIT_INFO}
104 | * **Session ID:** test-session-id
105 | * **Operating System:** test-platform v20.0.0
106 | * **Sandbox Environment:** test
107 | * **Model Version:** gemini-pro
108 | * **Memory Usage:** 100 MB
109 | * **IDE Client:** VSCode
110 | `;
111 |     const expectedUrl = customTemplate
112 |       .replace('{title}', encodeURIComponent('A custom bug'))
113 |       .replace('{info}', encodeURIComponent(expectedInfo));
114 | 
115 |     expect(open).toHaveBeenCalledWith(expectedUrl);
116 |   });
117 | });
```

src/ui/commands/bugCommand.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import open from 'open';
8 | import process from 'node:process';
9 | import {
10 |   type CommandContext,
11 |   type SlashCommand,
12 |   CommandKind,
13 | } from './types.js';
14 | import { MessageType } from '../types.js';
15 | import { GIT_COMMIT_INFO } from '../../generated/git-commit.js';
16 | import { formatMemoryUsage } from '../utils/formatters.js';
17 | import { getCliVersion } from '../../utils/version.js';
18 | import { IdeClient, sessionId } from '@google/gemini-cli-core';
19 | 
20 | export const bugCommand: SlashCommand = {
21 |   name: 'bug',
22 |   description: 'submit a bug report',
23 |   kind: CommandKind.BUILT_IN,
24 |   action: async (context: CommandContext, args?: string): Promise<void> => {
25 |     const bugDescription = (args || '').trim();
26 |     const { config } = context.services;
27 | 
28 |     const osVersion = `${process.platform} ${process.version}`;
29 |     let sandboxEnv = 'no sandbox';
30 |     if (process.env['SANDBOX'] && process.env['SANDBOX'] !== 'sandbox-exec') {
31 |       sandboxEnv = process.env['SANDBOX'].replace(/^gemini-(?:code-)?/, '');
32 |     } else if (process.env['SANDBOX'] === 'sandbox-exec') {
33 |       sandboxEnv = `sandbox-exec (${
34 |         process.env['SEATBELT_PROFILE'] || 'unknown'
35 |       })`;
36 |     }
37 |     const modelVersion = config?.getModel() || 'Unknown';
38 |     const cliVersion = await getCliVersion();
39 |     const memoryUsage = formatMemoryUsage(process.memoryUsage().rss);
40 |     const ideClient = await getIdeClientName(context);
41 | 
42 |     let info = `
43 | * **CLI Version:** ${cliVersion}
44 | * **Git Commit:** ${GIT_COMMIT_INFO}
45 | * **Session ID:** ${sessionId}
46 | * **Operating System:** ${osVersion}
47 | * **Sandbox Environment:** ${sandboxEnv}
48 | * **Model Version:** ${modelVersion}
49 | * **Memory Usage:** ${memoryUsage}
50 | `;
51 |     if (ideClient) {
52 |       info += `* **IDE Client:** ${ideClient}\n`;
53 |     }
54 | 
55 |     let bugReportUrl =
56 |       'https://github.com/google-gemini/gemini-cli/issues/new?template=bug_report.yml&title={title}&info={info}';
57 | 
58 |     const bugCommandSettings = config?.getBugCommand();
59 |     if (bugCommandSettings?.urlTemplate) {
60 |       bugReportUrl = bugCommandSettings.urlTemplate;
61 |     }
62 | 
63 |     bugReportUrl = bugReportUrl
64 |       .replace('{title}', encodeURIComponent(bugDescription))
65 |       .replace('{info}', encodeURIComponent(info));
66 | 
67 |     context.ui.addItem(
68 |       {
69 |         type: MessageType.INFO,
70 |         text: `To submit your bug report, please open the following URL in your browser:\n${bugReportUrl}`,
71 |       },
72 |       Date.now(),
73 |     );
74 | 
75 |     try {
76 |       await open(bugReportUrl);
77 |     } catch (error) {
78 |       const errorMessage =
79 |         error instanceof Error ? error.message : String(error);
80 |       context.ui.addItem(
81 |         {
82 |           type: MessageType.ERROR,
83 |           text: `Could not open URL in browser: ${errorMessage}`,
84 |         },
85 |         Date.now(),
86 |       );
87 |     }
88 |   },
89 | };
90 | 
91 | async function getIdeClientName(context: CommandContext) {
92 |   if (!context.services.config?.getIdeMode()) {
93 |     return '';
94 |   }
95 |   const ideClient = await IdeClient.getInstance();
96 |   return ideClient.getDetectedIdeDisplayName() ?? '';
97 | }
```

src/ui/commands/chatCommand.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type { Mocked } from 'vitest';
8 | import { vi, describe, it, expect, beforeEach, afterEach } from 'vitest';
9 | 
10 | import type { SlashCommand, CommandContext } from './types.js';
11 | import { createMockCommandContext } from '../../test-utils/mockCommandContext.js';
12 | import type { Content } from '@google/genai';
13 | import type { GeminiClient } from '@google/gemini-cli-core';
14 | 
15 | import * as fsPromises from 'node:fs/promises';
16 | import { chatCommand, serializeHistoryToMarkdown } from './chatCommand.js';
17 | import type { Stats } from 'node:fs';
18 | import type { HistoryItemWithoutId } from '../types.js';
19 | import path from 'node:path';
20 | 
21 | vi.mock('fs/promises', () => ({
22 |   stat: vi.fn(),
23 |   readdir: vi.fn().mockResolvedValue(['file1.txt', 'file2.txt'] as string[]),
24 |   writeFile: vi.fn(),
25 | }));
26 | 
27 | describe('chatCommand', () => {
28 |   const mockFs = fsPromises as Mocked<typeof fsPromises>;
29 | 
30 |   let mockContext: CommandContext;
31 |   let mockGetChat: ReturnType<typeof vi.fn>;
32 |   let mockSaveCheckpoint: ReturnType<typeof vi.fn>;
33 |   let mockLoadCheckpoint: ReturnType<typeof vi.fn>;
34 |   let mockDeleteCheckpoint: ReturnType<typeof vi.fn>;
35 |   let mockGetHistory: ReturnType<typeof vi.fn>;
36 | 
37 |   const getSubCommand = (
38 |     name: 'list' | 'save' | 'resume' | 'delete' | 'share',
39 |   ): SlashCommand => {
40 |     const subCommand = chatCommand.subCommands?.find(
41 |       (cmd) => cmd.name === name,
42 |     );
43 |     if (!subCommand) {
44 |       throw new Error(`/chat ${name} command not found.`);
45 |     }
46 |     return subCommand;
47 |   };
48 | 
49 |   beforeEach(() => {
50 |     mockGetHistory = vi.fn().mockReturnValue([]);
51 |     mockGetChat = vi.fn().mockResolvedValue({
52 |       getHistory: mockGetHistory,
53 |     });
54 |     mockSaveCheckpoint = vi.fn().mockResolvedValue(undefined);
55 |     mockLoadCheckpoint = vi.fn().mockResolvedValue([]);
56 |     mockDeleteCheckpoint = vi.fn().mockResolvedValue(true);
57 | 
58 |     mockContext = createMockCommandContext({
59 |       services: {
60 |         config: {
61 |           getProjectRoot: () => '/project/root',
62 |           getGeminiClient: () =>
63 |             ({
64 |               getChat: mockGetChat,
65 |             }) as unknown as GeminiClient,
66 |           storage: {
67 |             getProjectTempDir: () => '/project/root/.gemini/tmp/mockhash',
68 |           },
69 |         },
70 |         logger: {
71 |           saveCheckpoint: mockSaveCheckpoint,
72 |           loadCheckpoint: mockLoadCheckpoint,
73 |           deleteCheckpoint: mockDeleteCheckpoint,
74 |           initialize: vi.fn().mockResolvedValue(undefined),
75 |         },
76 |       },
77 |     });
78 |   });
79 | 
80 |   afterEach(() => {
81 |     vi.restoreAllMocks();
82 |   });
83 | 
84 |   it('should have the correct main command definition', () => {
85 |     expect(chatCommand.name).toBe('chat');
86 |     expect(chatCommand.description).toBe('Manage conversation history.');
87 |     expect(chatCommand.subCommands).toHaveLength(5);
88 |   });
89 | 
90 |   describe('list subcommand', () => {
91 |     let listCommand: SlashCommand;
92 | 
93 |     beforeEach(() => {
94 |       listCommand = getSubCommand('list');
95 |     });
96 | 
97 |     it('should add a chat_list item to the UI', async () => {
98 |       const fakeFiles = ['checkpoint-test1.json', 'checkpoint-test2.json'];
99 |       const date1 = new Date();
100 |       const date2 = new Date(date1.getTime() + 1000);
101 | 
102 |       mockFs.readdir.mockResolvedValue(fakeFiles);
103 |       mockFs.stat.mockImplementation(async (path: string): Promise<Stats> => {
104 |         if (path.endsWith('test1.json')) {
105 |           return { mtime: date1 } as Stats;
106 |         }
107 |         return { mtime: date2 } as Stats;
108 |       });
109 | 
110 |       await listCommand?.action?.(mockContext, '');
111 | 
112 |       expect(mockContext.ui.addItem).toHaveBeenCalledWith(
113 |         {
114 |           type: 'chat_list',
115 |           chats: [
116 |             {
117 |               name: 'test1',
118 |               mtime: date1.toISOString(),
119 |             },
120 |             {
121 |               name: 'test2',
122 |               mtime: date2.toISOString(),
123 |             },
124 |           ],
125 |         },
126 |         expect.any(Number),
127 |       );
128 |     });
129 |   });
130 |   describe('save subcommand', () => {
131 |     let saveCommand: SlashCommand;
132 |     const tag = 'my-tag';
133 |     let mockCheckpointExists: ReturnType<typeof vi.fn>;
134 | 
135 |     beforeEach(() => {
136 |       saveCommand = getSubCommand('save');
137 |       mockCheckpointExists = vi.fn().mockResolvedValue(false);
138 |       mockContext.services.logger.checkpointExists = mockCheckpointExists;
139 |     });
140 | 
141 |     it('should return an error if tag is missing', async () => {
142 |       const result = await saveCommand?.action?.(mockContext, '  ');
143 |       expect(result).toEqual({
144 |         type: 'message',
145 |         messageType: 'error',
146 |         content: 'Missing tag. Usage: /chat save <tag>',
147 |       });
148 |     });
149 | 
150 |     it('should inform if conversation history is empty or only contains system context', async () => {
151 |       mockGetHistory.mockReturnValue([]);
152 |       let result = await saveCommand?.action?.(mockContext, tag);
153 |       expect(result).toEqual({
154 |         type: 'message',
155 |         messageType: 'info',
156 |         content: 'No conversation found to save.',
157 |       });
158 | 
159 |       mockGetHistory.mockReturnValue([
160 |         { role: 'user', parts: [{ text: 'context for our chat' }] },
161 |         { role: 'model', parts: [{ text: 'Got it. Thanks for the context!' }] },
162 |       ]);
163 |       result = await saveCommand?.action?.(mockContext, tag);
164 |       expect(result).toEqual({
165 |         type: 'message',
166 |         messageType: 'info',
167 |         content: 'No conversation found to save.',
168 |       });
169 | 
170 |       mockGetHistory.mockReturnValue([
171 |         { role: 'user', parts: [{ text: 'context for our chat' }] },
172 |         { role: 'model', parts: [{ text: 'Got it. Thanks for the context!' }] },
173 |         { role: 'user', parts: [{ text: 'Hello, how are you?' }] },
174 |       ]);
175 |       result = await saveCommand?.action?.(mockContext, tag);
176 |       expect(result).toEqual({
177 |         type: 'message',
178 |         messageType: 'info',
179 |         content: `Conversation checkpoint saved with tag: ${tag}.`,
180 |       });
181 |     });
182 | 
183 |     it('should return confirm_action if checkpoint already exists', async () => {
184 |       mockCheckpointExists.mockResolvedValue(true);
185 |       mockContext.invocation = {
186 |         raw: `/chat save ${tag}`,
187 |         name: 'save',
188 |         args: tag,
189 |       };
190 | 
191 |       const result = await saveCommand?.action?.(mockContext, tag);
192 | 
193 |       expect(mockCheckpointExists).toHaveBeenCalledWith(tag);
194 |       expect(mockSaveCheckpoint).not.toHaveBeenCalled();
195 |       expect(result).toMatchObject({
196 |         type: 'confirm_action',
197 |         originalInvocation: { raw: `/chat save ${tag}` },
198 |       });
199 |       // Check that prompt is a React element
200 |       expect(result).toHaveProperty('prompt');
201 |     });
202 | 
203 |     it('should save the conversation if overwrite is confirmed', async () => {
204 |       const history: Content[] = [
205 |         { role: 'user', parts: [{ text: 'context for our chat' }] },
206 |         { role: 'model', parts: [{ text: 'Got it. Thanks for the context!' }] },
207 |         { role: 'user', parts: [{ text: 'hello' }] },
208 |         { role: 'model', parts: [{ text: 'Hi there!' }] },
209 |       ];
210 |       mockGetHistory.mockReturnValue(history);
211 |       mockContext.overwriteConfirmed = true;
212 | 
213 |       const result = await saveCommand?.action?.(mockContext, tag);
214 | 
215 |       expect(mockCheckpointExists).not.toHaveBeenCalled(); // Should skip existence check
216 |       expect(mockSaveCheckpoint).toHaveBeenCalledWith(history, tag);
217 |       expect(result).toEqual({
218 |         type: 'message',
219 |         messageType: 'info',
220 |         content: `Conversation checkpoint saved with tag: ${tag}.`,
221 |       });
222 |     });
223 |   });
224 | 
225 |   describe('resume subcommand', () => {
226 |     const goodTag = 'good-tag';
227 |     const badTag = 'bad-tag';
228 | 
229 |     let resumeCommand: SlashCommand;
230 |     beforeEach(() => {
231 |       resumeCommand = getSubCommand('resume');
232 |     });
233 | 
234 |     it('should return an error if tag is missing', async () => {
235 |       const result = await resumeCommand?.action?.(mockContext, '');
236 | 
237 |       expect(result).toEqual({
238 |         type: 'message',
239 |         messageType: 'error',
240 |         content: 'Missing tag. Usage: /chat resume <tag>',
241 |       });
242 |     });
243 | 
244 |     it('should inform if checkpoint is not found', async () => {
245 |       mockLoadCheckpoint.mockResolvedValue([]);
246 | 
247 |       const result = await resumeCommand?.action?.(mockContext, badTag);
248 | 
249 |       expect(result).toEqual({
250 |         type: 'message',
251 |         messageType: 'info',
252 |         content: `No saved checkpoint found with tag: ${badTag}.`,
253 |       });
254 |     });
255 | 
256 |     it('should resume a conversation', async () => {
257 |       const conversation: Content[] = [
258 |         { role: 'user', parts: [{ text: 'hello gemini' }] },
259 |         { role: 'model', parts: [{ text: 'hello world' }] },
260 |       ];
261 |       mockLoadCheckpoint.mockResolvedValue(conversation);
262 | 
263 |       const result = await resumeCommand?.action?.(mockContext, goodTag);
264 | 
265 |       expect(result).toEqual({
266 |         type: 'load_history',
267 |         history: [
268 |           { type: 'user', text: 'hello gemini' },
269 |           { type: 'gemini', text: 'hello world' },
270 |         ] as HistoryItemWithoutId[],
271 |         clientHistory: conversation,
272 |       });
273 |     });
274 | 
275 |     describe('completion', () => {
276 |       it('should provide completion suggestions', async () => {
277 |         const fakeFiles = ['checkpoint-alpha.json', 'checkpoint-beta.json'];
278 |         mockFs.readdir.mockImplementation(
279 |           (async (_: string): Promise<string[]> =>
280 |             fakeFiles as string[]) as unknown as typeof fsPromises.readdir,
281 |         );
282 | 
283 |         mockFs.stat.mockImplementation(
284 |           (async (_: string): Promise<Stats> =>
285 |             ({
286 |               mtime: new Date(),
287 |             }) as Stats) as unknown as typeof fsPromises.stat,
288 |         );
289 | 
290 |         const result = await resumeCommand?.completion?.(mockContext, 'a');
291 | 
292 |         expect(result).toEqual(['alpha']);
293 |       });
294 | 
295 |       it('should suggest filenames sorted by modified time (newest first)', async () => {
296 |         const fakeFiles = ['checkpoint-test1.json', 'checkpoint-test2.json'];
297 |         const date = new Date();
298 |         mockFs.readdir.mockImplementation(
299 |           (async (_: string): Promise<string[]> =>
300 |             fakeFiles as string[]) as unknown as typeof fsPromises.readdir,
301 |         );
302 |         mockFs.stat.mockImplementation((async (
303 |           path: string,
304 |         ): Promise<Stats> => {
305 |           if (path.endsWith('test1.json')) {
306 |             return { mtime: date } as Stats;
307 |           }
308 |           return { mtime: new Date(date.getTime() + 1000) } as Stats;
309 |         }) as unknown as typeof fsPromises.stat);
310 | 
311 |         const result = await resumeCommand?.completion?.(mockContext, '');
312 |         // Sort items by last modified time (newest first)
313 |         expect(result).toEqual(['test2', 'test1']);
314 |       });
315 |     });
316 |   });
317 | 
318 |   describe('delete subcommand', () => {
319 |     let deleteCommand: SlashCommand;
320 |     const tag = 'my-tag';
321 |     beforeEach(() => {
322 |       deleteCommand = getSubCommand('delete');
323 |     });
324 | 
325 |     it('should return an error if tag is missing', async () => {
326 |       const result = await deleteCommand?.action?.(mockContext, '  ');
327 |       expect(result).toEqual({
328 |         type: 'message',
329 |         messageType: 'error',
330 |         content: 'Missing tag. Usage: /chat delete <tag>',
331 |       });
332 |     });
333 | 
334 |     it('should return an error if checkpoint is not found', async () => {
335 |       mockDeleteCheckpoint.mockResolvedValue(false);
336 |       const result = await deleteCommand?.action?.(mockContext, tag);
337 |       expect(result).toEqual({
338 |         type: 'message',
339 |         messageType: 'error',
340 |         content: `Error: No checkpoint found with tag '${tag}'.`,
341 |       });
342 |     });
343 | 
344 |     it('should delete the conversation', async () => {
345 |       const result = await deleteCommand?.action?.(mockContext, tag);
346 | 
347 |       expect(mockDeleteCheckpoint).toHaveBeenCalledWith(tag);
348 |       expect(result).toEqual({
349 |         type: 'message',
350 |         messageType: 'info',
351 |         content: `Conversation checkpoint '${tag}' has been deleted.`,
352 |       });
353 |     });
354 | 
355 |     describe('completion', () => {
356 |       it('should provide completion suggestions', async () => {
357 |         const fakeFiles = ['checkpoint-alpha.json', 'checkpoint-beta.json'];
358 |         mockFs.readdir.mockImplementation(
359 |           (async (_: string): Promise<string[]> =>
[TRUNCATED]
```

src/ui/commands/chatCommand.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import * as fsPromises from 'node:fs/promises';
8 | import React from 'react';
9 | import { Text } from 'ink';
10 | import { theme } from '../semantic-colors.js';
11 | import type {
12 |   CommandContext,
13 |   SlashCommand,
14 |   MessageActionReturn,
15 |   SlashCommandActionReturn,
16 | } from './types.js';
17 | import { CommandKind } from './types.js';
18 | import { decodeTagName } from '@google/gemini-cli-core';
19 | import path from 'node:path';
20 | import type {
21 |   HistoryItemWithoutId,
22 |   HistoryItemChatList,
23 |   ChatDetail,
24 | } from '../types.js';
25 | import { MessageType } from '../types.js';
26 | import type { Content } from '@google/genai';
27 | 
28 | const getSavedChatTags = async (
29 |   context: CommandContext,
30 |   mtSortDesc: boolean,
31 | ): Promise<ChatDetail[]> => {
32 |   const cfg = context.services.config;
33 |   const geminiDir = cfg?.storage?.getProjectTempDir();
34 |   if (!geminiDir) {
35 |     return [];
36 |   }
37 |   try {
38 |     const file_head = 'checkpoint-';
39 |     const file_tail = '.json';
40 |     const files = await fsPromises.readdir(geminiDir);
41 |     const chatDetails: ChatDetail[] = [];
42 | 
43 |     for (const file of files) {
44 |       if (file.startsWith(file_head) && file.endsWith(file_tail)) {
45 |         const filePath = path.join(geminiDir, file);
46 |         const stats = await fsPromises.stat(filePath);
47 |         const tagName = file.slice(file_head.length, -file_tail.length);
48 |         chatDetails.push({
49 |           name: decodeTagName(tagName),
50 |           mtime: stats.mtime.toISOString(),
51 |         });
52 |       }
53 |     }
54 | 
55 |     chatDetails.sort((a, b) =>
56 |       mtSortDesc
57 |         ? b.mtime.localeCompare(a.mtime)
58 |         : a.mtime.localeCompare(b.mtime),
59 |     );
60 | 
61 |     return chatDetails;
62 |   } catch (_err) {
63 |     return [];
64 |   }
65 | };
66 | 
67 | const listCommand: SlashCommand = {
68 |   name: 'list',
69 |   description: 'List saved conversation checkpoints',
70 |   kind: CommandKind.BUILT_IN,
71 |   action: async (context): Promise<void> => {
72 |     const chatDetails = await getSavedChatTags(context, false);
73 | 
74 |     const item: HistoryItemChatList = {
75 |       type: MessageType.CHAT_LIST,
76 |       chats: chatDetails,
77 |     };
78 | 
79 |     context.ui.addItem(item, Date.now());
80 |   },
81 | };
82 | 
83 | const saveCommand: SlashCommand = {
84 |   name: 'save',
85 |   description:
86 |     'Save the current conversation as a checkpoint. Usage: /chat save <tag>',
87 |   kind: CommandKind.BUILT_IN,
88 |   action: async (context, args): Promise<SlashCommandActionReturn | void> => {
89 |     const tag = args.trim();
90 |     if (!tag) {
91 |       return {
92 |         type: 'message',
93 |         messageType: 'error',
94 |         content: 'Missing tag. Usage: /chat save <tag>',
95 |       };
96 |     }
97 | 
98 |     const { logger, config } = context.services;
99 |     await logger.initialize();
100 | 
101 |     if (!context.overwriteConfirmed) {
102 |       const exists = await logger.checkpointExists(tag);
103 |       if (exists) {
104 |         return {
105 |           type: 'confirm_action',
106 |           prompt: React.createElement(
107 |             Text,
108 |             null,
109 |             'A checkpoint with the tag ',
110 |             React.createElement(Text, { color: theme.text.accent }, tag),
111 |             ' already exists. Do you want to overwrite it?',
112 |           ),
113 |           originalInvocation: {
114 |             raw: context.invocation?.raw || `/chat save ${tag}`,
115 |           },
116 |         };
117 |       }
118 |     }
119 | 
120 |     const chat = await config?.getGeminiClient()?.getChat();
121 |     if (!chat) {
122 |       return {
123 |         type: 'message',
124 |         messageType: 'error',
125 |         content: 'No chat client available to save conversation.',
126 |       };
127 |     }
128 | 
129 |     const history = chat.getHistory();
130 |     if (history.length > 2) {
131 |       await logger.saveCheckpoint(history, tag);
132 |       return {
133 |         type: 'message',
134 |         messageType: 'info',
135 |         content: `Conversation checkpoint saved with tag: ${decodeTagName(tag)}.`,
136 |       };
137 |     } else {
138 |       return {
139 |         type: 'message',
140 |         messageType: 'info',
141 |         content: 'No conversation found to save.',
142 |       };
143 |     }
144 |   },
145 | };
146 | 
147 | const resumeCommand: SlashCommand = {
148 |   name: 'resume',
149 |   altNames: ['load'],
150 |   description:
151 |     'Resume a conversation from a checkpoint. Usage: /chat resume <tag>',
152 |   kind: CommandKind.BUILT_IN,
153 |   action: async (context, args) => {
154 |     const tag = args.trim();
155 |     if (!tag) {
156 |       return {
157 |         type: 'message',
158 |         messageType: 'error',
159 |         content: 'Missing tag. Usage: /chat resume <tag>',
160 |       };
161 |     }
162 | 
163 |     const { logger } = context.services;
164 |     await logger.initialize();
165 |     const conversation = await logger.loadCheckpoint(tag);
166 | 
167 |     if (conversation.length === 0) {
168 |       return {
169 |         type: 'message',
170 |         messageType: 'info',
171 |         content: `No saved checkpoint found with tag: ${decodeTagName(tag)}.`,
172 |       };
173 |     }
174 | 
175 |     const rolemap: { [key: string]: MessageType } = {
176 |       user: MessageType.USER,
177 |       model: MessageType.GEMINI,
178 |     };
179 | 
180 |     const uiHistory: HistoryItemWithoutId[] = [];
181 |     let hasSystemPrompt = false;
182 |     let i = 0;
183 | 
184 |     for (const item of conversation) {
185 |       i += 1;
186 |       const text =
187 |         item.parts
188 |           ?.filter((m) => !!m.text)
189 |           .map((m) => m.text)
190 |           .join('') || '';
191 |       if (!text) {
192 |         continue;
193 |       }
194 |       if (i === 1 && text.match(/context for our chat/)) {
195 |         hasSystemPrompt = true;
196 |       }
197 |       if (i > 2 || !hasSystemPrompt) {
198 |         uiHistory.push({
199 |           type: (item.role && rolemap[item.role]) || MessageType.GEMINI,
200 |           text,
201 |         } as HistoryItemWithoutId);
202 |       }
203 |     }
204 |     return {
205 |       type: 'load_history',
206 |       history: uiHistory,
207 |       clientHistory: conversation,
208 |     };
209 |   },
210 |   completion: async (context, partialArg) => {
211 |     const chatDetails = await getSavedChatTags(context, true);
212 |     return chatDetails
213 |       .map((chat) => chat.name)
214 |       .filter((name) => name.startsWith(partialArg));
215 |   },
216 | };
217 | 
218 | const deleteCommand: SlashCommand = {
219 |   name: 'delete',
220 |   description: 'Delete a conversation checkpoint. Usage: /chat delete <tag>',
221 |   kind: CommandKind.BUILT_IN,
222 |   action: async (context, args): Promise<MessageActionReturn> => {
223 |     const tag = args.trim();
224 |     if (!tag) {
225 |       return {
226 |         type: 'message',
227 |         messageType: 'error',
228 |         content: 'Missing tag. Usage: /chat delete <tag>',
229 |       };
230 |     }
231 | 
232 |     const { logger } = context.services;
233 |     await logger.initialize();
234 |     const deleted = await logger.deleteCheckpoint(tag);
235 | 
236 |     if (deleted) {
237 |       return {
238 |         type: 'message',
239 |         messageType: 'info',
240 |         content: `Conversation checkpoint '${decodeTagName(tag)}' has been deleted.`,
241 |       };
242 |     } else {
243 |       return {
244 |         type: 'message',
245 |         messageType: 'error',
246 |         content: `Error: No checkpoint found with tag '${decodeTagName(tag)}'.`,
247 |       };
248 |     }
249 |   },
250 |   completion: async (context, partialArg) => {
251 |     const chatDetails = await getSavedChatTags(context, true);
252 |     return chatDetails
253 |       .map((chat) => chat.name)
254 |       .filter((name) => name.startsWith(partialArg));
255 |   },
256 | };
257 | 
258 | export function serializeHistoryToMarkdown(history: Content[]): string {
259 |   return history
260 |     .map((item) => {
261 |       const text =
262 |         item.parts
263 |           ?.map((part) => {
264 |             if (part.text) {
265 |               return part.text;
266 |             }
267 |             if (part.functionCall) {
268 |               return `**Tool Command**:\n\`\`\`json\n${JSON.stringify(
269 |                 part.functionCall,
270 |                 null,
271 |                 2,
272 |               )}\n\`\`\``;
273 |             }
274 |             if (part.functionResponse) {
275 |               return `**Tool Response**:\n\`\`\`json\n${JSON.stringify(
276 |                 part.functionResponse,
277 |                 null,
278 |                 2,
279 |               )}\n\`\`\``;
280 |             }
281 |             return '';
282 |           })
283 |           .join('') || '';
284 |       const roleIcon = item.role === 'user' ? '🧑‍💻' : '✨';
285 |       return `${roleIcon} ## ${(item.role || 'model').toUpperCase()}\n\n${text}`;
286 |     })
287 |     .join('\n\n---\n\n');
288 | }
289 | 
290 | const shareCommand: SlashCommand = {
291 |   name: 'share',
292 |   description:
293 |     'Share the current conversation to a markdown or json file. Usage: /chat share <file>',
294 |   kind: CommandKind.BUILT_IN,
295 |   action: async (context, args): Promise<MessageActionReturn> => {
296 |     let filePathArg = args.trim();
297 |     if (!filePathArg) {
298 |       filePathArg = `gemini-conversation-${Date.now()}.json`;
299 |     }
300 | 
301 |     const filePath = path.resolve(filePathArg);
302 |     const extension = path.extname(filePath);
303 |     if (extension !== '.md' && extension !== '.json') {
304 |       return {
305 |         type: 'message',
306 |         messageType: 'error',
307 |         content: 'Invalid file format. Only .md and .json are supported.',
308 |       };
309 |     }
310 | 
311 |     const chat = await context.services.config?.getGeminiClient()?.getChat();
312 |     if (!chat) {
313 |       return {
314 |         type: 'message',
315 |         messageType: 'error',
316 |         content: 'No chat client available to share conversation.',
317 |       };
318 |     }
319 | 
320 |     const history = chat.getHistory();
321 | 
322 |     // An empty conversation has two hidden messages that setup the context for
323 |     // the chat. Thus, to check whether a conversation has been started, we
324 |     // can't check for length 0.
325 |     if (history.length <= 2) {
326 |       return {
327 |         type: 'message',
328 |         messageType: 'info',
329 |         content: 'No conversation found to share.',
330 |       };
331 |     }
332 | 
333 |     let content = '';
334 |     if (extension === '.json') {
335 |       content = JSON.stringify(history, null, 2);
336 |     } else {
337 |       content = serializeHistoryToMarkdown(history);
338 |     }
339 | 
340 |     try {
341 |       await fsPromises.writeFile(filePath, content);
342 |       return {
343 |         type: 'message',
344 |         messageType: 'info',
345 |         content: `Conversation shared to ${filePath}`,
346 |       };
347 |     } catch (err) {
348 |       const errorMessage = err instanceof Error ? err.message : String(err);
349 |       return {
350 |         type: 'message',
351 |         messageType: 'error',
352 |         content: `Error sharing conversation: ${errorMessage}`,
353 |       };
354 |     }
355 |   },
356 | };
357 | 
358 | export const chatCommand: SlashCommand = {
359 |   name: 'chat',
360 |   description: 'Manage conversation history.',
361 |   kind: CommandKind.BUILT_IN,
362 |   subCommands: [
363 |     listCommand,
364 |     saveCommand,
365 |     resumeCommand,
366 |     deleteCommand,
367 |     shareCommand,
368 |   ],
369 | };
```

src/ui/commands/clearCommand.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type { Mock } from 'vitest';
8 | import { vi, describe, it, expect, beforeEach } from 'vitest';
9 | import { clearCommand } from './clearCommand.js';
10 | import { type CommandContext } from './types.js';
11 | import { createMockCommandContext } from '../../test-utils/mockCommandContext.js';
12 | 
13 | // Mock the telemetry service
14 | vi.mock('@google/gemini-cli-core', async () => {
15 |   const actual = await vi.importActual('@google/gemini-cli-core');
16 |   return {
17 |     ...actual,
18 |     uiTelemetryService: {
19 |       setLastPromptTokenCount: vi.fn(),
20 |     },
21 |   };
22 | });
23 | 
24 | import type { GeminiClient } from '@google/gemini-cli-core';
25 | import { uiTelemetryService } from '@google/gemini-cli-core';
26 | 
27 | describe('clearCommand', () => {
28 |   let mockContext: CommandContext;
29 |   let mockResetChat: ReturnType<typeof vi.fn>;
30 | 
31 |   beforeEach(() => {
32 |     mockResetChat = vi.fn().mockResolvedValue(undefined);
33 |     vi.clearAllMocks();
34 | 
35 |     mockContext = createMockCommandContext({
36 |       services: {
37 |         config: {
38 |           getGeminiClient: () =>
39 |             ({
40 |               resetChat: mockResetChat,
41 |             }) as unknown as GeminiClient,
42 |         },
43 |       },
44 |     });
45 |   });
46 | 
47 |   it('should set debug message, reset chat, reset telemetry, and clear UI when config is available', async () => {
48 |     if (!clearCommand.action) {
49 |       throw new Error('clearCommand must have an action.');
50 |     }
51 | 
52 |     await clearCommand.action(mockContext, '');
53 | 
54 |     expect(mockContext.ui.setDebugMessage).toHaveBeenCalledWith(
55 |       'Clearing terminal and resetting chat.',
56 |     );
57 |     expect(mockContext.ui.setDebugMessage).toHaveBeenCalledTimes(1);
58 | 
59 |     expect(mockResetChat).toHaveBeenCalledTimes(1);
60 |     expect(uiTelemetryService.setLastPromptTokenCount).toHaveBeenCalledWith(0);
61 |     expect(uiTelemetryService.setLastPromptTokenCount).toHaveBeenCalledTimes(1);
62 |     expect(mockContext.ui.clear).toHaveBeenCalledTimes(1);
63 | 
64 |     // Check the order of operations.
65 |     const setDebugMessageOrder = (mockContext.ui.setDebugMessage as Mock).mock
66 |       .invocationCallOrder[0];
67 |     const resetChatOrder = mockResetChat.mock.invocationCallOrder[0];
68 |     const resetTelemetryOrder = (
69 |       uiTelemetryService.setLastPromptTokenCount as Mock
70 |     ).mock.invocationCallOrder[0];
71 |     const clearOrder = (mockContext.ui.clear as Mock).mock
72 |       .invocationCallOrder[0];
73 | 
74 |     expect(setDebugMessageOrder).toBeLessThan(resetChatOrder);
75 |     expect(resetChatOrder).toBeLessThan(resetTelemetryOrder);
76 |     expect(resetTelemetryOrder).toBeLessThan(clearOrder);
77 |   });
78 | 
79 |   it('should not attempt to reset chat if config service is not available', async () => {
80 |     if (!clearCommand.action) {
81 |       throw new Error('clearCommand must have an action.');
82 |     }
83 | 
84 |     const nullConfigContext = createMockCommandContext({
85 |       services: {
86 |         config: null,
87 |       },
88 |     });
89 | 
90 |     await clearCommand.action(nullConfigContext, '');
91 | 
92 |     expect(nullConfigContext.ui.setDebugMessage).toHaveBeenCalledWith(
93 |       'Clearing terminal.',
94 |     );
95 |     expect(mockResetChat).not.toHaveBeenCalled();
96 |     expect(uiTelemetryService.setLastPromptTokenCount).toHaveBeenCalledWith(0);
97 |     expect(uiTelemetryService.setLastPromptTokenCount).toHaveBeenCalledTimes(1);
98 |     expect(nullConfigContext.ui.clear).toHaveBeenCalledTimes(1);
99 |   });
100 | });
```

src/ui/commands/clearCommand.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { uiTelemetryService } from '@google/gemini-cli-core';
8 | import type { SlashCommand } from './types.js';
9 | import { CommandKind } from './types.js';
10 | 
11 | export const clearCommand: SlashCommand = {
12 |   name: 'clear',
13 |   description: 'clear the screen and conversation history',
14 |   kind: CommandKind.BUILT_IN,
15 |   action: async (context, _args) => {
16 |     const geminiClient = context.services.config?.getGeminiClient();
17 | 
18 |     if (geminiClient) {
19 |       context.ui.setDebugMessage('Clearing terminal and resetting chat.');
20 |       // If resetChat fails, the exception will propagate and halt the command,
21 |       // which is the correct behavior to signal a failure to the user.
22 |       await geminiClient.resetChat();
23 |     } else {
24 |       context.ui.setDebugMessage('Clearing terminal.');
25 |     }
26 | 
27 |     uiTelemetryService.setLastPromptTokenCount(0);
28 |     context.ui.clear();
29 |   },
30 | };
```

src/ui/commands/compressCommand.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import {
8 |   CompressionStatus,
9 |   type ChatCompressionInfo,
10 |   type GeminiClient,
11 | } from '@google/gemini-cli-core';
12 | import { vi, describe, it, expect, beforeEach } from 'vitest';
13 | import { compressCommand } from './compressCommand.js';
14 | import { createMockCommandContext } from '../../test-utils/mockCommandContext.js';
15 | import { MessageType } from '../types.js';
16 | 
17 | describe('compressCommand', () => {
18 |   let context: ReturnType<typeof createMockCommandContext>;
19 |   let mockTryCompressChat: ReturnType<typeof vi.fn>;
20 | 
21 |   beforeEach(() => {
22 |     mockTryCompressChat = vi.fn();
23 |     context = createMockCommandContext({
24 |       services: {
25 |         config: {
26 |           getGeminiClient: () =>
27 |             ({
28 |               tryCompressChat: mockTryCompressChat,
29 |             }) as unknown as GeminiClient,
30 |         },
31 |       },
32 |     });
33 |   });
34 | 
35 |   it('should do nothing if a compression is already pending', async () => {
36 |     context.ui.pendingItem = {
37 |       type: MessageType.COMPRESSION,
38 |       compression: {
39 |         isPending: true,
40 |         originalTokenCount: null,
41 |         newTokenCount: null,
42 |         compressionStatus: null,
43 |       },
44 |     };
45 |     await compressCommand.action!(context, '');
46 |     expect(context.ui.addItem).toHaveBeenCalledWith(
47 |       expect.objectContaining({
48 |         type: MessageType.ERROR,
49 |         text: 'Already compressing, wait for previous request to complete',
50 |       }),
51 |       expect.any(Number),
52 |     );
53 |     expect(context.ui.setPendingItem).not.toHaveBeenCalled();
54 |     expect(mockTryCompressChat).not.toHaveBeenCalled();
55 |   });
56 | 
57 |   it('should set pending item, call tryCompressChat, and add result on success', async () => {
58 |     const compressedResult: ChatCompressionInfo = {
59 |       originalTokenCount: 200,
60 |       compressionStatus: CompressionStatus.COMPRESSED,
61 |       newTokenCount: 100,
62 |     };
63 |     mockTryCompressChat.mockResolvedValue(compressedResult);
64 | 
65 |     await compressCommand.action!(context, '');
66 | 
67 |     expect(context.ui.setPendingItem).toHaveBeenNthCalledWith(1, {
68 |       type: MessageType.COMPRESSION,
69 |       compression: {
70 |         isPending: true,
71 |         compressionStatus: null,
72 |         originalTokenCount: null,
73 |         newTokenCount: null,
74 |       },
75 |     });
76 | 
77 |     expect(mockTryCompressChat).toHaveBeenCalledWith(
78 |       expect.stringMatching(/^compress-\d+$/),
79 |       true,
80 |     );
81 | 
82 |     expect(context.ui.addItem).toHaveBeenCalledWith(
83 |       {
84 |         type: MessageType.COMPRESSION,
85 |         compression: {
86 |           isPending: false,
87 |           compressionStatus: CompressionStatus.COMPRESSED,
88 |           originalTokenCount: 200,
89 |           newTokenCount: 100,
90 |         },
91 |       },
92 |       expect.any(Number),
93 |     );
94 | 
95 |     expect(context.ui.setPendingItem).toHaveBeenNthCalledWith(2, null);
96 |   });
97 | 
98 |   it('should add an error message if tryCompressChat returns falsy', async () => {
99 |     mockTryCompressChat.mockResolvedValue(null);
100 | 
101 |     await compressCommand.action!(context, '');
102 | 
103 |     expect(context.ui.addItem).toHaveBeenCalledWith(
104 |       expect.objectContaining({
105 |         type: MessageType.ERROR,
106 |         text: 'Failed to compress chat history.',
107 |       }),
108 |       expect.any(Number),
109 |     );
110 |     expect(context.ui.setPendingItem).toHaveBeenCalledWith(null);
111 |   });
112 | 
113 |   it('should add an error message if tryCompressChat throws', async () => {
114 |     const error = new Error('Compression failed');
115 |     mockTryCompressChat.mockRejectedValue(error);
116 | 
117 |     await compressCommand.action!(context, '');
118 | 
119 |     expect(context.ui.addItem).toHaveBeenCalledWith(
120 |       expect.objectContaining({
121 |         type: MessageType.ERROR,
122 |         text: `Failed to compress chat history: ${error.message}`,
123 |       }),
124 |       expect.any(Number),
125 |     );
126 |     expect(context.ui.setPendingItem).toHaveBeenCalledWith(null);
127 |   });
128 | 
129 |   it('should clear the pending item in a finally block', async () => {
130 |     mockTryCompressChat.mockRejectedValue(new Error('some error'));
131 |     await compressCommand.action!(context, '');
132 |     expect(context.ui.setPendingItem).toHaveBeenCalledWith(null);
133 |   });
134 | });
```

src/ui/commands/compressCommand.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type { HistoryItemCompression } from '../types.js';
8 | import { MessageType } from '../types.js';
9 | import type { SlashCommand } from './types.js';
10 | import { CommandKind } from './types.js';
11 | 
12 | export const compressCommand: SlashCommand = {
13 |   name: 'compress',
14 |   altNames: ['summarize'],
15 |   description: 'Compresses the context by replacing it with a summary.',
16 |   kind: CommandKind.BUILT_IN,
17 |   action: async (context) => {
18 |     const { ui } = context;
19 |     if (ui.pendingItem) {
20 |       ui.addItem(
21 |         {
22 |           type: MessageType.ERROR,
23 |           text: 'Already compressing, wait for previous request to complete',
24 |         },
25 |         Date.now(),
26 |       );
27 |       return;
28 |     }
29 | 
30 |     const pendingMessage: HistoryItemCompression = {
31 |       type: MessageType.COMPRESSION,
32 |       compression: {
33 |         isPending: true,
34 |         originalTokenCount: null,
35 |         newTokenCount: null,
36 |         compressionStatus: null,
37 |       },
38 |     };
39 | 
40 |     try {
41 |       ui.setPendingItem(pendingMessage);
42 |       const promptId = `compress-${Date.now()}`;
43 |       const compressed = await context.services.config
44 |         ?.getGeminiClient()
45 |         ?.tryCompressChat(promptId, true);
46 |       if (compressed) {
47 |         ui.addItem(
48 |           {
49 |             type: MessageType.COMPRESSION,
50 |             compression: {
51 |               isPending: false,
52 |               originalTokenCount: compressed.originalTokenCount,
53 |               newTokenCount: compressed.newTokenCount,
54 |               compressionStatus: compressed.compressionStatus,
55 |             },
56 |           } as HistoryItemCompression,
57 |           Date.now(),
58 |         );
59 |       } else {
60 |         ui.addItem(
61 |           {
62 |             type: MessageType.ERROR,
63 |             text: 'Failed to compress chat history.',
64 |           },
65 |           Date.now(),
66 |         );
67 |       }
68 |     } catch (e) {
69 |       ui.addItem(
70 |         {
71 |           type: MessageType.ERROR,
72 |           text: `Failed to compress chat history: ${
73 |             e instanceof Error ? e.message : String(e)
74 |           }`,
75 |         },
76 |         Date.now(),
77 |       );
78 |     } finally {
79 |       ui.setPendingItem(null);
80 |     }
81 |   },
82 | };
```

src/ui/commands/copyCommand.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type { Mock } from 'vitest';
8 | import { vi, describe, it, expect, beforeEach } from 'vitest';
9 | import { copyCommand } from './copyCommand.js';
10 | import { type CommandContext } from './types.js';
11 | import { createMockCommandContext } from '../../test-utils/mockCommandContext.js';
12 | import { copyToClipboard } from '../utils/commandUtils.js';
13 | 
14 | vi.mock('../utils/commandUtils.js', () => ({
15 |   copyToClipboard: vi.fn(),
16 | }));
17 | 
18 | describe('copyCommand', () => {
19 |   let mockContext: CommandContext;
20 |   let mockCopyToClipboard: Mock;
21 |   let mockGetChat: Mock;
22 |   let mockGetHistory: Mock;
23 | 
24 |   beforeEach(() => {
25 |     vi.clearAllMocks();
26 | 
27 |     mockCopyToClipboard = vi.mocked(copyToClipboard);
28 |     mockGetChat = vi.fn();
29 |     mockGetHistory = vi.fn();
30 | 
31 |     mockContext = createMockCommandContext({
32 |       services: {
33 |         config: {
34 |           getGeminiClient: () => ({
35 |             getChat: mockGetChat,
36 |           }),
37 |         },
38 |       },
39 |     });
40 | 
41 |     mockGetChat.mockReturnValue({
42 |       getHistory: mockGetHistory,
43 |     });
44 |   });
45 | 
46 |   it('should return info message when no history is available', async () => {
47 |     if (!copyCommand.action) throw new Error('Command has no action');
48 | 
49 |     mockGetChat.mockReturnValue(undefined);
50 | 
51 |     const result = await copyCommand.action(mockContext, '');
52 | 
53 |     expect(result).toEqual({
54 |       type: 'message',
55 |       messageType: 'info',
56 |       content: 'No output in history',
57 |     });
58 | 
59 |     expect(mockCopyToClipboard).not.toHaveBeenCalled();
60 |   });
61 | 
62 |   it('should return info message when history is empty', async () => {
63 |     if (!copyCommand.action) throw new Error('Command has no action');
64 | 
65 |     mockGetHistory.mockReturnValue([]);
66 | 
67 |     const result = await copyCommand.action(mockContext, '');
68 | 
69 |     expect(result).toEqual({
70 |       type: 'message',
71 |       messageType: 'info',
72 |       content: 'No output in history',
73 |     });
74 | 
75 |     expect(mockCopyToClipboard).not.toHaveBeenCalled();
76 |   });
77 | 
78 |   it('should return info message when no AI messages are found in history', async () => {
79 |     if (!copyCommand.action) throw new Error('Command has no action');
80 | 
81 |     const historyWithUserOnly = [
82 |       {
83 |         role: 'user',
84 |         parts: [{ text: 'Hello' }],
85 |       },
86 |     ];
87 | 
88 |     mockGetHistory.mockReturnValue(historyWithUserOnly);
89 | 
90 |     const result = await copyCommand.action(mockContext, '');
91 | 
92 |     expect(result).toEqual({
93 |       type: 'message',
94 |       messageType: 'info',
95 |       content: 'No output in history',
96 |     });
97 | 
98 |     expect(mockCopyToClipboard).not.toHaveBeenCalled();
99 |   });
100 | 
101 |   it('should copy last AI message to clipboard successfully', async () => {
102 |     if (!copyCommand.action) throw new Error('Command has no action');
103 | 
104 |     const historyWithAiMessage = [
105 |       {
106 |         role: 'user',
107 |         parts: [{ text: 'Hello' }],
108 |       },
109 |       {
110 |         role: 'model',
111 |         parts: [{ text: 'Hi there! How can I help you?' }],
112 |       },
113 |     ];
114 | 
115 |     mockGetHistory.mockReturnValue(historyWithAiMessage);
116 |     mockCopyToClipboard.mockResolvedValue(undefined);
117 | 
118 |     const result = await copyCommand.action(mockContext, '');
119 | 
120 |     expect(result).toEqual({
121 |       type: 'message',
122 |       messageType: 'info',
123 |       content: 'Last output copied to the clipboard',
124 |     });
125 | 
126 |     expect(mockCopyToClipboard).toHaveBeenCalledWith(
127 |       'Hi there! How can I help you?',
128 |     );
129 |   });
130 | 
131 |   it('should handle multiple text parts in AI message', async () => {
132 |     if (!copyCommand.action) throw new Error('Command has no action');
133 | 
134 |     const historyWithMultipleParts = [
135 |       {
136 |         role: 'model',
137 |         parts: [{ text: 'Part 1: ' }, { text: 'Part 2: ' }, { text: 'Part 3' }],
138 |       },
139 |     ];
140 | 
141 |     mockGetHistory.mockReturnValue(historyWithMultipleParts);
142 |     mockCopyToClipboard.mockResolvedValue(undefined);
143 | 
144 |     const result = await copyCommand.action(mockContext, '');
145 | 
146 |     expect(mockCopyToClipboard).toHaveBeenCalledWith('Part 1: Part 2: Part 3');
147 |     expect(result).toEqual({
148 |       type: 'message',
149 |       messageType: 'info',
150 |       content: 'Last output copied to the clipboard',
151 |     });
152 |   });
153 | 
154 |   it('should filter out non-text parts', async () => {
155 |     if (!copyCommand.action) throw new Error('Command has no action');
156 | 
157 |     const historyWithMixedParts = [
158 |       {
159 |         role: 'model',
160 |         parts: [
161 |           { text: 'Text part' },
162 |           { image: 'base64data' }, // Non-text part
163 |           { text: ' more text' },
164 |         ],
165 |       },
166 |     ];
167 | 
168 |     mockGetHistory.mockReturnValue(historyWithMixedParts);
169 |     mockCopyToClipboard.mockResolvedValue(undefined);
170 | 
171 |     const result = await copyCommand.action(mockContext, '');
172 | 
173 |     expect(mockCopyToClipboard).toHaveBeenCalledWith('Text part more text');
174 |     expect(result).toEqual({
175 |       type: 'message',
176 |       messageType: 'info',
177 |       content: 'Last output copied to the clipboard',
178 |     });
179 |   });
180 | 
181 |   it('should get the last AI message when multiple AI messages exist', async () => {
182 |     if (!copyCommand.action) throw new Error('Command has no action');
183 | 
184 |     const historyWithMultipleAiMessages = [
185 |       {
186 |         role: 'model',
187 |         parts: [{ text: 'First AI response' }],
188 |       },
189 |       {
190 |         role: 'user',
191 |         parts: [{ text: 'User message' }],
192 |       },
193 |       {
194 |         role: 'model',
195 |         parts: [{ text: 'Second AI response' }],
196 |       },
197 |     ];
198 | 
199 |     mockGetHistory.mockReturnValue(historyWithMultipleAiMessages);
200 |     mockCopyToClipboard.mockResolvedValue(undefined);
201 | 
202 |     const result = await copyCommand.action(mockContext, '');
203 | 
204 |     expect(mockCopyToClipboard).toHaveBeenCalledWith('Second AI response');
205 |     expect(result).toEqual({
206 |       type: 'message',
207 |       messageType: 'info',
208 |       content: 'Last output copied to the clipboard',
209 |     });
210 |   });
211 | 
212 |   it('should handle clipboard copy error', async () => {
213 |     if (!copyCommand.action) throw new Error('Command has no action');
214 | 
215 |     const historyWithAiMessage = [
216 |       {
217 |         role: 'model',
218 |         parts: [{ text: 'AI response' }],
219 |       },
220 |     ];
221 | 
222 |     mockGetHistory.mockReturnValue(historyWithAiMessage);
223 |     const clipboardError = new Error('Clipboard access denied');
224 |     mockCopyToClipboard.mockRejectedValue(clipboardError);
225 | 
226 |     const result = await copyCommand.action(mockContext, '');
227 | 
228 |     expect(result).toEqual({
229 |       type: 'message',
230 |       messageType: 'error',
231 |       content: `Failed to copy to the clipboard. ${clipboardError.message}`,
232 |     });
233 |   });
234 | 
235 |   it('should handle non-Error clipboard errors', async () => {
236 |     if (!copyCommand.action) throw new Error('Command has no action');
237 | 
238 |     const historyWithAiMessage = [
239 |       {
240 |         role: 'model',
241 |         parts: [{ text: 'AI response' }],
242 |       },
243 |     ];
244 | 
245 |     mockGetHistory.mockReturnValue(historyWithAiMessage);
246 |     const rejectedValue = 'String error';
247 |     mockCopyToClipboard.mockRejectedValue(rejectedValue);
248 | 
249 |     const result = await copyCommand.action(mockContext, '');
250 | 
251 |     expect(result).toEqual({
252 |       type: 'message',
253 |       messageType: 'error',
254 |       content: `Failed to copy to the clipboard. ${rejectedValue}`,
255 |     });
256 |   });
257 | 
258 |   it('should return info message when no text parts found in AI message', async () => {
259 |     if (!copyCommand.action) throw new Error('Command has no action');
260 | 
261 |     const historyWithEmptyParts = [
262 |       {
263 |         role: 'model',
264 |         parts: [{ image: 'base64data' }], // No text parts
265 |       },
266 |     ];
267 | 
268 |     mockGetHistory.mockReturnValue(historyWithEmptyParts);
269 | 
270 |     const result = await copyCommand.action(mockContext, '');
271 | 
272 |     expect(result).toEqual({
273 |       type: 'message',
274 |       messageType: 'info',
275 |       content: 'Last AI output contains no text to copy.',
276 |     });
277 | 
278 |     expect(mockCopyToClipboard).not.toHaveBeenCalled();
279 |   });
280 | 
281 |   it('should handle unavailable config service', async () => {
282 |     if (!copyCommand.action) throw new Error('Command has no action');
283 | 
284 |     const nullConfigContext = createMockCommandContext({
285 |       services: { config: null },
286 |     });
287 | 
288 |     const result = await copyCommand.action(nullConfigContext, '');
289 | 
290 |     expect(result).toEqual({
291 |       type: 'message',
292 |       messageType: 'info',
293 |       content: 'No output in history',
294 |     });
295 | 
296 |     expect(mockCopyToClipboard).not.toHaveBeenCalled();
297 |   });
298 | });
```

src/ui/commands/copyCommand.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { copyToClipboard } from '../utils/commandUtils.js';
8 | import type { SlashCommand, SlashCommandActionReturn } from './types.js';
9 | import { CommandKind } from './types.js';
10 | 
11 | export const copyCommand: SlashCommand = {
12 |   name: 'copy',
13 |   description: 'Copy the last result or code snippet to clipboard',
14 |   kind: CommandKind.BUILT_IN,
15 |   action: async (context, _args): Promise<SlashCommandActionReturn | void> => {
16 |     const chat = await context.services.config?.getGeminiClient()?.getChat();
17 |     const history = chat?.getHistory();
18 | 
19 |     // Get the last message from the AI (model role)
20 |     const lastAiMessage = history
21 |       ? history.filter((item) => item.role === 'model').pop()
22 |       : undefined;
23 | 
24 |     if (!lastAiMessage) {
25 |       return {
26 |         type: 'message',
27 |         messageType: 'info',
28 |         content: 'No output in history',
29 |       };
30 |     }
31 |     // Extract text from the parts
32 |     const lastAiOutput = lastAiMessage.parts
33 |       ?.filter((part) => part.text)
34 |       .map((part) => part.text)
35 |       .join('');
36 | 
37 |     if (lastAiOutput) {
38 |       try {
39 |         await copyToClipboard(lastAiOutput);
40 | 
41 |         return {
42 |           type: 'message',
43 |           messageType: 'info',
44 |           content: 'Last output copied to the clipboard',
45 |         };
46 |       } catch (error) {
47 |         const message = error instanceof Error ? error.message : String(error);
48 |         console.debug(message);
49 | 
50 |         return {
51 |           type: 'message',
52 |           messageType: 'error',
53 |           content: `Failed to copy to the clipboard. ${message}`,
54 |         };
55 |       }
56 |     } else {
57 |       return {
58 |         type: 'message',
59 |         messageType: 'info',
60 |         content: 'Last AI output contains no text to copy.',
61 |       };
62 |     }
63 |   },
64 | };
```

src/ui/commands/corgiCommand.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect, beforeEach, vi } from 'vitest';
8 | import { corgiCommand } from './corgiCommand.js';
9 | import { type CommandContext } from './types.js';
10 | import { createMockCommandContext } from '../../test-utils/mockCommandContext.js';
11 | 
12 | describe('corgiCommand', () => {
13 |   let mockContext: CommandContext;
14 | 
15 |   beforeEach(() => {
16 |     mockContext = createMockCommandContext();
17 |     vi.spyOn(mockContext.ui, 'toggleCorgiMode');
18 |   });
19 | 
20 |   it('should call the toggleCorgiMode function on the UI context', async () => {
21 |     if (!corgiCommand.action) {
22 |       throw new Error('The corgi command must have an action.');
23 |     }
24 | 
25 |     await corgiCommand.action(mockContext, '');
26 | 
27 |     expect(mockContext.ui.toggleCorgiMode).toHaveBeenCalledTimes(1);
28 |   });
29 | 
30 |   it('should have the correct name and description', () => {
31 |     expect(corgiCommand.name).toBe('corgi');
32 |     expect(corgiCommand.description).toBe('Toggles corgi mode.');
33 |   });
34 | });
```

src/ui/commands/corgiCommand.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { CommandKind, type SlashCommand } from './types.js';
8 | 
9 | export const corgiCommand: SlashCommand = {
10 |   name: 'corgi',
11 |   description: 'Toggles corgi mode.',
12 |   hidden: true,
13 |   kind: CommandKind.BUILT_IN,
14 |   action: (context, _args) => {
15 |     context.ui.toggleCorgiMode();
16 |   },
17 | };
```

src/ui/commands/directoryCommand.test.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect, vi, beforeEach } from 'vitest';
8 | import { directoryCommand, expandHomeDir } from './directoryCommand.js';
9 | import type { Config, WorkspaceContext } from '@google/gemini-cli-core';
10 | import type { CommandContext } from './types.js';
11 | import { MessageType } from '../types.js';
12 | import * as os from 'node:os';
13 | import * as path from 'node:path';
14 | 
15 | describe('directoryCommand', () => {
16 |   let mockContext: CommandContext;
17 |   let mockConfig: Config;
18 |   let mockWorkspaceContext: WorkspaceContext;
19 |   const addCommand = directoryCommand.subCommands?.find(
20 |     (c) => c.name === 'add',
21 |   );
22 |   const showCommand = directoryCommand.subCommands?.find(
23 |     (c) => c.name === 'show',
24 |   );
25 | 
26 |   beforeEach(() => {
27 |     mockWorkspaceContext = {
28 |       addDirectory: vi.fn(),
29 |       getDirectories: vi
30 |         .fn()
31 |         .mockReturnValue([
32 |           path.normalize('/home/user/project1'),
33 |           path.normalize('/home/user/project2'),
34 |         ]),
35 |     } as unknown as WorkspaceContext;
36 | 
37 |     mockConfig = {
38 |       getWorkspaceContext: () => mockWorkspaceContext,
39 |       isRestrictiveSandbox: vi.fn().mockReturnValue(false),
40 |       getGeminiClient: vi.fn().mockReturnValue({
41 |         addDirectoryContext: vi.fn(),
42 |       }),
43 |       getWorkingDir: () => '/test/dir',
44 |       shouldLoadMemoryFromIncludeDirectories: () => false,
45 |       getDebugMode: () => false,
46 |       getFileService: () => ({}),
47 |       getExtensionContextFilePaths: () => [],
48 |       getFileFilteringOptions: () => ({ ignore: [], include: [] }),
49 |       setUserMemory: vi.fn(),
50 |       setGeminiMdFileCount: vi.fn(),
51 |     } as unknown as Config;
52 | 
53 |     mockContext = {
54 |       services: {
55 |         config: mockConfig,
56 |         settings: {
57 |           merged: {
58 |             memoryDiscoveryMaxDirs: 1000,
59 |           },
60 |         },
61 |       },
62 |       ui: {
63 |         addItem: vi.fn(),
64 |       },
65 |     } as unknown as CommandContext;
66 |   });
67 | 
68 |   describe('show', () => {
69 |     it('should display the list of directories', () => {
70 |       if (!showCommand?.action) throw new Error('No action');
71 |       showCommand.action(mockContext, '');
72 |       expect(mockWorkspaceContext.getDirectories).toHaveBeenCalled();
73 |       expect(mockContext.ui.addItem).toHaveBeenCalledWith(
74 |         expect.objectContaining({
75 |           type: MessageType.INFO,
76 |           text: `Current workspace directories:\n- ${path.normalize(
77 |             '/home/user/project1',
78 |           )}\n- ${path.normalize('/home/user/project2')}`,
79 |         }),
80 |         expect.any(Number),
81 |       );
82 |     });
83 |   });
84 | 
85 |   describe('add', () => {
86 |     it('should show an error if no path is provided', () => {
87 |       if (!addCommand?.action) throw new Error('No action');
88 |       addCommand.action(mockContext, '');
89 |       expect(mockContext.ui.addItem).toHaveBeenCalledWith(
90 |         expect.objectContaining({
91 |           type: MessageType.ERROR,
92 |           text: 'Please provide at least one path to add.',
93 |         }),
94 |         expect.any(Number),
95 |       );
96 |     });
97 | 
98 |     it('should call addDirectory and show a success message for a single path', async () => {
99 |       const newPath = path.normalize('/home/user/new-project');
100 |       if (!addCommand?.action) throw new Error('No action');
101 |       await addCommand.action(mockContext, newPath);
102 |       expect(mockWorkspaceContext.addDirectory).toHaveBeenCalledWith(newPath);
103 |       expect(mockContext.ui.addItem).toHaveBeenCalledWith(
104 |         expect.objectContaining({
105 |           type: MessageType.INFO,
106 |           text: `Successfully added directories:\n- ${newPath}`,
107 |         }),
108 |         expect.any(Number),
109 |       );
110 |     });
111 | 
112 |     it('should call addDirectory for each path and show a success message for multiple paths', async () => {
113 |       const newPath1 = path.normalize('/home/user/new-project1');
114 |       const newPath2 = path.normalize('/home/user/new-project2');
115 |       if (!addCommand?.action) throw new Error('No action');
116 |       await addCommand.action(mockContext, `${newPath1},${newPath2}`);
117 |       expect(mockWorkspaceContext.addDirectory).toHaveBeenCalledWith(newPath1);
118 |       expect(mockWorkspaceContext.addDirectory).toHaveBeenCalledWith(newPath2);
119 |       expect(mockContext.ui.addItem).toHaveBeenCalledWith(
120 |         expect.objectContaining({
121 |           type: MessageType.INFO,
122 |           text: `Successfully added directories:\n- ${newPath1}\n- ${newPath2}`,
123 |         }),
124 |         expect.any(Number),
125 |       );
126 |     });
127 | 
128 |     it('should show an error if addDirectory throws an exception', async () => {
129 |       const error = new Error('Directory does not exist');
130 |       vi.mocked(mockWorkspaceContext.addDirectory).mockImplementation(() => {
131 |         throw error;
132 |       });
133 |       const newPath = path.normalize('/home/user/invalid-project');
134 |       if (!addCommand?.action) throw new Error('No action');
135 |       await addCommand.action(mockContext, newPath);
136 |       expect(mockContext.ui.addItem).toHaveBeenCalledWith(
137 |         expect.objectContaining({
138 |           type: MessageType.ERROR,
139 |           text: `Error adding '${newPath}': ${error.message}`,
140 |         }),
141 |         expect.any(Number),
142 |       );
143 |     });
144 | 
145 |     it('should handle a mix of successful and failed additions', async () => {
146 |       const validPath = path.normalize('/home/user/valid-project');
147 |       const invalidPath = path.normalize('/home/user/invalid-project');
148 |       const error = new Error('Directory does not exist');
149 |       vi.mocked(mockWorkspaceContext.addDirectory).mockImplementation(
150 |         (p: string) => {
151 |           if (p === invalidPath) {
152 |             throw error;
153 |           }
154 |         },
155 |       );
156 | 
157 |       if (!addCommand?.action) throw new Error('No action');
158 |       await addCommand.action(mockContext, `${validPath},${invalidPath}`);
159 | 
160 |       expect(mockContext.ui.addItem).toHaveBeenCalledWith(
161 |         expect.objectContaining({
162 |           type: MessageType.INFO,
163 |           text: `Successfully added directories:\n- ${validPath}`,
164 |         }),
165 |         expect.any(Number),
166 |       );
167 | 
168 |       expect(mockContext.ui.addItem).toHaveBeenCalledWith(
169 |         expect.objectContaining({
170 |           type: MessageType.ERROR,
171 |           text: `Error adding '${invalidPath}': ${error.message}`,
172 |         }),
173 |         expect.any(Number),
174 |       );
175 |     });
176 |   });
177 |   it('should correctly expand a Windows-style home directory path', () => {
178 |     const windowsPath = '%userprofile%\\Documents';
179 |     const expectedPath = path.win32.join(os.homedir(), 'Documents');
180 |     const result = expandHomeDir(windowsPath);
181 |     expect(path.win32.normalize(result)).toBe(
182 |       path.win32.normalize(expectedPath),
183 |     );
184 |   });
185 | });
```

src/ui/commands/directoryCommand.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type { SlashCommand, CommandContext } from './types.js';
8 | import { CommandKind } from './types.js';
9 | import { MessageType } from '../types.js';
10 | import * as os from 'node:os';
11 | import * as path from 'node:path';
12 | import { loadServerHierarchicalMemory } from '@google/gemini-cli-core';
13 | 
14 | export function expandHomeDir(p: string): string {
15 |   if (!p) {
16 |     return '';
17 |   }
18 |   let expandedPath = p;
19 |   if (p.toLowerCase().startsWith('%userprofile%')) {
20 |     expandedPath = os.homedir() + p.substring('%userprofile%'.length);
21 |   } else if (p === '~' || p.startsWith('~/')) {
22 |     expandedPath = os.homedir() + p.substring(1);
23 |   }
24 |   return path.normalize(expandedPath);
25 | }
26 | 
27 | export const directoryCommand: SlashCommand = {
28 |   name: 'directory',
29 |   altNames: ['dir'],
30 |   description: 'Manage workspace directories',
31 |   kind: CommandKind.BUILT_IN,
32 |   subCommands: [
33 |     {
34 |       name: 'add',
35 |       description:
36 |         'Add directories to the workspace. Use comma to separate multiple paths',
37 |       kind: CommandKind.BUILT_IN,
38 |       action: async (context: CommandContext, args: string) => {
39 |         const {
40 |           ui: { addItem },
41 |           services: { config },
42 |         } = context;
43 |         const [...rest] = args.split(' ');
44 | 
45 |         if (!config) {
46 |           addItem(
47 |             {
48 |               type: MessageType.ERROR,
49 |               text: 'Configuration is not available.',
50 |             },
51 |             Date.now(),
52 |           );
53 |           return;
54 |         }
55 | 
56 |         const workspaceContext = config.getWorkspaceContext();
57 | 
58 |         const pathsToAdd = rest
59 |           .join(' ')
60 |           .split(',')
61 |           .filter((p) => p);
62 |         if (pathsToAdd.length === 0) {
63 |           addItem(
64 |             {
65 |               type: MessageType.ERROR,
66 |               text: 'Please provide at least one path to add.',
67 |             },
68 |             Date.now(),
69 |           );
70 |           return;
71 |         }
72 | 
73 |         if (config.isRestrictiveSandbox()) {
74 |           return {
75 |             type: 'message' as const,
76 |             messageType: 'error' as const,
77 |             content:
78 |               'The /directory add command is not supported in restrictive sandbox profiles. Please use --include-directories when starting the session instead.',
79 |           };
80 |         }
81 | 
82 |         const added: string[] = [];
83 |         const errors: string[] = [];
84 | 
85 |         for (const pathToAdd of pathsToAdd) {
86 |           try {
87 |             workspaceContext.addDirectory(expandHomeDir(pathToAdd.trim()));
88 |             added.push(pathToAdd.trim());
89 |           } catch (e) {
90 |             const error = e as Error;
91 |             errors.push(`Error adding '${pathToAdd.trim()}': ${error.message}`);
92 |           }
93 |         }
94 | 
95 |         try {
96 |           if (config.shouldLoadMemoryFromIncludeDirectories()) {
97 |             const { memoryContent, fileCount } =
98 |               await loadServerHierarchicalMemory(
99 |                 config.getWorkingDir(),
100 |                 [
101 |                   ...config.getWorkspaceContext().getDirectories(),
102 |                   ...pathsToAdd,
103 |                 ],
104 |                 config.getDebugMode(),
105 |                 config.getFileService(),
106 |                 config.getExtensionContextFilePaths(),
107 |                 config.getFolderTrust(),
108 |                 context.services.settings.merged.context?.importFormat ||
109 |                   'tree', // Use setting or default to 'tree'
110 |                 config.getFileFilteringOptions(),
111 |                 context.services.settings.merged.context?.discoveryMaxDirs,
112 |               );
113 |             config.setUserMemory(memoryContent);
114 |             config.setGeminiMdFileCount(fileCount);
115 |             context.ui.setGeminiMdFileCount(fileCount);
116 |           }
117 |           addItem(
118 |             {
119 |               type: MessageType.INFO,
120 |               text: `Successfully added GEMINI.md files from the following directories if there are:\n- ${added.join('\n- ')}`,
121 |             },
122 |             Date.now(),
123 |           );
124 |         } catch (error) {
125 |           errors.push(`Error refreshing memory: ${(error as Error).message}`);
126 |         }
127 | 
128 |         if (added.length > 0) {
129 |           const gemini = config.getGeminiClient();
130 |           if (gemini) {
131 |             await gemini.addDirectoryContext();
132 |           }
133 |           addItem(
134 |             {
135 |               type: MessageType.INFO,
136 |               text: `Successfully added directories:\n- ${added.join('\n- ')}`,
137 |             },
138 |             Date.now(),
139 |           );
140 |         }
141 | 
142 |         if (errors.length > 0) {
143 |           addItem(
144 |             { type: MessageType.ERROR, text: errors.join('\n') },
145 |             Date.now(),
146 |           );
147 |         }
148 |         return;
149 |       },
150 |     },
151 |     {
152 |       name: 'show',
153 |       description: 'Show all directories in the workspace',
154 |       kind: CommandKind.BUILT_IN,
155 |       action: async (context: CommandContext) => {
156 |         const {
157 |           ui: { addItem },
158 |           services: { config },
159 |         } = context;
160 |         if (!config) {
161 |           addItem(
162 |             {
163 |               type: MessageType.ERROR,
164 |               text: 'Configuration is not available.',
165 |             },
166 |             Date.now(),
167 |           );
168 |           return;
169 |         }
170 |         const workspaceContext = config.getWorkspaceContext();
171 |         const directories = workspaceContext.getDirectories();
172 |         const directoryList = directories.map((dir) => `- ${dir}`).join('\n');
173 |         addItem(
174 |           {
175 |             type: MessageType.INFO,
176 |             text: `Current workspace directories:\n${directoryList}`,
177 |           },
178 |           Date.now(),
179 |         );
180 |       },
181 |     },
182 |   ],
183 | };
```

src/ui/commands/docsCommand.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { vi, describe, it, expect, beforeEach, afterEach } from 'vitest';
8 | import open from 'open';
9 | import { docsCommand } from './docsCommand.js';
10 | import { type CommandContext } from './types.js';
11 | import { createMockCommandContext } from '../../test-utils/mockCommandContext.js';
12 | import { MessageType } from '../types.js';
13 | 
14 | // Mock the 'open' library
15 | vi.mock('open', () => ({
16 |   default: vi.fn(),
17 | }));
18 | 
19 | describe('docsCommand', () => {
20 |   let mockContext: CommandContext;
21 |   beforeEach(() => {
22 |     // Create a fresh mock context before each test
23 |     mockContext = createMockCommandContext();
24 |     // Reset the `open` mock
25 |     vi.mocked(open).mockClear();
26 |   });
27 | 
28 |   afterEach(() => {
29 |     // Restore any stubbed environment variables
30 |     vi.unstubAllEnvs();
31 |   });
32 | 
33 |   it("should add an info message and call 'open' in a non-sandbox environment", async () => {
34 |     if (!docsCommand.action) {
35 |       throw new Error('docsCommand must have an action.');
36 |     }
37 | 
38 |     const docsUrl = 'https://goo.gle/gemini-cli-docs';
39 | 
40 |     await docsCommand.action(mockContext, '');
41 | 
42 |     expect(mockContext.ui.addItem).toHaveBeenCalledWith(
43 |       {
44 |         type: MessageType.INFO,
45 |         text: `Opening documentation in your browser: ${docsUrl}`,
46 |       },
47 |       expect.any(Number),
48 |     );
49 | 
50 |     expect(open).toHaveBeenCalledWith(docsUrl);
51 |   });
52 | 
53 |   it('should only add an info message in a sandbox environment', async () => {
54 |     if (!docsCommand.action) {
55 |       throw new Error('docsCommand must have an action.');
56 |     }
57 | 
58 |     // Simulate a sandbox environment
59 |     vi.stubEnv('SANDBOX', 'gemini-sandbox');
60 |     const docsUrl = 'https://goo.gle/gemini-cli-docs';
61 | 
62 |     await docsCommand.action(mockContext, '');
63 | 
64 |     expect(mockContext.ui.addItem).toHaveBeenCalledWith(
65 |       {
66 |         type: MessageType.INFO,
67 |         text: `Please open the following URL in your browser to view the documentation:\n${docsUrl}`,
68 |       },
69 |       expect.any(Number),
70 |     );
71 | 
72 |     // Ensure 'open' was not called in the sandbox
73 |     expect(open).not.toHaveBeenCalled();
74 |   });
75 | 
76 |   it("should not open browser for 'sandbox-exec'", async () => {
77 |     if (!docsCommand.action) {
78 |       throw new Error('docsCommand must have an action.');
79 |     }
80 | 
81 |     // Simulate the specific 'sandbox-exec' environment
82 |     vi.stubEnv('SANDBOX', 'sandbox-exec');
83 |     const docsUrl = 'https://goo.gle/gemini-cli-docs';
84 | 
85 |     await docsCommand.action(mockContext, '');
86 | 
87 |     // The logic should fall through to the 'else' block
88 |     expect(mockContext.ui.addItem).toHaveBeenCalledWith(
89 |       {
90 |         type: MessageType.INFO,
91 |         text: `Opening documentation in your browser: ${docsUrl}`,
92 |       },
93 |       expect.any(Number),
94 |     );
95 | 
96 |     // 'open' should be called in this specific sandbox case
97 |     expect(open).toHaveBeenCalledWith(docsUrl);
98 |   });
99 | });
```

src/ui/commands/docsCommand.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import open from 'open';
8 | import process from 'node:process';
9 | import {
10 |   type CommandContext,
11 |   type SlashCommand,
12 |   CommandKind,
13 | } from './types.js';
14 | import { MessageType } from '../types.js';
15 | 
16 | export const docsCommand: SlashCommand = {
17 |   name: 'docs',
18 |   description: 'open full Gemini CLI documentation in your browser',
19 |   kind: CommandKind.BUILT_IN,
20 |   action: async (context: CommandContext): Promise<void> => {
21 |     const docsUrl = 'https://goo.gle/gemini-cli-docs';
22 | 
23 |     if (process.env['SANDBOX'] && process.env['SANDBOX'] !== 'sandbox-exec') {
24 |       context.ui.addItem(
25 |         {
26 |           type: MessageType.INFO,
27 |           text: `Please open the following URL in your browser to view the documentation:\n${docsUrl}`,
28 |         },
29 |         Date.now(),
30 |       );
31 |     } else {
32 |       context.ui.addItem(
33 |         {
34 |           type: MessageType.INFO,
35 |           text: `Opening documentation in your browser: ${docsUrl}`,
36 |         },
37 |         Date.now(),
38 |       );
39 |       await open(docsUrl);
40 |     }
41 |   },
42 | };
```

src/ui/commands/editorCommand.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect } from 'vitest';
8 | import { editorCommand } from './editorCommand.js';
9 | // 1. Import the mock context utility
10 | import { createMockCommandContext } from '../../test-utils/mockCommandContext.js';
11 | 
12 | describe('editorCommand', () => {
13 |   it('should return a dialog action to open the editor dialog', () => {
14 |     if (!editorCommand.action) {
15 |       throw new Error('The editor command must have an action.');
16 |     }
17 |     const mockContext = createMockCommandContext();
18 |     const result = editorCommand.action(mockContext, '');
19 | 
20 |     expect(result).toEqual({
21 |       type: 'dialog',
22 |       dialog: 'editor',
23 |     });
24 |   });
25 | 
26 |   it('should have the correct name and description', () => {
27 |     expect(editorCommand.name).toBe('editor');
28 |     expect(editorCommand.description).toBe('set external editor preference');
29 |   });
30 | });
```

src/ui/commands/editorCommand.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import {
8 |   CommandKind,
9 |   type OpenDialogActionReturn,
10 |   type SlashCommand,
11 | } from './types.js';
12 | 
13 | export const editorCommand: SlashCommand = {
14 |   name: 'editor',
15 |   description: 'set external editor preference',
16 |   kind: CommandKind.BUILT_IN,
17 |   action: (): OpenDialogActionReturn => ({
18 |     type: 'dialog',
19 |     dialog: 'editor',
20 |   }),
21 | };
```

src/ui/commands/extensionsCommand.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type { GeminiCLIExtension } from '@google/gemini-cli-core';
8 | import { createMockCommandContext } from '../../test-utils/mockCommandContext.js';
9 | import { MessageType } from '../types.js';
10 | import { extensionsCommand } from './extensionsCommand.js';
11 | import { type CommandContext } from './types.js';
12 | import { describe, it, expect, vi, beforeEach } from 'vitest';
13 | import { type ExtensionUpdateAction } from '../state/extensions.js';
14 | 
15 | vi.mock('../../config/extensions/update.js', () => ({
16 |   updateExtension: vi.fn(),
17 |   checkForAllExtensionUpdates: vi.fn(),
18 | }));
19 | 
20 | const mockGetExtensions = vi.fn();
21 | 
22 | describe('extensionsCommand', () => {
23 |   let mockContext: CommandContext;
24 |   const mockDispatchExtensionState = vi.fn();
25 | 
26 |   beforeEach(() => {
27 |     vi.resetAllMocks();
28 |     mockContext = createMockCommandContext({
29 |       services: {
30 |         config: {
31 |           getExtensions: mockGetExtensions,
32 |           getWorkingDir: () => '/test/dir',
33 |         },
34 |       },
35 |       ui: {
36 |         dispatchExtensionStateUpdate: mockDispatchExtensionState,
37 |       },
38 |     });
39 |   });
40 | 
41 |   describe('list', () => {
42 |     it('should add an EXTENSIONS_LIST item to the UI', async () => {
43 |       if (!extensionsCommand.action) throw new Error('Action not defined');
44 |       await extensionsCommand.action(mockContext, '');
45 | 
46 |       expect(mockContext.ui.addItem).toHaveBeenCalledWith(
47 |         {
48 |           type: MessageType.EXTENSIONS_LIST,
49 |         },
50 |         expect.any(Number),
51 |       );
52 |     });
53 |   });
54 | 
55 |   describe('update', () => {
56 |     const updateAction = extensionsCommand.subCommands?.find(
57 |       (cmd) => cmd.name === 'update',
58 |     )?.action;
59 | 
60 |     if (!updateAction) {
61 |       throw new Error('Update action not found');
62 |     }
63 | 
64 |     it('should show usage if no args are provided', async () => {
65 |       await updateAction(mockContext, '');
66 |       expect(mockContext.ui.addItem).toHaveBeenCalledWith(
67 |         {
68 |           type: MessageType.ERROR,
69 |           text: 'Usage: /extensions update <extension-names>|--all',
70 |         },
71 |         expect.any(Number),
72 |       );
73 |     });
74 | 
75 |     it('should inform user if there are no extensions to update with --all', async () => {
76 |       mockDispatchExtensionState.mockImplementationOnce(
77 |         (action: ExtensionUpdateAction) => {
78 |           if (action.type === 'SCHEDULE_UPDATE') {
79 |             action.payload.onComplete([]);
80 |           }
81 |         },
82 |       );
83 | 
84 |       await updateAction(mockContext, '--all');
85 |       expect(mockContext.ui.addItem).toHaveBeenCalledWith(
86 |         {
87 |           type: MessageType.INFO,
88 |           text: 'No extensions to update.',
89 |         },
90 |         expect.any(Number),
91 |       );
92 |     });
93 | 
94 |     it('should call setPendingItem and addItem in a finally block on success', async () => {
95 |       mockDispatchExtensionState.mockImplementationOnce(
96 |         (action: ExtensionUpdateAction) => {
97 |           if (action.type === 'SCHEDULE_UPDATE') {
98 |             action.payload.onComplete([
99 |               {
100 |                 name: 'ext-one',
101 |                 originalVersion: '1.0.0',
102 |                 updatedVersion: '1.0.1',
103 |               },
104 |               {
105 |                 name: 'ext-two',
106 |                 originalVersion: '2.0.0',
107 |                 updatedVersion: '2.0.1',
108 |               },
109 |             ]);
110 |           }
111 |         },
112 |       );
113 |       await updateAction(mockContext, '--all');
114 |       expect(mockContext.ui.setPendingItem).toHaveBeenCalledWith({
115 |         type: MessageType.EXTENSIONS_LIST,
116 |       });
117 |       expect(mockContext.ui.setPendingItem).toHaveBeenCalledWith(null);
118 |       expect(mockContext.ui.addItem).toHaveBeenCalledWith(
119 |         {
120 |           type: MessageType.EXTENSIONS_LIST,
121 |         },
122 |         expect.any(Number),
123 |       );
124 |     });
125 | 
126 |     it('should call setPendingItem and addItem in a finally block on failure', async () => {
127 |       mockDispatchExtensionState.mockImplementationOnce((_) => {
128 |         throw new Error('Something went wrong');
129 |       });
130 |       await updateAction(mockContext, '--all');
131 |       expect(mockContext.ui.setPendingItem).toHaveBeenCalledWith({
132 |         type: MessageType.EXTENSIONS_LIST,
133 |       });
134 |       expect(mockContext.ui.setPendingItem).toHaveBeenCalledWith(null);
135 |       expect(mockContext.ui.addItem).toHaveBeenCalledWith(
136 |         {
137 |           type: MessageType.EXTENSIONS_LIST,
138 |         },
139 |         expect.any(Number),
140 |       );
141 |       expect(mockContext.ui.addItem).toHaveBeenCalledWith(
142 |         {
143 |           type: MessageType.ERROR,
144 |           text: 'Something went wrong',
145 |         },
146 |         expect.any(Number),
147 |       );
148 |     });
149 | 
150 |     it('should update a single extension by name', async () => {
151 |       mockDispatchExtensionState.mockImplementationOnce(
152 |         (action: ExtensionUpdateAction) => {
153 |           if (action.type === 'SCHEDULE_UPDATE') {
154 |             action.payload.onComplete([
155 |               {
156 |                 name: 'ext-one',
157 |                 originalVersion: '1.0.0',
158 |                 updatedVersion: '1.0.1',
159 |               },
160 |             ]);
161 |           }
162 |         },
163 |       );
164 |       await updateAction(mockContext, 'ext-one');
165 |       expect(mockDispatchExtensionState).toHaveBeenCalledWith({
166 |         type: 'SCHEDULE_UPDATE',
167 |         payload: {
168 |           all: false,
169 |           names: ['ext-one'],
170 |           onComplete: expect.any(Function),
171 |         },
172 |       });
173 |     });
174 | 
175 |     it('should update multiple extensions by name', async () => {
176 |       mockDispatchExtensionState.mockImplementationOnce(
177 |         (action: ExtensionUpdateAction) => {
178 |           if (action.type === 'SCHEDULE_UPDATE') {
179 |             action.payload.onComplete([
180 |               {
181 |                 name: 'ext-one',
182 |                 originalVersion: '1.0.0',
183 |                 updatedVersion: '1.0.1',
184 |               },
185 |               {
186 |                 name: 'ext-two',
187 |                 originalVersion: '1.0.0',
188 |                 updatedVersion: '1.0.1',
189 |               },
190 |             ]);
191 |           }
192 |         },
193 |       );
194 |       await updateAction(mockContext, 'ext-one ext-two');
195 |       expect(mockDispatchExtensionState).toHaveBeenCalledWith({
196 |         type: 'SCHEDULE_UPDATE',
197 |         payload: {
198 |           all: false,
199 |           names: ['ext-one', 'ext-two'],
200 |           onComplete: expect.any(Function),
201 |         },
202 |       });
203 |       expect(mockContext.ui.setPendingItem).toHaveBeenCalledWith({
204 |         type: MessageType.EXTENSIONS_LIST,
205 |       });
206 |       expect(mockContext.ui.setPendingItem).toHaveBeenCalledWith(null);
207 |       expect(mockContext.ui.addItem).toHaveBeenCalledWith(
208 |         {
209 |           type: MessageType.EXTENSIONS_LIST,
210 |         },
211 |         expect.any(Number),
212 |       );
213 |     });
214 | 
215 |     describe('completion', () => {
216 |       const updateCompletion = extensionsCommand.subCommands?.find(
217 |         (cmd) => cmd.name === 'update',
218 |       )?.completion;
219 | 
220 |       if (!updateCompletion) {
221 |         throw new Error('Update completion not found');
222 |       }
223 | 
224 |       const extensionOne: GeminiCLIExtension = {
225 |         name: 'ext-one',
226 |         version: '1.0.0',
227 |         isActive: true,
228 |         path: '/test/dir/ext-one',
229 |         installMetadata: {
230 |           type: 'git',
231 |           autoUpdate: false,
232 |           source: 'https://github.com/some/extension.git',
233 |         },
234 |       };
235 |       const extensionTwo: GeminiCLIExtension = {
236 |         name: 'another-ext',
237 |         version: '1.0.0',
238 |         isActive: true,
239 |         path: '/test/dir/another-ext',
240 |         installMetadata: {
241 |           type: 'git',
242 |           autoUpdate: false,
243 |           source: 'https://github.com/some/extension.git',
244 |         },
245 |       };
246 |       const allExt: GeminiCLIExtension = {
247 |         name: 'all-ext',
248 |         version: '1.0.0',
249 |         isActive: true,
250 |         path: '/test/dir/all-ext',
251 |         installMetadata: {
252 |           type: 'git',
253 |           autoUpdate: false,
254 |           source: 'https://github.com/some/extension.git',
255 |         },
256 |       };
257 | 
258 |       it.each([
259 |         {
260 |           description: 'should return matching extension names',
261 |           extensions: [extensionOne, extensionTwo],
262 |           partialArg: 'ext',
263 |           expected: ['ext-one'],
264 |         },
265 |         {
266 |           description: 'should return --all when partialArg matches',
267 |           extensions: [],
268 |           partialArg: '--al',
269 |           expected: ['--all'],
270 |         },
271 |         {
272 |           description:
273 |             'should return both extension names and --all when both match',
274 |           extensions: [allExt],
275 |           partialArg: 'all',
276 |           expected: ['--all', 'all-ext'],
277 |         },
278 |         {
279 |           description: 'should return an empty array if no matches',
280 |           extensions: [extensionOne],
281 |           partialArg: 'nomatch',
282 |           expected: [],
283 |         },
284 |       ])('$description', async ({ extensions, partialArg, expected }) => {
285 |         mockGetExtensions.mockReturnValue(extensions);
286 |         const suggestions = await updateCompletion(mockContext, partialArg);
287 |         expect(suggestions).toEqual(expected);
288 |       });
289 |     });
290 |   });
291 | });
```

src/ui/commands/extensionsCommand.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type { ExtensionUpdateInfo } from '../../config/extension.js';
8 | import { getErrorMessage } from '../../utils/errors.js';
9 | import { MessageType } from '../types.js';
10 | import {
11 |   type CommandContext,
12 |   type SlashCommand,
13 |   CommandKind,
14 | } from './types.js';
15 | 
16 | async function listAction(context: CommandContext) {
17 |   context.ui.addItem(
18 |     {
19 |       type: MessageType.EXTENSIONS_LIST,
20 |     },
21 |     Date.now(),
22 |   );
23 | }
24 | 
25 | function updateAction(context: CommandContext, args: string): Promise<void> {
26 |   const updateArgs = args.split(' ').filter((value) => value.length > 0);
27 |   const all = updateArgs.length === 1 && updateArgs[0] === '--all';
28 |   const names = all ? null : updateArgs;
29 | 
30 |   if (!all && names?.length === 0) {
31 |     context.ui.addItem(
32 |       {
33 |         type: MessageType.ERROR,
34 |         text: 'Usage: /extensions update <extension-names>|--all',
35 |       },
36 |       Date.now(),
37 |     );
38 |     return Promise.resolve();
39 |   }
40 | 
41 |   let resolveUpdateComplete: (updateInfo: ExtensionUpdateInfo[]) => void;
42 |   const updateComplete = new Promise<ExtensionUpdateInfo[]>(
43 |     (resolve) => (resolveUpdateComplete = resolve),
44 |   );
45 |   updateComplete.then((updateInfos) => {
46 |     if (updateInfos.length === 0) {
47 |       context.ui.addItem(
48 |         {
49 |           type: MessageType.INFO,
50 |           text: 'No extensions to update.',
51 |         },
52 |         Date.now(),
53 |       );
54 |     }
55 |     context.ui.addItem(
56 |       {
57 |         type: MessageType.EXTENSIONS_LIST,
58 |       },
59 |       Date.now(),
60 |     );
61 |     context.ui.setPendingItem(null);
62 |   });
63 | 
64 |   try {
65 |     context.ui.setPendingItem({
66 |       type: MessageType.EXTENSIONS_LIST,
67 |     });
68 | 
69 |     context.ui.dispatchExtensionStateUpdate({
70 |       type: 'SCHEDULE_UPDATE',
71 |       payload: {
72 |         all,
73 |         names,
74 |         onComplete: (updateInfos) => {
75 |           resolveUpdateComplete(updateInfos);
76 |         },
77 |       },
78 |     });
79 |     if (names?.length) {
80 |       const extensions = context.services.config!.getExtensions();
81 |       for (const name of names) {
82 |         const extension = extensions.find(
83 |           (extension) => extension.name === name,
84 |         );
85 |         if (!extension) {
86 |           context.ui.addItem(
87 |             {
88 |               type: MessageType.ERROR,
89 |               text: `Extension ${name} not found.`,
90 |             },
91 |             Date.now(),
92 |           );
93 |           continue;
94 |         }
95 |       }
96 |     }
97 |   } catch (error) {
98 |     resolveUpdateComplete!([]);
99 |     context.ui.addItem(
100 |       {
101 |         type: MessageType.ERROR,
102 |         text: getErrorMessage(error),
103 |       },
104 |       Date.now(),
105 |     );
106 |   }
107 |   return updateComplete.then((_) => {});
108 | }
109 | 
110 | const listExtensionsCommand: SlashCommand = {
111 |   name: 'list',
112 |   description: 'List active extensions',
113 |   kind: CommandKind.BUILT_IN,
114 |   action: listAction,
115 | };
116 | 
117 | const updateExtensionsCommand: SlashCommand = {
118 |   name: 'update',
119 |   description: 'Update extensions. Usage: update <extension-names>|--all',
120 |   kind: CommandKind.BUILT_IN,
121 |   action: updateAction,
122 |   completion: async (context, partialArg) => {
123 |     const extensions = context.services.config?.getExtensions() ?? [];
124 |     const extensionNames = extensions.map((ext) => ext.name);
125 |     const suggestions = extensionNames.filter((name) =>
126 |       name.startsWith(partialArg),
127 |     );
128 | 
129 |     if ('--all'.startsWith(partialArg) || 'all'.startsWith(partialArg)) {
130 |       suggestions.unshift('--all');
131 |     }
132 | 
133 |     return suggestions;
134 |   },
135 | };
136 | 
137 | export const extensionsCommand: SlashCommand = {
138 |   name: 'extensions',
139 |   description: 'Manage extensions',
140 |   kind: CommandKind.BUILT_IN,
141 |   subCommands: [listExtensionsCommand, updateExtensionsCommand],
142 |   action: (context, args) =>
143 |     // Default to list if no subcommand is provided
144 |     listExtensionsCommand.action!(context, args),
145 | };
```

src/ui/commands/helpCommand.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
8 | import { helpCommand } from './helpCommand.js';
9 | import { type CommandContext } from './types.js';
10 | import { createMockCommandContext } from '../../test-utils/mockCommandContext.js';
11 | import { MessageType } from '../types.js';
12 | import { CommandKind } from './types.js';
13 | 
14 | describe('helpCommand', () => {
15 |   let mockContext: CommandContext;
16 |   const originalEnv = { ...process.env };
17 | 
18 |   beforeEach(() => {
19 |     mockContext = createMockCommandContext({
20 |       ui: {
21 |         addItem: vi.fn(),
22 |       },
23 |     } as unknown as CommandContext);
24 |   });
25 | 
26 |   afterEach(() => {
27 |     process.env = { ...originalEnv };
28 |     vi.clearAllMocks();
29 |   });
30 | 
31 |   it('should add a help message to the UI history', async () => {
32 |     if (!helpCommand.action) {
33 |       throw new Error('Help command has no action');
34 |     }
35 | 
36 |     await helpCommand.action(mockContext, '');
37 | 
38 |     expect(mockContext.ui.addItem).toHaveBeenCalledWith(
39 |       expect.objectContaining({
40 |         type: MessageType.HELP,
41 |         timestamp: expect.any(Date),
42 |       }),
43 |       expect.any(Number),
44 |     );
45 |   });
46 | 
47 |   it('should have the correct command properties', () => {
48 |     expect(helpCommand.name).toBe('help');
49 |     expect(helpCommand.kind).toBe(CommandKind.BUILT_IN);
50 |     expect(helpCommand.description).toBe('for help on gemini-cli');
51 |   });
52 | });
```

src/ui/commands/helpCommand.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type { SlashCommand } from './types.js';
8 | import { CommandKind } from './types.js';
9 | import { MessageType, type HistoryItemHelp } from '../types.js';
10 | 
11 | export const helpCommand: SlashCommand = {
12 |   name: 'help',
13 |   altNames: ['?'],
14 |   kind: CommandKind.BUILT_IN,
15 |   description: 'for help on gemini-cli',
16 |   action: async (context) => {
17 |     const helpItem: Omit<HistoryItemHelp, 'id'> = {
18 |       type: MessageType.HELP,
19 |       timestamp: new Date(),
20 |     };
21 | 
22 |     context.ui.addItem(helpItem, Date.now());
23 |   },
24 | };
```

src/ui/commands/ideCommand.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type { MockInstance } from 'vitest';
8 | import { vi, describe, it, expect, beforeEach, afterEach } from 'vitest';
9 | import { ideCommand } from './ideCommand.js';
10 | import { type CommandContext } from './types.js';
11 | import { IDE_DEFINITIONS } from '@google/gemini-cli-core';
12 | import * as core from '@google/gemini-cli-core';
13 | 
14 | vi.mock('@google/gemini-cli-core', async (importOriginal) => {
15 |   const original = await importOriginal<typeof core>();
16 |   return {
17 |     ...original,
18 |     getOauthClient: vi.fn(original.getOauthClient),
19 |     getIdeInstaller: vi.fn(original.getIdeInstaller),
20 |     IdeClient: {
21 |       getInstance: vi.fn(),
22 |     },
23 |   };
24 | });
25 | 
26 | describe('ideCommand', () => {
27 |   let mockContext: CommandContext;
28 |   let mockIdeClient: core.IdeClient;
29 |   let platformSpy: MockInstance;
30 | 
31 |   beforeEach(() => {
32 |     vi.resetAllMocks();
33 | 
34 |     mockIdeClient = {
35 |       reconnect: vi.fn(),
36 |       disconnect: vi.fn(),
37 |       connect: vi.fn(),
38 |       getCurrentIde: vi.fn(),
39 |       getConnectionStatus: vi.fn(),
40 |       getDetectedIdeDisplayName: vi.fn(),
41 |     } as unknown as core.IdeClient;
42 | 
43 |     vi.mocked(core.IdeClient.getInstance).mockResolvedValue(mockIdeClient);
44 |     vi.mocked(mockIdeClient.getDetectedIdeDisplayName).mockReturnValue(
45 |       'VS Code',
46 |     );
47 | 
48 |     mockContext = {
49 |       ui: {
50 |         addItem: vi.fn(),
51 |       },
52 |       services: {
53 |         settings: {
54 |           setValue: vi.fn(),
55 |         },
56 |         config: {
57 |           getIdeMode: vi.fn(),
58 |           setIdeMode: vi.fn(),
59 |           getUsageStatisticsEnabled: vi.fn().mockReturnValue(false),
60 |         },
61 |       },
62 |     } as unknown as CommandContext;
63 | 
64 |     platformSpy = vi.spyOn(process, 'platform', 'get');
65 |   });
66 | 
67 |   afterEach(() => {
68 |     vi.restoreAllMocks();
69 |   });
70 | 
71 |   it('should return the ide command', async () => {
72 |     vi.mocked(mockIdeClient.getCurrentIde).mockReturnValue(
73 |       IDE_DEFINITIONS.vscode,
74 |     );
75 |     vi.mocked(mockIdeClient.getConnectionStatus).mockReturnValue({
76 |       status: core.IDEConnectionStatus.Disconnected,
77 |     });
78 |     const command = await ideCommand();
79 |     expect(command).not.toBeNull();
80 |     expect(command.name).toBe('ide');
81 |     expect(command.subCommands).toHaveLength(3);
82 |     expect(command.subCommands?.[0].name).toBe('enable');
83 |     expect(command.subCommands?.[1].name).toBe('status');
84 |     expect(command.subCommands?.[2].name).toBe('install');
85 |   });
86 | 
87 |   it('should show disable command when connected', async () => {
88 |     vi.mocked(mockIdeClient.getCurrentIde).mockReturnValue(
89 |       IDE_DEFINITIONS.vscode,
90 |     );
91 |     vi.mocked(mockIdeClient.getConnectionStatus).mockReturnValue({
92 |       status: core.IDEConnectionStatus.Connected,
93 |     });
94 |     const command = await ideCommand();
95 |     expect(command).not.toBeNull();
96 |     const subCommandNames = command.subCommands?.map((cmd) => cmd.name);
97 |     expect(subCommandNames).toContain('disable');
98 |     expect(subCommandNames).not.toContain('enable');
99 |   });
100 | 
101 |   describe('status subcommand', () => {
102 |     beforeEach(() => {
103 |       vi.mocked(mockIdeClient.getCurrentIde).mockReturnValue(
104 |         IDE_DEFINITIONS.vscode,
105 |       );
106 |     });
107 | 
108 |     it('should show connected status', async () => {
109 |       vi.mocked(mockIdeClient.getConnectionStatus).mockReturnValue({
110 |         status: core.IDEConnectionStatus.Connected,
111 |       });
112 |       const command = await ideCommand();
113 |       const result = await command!.subCommands!.find(
114 |         (c) => c.name === 'status',
115 |       )!.action!(mockContext, '');
116 |       expect(vi.mocked(mockIdeClient.getConnectionStatus)).toHaveBeenCalled();
117 |       expect(result).toEqual({
118 |         type: 'message',
119 |         messageType: 'info',
120 |         content: '🟢 Connected to VS Code',
121 |       });
122 |     });
123 | 
124 |     it('should show connecting status', async () => {
125 |       vi.mocked(mockIdeClient.getConnectionStatus).mockReturnValue({
126 |         status: core.IDEConnectionStatus.Connecting,
127 |       });
128 |       const command = await ideCommand();
129 |       const result = await command!.subCommands!.find(
130 |         (c) => c.name === 'status',
131 |       )!.action!(mockContext, '');
132 |       expect(vi.mocked(mockIdeClient.getConnectionStatus)).toHaveBeenCalled();
133 |       expect(result).toEqual({
134 |         type: 'message',
135 |         messageType: 'info',
136 |         content: `🟡 Connecting...`,
137 |       });
138 |     });
139 |     it('should show disconnected status', async () => {
140 |       vi.mocked(mockIdeClient.getConnectionStatus).mockReturnValue({
141 |         status: core.IDEConnectionStatus.Disconnected,
142 |       });
143 |       const command = await ideCommand();
144 |       const result = await command!.subCommands!.find(
145 |         (c) => c.name === 'status',
146 |       )!.action!(mockContext, '');
147 |       expect(vi.mocked(mockIdeClient.getConnectionStatus)).toHaveBeenCalled();
148 |       expect(result).toEqual({
149 |         type: 'message',
150 |         messageType: 'error',
151 |         content: `🔴 Disconnected`,
152 |       });
153 |     });
154 | 
155 |     it('should show disconnected status with details', async () => {
156 |       const details = 'Something went wrong';
157 |       vi.mocked(mockIdeClient.getConnectionStatus).mockReturnValue({
158 |         status: core.IDEConnectionStatus.Disconnected,
159 |         details,
160 |       });
161 |       const command = await ideCommand();
162 |       const result = await command!.subCommands!.find(
163 |         (c) => c.name === 'status',
164 |       )!.action!(mockContext, '');
165 |       expect(vi.mocked(mockIdeClient.getConnectionStatus)).toHaveBeenCalled();
166 |       expect(result).toEqual({
167 |         type: 'message',
168 |         messageType: 'error',
169 |         content: `🔴 Disconnected: ${details}`,
170 |       });
171 |     });
172 |   });
173 | 
174 |   describe('install subcommand', () => {
175 |     const mockInstall = vi.fn();
176 |     beforeEach(() => {
177 |       vi.mocked(mockIdeClient.getCurrentIde).mockReturnValue(
178 |         IDE_DEFINITIONS.vscode,
179 |       );
180 |       vi.mocked(mockIdeClient.getConnectionStatus).mockReturnValue({
181 |         status: core.IDEConnectionStatus.Disconnected,
182 |       });
183 |       vi.mocked(core.getIdeInstaller).mockReturnValue({
184 |         install: mockInstall,
185 |       });
186 |       platformSpy.mockReturnValue('linux');
187 |     });
188 | 
189 |     it('should install the extension', async () => {
190 |       vi.useFakeTimers();
191 |       mockInstall.mockResolvedValue({
192 |         success: true,
193 |         message: 'Successfully installed.',
194 |       });
195 | 
196 |       const command = await ideCommand();
197 | 
198 |       // For the polling loop inside the action.
199 |       vi.mocked(mockIdeClient.getConnectionStatus).mockReturnValue({
200 |         status: core.IDEConnectionStatus.Connected,
201 |       });
202 | 
203 |       const actionPromise = command!.subCommands!.find(
204 |         (c) => c.name === 'install',
205 |       )!.action!(mockContext, '');
206 |       await vi.runAllTimersAsync();
207 |       await actionPromise;
208 | 
209 |       expect(core.getIdeInstaller).toHaveBeenCalledWith(IDE_DEFINITIONS.vscode);
210 |       expect(mockInstall).toHaveBeenCalled();
211 |       expect(mockContext.ui.addItem).toHaveBeenCalledWith(
212 |         expect.objectContaining({
213 |           type: 'info',
214 |           text: `Installing IDE companion...`,
215 |         }),
216 |         expect.any(Number),
217 |       );
218 |       expect(mockContext.ui.addItem).toHaveBeenCalledWith(
219 |         expect.objectContaining({
220 |           type: 'info',
221 |           text: 'Successfully installed.',
222 |         }),
223 |         expect.any(Number),
224 |       );
225 |       expect(mockContext.ui.addItem).toHaveBeenCalledWith(
226 |         expect.objectContaining({
227 |           type: 'info',
228 |           text: '🟢 Connected to VS Code',
229 |         }),
230 |         expect.any(Number),
231 |       );
232 |       vi.useRealTimers();
233 |     }, 10000);
234 | 
235 |     it('should show an error if installation fails', async () => {
236 |       mockInstall.mockResolvedValue({
237 |         success: false,
238 |         message: 'Installation failed.',
239 |       });
240 | 
241 |       const command = await ideCommand();
242 |       await command!.subCommands!.find((c) => c.name === 'install')!.action!(
243 |         mockContext,
244 |         '',
245 |       );
246 | 
247 |       expect(core.getIdeInstaller).toHaveBeenCalledWith(IDE_DEFINITIONS.vscode);
248 |       expect(mockInstall).toHaveBeenCalled();
249 |       expect(mockContext.ui.addItem).toHaveBeenCalledWith(
250 |         expect.objectContaining({
251 |           type: 'info',
252 |           text: `Installing IDE companion...`,
253 |         }),
254 |         expect.any(Number),
255 |       );
256 |       expect(mockContext.ui.addItem).toHaveBeenCalledWith(
257 |         expect.objectContaining({
258 |           type: 'error',
259 |           text: 'Installation failed.',
260 |         }),
261 |         expect.any(Number),
262 |       );
263 |     });
264 |   });
265 | });
```

src/ui/commands/ideCommand.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import {
8 |   type Config,
9 |   IdeClient,
10 |   type File,
11 |   logIdeConnection,
12 |   IdeConnectionEvent,
13 |   IdeConnectionType,
14 | } from '@google/gemini-cli-core';
15 | import {
16 |   getIdeInstaller,
17 |   IDEConnectionStatus,
18 |   ideContextStore,
19 |   GEMINI_CLI_COMPANION_EXTENSION_NAME,
20 | } from '@google/gemini-cli-core';
21 | import path from 'node:path';
22 | import type {
23 |   CommandContext,
24 |   SlashCommand,
25 |   SlashCommandActionReturn,
26 | } from './types.js';
27 | import { CommandKind } from './types.js';
28 | import { SettingScope } from '../../config/settings.js';
29 | 
30 | function getIdeStatusMessage(ideClient: IdeClient): {
31 |   messageType: 'info' | 'error';
32 |   content: string;
33 | } {
34 |   const connection = ideClient.getConnectionStatus();
35 |   switch (connection.status) {
36 |     case IDEConnectionStatus.Connected:
37 |       return {
38 |         messageType: 'info',
39 |         content: `🟢 Connected to ${ideClient.getDetectedIdeDisplayName()}`,
40 |       };
41 |     case IDEConnectionStatus.Connecting:
42 |       return {
43 |         messageType: 'info',
44 |         content: `🟡 Connecting...`,
45 |       };
46 |     default: {
47 |       let content = `🔴 Disconnected`;
48 |       if (connection?.details) {
49 |         content += `: ${connection.details}`;
50 |       }
51 |       return {
52 |         messageType: 'error',
53 |         content,
54 |       };
55 |     }
56 |   }
57 | }
58 | 
59 | function formatFileList(openFiles: File[]): string {
60 |   const basenameCounts = new Map<string, number>();
61 |   for (const file of openFiles) {
62 |     const basename = path.basename(file.path);
63 |     basenameCounts.set(basename, (basenameCounts.get(basename) || 0) + 1);
64 |   }
65 | 
66 |   const fileList = openFiles
67 |     .map((file: File) => {
68 |       const basename = path.basename(file.path);
69 |       const isDuplicate = (basenameCounts.get(basename) || 0) > 1;
70 |       const parentDir = path.basename(path.dirname(file.path));
71 |       const displayName = isDuplicate
72 |         ? `${basename} (/${parentDir})`
73 |         : basename;
74 | 
75 |       return `  - ${displayName}${file.isActive ? ' (active)' : ''}`;
76 |     })
77 |     .join('\n');
78 | 
79 |   const infoMessage = `
80 | (Note: The file list is limited to a number of recently accessed files within your workspace and only includes local files on disk)`;
81 | 
82 |   return `\n\nOpen files:\n${fileList}\n${infoMessage}`;
83 | }
84 | 
85 | async function getIdeStatusMessageWithFiles(ideClient: IdeClient): Promise<{
86 |   messageType: 'info' | 'error';
87 |   content: string;
88 | }> {
89 |   const connection = ideClient.getConnectionStatus();
90 |   switch (connection.status) {
91 |     case IDEConnectionStatus.Connected: {
92 |       let content = `🟢 Connected to ${ideClient.getDetectedIdeDisplayName()}`;
93 |       const context = ideContextStore.get();
94 |       const openFiles = context?.workspaceState?.openFiles;
95 |       if (openFiles && openFiles.length > 0) {
96 |         content += formatFileList(openFiles);
97 |       }
98 |       return {
99 |         messageType: 'info',
100 |         content,
101 |       };
102 |     }
103 |     case IDEConnectionStatus.Connecting:
104 |       return {
105 |         messageType: 'info',
106 |         content: `🟡 Connecting...`,
107 |       };
108 |     default: {
109 |       let content = `🔴 Disconnected`;
110 |       if (connection?.details) {
111 |         content += `: ${connection.details}`;
112 |       }
113 |       return {
114 |         messageType: 'error',
115 |         content,
116 |       };
117 |     }
118 |   }
119 | }
120 | 
121 | async function setIdeModeAndSyncConnection(
122 |   config: Config,
123 |   value: boolean,
124 | ): Promise<void> {
125 |   config.setIdeMode(value);
126 |   const ideClient = await IdeClient.getInstance();
127 |   if (value) {
128 |     await ideClient.connect();
129 |     logIdeConnection(config, new IdeConnectionEvent(IdeConnectionType.SESSION));
130 |   } else {
131 |     await ideClient.disconnect();
132 |   }
133 | }
134 | 
135 | export const ideCommand = async (): Promise<SlashCommand> => {
136 |   const ideClient = await IdeClient.getInstance();
137 |   const currentIDE = ideClient.getCurrentIde();
138 |   if (!currentIDE) {
139 |     return {
140 |       name: 'ide',
141 |       description: 'manage IDE integration',
142 |       kind: CommandKind.BUILT_IN,
143 |       action: (): SlashCommandActionReturn =>
144 |         ({
145 |           type: 'message',
146 |           messageType: 'error',
147 |           content: `IDE integration is not supported in your current environment. To use this feature, run Gemini CLI in one of these supported IDEs: VS Code or VS Code forks.`,
148 |         }) as const,
149 |     };
150 |   }
151 | 
152 |   const ideSlashCommand: SlashCommand = {
153 |     name: 'ide',
154 |     description: 'manage IDE integration',
155 |     kind: CommandKind.BUILT_IN,
156 |     subCommands: [],
157 |   };
158 | 
159 |   const statusCommand: SlashCommand = {
160 |     name: 'status',
161 |     description: 'check status of IDE integration',
162 |     kind: CommandKind.BUILT_IN,
163 |     action: async (): Promise<SlashCommandActionReturn> => {
164 |       const { messageType, content } =
165 |         await getIdeStatusMessageWithFiles(ideClient);
166 |       return {
167 |         type: 'message',
168 |         messageType,
169 |         content,
170 |       } as const;
171 |     },
172 |   };
173 | 
174 |   const installCommand: SlashCommand = {
175 |     name: 'install',
176 |     description: `install required IDE companion for ${ideClient.getDetectedIdeDisplayName()}`,
177 |     kind: CommandKind.BUILT_IN,
178 |     action: async (context) => {
179 |       const installer = getIdeInstaller(currentIDE);
180 |       if (!installer) {
181 |         context.ui.addItem(
182 |           {
183 |             type: 'error',
184 |             text: `No installer is available for ${ideClient.getDetectedIdeDisplayName()}. Please install the '${GEMINI_CLI_COMPANION_EXTENSION_NAME}' extension manually from the marketplace.`,
185 |           },
186 |           Date.now(),
187 |         );
188 |         return;
189 |       }
190 | 
191 |       context.ui.addItem(
192 |         {
193 |           type: 'info',
194 |           text: `Installing IDE companion...`,
195 |         },
196 |         Date.now(),
197 |       );
198 | 
199 |       const result = await installer.install();
200 |       context.ui.addItem(
201 |         {
202 |           type: result.success ? 'info' : 'error',
203 |           text: result.message,
204 |         },
205 |         Date.now(),
206 |       );
207 |       if (result.success) {
208 |         context.services.settings.setValue(
209 |           SettingScope.User,
210 |           'ide.enabled',
211 |           true,
212 |         );
213 |         // Poll for up to 5 seconds for the extension to activate.
214 |         for (let i = 0; i < 10; i++) {
215 |           await setIdeModeAndSyncConnection(context.services.config!, true);
216 |           if (
217 |             ideClient.getConnectionStatus().status ===
218 |             IDEConnectionStatus.Connected
219 |           ) {
220 |             break;
221 |           }
222 |           await new Promise((resolve) => setTimeout(resolve, 500));
223 |         }
224 | 
225 |         const { messageType, content } = getIdeStatusMessage(ideClient);
226 |         if (messageType === 'error') {
227 |           context.ui.addItem(
228 |             {
229 |               type: messageType,
230 |               text: `Failed to automatically enable IDE integration. To fix this, run the CLI in a new terminal window.`,
231 |             },
232 |             Date.now(),
233 |           );
234 |         } else {
235 |           context.ui.addItem(
236 |             {
237 |               type: messageType,
238 |               text: content,
239 |             },
240 |             Date.now(),
241 |           );
242 |         }
243 |       }
244 |     },
245 |   };
246 | 
247 |   const enableCommand: SlashCommand = {
248 |     name: 'enable',
249 |     description: 'enable IDE integration',
250 |     kind: CommandKind.BUILT_IN,
251 |     action: async (context: CommandContext) => {
252 |       context.services.settings.setValue(
253 |         SettingScope.User,
254 |         'ide.enabled',
255 |         true,
256 |       );
257 |       await setIdeModeAndSyncConnection(context.services.config!, true);
258 |       const { messageType, content } = getIdeStatusMessage(ideClient);
259 |       context.ui.addItem(
260 |         {
261 |           type: messageType,
262 |           text: content,
263 |         },
264 |         Date.now(),
265 |       );
266 |     },
267 |   };
268 | 
269 |   const disableCommand: SlashCommand = {
270 |     name: 'disable',
271 |     description: 'disable IDE integration',
272 |     kind: CommandKind.BUILT_IN,
273 |     action: async (context: CommandContext) => {
274 |       context.services.settings.setValue(
275 |         SettingScope.User,
276 |         'ide.enabled',
277 |         false,
278 |       );
279 |       await setIdeModeAndSyncConnection(context.services.config!, false);
280 |       const { messageType, content } = getIdeStatusMessage(ideClient);
281 |       context.ui.addItem(
282 |         {
283 |           type: messageType,
284 |           text: content,
285 |         },
286 |         Date.now(),
287 |       );
288 |     },
289 |   };
290 | 
291 |   const { status } = ideClient.getConnectionStatus();
292 |   const isConnected = status === IDEConnectionStatus.Connected;
293 | 
294 |   if (isConnected) {
295 |     ideSlashCommand.subCommands = [statusCommand, disableCommand];
296 |   } else {
297 |     ideSlashCommand.subCommands = [
298 |       enableCommand,
299 |       statusCommand,
300 |       installCommand,
301 |     ];
302 |   }
303 | 
304 |   return ideSlashCommand;
305 | };
```

src/ui/commands/initCommand.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { vi, describe, it, expect, beforeEach, afterEach } from 'vitest';
8 | import * as fs from 'node:fs';
9 | import * as path from 'node:path';
10 | import { initCommand } from './initCommand.js';
11 | import { createMockCommandContext } from '../../test-utils/mockCommandContext.js';
12 | import { type CommandContext } from './types.js';
13 | 
14 | // Mock the 'fs' module
15 | vi.mock('fs', () => ({
16 |   existsSync: vi.fn(),
17 |   writeFileSync: vi.fn(),
18 | }));
19 | 
20 | describe('initCommand', () => {
21 |   let mockContext: CommandContext;
22 |   const targetDir = '/test/dir';
23 |   const geminiMdPath = path.join(targetDir, 'GEMINI.md');
24 | 
25 |   beforeEach(() => {
26 |     // Create a fresh mock context for each test
27 |     mockContext = createMockCommandContext({
28 |       services: {
29 |         config: {
30 |           getTargetDir: () => targetDir,
31 |         },
32 |       },
33 |     });
34 |   });
35 | 
36 |   afterEach(() => {
37 |     // Clear all mocks after each test
38 |     vi.clearAllMocks();
39 |   });
40 | 
41 |   it('should inform the user if GEMINI.md already exists', async () => {
42 |     // Arrange: Simulate that the file exists
43 |     vi.mocked(fs.existsSync).mockReturnValue(true);
44 | 
45 |     // Act: Run the command's action
46 |     const result = await initCommand.action!(mockContext, '');
47 | 
48 |     // Assert: Check for the correct informational message
49 |     expect(result).toEqual({
50 |       type: 'message',
51 |       messageType: 'info',
52 |       content:
53 |         'A GEMINI.md file already exists in this directory. No changes were made.',
54 |     });
55 |     // Assert: Ensure no file was written
56 |     expect(fs.writeFileSync).not.toHaveBeenCalled();
57 |   });
58 | 
59 |   it('should create GEMINI.md and submit a prompt if it does not exist', async () => {
60 |     // Arrange: Simulate that the file does not exist
61 |     vi.mocked(fs.existsSync).mockReturnValue(false);
62 | 
63 |     // Act: Run the command's action
64 |     const result = await initCommand.action!(mockContext, '');
65 | 
66 |     // Assert: Check that writeFileSync was called correctly
67 |     expect(fs.writeFileSync).toHaveBeenCalledWith(geminiMdPath, '', 'utf8');
68 | 
69 |     // Assert: Check that an informational message was added to the UI
70 |     expect(mockContext.ui.addItem).toHaveBeenCalledWith(
71 |       {
72 |         type: 'info',
73 |         text: 'Empty GEMINI.md created. Now analyzing the project to populate it.',
74 |       },
75 |       expect.any(Number),
76 |     );
77 | 
78 |     // Assert: Check that the correct prompt is submitted
79 |     expect(result.type).toBe('submit_prompt');
80 |     expect(result.content).toContain(
81 |       'You are an AI agent that brings the power of Gemini',
82 |     );
83 |   });
84 | 
85 |   it('should return an error if config is not available', async () => {
86 |     // Arrange: Create a context without config
87 |     const noConfigContext = createMockCommandContext();
88 |     if (noConfigContext.services) {
89 |       noConfigContext.services.config = null;
90 |     }
91 | 
92 |     // Act: Run the command's action
93 |     const result = await initCommand.action!(noConfigContext, '');
94 | 
95 |     // Assert: Check for the correct error message
96 |     expect(result).toEqual({
97 |       type: 'message',
98 |       messageType: 'error',
99 |       content: 'Configuration not available.',
100 |     });
101 |   });
102 | });
```

src/ui/commands/initCommand.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import * as fs from 'node:fs';
8 | import * as path from 'node:path';
9 | import type {
10 |   CommandContext,
11 |   SlashCommand,
12 |   SlashCommandActionReturn,
13 | } from './types.js';
14 | import { CommandKind } from './types.js';
15 | 
16 | export const initCommand: SlashCommand = {
17 |   name: 'init',
18 |   description: 'Analyzes the project and creates a tailored GEMINI.md file.',
19 |   kind: CommandKind.BUILT_IN,
20 |   action: async (
21 |     context: CommandContext,
22 |     _args: string,
23 |   ): Promise<SlashCommandActionReturn> => {
24 |     if (!context.services.config) {
25 |       return {
26 |         type: 'message',
27 |         messageType: 'error',
28 |         content: 'Configuration not available.',
29 |       };
30 |     }
31 |     const targetDir = context.services.config.getTargetDir();
32 |     const geminiMdPath = path.join(targetDir, 'GEMINI.md');
33 | 
34 |     if (fs.existsSync(geminiMdPath)) {
35 |       return {
36 |         type: 'message',
37 |         messageType: 'info',
38 |         content:
39 |           'A GEMINI.md file already exists in this directory. No changes were made.',
40 |       };
41 |     }
42 | 
43 |     // Create an empty GEMINI.md file
44 |     fs.writeFileSync(geminiMdPath, '', 'utf8');
45 | 
46 |     context.ui.addItem(
47 |       {
48 |         type: 'info',
49 |         text: 'Empty GEMINI.md created. Now analyzing the project to populate it.',
50 |       },
51 |       Date.now(),
52 |     );
53 | 
54 |     return {
55 |       type: 'submit_prompt',
56 |       content: `
57 | You are an AI agent that brings the power of Gemini directly into the terminal. Your task is to analyze the current directory and generate a comprehensive GEMINI.md file to be used as instructional context for future interactions.
58 | 
59 | **Analysis Process:**
60 | 
61 | 1.  **Initial Exploration:**
62 |     *   Start by listing the files and directories to get a high-level overview of the structure.
63 |     *   Read the README file (e.g., \`README.md\`, \`README.txt\`) if it exists. This is often the best place to start.
64 | 
65 | 2.  **Iterative Deep Dive (up to 10 files):**
66 |     *   Based on your initial findings, select a few files that seem most important (e.g., configuration files, main source files, documentation).
67 |     *   Read them. As you learn more, refine your understanding and decide which files to read next. You don't need to decide all 10 files at once. Let your discoveries guide your exploration.
68 | 
69 | 3.  **Identify Project Type:**
70 |     *   **Code Project:** Look for clues like \`package.json\`, \`requirements.txt\`, \`pom.xml\`, \`go.mod\`, \`Cargo.toml\`, \`build.gradle\`, or a \`src\` directory. If you find them, this is likely a software project.
71 |     *   **Non-Code Project:** If you don't find code-related files, this might be a directory for documentation, research papers, notes, or something else.
72 | 
73 | **GEMINI.md Content Generation:**
74 | 
75 | **For a Code Project:**
76 | 
77 | *   **Project Overview:** Write a clear and concise summary of the project's purpose, main technologies, and architecture.
78 | *   **Building and Running:** Document the key commands for building, running, and testing the project. Infer these from the files you've read (e.g., \`scripts\` in \`package.json\`, \`Makefile\`, etc.). If you can't find explicit commands, provide a placeholder with a TODO.
79 | *   **Development Conventions:** Describe any coding styles, testing practices, or contribution guidelines you can infer from the codebase.
80 | 
81 | **For a Non-Code Project:**
82 | 
83 | *   **Directory Overview:** Describe the purpose and contents of the directory. What is it for? What kind of information does it hold?
84 | *   **Key Files:** List the most important files and briefly explain what they contain.
85 | *   **Usage:** Explain how the contents of this directory are intended to be used.
86 | 
87 | **Final Output:**
88 | 
89 | Write the complete content to the \`GEMINI.md\` file. The output must be well-formatted Markdown.
90 | `,
91 |     };
92 |   },
93 | };
```

src/ui/commands/mcpCommand.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { vi, describe, it, expect, beforeEach } from 'vitest';
8 | import { mcpCommand } from './mcpCommand.js';
9 | import { createMockCommandContext } from '../../test-utils/mockCommandContext.js';
10 | import {
11 |   MCPServerStatus,
12 |   MCPDiscoveryState,
13 |   getMCPServerStatus,
14 |   getMCPDiscoveryState,
15 |   DiscoveredMCPTool,
16 | } from '@google/gemini-cli-core';
17 | 
18 | import type { CallableTool } from '@google/genai';
19 | import { Type } from '@google/genai';
20 | import { MessageType } from '../types.js';
21 | 
22 | vi.mock('@google/gemini-cli-core', async (importOriginal) => {
23 |   const actual =
24 |     await importOriginal<typeof import('@google/gemini-cli-core')>();
25 |   const mockAuthenticate = vi.fn();
26 |   return {
27 |     ...actual,
28 |     getMCPServerStatus: vi.fn(),
29 |     getMCPDiscoveryState: vi.fn(),
30 |     MCPOAuthProvider: vi.fn(() => ({
31 |       authenticate: mockAuthenticate,
32 |     })),
33 |     MCPOAuthTokenStorage: vi.fn(() => ({
34 |       getToken: vi.fn(),
35 |       isTokenExpired: vi.fn(),
36 |     })),
37 |   };
38 | });
39 | 
40 | // Helper function to create a mock DiscoveredMCPTool
41 | const createMockMCPTool = (
42 |   name: string,
43 |   serverName: string,
44 |   description?: string,
45 | ) =>
46 |   new DiscoveredMCPTool(
47 |     {
48 |       callTool: vi.fn(),
49 |       tool: vi.fn(),
50 |     } as unknown as CallableTool,
51 |     serverName,
52 |     name,
53 |     description || `Description for ${name}`,
54 |     { type: Type.OBJECT, properties: {} },
55 |   );
56 | 
57 | describe('mcpCommand', () => {
58 |   let mockContext: ReturnType<typeof createMockCommandContext>;
59 |   let mockConfig: {
60 |     getToolRegistry: ReturnType<typeof vi.fn>;
61 |     getMcpServers: ReturnType<typeof vi.fn>;
62 |     getBlockedMcpServers: ReturnType<typeof vi.fn>;
63 |     getPromptRegistry: ReturnType<typeof vi.fn>;
64 |     getGeminiClient: ReturnType<typeof vi.fn>;
65 |   };
66 | 
67 |   beforeEach(() => {
68 |     vi.clearAllMocks();
69 | 
70 |     // Set up default mock environment
71 |     vi.unstubAllEnvs();
72 | 
73 |     // Default mock implementations
74 |     vi.mocked(getMCPServerStatus).mockReturnValue(MCPServerStatus.CONNECTED);
75 |     vi.mocked(getMCPDiscoveryState).mockReturnValue(
76 |       MCPDiscoveryState.COMPLETED,
77 |     );
78 | 
79 |     // Create mock config with all necessary methods
80 |     mockConfig = {
81 |       getToolRegistry: vi.fn().mockReturnValue({
82 |         getAllTools: vi.fn().mockReturnValue([]),
83 |       }),
84 |       getMcpServers: vi.fn().mockReturnValue({}),
85 |       getBlockedMcpServers: vi.fn().mockReturnValue([]),
86 |       getPromptRegistry: vi.fn().mockResolvedValue({
87 |         getAllPrompts: vi.fn().mockReturnValue([]),
88 |         getPromptsByServer: vi.fn().mockReturnValue([]),
89 |       }),
90 |       getGeminiClient: vi.fn(),
91 |     };
92 | 
93 |     mockContext = createMockCommandContext({
94 |       services: {
95 |         config: mockConfig,
96 |       },
97 |     });
98 |   });
99 | 
100 |   describe('basic functionality', () => {
101 |     it('should show an error if config is not available', async () => {
102 |       const contextWithoutConfig = createMockCommandContext({
103 |         services: {
104 |           config: null,
105 |         },
106 |       });
107 | 
108 |       const result = await mcpCommand.action!(contextWithoutConfig, '');
109 | 
110 |       expect(result).toEqual({
111 |         type: 'message',
112 |         messageType: 'error',
113 |         content: 'Config not loaded.',
114 |       });
115 |     });
116 | 
117 |     it('should show an error if tool registry is not available', async () => {
118 |       mockConfig.getToolRegistry = vi.fn().mockReturnValue(undefined);
119 | 
120 |       const result = await mcpCommand.action!(mockContext, '');
121 | 
122 |       expect(result).toEqual({
123 |         type: 'message',
124 |         messageType: 'error',
125 |         content: 'Could not retrieve tool registry.',
126 |       });
127 |     });
128 |   });
129 | 
130 |   describe('with configured MCP servers', () => {
131 |     beforeEach(() => {
132 |       const mockMcpServers = {
133 |         server1: { command: 'cmd1' },
134 |         server2: { command: 'cmd2' },
135 |         server3: { command: 'cmd3' },
136 |       };
137 | 
138 |       mockConfig.getMcpServers = vi.fn().mockReturnValue(mockMcpServers);
139 |     });
140 | 
141 |     it('should display configured MCP servers with status indicators and their tools', async () => {
142 |       // Setup getMCPServerStatus mock implementation
143 |       vi.mocked(getMCPServerStatus).mockImplementation((serverName) => {
144 |         if (serverName === 'server1') return MCPServerStatus.CONNECTED;
145 |         if (serverName === 'server2') return MCPServerStatus.CONNECTED;
146 |         return MCPServerStatus.DISCONNECTED; // server3
147 |       });
148 | 
149 |       // Mock tools from each server using actual DiscoveredMCPTool instances
150 |       const mockServer1Tools = [
151 |         createMockMCPTool('server1_tool1', 'server1'),
152 |         createMockMCPTool('server1_tool2', 'server1'),
153 |       ];
154 |       const mockServer2Tools = [createMockMCPTool('server2_tool1', 'server2')];
155 |       const mockServer3Tools = [createMockMCPTool('server3_tool1', 'server3')];
156 | 
157 |       const allTools = [
158 |         ...mockServer1Tools,
159 |         ...mockServer2Tools,
160 |         ...mockServer3Tools,
161 |       ];
162 | 
163 |       mockConfig.getToolRegistry = vi.fn().mockReturnValue({
164 |         getAllTools: vi.fn().mockReturnValue(allTools),
165 |       });
166 | 
167 |       await mcpCommand.action!(mockContext, '');
168 | 
169 |       expect(mockContext.ui.addItem).toHaveBeenCalledWith(
170 |         expect.objectContaining({
171 |           type: MessageType.MCP_STATUS,
172 |           tools: allTools.map((tool) => ({
173 |             serverName: tool.serverName,
174 |             name: tool.name,
175 |             description: tool.description,
176 |             schema: tool.schema,
177 |           })),
178 |           showTips: true,
179 |         }),
180 |         expect.any(Number),
181 |       );
182 |     });
183 | 
184 |     it('should display tool descriptions when desc argument is used', async () => {
185 |       await mcpCommand.action!(mockContext, 'desc');
186 | 
187 |       expect(mockContext.ui.addItem).toHaveBeenCalledWith(
188 |         expect.objectContaining({
189 |           type: MessageType.MCP_STATUS,
190 |           showDescriptions: true,
191 |           showTips: false,
192 |         }),
193 |         expect.any(Number),
194 |       );
195 |     });
196 | 
197 |     it('should not display descriptions when nodesc argument is used', async () => {
198 |       await mcpCommand.action!(mockContext, 'nodesc');
199 | 
200 |       expect(mockContext.ui.addItem).toHaveBeenCalledWith(
201 |         expect.objectContaining({
202 |           type: MessageType.MCP_STATUS,
203 |           showDescriptions: false,
204 |           showTips: false,
205 |         }),
206 |         expect.any(Number),
207 |       );
208 |     });
209 |   });
210 | });
```

src/ui/commands/mcpCommand.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type {
8 |   SlashCommand,
9 |   SlashCommandActionReturn,
10 |   CommandContext,
11 |   MessageActionReturn,
12 | } from './types.js';
13 | import { CommandKind } from './types.js';
14 | import type { DiscoveredMCPPrompt } from '@google/gemini-cli-core';
15 | import {
16 |   DiscoveredMCPTool,
17 |   getMCPDiscoveryState,
18 |   getMCPServerStatus,
19 |   MCPDiscoveryState,
20 |   MCPServerStatus,
21 |   getErrorMessage,
22 |   MCPOAuthTokenStorage,
23 | } from '@google/gemini-cli-core';
24 | import { appEvents, AppEvent } from '../../utils/events.js';
25 | import { MessageType, type HistoryItemMcpStatus } from '../types.js';
26 | 
27 | const authCommand: SlashCommand = {
28 |   name: 'auth',
29 |   description: 'Authenticate with an OAuth-enabled MCP server',
30 |   kind: CommandKind.BUILT_IN,
31 |   action: async (
32 |     context: CommandContext,
33 |     args: string,
34 |   ): Promise<MessageActionReturn> => {
35 |     const serverName = args.trim();
36 |     const { config } = context.services;
37 | 
38 |     if (!config) {
39 |       return {
40 |         type: 'message',
41 |         messageType: 'error',
42 |         content: 'Config not loaded.',
43 |       };
44 |     }
45 | 
46 |     const mcpServers = config.getMcpServers() || {};
47 | 
48 |     if (!serverName) {
49 |       // List servers that support OAuth
50 |       const oauthServers = Object.entries(mcpServers)
51 |         .filter(([_, server]) => server.oauth?.enabled)
52 |         .map(([name, _]) => name);
53 | 
54 |       if (oauthServers.length === 0) {
55 |         return {
56 |           type: 'message',
57 |           messageType: 'info',
58 |           content: 'No MCP servers configured with OAuth authentication.',
59 |         };
60 |       }
61 | 
62 |       return {
63 |         type: 'message',
64 |         messageType: 'info',
65 |         content: `MCP servers with OAuth authentication:\n${oauthServers.map((s) => `  - ${s}`).join('\n')}\n\nUse /mcp auth <server-name> to authenticate.`,
66 |       };
67 |     }
68 | 
69 |     const server = mcpServers[serverName];
70 |     if (!server) {
71 |       return {
72 |         type: 'message',
73 |         messageType: 'error',
74 |         content: `MCP server '${serverName}' not found.`,
75 |       };
76 |     }
77 | 
78 |     // Always attempt OAuth authentication, even if not explicitly configured
79 |     // The authentication process will discover OAuth requirements automatically
80 | 
81 |     const displayListener = (message: string) => {
82 |       context.ui.addItem({ type: 'info', text: message }, Date.now());
83 |     };
84 | 
85 |     appEvents.on(AppEvent.OauthDisplayMessage, displayListener);
86 | 
87 |     try {
88 |       context.ui.addItem(
89 |         {
90 |           type: 'info',
91 |           text: `Starting OAuth authentication for MCP server '${serverName}'...`,
92 |         },
93 |         Date.now(),
94 |       );
95 | 
96 |       // Import dynamically to avoid circular dependencies
97 |       const { MCPOAuthProvider } = await import('@google/gemini-cli-core');
98 | 
99 |       let oauthConfig = server.oauth;
100 |       if (!oauthConfig) {
101 |         oauthConfig = { enabled: false };
102 |       }
103 | 
104 |       const mcpServerUrl = server.httpUrl || server.url;
105 |       const authProvider = new MCPOAuthProvider(new MCPOAuthTokenStorage());
106 |       await authProvider.authenticate(
107 |         serverName,
108 |         oauthConfig,
109 |         mcpServerUrl,
110 |         appEvents,
111 |       );
112 | 
113 |       context.ui.addItem(
114 |         {
115 |           type: 'info',
116 |           text: `✅ Successfully authenticated with MCP server '${serverName}'!`,
117 |         },
118 |         Date.now(),
119 |       );
120 | 
121 |       // Trigger tool re-discovery to pick up authenticated server
122 |       const toolRegistry = config.getToolRegistry();
123 |       if (toolRegistry) {
124 |         context.ui.addItem(
125 |           {
126 |             type: 'info',
127 |             text: `Re-discovering tools from '${serverName}'...`,
128 |           },
129 |           Date.now(),
130 |         );
131 |         await toolRegistry.discoverToolsForServer(serverName);
132 |       }
133 |       // Update the client with the new tools
134 |       const geminiClient = config.getGeminiClient();
135 |       if (geminiClient) {
136 |         await geminiClient.setTools();
137 |       }
138 | 
139 |       // Reload the slash commands to reflect the changes.
140 |       context.ui.reloadCommands();
141 | 
142 |       return {
143 |         type: 'message',
144 |         messageType: 'info',
145 |         content: `Successfully authenticated and refreshed tools for '${serverName}'.`,
146 |       };
147 |     } catch (error) {
148 |       return {
149 |         type: 'message',
150 |         messageType: 'error',
151 |         content: `Failed to authenticate with MCP server '${serverName}': ${getErrorMessage(error)}`,
152 |       };
153 |     } finally {
154 |       appEvents.removeListener(AppEvent.OauthDisplayMessage, displayListener);
155 |     }
156 |   },
157 |   completion: async (context: CommandContext, partialArg: string) => {
158 |     const { config } = context.services;
159 |     if (!config) return [];
160 | 
161 |     const mcpServers = config.getMcpServers() || {};
162 |     return Object.keys(mcpServers).filter((name) =>
163 |       name.startsWith(partialArg),
164 |     );
165 |   },
166 | };
167 | 
168 | const listCommand: SlashCommand = {
169 |   name: 'list',
170 |   description: 'List configured MCP servers and tools',
171 |   kind: CommandKind.BUILT_IN,
172 |   action: async (
173 |     context: CommandContext,
174 |     args: string,
175 |   ): Promise<void | MessageActionReturn> => {
176 |     const { config } = context.services;
177 |     if (!config) {
178 |       return {
179 |         type: 'message',
180 |         messageType: 'error',
181 |         content: 'Config not loaded.',
182 |       };
183 |     }
184 | 
185 |     const toolRegistry = config.getToolRegistry();
186 |     if (!toolRegistry) {
187 |       return {
188 |         type: 'message',
189 |         messageType: 'error',
190 |         content: 'Could not retrieve tool registry.',
191 |       };
192 |     }
193 | 
194 |     const lowerCaseArgs = args.toLowerCase().split(/\s+/).filter(Boolean);
195 | 
196 |     const hasDesc =
197 |       lowerCaseArgs.includes('desc') || lowerCaseArgs.includes('descriptions');
198 |     const hasNodesc =
199 |       lowerCaseArgs.includes('nodesc') ||
200 |       lowerCaseArgs.includes('nodescriptions');
201 |     const showSchema = lowerCaseArgs.includes('schema');
202 | 
203 |     const showDescriptions = !hasNodesc && (hasDesc || showSchema);
204 |     const showTips = lowerCaseArgs.length === 0;
205 | 
206 |     const mcpServers = config.getMcpServers() || {};
207 |     const serverNames = Object.keys(mcpServers);
208 |     const blockedMcpServers = config.getBlockedMcpServers() || [];
209 | 
210 |     const connectingServers = serverNames.filter(
211 |       (name) => getMCPServerStatus(name) === MCPServerStatus.CONNECTING,
212 |     );
213 |     const discoveryState = getMCPDiscoveryState();
214 |     const discoveryInProgress =
215 |       discoveryState === MCPDiscoveryState.IN_PROGRESS ||
216 |       connectingServers.length > 0;
217 | 
218 |     const allTools = toolRegistry.getAllTools();
219 |     const mcpTools = allTools.filter(
220 |       (tool) => tool instanceof DiscoveredMCPTool,
221 |     ) as DiscoveredMCPTool[];
222 | 
223 |     const promptRegistry = await config.getPromptRegistry();
224 |     const mcpPrompts = promptRegistry
225 |       .getAllPrompts()
226 |       .filter(
227 |         (prompt) =>
228 |           'serverName' in prompt &&
229 |           serverNames.includes(prompt.serverName as string),
230 |       ) as DiscoveredMCPPrompt[];
231 | 
232 |     const authStatus: HistoryItemMcpStatus['authStatus'] = {};
233 |     const tokenStorage = new MCPOAuthTokenStorage();
234 |     for (const serverName of serverNames) {
235 |       const server = mcpServers[serverName];
236 |       if (server.oauth?.enabled) {
237 |         const creds = await tokenStorage.getCredentials(serverName);
238 |         if (creds) {
239 |           if (creds.token.expiresAt && creds.token.expiresAt < Date.now()) {
240 |             authStatus[serverName] = 'expired';
241 |           } else {
242 |             authStatus[serverName] = 'authenticated';
243 |           }
244 |         } else {
245 |           authStatus[serverName] = 'unauthenticated';
246 |         }
247 |       } else {
248 |         authStatus[serverName] = 'not-configured';
249 |       }
250 |     }
251 | 
252 |     const mcpStatusItem: HistoryItemMcpStatus = {
253 |       type: MessageType.MCP_STATUS,
254 |       servers: mcpServers,
255 |       tools: mcpTools.map((tool) => ({
256 |         serverName: tool.serverName,
257 |         name: tool.name,
258 |         description: tool.description,
259 |         schema: tool.schema,
260 |       })),
261 |       prompts: mcpPrompts.map((prompt) => ({
262 |         serverName: prompt.serverName as string,
263 |         name: prompt.name,
264 |         description: prompt.description,
265 |       })),
266 |       authStatus,
267 |       blockedServers: blockedMcpServers,
268 |       discoveryInProgress,
269 |       connectingServers,
270 |       showDescriptions,
271 |       showSchema,
272 |       showTips,
273 |     };
274 | 
275 |     context.ui.addItem(mcpStatusItem, Date.now());
276 |   },
277 | };
278 | 
279 | const refreshCommand: SlashCommand = {
280 |   name: 'refresh',
281 |   description: 'Restarts MCP servers.',
282 |   kind: CommandKind.BUILT_IN,
283 |   action: async (
284 |     context: CommandContext,
285 |   ): Promise<void | SlashCommandActionReturn> => {
286 |     const { config } = context.services;
287 |     if (!config) {
288 |       return {
289 |         type: 'message',
290 |         messageType: 'error',
291 |         content: 'Config not loaded.',
292 |       };
293 |     }
294 | 
295 |     const toolRegistry = config.getToolRegistry();
296 |     if (!toolRegistry) {
297 |       return {
298 |         type: 'message',
299 |         messageType: 'error',
300 |         content: 'Could not retrieve tool registry.',
301 |       };
302 |     }
303 | 
304 |     context.ui.addItem(
305 |       {
306 |         type: 'info',
307 |         text: 'Restarting MCP servers...',
308 |       },
309 |       Date.now(),
310 |     );
311 | 
312 |     await toolRegistry.restartMcpServers();
313 | 
314 |     // Update the client with the new tools
315 |     const geminiClient = config.getGeminiClient();
316 |     if (geminiClient) {
317 |       await geminiClient.setTools();
318 |     }
319 | 
320 |     // Reload the slash commands to reflect the changes.
321 |     context.ui.reloadCommands();
322 | 
323 |     return listCommand.action!(context, '');
324 |   },
325 | };
326 | 
327 | export const mcpCommand: SlashCommand = {
328 |   name: 'mcp',
329 |   description:
330 |     'list configured MCP servers and tools, or authenticate with OAuth-enabled servers',
331 |   kind: CommandKind.BUILT_IN,
332 |   subCommands: [listCommand, authCommand, refreshCommand],
333 |   // Default action when no subcommand is provided
334 |   action: async (
335 |     context: CommandContext,
336 |     args: string,
337 |   ): Promise<void | SlashCommandActionReturn> =>
338 |     // If no subcommand, run the list command
339 |     listCommand.action!(context, args),
340 | };
```

src/ui/commands/memoryCommand.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type { Mock } from 'vitest';
8 | import { vi, describe, it, expect, beforeEach } from 'vitest';
9 | import { memoryCommand } from './memoryCommand.js';
10 | import type { SlashCommand, CommandContext } from './types.js';
11 | import { createMockCommandContext } from '../../test-utils/mockCommandContext.js';
12 | import { MessageType } from '../types.js';
13 | import type { LoadedSettings } from '../../config/settings.js';
14 | import {
15 |   getErrorMessage,
16 |   type FileDiscoveryService,
17 | } from '@google/gemini-cli-core';
18 | import type { LoadServerHierarchicalMemoryResponse } from '@google/gemini-cli-core/index.js';
19 | import { loadHierarchicalGeminiMemory } from '../../config/config.js';
20 | 
21 | vi.mock('@google/gemini-cli-core', async (importOriginal) => {
22 |   const original =
23 |     await importOriginal<typeof import('@google/gemini-cli-core')>();
24 |   return {
25 |     ...original,
26 |     getErrorMessage: vi.fn((error: unknown) => {
27 |       if (error instanceof Error) return error.message;
28 |       return String(error);
29 |     }),
30 |   };
31 | });
32 | 
33 | vi.mock('../../config/config.js', async (importOriginal) => {
34 |   const original =
35 |     await importOriginal<typeof import('../../config/config.js')>();
36 |   return {
37 |     ...original,
38 |     loadHierarchicalGeminiMemory: vi.fn(),
39 |   };
40 | });
41 | 
42 | const mockLoadHierarchicalGeminiMemory = loadHierarchicalGeminiMemory as Mock;
43 | 
44 | describe('memoryCommand', () => {
45 |   let mockContext: CommandContext;
46 | 
47 |   const getSubCommand = (
48 |     name: 'show' | 'add' | 'refresh' | 'list',
49 |   ): SlashCommand => {
50 |     const subCommand = memoryCommand.subCommands?.find(
51 |       (cmd) => cmd.name === name,
52 |     );
53 |     if (!subCommand) {
54 |       throw new Error(`/memory ${name} command not found.`);
55 |     }
56 |     return subCommand;
57 |   };
58 | 
59 |   describe('/memory show', () => {
60 |     let showCommand: SlashCommand;
61 |     let mockGetUserMemory: Mock;
62 |     let mockGetGeminiMdFileCount: Mock;
63 | 
64 |     beforeEach(() => {
65 |       showCommand = getSubCommand('show');
66 | 
67 |       mockGetUserMemory = vi.fn();
68 |       mockGetGeminiMdFileCount = vi.fn();
69 | 
70 |       mockContext = createMockCommandContext({
71 |         services: {
72 |           config: {
73 |             getUserMemory: mockGetUserMemory,
74 |             getGeminiMdFileCount: mockGetGeminiMdFileCount,
75 |           },
76 |         },
77 |       });
78 |     });
79 | 
80 |     it('should display a message if memory is empty', async () => {
81 |       if (!showCommand.action) throw new Error('Command has no action');
82 | 
83 |       mockGetUserMemory.mockReturnValue('');
84 |       mockGetGeminiMdFileCount.mockReturnValue(0);
85 | 
86 |       await showCommand.action(mockContext, '');
87 | 
88 |       expect(mockContext.ui.addItem).toHaveBeenCalledWith(
89 |         {
90 |           type: MessageType.INFO,
91 |           text: 'Memory is currently empty.',
92 |         },
93 |         expect.any(Number),
94 |       );
95 |     });
96 | 
97 |     it('should display the memory content and file count if it exists', async () => {
98 |       if (!showCommand.action) throw new Error('Command has no action');
99 | 
100 |       const memoryContent = 'This is a test memory.';
101 | 
102 |       mockGetUserMemory.mockReturnValue(memoryContent);
103 |       mockGetGeminiMdFileCount.mockReturnValue(1);
104 | 
105 |       await showCommand.action(mockContext, '');
106 | 
107 |       expect(mockContext.ui.addItem).toHaveBeenCalledWith(
108 |         {
109 |           type: MessageType.INFO,
110 |           text: `Current memory content from 1 file(s):\n\n---\n${memoryContent}\n---`,
111 |         },
112 |         expect.any(Number),
113 |       );
114 |     });
115 |   });
116 | 
117 |   describe('/memory add', () => {
118 |     let addCommand: SlashCommand;
119 | 
120 |     beforeEach(() => {
121 |       addCommand = getSubCommand('add');
122 |       mockContext = createMockCommandContext();
123 |     });
124 | 
125 |     it('should return an error message if no arguments are provided', () => {
126 |       if (!addCommand.action) throw new Error('Command has no action');
127 | 
128 |       const result = addCommand.action(mockContext, '  ');
129 |       expect(result).toEqual({
130 |         type: 'message',
131 |         messageType: 'error',
132 |         content: 'Usage: /memory add <text to remember>',
133 |       });
134 | 
135 |       expect(mockContext.ui.addItem).not.toHaveBeenCalled();
136 |     });
137 | 
138 |     it('should return a tool action and add an info message when arguments are provided', () => {
139 |       if (!addCommand.action) throw new Error('Command has no action');
140 | 
141 |       const fact = 'remember this';
142 |       const result = addCommand.action(mockContext, `  ${fact}  `);
143 | 
144 |       expect(mockContext.ui.addItem).toHaveBeenCalledWith(
145 |         {
146 |           type: MessageType.INFO,
147 |           text: `Attempting to save to memory: "${fact}"`,
148 |         },
149 |         expect.any(Number),
150 |       );
151 | 
152 |       expect(result).toEqual({
153 |         type: 'tool',
154 |         toolName: 'save_memory',
155 |         toolArgs: { fact },
156 |       });
157 |     });
158 |   });
159 | 
160 |   describe('/memory refresh', () => {
161 |     let refreshCommand: SlashCommand;
162 |     let mockSetUserMemory: Mock;
163 |     let mockSetGeminiMdFileCount: Mock;
164 |     let mockSetGeminiMdFilePaths: Mock;
165 | 
166 |     beforeEach(() => {
167 |       refreshCommand = getSubCommand('refresh');
168 |       mockSetUserMemory = vi.fn();
169 |       mockSetGeminiMdFileCount = vi.fn();
170 |       mockSetGeminiMdFilePaths = vi.fn();
171 | 
172 |       const mockConfig = {
173 |         setUserMemory: mockSetUserMemory,
174 |         setGeminiMdFileCount: mockSetGeminiMdFileCount,
175 |         setGeminiMdFilePaths: mockSetGeminiMdFilePaths,
176 |         getWorkingDir: () => '/test/dir',
177 |         getDebugMode: () => false,
178 |         getFileService: () => ({}) as FileDiscoveryService,
179 |         getExtensionContextFilePaths: () => [],
180 |         shouldLoadMemoryFromIncludeDirectories: () => false,
181 |         getWorkspaceContext: () => ({
182 |           getDirectories: () => [],
183 |         }),
184 |         getFileFilteringOptions: () => ({
185 |           ignore: [],
186 |           include: [],
187 |         }),
188 |         isTrustedFolder: () => false,
189 |       };
190 | 
191 |       mockContext = createMockCommandContext({
192 |         services: {
193 |           config: mockConfig,
194 |           settings: {
195 |             merged: {
196 |               memoryDiscoveryMaxDirs: 1000,
197 |               context: {
198 |                 importFormat: 'tree',
199 |               },
200 |             },
201 |           } as LoadedSettings,
202 |         },
203 |         ui: {
204 |           setGeminiMdFileCount: vi.fn(),
205 |         },
206 |       });
207 |       mockLoadHierarchicalGeminiMemory.mockClear();
208 |     });
209 | 
210 |     it('should display success message when memory is refreshed with content', async () => {
211 |       if (!refreshCommand.action) throw new Error('Command has no action');
212 | 
213 |       const refreshResult: LoadServerHierarchicalMemoryResponse = {
214 |         memoryContent: 'new memory content',
215 |         fileCount: 2,
216 |         filePaths: ['/path/one/GEMINI.md', '/path/two/GEMINI.md'],
217 |       };
218 |       mockLoadHierarchicalGeminiMemory.mockResolvedValue(refreshResult);
219 | 
220 |       await refreshCommand.action(mockContext, '');
221 | 
222 |       expect(mockContext.ui.addItem).toHaveBeenCalledWith(
223 |         {
224 |           type: MessageType.INFO,
225 |           text: 'Refreshing memory from source files...',
226 |         },
227 |         expect.any(Number),
228 |       );
229 | 
230 |       expect(mockLoadHierarchicalGeminiMemory).toHaveBeenCalledOnce();
231 |       expect(mockSetUserMemory).toHaveBeenCalledWith(
232 |         refreshResult.memoryContent,
233 |       );
234 |       expect(mockSetGeminiMdFileCount).toHaveBeenCalledWith(
235 |         refreshResult.fileCount,
236 |       );
237 |       expect(mockSetGeminiMdFilePaths).toHaveBeenCalledWith(
238 |         refreshResult.filePaths,
239 |       );
240 |       expect(mockContext.ui.setGeminiMdFileCount).toHaveBeenCalledWith(
241 |         refreshResult.fileCount,
242 |       );
243 | 
244 |       expect(mockContext.ui.addItem).toHaveBeenCalledWith(
245 |         {
246 |           type: MessageType.INFO,
247 |           text: 'Memory refreshed successfully. Loaded 18 characters from 2 file(s).',
248 |         },
249 |         expect.any(Number),
250 |       );
251 |     });
252 | 
253 |     it('should display success message when memory is refreshed with no content', async () => {
254 |       if (!refreshCommand.action) throw new Error('Command has no action');
255 | 
256 |       const refreshResult = { memoryContent: '', fileCount: 0, filePaths: [] };
257 |       mockLoadHierarchicalGeminiMemory.mockResolvedValue(refreshResult);
258 | 
259 |       await refreshCommand.action(mockContext, '');
260 | 
261 |       expect(mockLoadHierarchicalGeminiMemory).toHaveBeenCalledOnce();
262 |       expect(mockSetUserMemory).toHaveBeenCalledWith('');
263 |       expect(mockSetGeminiMdFileCount).toHaveBeenCalledWith(0);
264 |       expect(mockSetGeminiMdFilePaths).toHaveBeenCalledWith([]);
265 | 
266 |       expect(mockContext.ui.addItem).toHaveBeenCalledWith(
267 |         {
268 |           type: MessageType.INFO,
269 |           text: 'Memory refreshed successfully. No memory content found.',
270 |         },
271 |         expect.any(Number),
272 |       );
273 |     });
274 | 
275 |     it('should display an error message if refreshing fails', async () => {
276 |       if (!refreshCommand.action) throw new Error('Command has no action');
277 | 
278 |       const error = new Error('Failed to read memory files.');
279 |       mockLoadHierarchicalGeminiMemory.mockRejectedValue(error);
280 | 
281 |       await refreshCommand.action(mockContext, '');
282 | 
283 |       expect(mockLoadHierarchicalGeminiMemory).toHaveBeenCalledOnce();
284 |       expect(mockSetUserMemory).not.toHaveBeenCalled();
285 |       expect(mockSetGeminiMdFileCount).not.toHaveBeenCalled();
286 |       expect(mockSetGeminiMdFilePaths).not.toHaveBeenCalled();
287 | 
288 |       expect(mockContext.ui.addItem).toHaveBeenCalledWith(
289 |         {
290 |           type: MessageType.ERROR,
291 |           text: `Error refreshing memory: ${error.message}`,
292 |         },
293 |         expect.any(Number),
294 |       );
295 | 
296 |       expect(getErrorMessage).toHaveBeenCalledWith(error);
297 |     });
298 | 
299 |     it('should not throw if config service is unavailable', async () => {
300 |       if (!refreshCommand.action) throw new Error('Command has no action');
301 | 
302 |       const nullConfigContext = createMockCommandContext({
303 |         services: { config: null },
304 |       });
305 | 
306 |       await expect(
307 |         refreshCommand.action(nullConfigContext, ''),
308 |       ).resolves.toBeUndefined();
309 | 
310 |       expect(nullConfigContext.ui.addItem).toHaveBeenCalledWith(
311 |         {
312 |           type: MessageType.INFO,
313 |           text: 'Refreshing memory from source files...',
314 |         },
315 |         expect.any(Number),
316 |       );
317 | 
318 |       expect(mockLoadHierarchicalGeminiMemory).not.toHaveBeenCalled();
319 |     });
320 |   });
321 | 
322 |   describe('/memory list', () => {
323 |     let listCommand: SlashCommand;
324 |     let mockGetGeminiMdfilePaths: Mock;
325 | 
326 |     beforeEach(() => {
327 |       listCommand = getSubCommand('list');
328 |       mockGetGeminiMdfilePaths = vi.fn();
329 |       mockContext = createMockCommandContext({
330 |         services: {
331 |           config: {
332 |             getGeminiMdFilePaths: mockGetGeminiMdfilePaths,
333 |           },
334 |         },
335 |       });
336 |     });
337 | 
338 |     it('should display a message if no GEMINI.md files are found', async () => {
339 |       if (!listCommand.action) throw new Error('Command has no action');
340 | 
341 |       mockGetGeminiMdfilePaths.mockReturnValue([]);
342 | 
343 |       await listCommand.action(mockContext, '');
344 | 
345 |       expect(mockContext.ui.addItem).toHaveBeenCalledWith(
346 |         {
347 |           type: MessageType.INFO,
348 |           text: 'No GEMINI.md files in use.',
349 |         },
350 |         expect.any(Number),
351 |       );
352 |     });
353 | 
354 |     it('should display the file count and paths if they exist', async () => {
355 |       if (!listCommand.action) throw new Error('Command has no action');
356 | 
357 |       const filePaths = ['/path/one/GEMINI.md', '/path/two/GEMINI.md'];
358 |       mockGetGeminiMdfilePaths.mockReturnValue(filePaths);
359 | 
360 |       await listCommand.action(mockContext, '');
361 | 
362 |       expect(mockContext.ui.addItem).toHaveBeenCalledWith(
363 |         {
364 |           type: MessageType.INFO,
365 |           text: `There are 2 GEMINI.md file(s) in use:\n\n${filePaths.join('\n')}`,
366 |         },
367 |         expect.any(Number),
368 |       );
369 |     });
370 |   });
371 | });
```

src/ui/commands/memoryCommand.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { getErrorMessage } from '@google/gemini-cli-core';
8 | import { MessageType } from '../types.js';
9 | import { loadHierarchicalGeminiMemory } from '../../config/config.js';
10 | import type { SlashCommand, SlashCommandActionReturn } from './types.js';
11 | import { CommandKind } from './types.js';
12 | 
13 | export const memoryCommand: SlashCommand = {
14 |   name: 'memory',
15 |   description: 'Commands for interacting with memory.',
16 |   kind: CommandKind.BUILT_IN,
17 |   subCommands: [
18 |     {
19 |       name: 'show',
20 |       description: 'Show the current memory contents.',
21 |       kind: CommandKind.BUILT_IN,
22 |       action: async (context) => {
23 |         const memoryContent = context.services.config?.getUserMemory() || '';
24 |         const fileCount = context.services.config?.getGeminiMdFileCount() || 0;
25 | 
26 |         const messageContent =
27 |           memoryContent.length > 0
28 |             ? `Current memory content from ${fileCount} file(s):\n\n---\n${memoryContent}\n---`
29 |             : 'Memory is currently empty.';
30 | 
31 |         context.ui.addItem(
32 |           {
33 |             type: MessageType.INFO,
34 |             text: messageContent,
35 |           },
36 |           Date.now(),
37 |         );
38 |       },
39 |     },
40 |     {
41 |       name: 'add',
42 |       description: 'Add content to the memory.',
43 |       kind: CommandKind.BUILT_IN,
44 |       action: (context, args): SlashCommandActionReturn | void => {
45 |         if (!args || args.trim() === '') {
46 |           return {
47 |             type: 'message',
48 |             messageType: 'error',
49 |             content: 'Usage: /memory add <text to remember>',
50 |           };
51 |         }
52 | 
53 |         context.ui.addItem(
54 |           {
55 |             type: MessageType.INFO,
56 |             text: `Attempting to save to memory: "${args.trim()}"`,
57 |           },
58 |           Date.now(),
59 |         );
60 | 
61 |         return {
62 |           type: 'tool',
63 |           toolName: 'save_memory',
64 |           toolArgs: { fact: args.trim() },
65 |         };
66 |       },
67 |     },
68 |     {
69 |       name: 'refresh',
70 |       description: 'Refresh the memory from the source.',
71 |       kind: CommandKind.BUILT_IN,
72 |       action: async (context) => {
73 |         context.ui.addItem(
74 |           {
75 |             type: MessageType.INFO,
76 |             text: 'Refreshing memory from source files...',
77 |           },
78 |           Date.now(),
79 |         );
80 | 
81 |         try {
82 |           const config = await context.services.config;
83 |           const settings = context.services.settings;
84 |           if (config) {
85 |             const { memoryContent, fileCount, filePaths } =
86 |               await loadHierarchicalGeminiMemory(
87 |                 config.getWorkingDir(),
88 |                 config.shouldLoadMemoryFromIncludeDirectories()
89 |                   ? config.getWorkspaceContext().getDirectories()
90 |                   : [],
91 |                 config.getDebugMode(),
92 |                 config.getFileService(),
93 |                 settings.merged,
94 |                 config.getExtensionContextFilePaths(),
95 |                 config.isTrustedFolder(),
96 |                 settings.merged.context?.importFormat || 'tree',
97 |                 config.getFileFilteringOptions(),
98 |               );
99 |             config.setUserMemory(memoryContent);
100 |             config.setGeminiMdFileCount(fileCount);
101 |             config.setGeminiMdFilePaths(filePaths);
102 |             context.ui.setGeminiMdFileCount(fileCount);
103 | 
104 |             const successMessage =
105 |               memoryContent.length > 0
106 |                 ? `Memory refreshed successfully. Loaded ${memoryContent.length} characters from ${fileCount} file(s).`
107 |                 : 'Memory refreshed successfully. No memory content found.';
108 | 
109 |             context.ui.addItem(
110 |               {
111 |                 type: MessageType.INFO,
112 |                 text: successMessage,
113 |               },
114 |               Date.now(),
115 |             );
116 |           }
117 |         } catch (error) {
118 |           const errorMessage = getErrorMessage(error);
119 |           context.ui.addItem(
120 |             {
121 |               type: MessageType.ERROR,
122 |               text: `Error refreshing memory: ${errorMessage}`,
123 |             },
124 |             Date.now(),
125 |           );
126 |         }
127 |       },
128 |     },
129 |     {
130 |       name: 'list',
131 |       description: 'Lists the paths of the GEMINI.md files in use.',
132 |       kind: CommandKind.BUILT_IN,
133 |       action: async (context) => {
134 |         const filePaths = context.services.config?.getGeminiMdFilePaths() || [];
135 |         const fileCount = filePaths.length;
136 | 
137 |         const messageContent =
138 |           fileCount > 0
139 |             ? `There are ${fileCount} GEMINI.md file(s) in use:\n\n${filePaths.join('\n')}`
140 |             : 'No GEMINI.md files in use.';
141 | 
142 |         context.ui.addItem(
143 |           {
144 |             type: MessageType.INFO,
145 |             text: messageContent,
146 |           },
147 |           Date.now(),
148 |         );
149 |       },
150 |     },
151 |   ],
152 | };
```

src/ui/commands/modelCommand.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect, beforeEach } from 'vitest';
8 | import { modelCommand } from './modelCommand.js';
9 | import { type CommandContext } from './types.js';
10 | import { createMockCommandContext } from '../../test-utils/mockCommandContext.js';
11 | 
12 | describe('modelCommand', () => {
13 |   let mockContext: CommandContext;
14 | 
15 |   beforeEach(() => {
16 |     mockContext = createMockCommandContext();
17 |   });
18 | 
19 |   it('should return a dialog action to open the model dialog', async () => {
20 |     if (!modelCommand.action) {
21 |       throw new Error('The model command must have an action.');
22 |     }
23 | 
24 |     const result = await modelCommand.action(mockContext, '');
25 | 
26 |     expect(result).toEqual({
27 |       type: 'dialog',
28 |       dialog: 'model',
29 |     });
30 |   });
31 | 
32 |   it('should have the correct name and description', () => {
33 |     expect(modelCommand.name).toBe('model');
34 |     expect(modelCommand.description).toBe(
35 |       'Opens a dialog to configure the model',
36 |     );
37 |   });
38 | });
```

src/ui/commands/modelCommand.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { CommandKind, type SlashCommand } from './types.js';
8 | 
9 | export const modelCommand: SlashCommand = {
10 |   name: 'model',
11 |   description: 'Opens a dialog to configure the model',
12 |   kind: CommandKind.BUILT_IN,
13 |   action: async () => ({
14 |     type: 'dialog',
15 |     dialog: 'model',
16 |   }),
17 | };
```

src/ui/commands/permissionsCommand.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect, beforeEach } from 'vitest';
8 | import { permissionsCommand } from './permissionsCommand.js';
9 | import { type CommandContext, CommandKind } from './types.js';
10 | import { createMockCommandContext } from '../../test-utils/mockCommandContext.js';
11 | 
12 | describe('permissionsCommand', () => {
13 |   let mockContext: CommandContext;
14 | 
15 |   beforeEach(() => {
16 |     mockContext = createMockCommandContext();
17 |   });
18 | 
19 |   it('should have the correct name and description', () => {
20 |     expect(permissionsCommand.name).toBe('permissions');
21 |     expect(permissionsCommand.description).toBe('Manage folder trust settings');
22 |   });
23 | 
24 |   it('should be a built-in command', () => {
25 |     expect(permissionsCommand.kind).toBe(CommandKind.BUILT_IN);
26 |   });
27 | 
28 |   it('should return an action to open the permissions dialog', () => {
29 |     const actionResult = permissionsCommand.action?.(mockContext, '');
30 |     expect(actionResult).toEqual({
31 |       type: 'dialog',
32 |       dialog: 'permissions',
33 |     });
34 |   });
35 | });
```

src/ui/commands/permissionsCommand.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type { OpenDialogActionReturn, SlashCommand } from './types.js';
8 | import { CommandKind } from './types.js';
9 | 
10 | export const permissionsCommand: SlashCommand = {
11 |   name: 'permissions',
12 |   description: 'Manage folder trust settings',
13 |   kind: CommandKind.BUILT_IN,
14 |   action: (): OpenDialogActionReturn => ({
15 |     type: 'dialog',
16 |     dialog: 'permissions',
17 |   }),
18 | };
```

src/ui/commands/privacyCommand.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect, beforeEach } from 'vitest';
8 | import { privacyCommand } from './privacyCommand.js';
9 | import { type CommandContext } from './types.js';
10 | import { createMockCommandContext } from '../../test-utils/mockCommandContext.js';
11 | 
12 | describe('privacyCommand', () => {
13 |   let mockContext: CommandContext;
14 | 
15 |   beforeEach(() => {
16 |     mockContext = createMockCommandContext();
17 |   });
18 | 
19 |   it('should return a dialog action to open the privacy dialog', () => {
20 |     // Ensure the command has an action to test.
21 |     if (!privacyCommand.action) {
22 |       throw new Error('The privacy command must have an action.');
23 |     }
24 | 
25 |     const result = privacyCommand.action(mockContext, '');
26 | 
27 |     // Assert that the action returns the correct object to trigger the privacy dialog.
28 |     expect(result).toEqual({
29 |       type: 'dialog',
30 |       dialog: 'privacy',
31 |     });
32 |   });
33 | 
34 |   it('should have the correct name and description', () => {
35 |     expect(privacyCommand.name).toBe('privacy');
36 |     expect(privacyCommand.description).toBe('display the privacy notice');
37 |   });
38 | });
```

src/ui/commands/privacyCommand.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type { OpenDialogActionReturn, SlashCommand } from './types.js';
8 | import { CommandKind } from './types.js';
9 | 
10 | export const privacyCommand: SlashCommand = {
11 |   name: 'privacy',
12 |   description: 'display the privacy notice',
13 |   kind: CommandKind.BUILT_IN,
14 |   action: (): OpenDialogActionReturn => ({
15 |     type: 'dialog',
16 |     dialog: 'privacy',
17 |   }),
18 | };
```

src/ui/commands/profileCommand.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { isDevelopment } from '../../utils/installationInfo.js';
8 | import { CommandKind, type SlashCommand } from './types.js';
9 | 
10 | export const profileCommand: SlashCommand | null = isDevelopment
11 |   ? {
12 |       name: 'profile',
13 |       kind: CommandKind.BUILT_IN,
14 |       description: 'Toggle the debug profile display',
15 |       action: async (context) => {
16 |         context.ui.toggleDebugProfiler();
17 |         return {
18 |           type: 'message',
19 |           messageType: 'info',
20 |           content: 'Toggled profile display.',
21 |         };
22 |       },
23 |     }
24 |   : null;
```

src/ui/commands/quitCommand.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { vi, describe, it, expect, beforeEach, afterEach } from 'vitest';
8 | import { quitCommand } from './quitCommand.js';
9 | import { createMockCommandContext } from '../../test-utils/mockCommandContext.js';
10 | import { formatDuration } from '../utils/formatters.js';
11 | 
12 | vi.mock('../utils/formatters.js');
13 | 
14 | describe('quitCommand', () => {
15 |   beforeEach(() => {
16 |     vi.useFakeTimers();
17 |     vi.setSystemTime(new Date('2025-01-01T01:00:00Z'));
18 |     vi.mocked(formatDuration).mockReturnValue('1h 0m 0s');
19 |   });
20 | 
21 |   afterEach(() => {
22 |     vi.useRealTimers();
23 |     vi.clearAllMocks();
24 |   });
25 | 
26 |   it('returns a QuitActionReturn object with the correct messages', () => {
27 |     const mockContext = createMockCommandContext({
28 |       session: {
29 |         stats: {
30 |           sessionStartTime: new Date('2025-01-01T00:00:00Z'),
31 |         },
32 |       },
33 |     });
34 | 
35 |     if (!quitCommand.action) throw new Error('Action is not defined');
36 |     const result = quitCommand.action(mockContext, 'quit');
37 | 
38 |     expect(formatDuration).toHaveBeenCalledWith(3600000); // 1 hour in ms
39 |     expect(result).toEqual({
40 |       type: 'quit',
41 |       messages: [
42 |         {
43 |           type: 'user',
44 |           text: '/quit',
45 |           id: expect.any(Number),
46 |         },
47 |         {
48 |           type: 'quit',
49 |           duration: '1h 0m 0s',
50 |           id: expect.any(Number),
51 |         },
52 |       ],
53 |     });
54 |   });
55 | });
```

src/ui/commands/quitCommand.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { formatDuration } from '../utils/formatters.js';
8 | import { CommandKind, type SlashCommand } from './types.js';
9 | 
10 | export const quitCommand: SlashCommand = {
11 |   name: 'quit',
12 |   altNames: ['exit'],
13 |   description: 'exit the cli',
14 |   kind: CommandKind.BUILT_IN,
15 |   action: (context) => {
16 |     const now = Date.now();
17 |     const { sessionStartTime } = context.session.stats;
18 |     const wallDuration = now - sessionStartTime.getTime();
19 | 
20 |     return {
21 |       type: 'quit',
22 |       messages: [
23 |         {
24 |           type: 'user',
25 |           text: `/quit`, // Keep it consistent, even if /exit was used
26 |           id: now - 1,
27 |         },
28 |         {
29 |           type: 'quit',
30 |           duration: formatDuration(wallDuration),
31 |           id: now,
32 |         },
33 |       ],
34 |     };
35 |   },
36 | };
```

src/ui/commands/restoreCommand.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { vi, describe, it, expect, beforeEach, afterEach } from 'vitest';
8 | import * as fs from 'node:fs/promises';
9 | import * as os from 'node:os';
10 | import * as path from 'node:path';
11 | import { restoreCommand } from './restoreCommand.js';
12 | import { type CommandContext } from './types.js';
13 | import { createMockCommandContext } from '../../test-utils/mockCommandContext.js';
14 | import type { Config, GitService } from '@google/gemini-cli-core';
15 | 
16 | describe('restoreCommand', () => {
17 |   let mockContext: CommandContext;
18 |   let mockConfig: Config;
19 |   let mockGitService: GitService;
20 |   let mockSetHistory: ReturnType<typeof vi.fn>;
21 |   let testRootDir: string;
22 |   let geminiTempDir: string;
23 |   let checkpointsDir: string;
24 | 
25 |   beforeEach(async () => {
26 |     testRootDir = await fs.mkdtemp(
27 |       path.join(os.tmpdir(), 'restore-command-test-'),
28 |     );
29 |     geminiTempDir = path.join(testRootDir, '.gemini');
30 |     checkpointsDir = path.join(geminiTempDir, 'checkpoints');
31 |     // The command itself creates this, but for tests it's easier to have it ready.
32 |     // Some tests might remove it to test error paths.
33 |     await fs.mkdir(checkpointsDir, { recursive: true });
34 | 
35 |     mockSetHistory = vi.fn().mockResolvedValue(undefined);
36 |     mockGitService = {
37 |       restoreProjectFromSnapshot: vi.fn().mockResolvedValue(undefined),
38 |     } as unknown as GitService;
39 | 
40 |     mockConfig = {
41 |       getCheckpointingEnabled: vi.fn().mockReturnValue(true),
42 |       storage: {
43 |         getProjectTempCheckpointsDir: vi.fn().mockReturnValue(checkpointsDir),
44 |         getProjectTempDir: vi.fn().mockReturnValue(geminiTempDir),
45 |       },
46 |       getGeminiClient: vi.fn().mockReturnValue({
47 |         setHistory: mockSetHistory,
48 |       }),
49 |     } as unknown as Config;
50 | 
51 |     mockContext = createMockCommandContext({
52 |       services: {
53 |         config: mockConfig,
54 |         git: mockGitService,
55 |       },
56 |     });
57 |   });
58 | 
59 |   afterEach(async () => {
60 |     vi.restoreAllMocks();
61 |     await fs.rm(testRootDir, { recursive: true, force: true });
62 |   });
63 | 
64 |   it('should return null if checkpointing is not enabled', () => {
65 |     vi.mocked(mockConfig.getCheckpointingEnabled).mockReturnValue(false);
66 | 
67 |     expect(restoreCommand(mockConfig)).toBeNull();
68 |   });
69 | 
70 |   it('should return the command if checkpointing is enabled', () => {
71 |     expect(restoreCommand(mockConfig)).toEqual(
72 |       expect.objectContaining({
73 |         name: 'restore',
74 |         description: expect.any(String),
75 |         action: expect.any(Function),
76 |         completion: expect.any(Function),
77 |       }),
78 |     );
79 |   });
80 | 
81 |   describe('action', () => {
82 |     it('should return an error if temp dir is not found', async () => {
83 |       vi.mocked(
84 |         mockConfig.storage.getProjectTempCheckpointsDir,
85 |       ).mockReturnValue('');
86 | 
87 |       expect(
88 |         await restoreCommand(mockConfig)?.action?.(mockContext, ''),
89 |       ).toEqual({
90 |         type: 'message',
91 |         messageType: 'error',
92 |         content: 'Could not determine the .gemini directory path.',
93 |       });
94 |     });
95 | 
96 |     it('should inform when no checkpoints are found if no args are passed', async () => {
97 |       // Remove the directory to ensure the command creates it.
98 |       await fs.rm(checkpointsDir, { recursive: true, force: true });
99 |       const command = restoreCommand(mockConfig);
100 | 
101 |       expect(await command?.action?.(mockContext, '')).toEqual({
102 |         type: 'message',
103 |         messageType: 'info',
104 |         content: 'No restorable tool calls found.',
105 |       });
106 |       // Verify the directory was created by the command.
107 |       await expect(fs.stat(checkpointsDir)).resolves.toBeDefined();
108 |     });
109 | 
110 |     it('should list available checkpoints if no args are passed', async () => {
111 |       await fs.writeFile(path.join(checkpointsDir, 'test1.json'), '{}');
112 |       await fs.writeFile(path.join(checkpointsDir, 'test2.json'), '{}');
113 |       const command = restoreCommand(mockConfig);
114 | 
115 |       expect(await command?.action?.(mockContext, '')).toEqual({
116 |         type: 'message',
117 |         messageType: 'info',
118 |         content: 'Available tool calls to restore:\n\ntest1\ntest2',
119 |       });
120 |     });
121 | 
122 |     it('should return an error if the specified file is not found', async () => {
123 |       await fs.writeFile(path.join(checkpointsDir, 'test1.json'), '{}');
124 |       const command = restoreCommand(mockConfig);
125 | 
126 |       expect(await command?.action?.(mockContext, 'test2')).toEqual({
127 |         type: 'message',
128 |         messageType: 'error',
129 |         content: 'File not found: test2.json',
130 |       });
131 |     });
132 | 
133 |     it('should handle file read errors gracefully', async () => {
134 |       const checkpointName = 'test1';
135 |       const checkpointPath = path.join(
136 |         checkpointsDir,
137 |         `${checkpointName}.json`,
138 |       );
139 |       // Create a directory instead of a file to cause a read error.
140 |       await fs.mkdir(checkpointPath);
141 |       const command = restoreCommand(mockConfig);
142 | 
143 |       expect(await command?.action?.(mockContext, checkpointName)).toEqual({
144 |         type: 'message',
145 |         messageType: 'error',
146 |         content: expect.stringContaining(
147 |           'Could not read restorable tool calls.',
148 |         ),
149 |       });
150 |     });
151 | 
152 |     it('should restore a tool call and project state', async () => {
153 |       const toolCallData = {
154 |         history: [{ type: 'user', text: 'do a thing' }],
155 |         clientHistory: [{ role: 'user', parts: [{ text: 'do a thing' }] }],
156 |         commitHash: 'abcdef123',
157 |         toolCall: { name: 'run_shell_command', args: 'ls' },
158 |       };
159 |       await fs.writeFile(
160 |         path.join(checkpointsDir, 'my-checkpoint.json'),
161 |         JSON.stringify(toolCallData),
162 |       );
163 |       const command = restoreCommand(mockConfig);
164 | 
165 |       expect(await command?.action?.(mockContext, 'my-checkpoint')).toEqual({
166 |         type: 'tool',
167 |         toolName: 'run_shell_command',
168 |         toolArgs: 'ls',
169 |       });
170 |       expect(mockContext.ui.loadHistory).toHaveBeenCalledWith(
171 |         toolCallData.history,
172 |       );
173 |       expect(mockSetHistory).toHaveBeenCalledWith(toolCallData.clientHistory);
174 |       expect(mockGitService.restoreProjectFromSnapshot).toHaveBeenCalledWith(
175 |         toolCallData.commitHash,
176 |       );
177 |       expect(mockContext.ui.addItem).toHaveBeenCalledWith(
178 |         {
179 |           type: 'info',
180 |           text: 'Restored project to the state before the tool call.',
181 |         },
182 |         expect.any(Number),
183 |       );
184 |     });
185 | 
186 |     it('should restore even if only toolCall is present', async () => {
187 |       const toolCallData = {
188 |         toolCall: { name: 'run_shell_command', args: 'ls' },
189 |       };
190 |       await fs.writeFile(
191 |         path.join(checkpointsDir, 'my-checkpoint.json'),
192 |         JSON.stringify(toolCallData),
193 |       );
194 | 
195 |       const command = restoreCommand(mockConfig);
196 | 
197 |       expect(await command?.action?.(mockContext, 'my-checkpoint')).toEqual({
198 |         type: 'tool',
199 |         toolName: 'run_shell_command',
200 |         toolArgs: 'ls',
201 |       });
202 | 
203 |       expect(mockContext.ui.loadHistory).not.toHaveBeenCalled();
204 |       expect(mockSetHistory).not.toHaveBeenCalled();
205 |       expect(mockGitService.restoreProjectFromSnapshot).not.toHaveBeenCalled();
206 |     });
207 |   });
208 | 
209 |   it('should return an error for a checkpoint file missing the toolCall property', async () => {
210 |     const checkpointName = 'missing-toolcall';
211 |     await fs.writeFile(
212 |       path.join(checkpointsDir, `${checkpointName}.json`),
213 |       JSON.stringify({ history: [] }), // An object that is valid JSON but missing the 'toolCall' property
214 |     );
215 |     const command = restoreCommand(mockConfig);
216 | 
217 |     expect(await command?.action?.(mockContext, checkpointName)).toEqual({
218 |       type: 'message',
219 |       messageType: 'error',
220 |       // A more specific error message would be ideal, but for now, we can assert the current behavior.
221 |       content: expect.stringContaining('Could not read restorable tool calls.'),
222 |     });
223 |   });
224 | 
225 |   describe('completion', () => {
226 |     it('should return an empty array if temp dir is not found', async () => {
227 |       vi.mocked(mockConfig.storage.getProjectTempDir).mockReturnValue('');
228 |       const command = restoreCommand(mockConfig);
229 | 
230 |       expect(await command?.completion?.(mockContext, '')).toEqual([]);
231 |     });
232 | 
233 |     it('should return an empty array on readdir error', async () => {
234 |       await fs.rm(checkpointsDir, { recursive: true, force: true });
235 |       const command = restoreCommand(mockConfig);
236 | 
237 |       expect(await command?.completion?.(mockContext, '')).toEqual([]);
238 |     });
239 | 
240 |     it('should return a list of checkpoint names', async () => {
241 |       await fs.writeFile(path.join(checkpointsDir, 'test1.json'), '{}');
242 |       await fs.writeFile(path.join(checkpointsDir, 'test2.json'), '{}');
243 |       await fs.writeFile(
244 |         path.join(checkpointsDir, 'not-a-checkpoint.txt'),
245 |         '{}',
246 |       );
247 |       const command = restoreCommand(mockConfig);
248 | 
249 |       expect(await command?.completion?.(mockContext, '')).toEqual([
250 |         'test1',
251 |         'test2',
252 |       ]);
253 |     });
254 |   });
255 | });
```

src/ui/commands/restoreCommand.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import * as fs from 'node:fs/promises';
8 | import path from 'node:path';
9 | import {
10 |   type CommandContext,
11 |   type SlashCommand,
12 |   type SlashCommandActionReturn,
13 |   CommandKind,
14 | } from './types.js';
15 | import type { Config } from '@google/gemini-cli-core';
16 | 
17 | async function restoreAction(
18 |   context: CommandContext,
19 |   args: string,
20 | ): Promise<void | SlashCommandActionReturn> {
21 |   const { services, ui } = context;
22 |   const { config, git: gitService } = services;
23 |   const { addItem, loadHistory } = ui;
24 | 
25 |   const checkpointDir = config?.storage.getProjectTempCheckpointsDir();
26 | 
27 |   if (!checkpointDir) {
28 |     return {
29 |       type: 'message',
30 |       messageType: 'error',
31 |       content: 'Could not determine the .gemini directory path.',
32 |     };
33 |   }
34 | 
35 |   try {
36 |     // Ensure the directory exists before trying to read it.
37 |     await fs.mkdir(checkpointDir, { recursive: true });
38 |     const files = await fs.readdir(checkpointDir);
39 |     const jsonFiles = files.filter((file) => file.endsWith('.json'));
40 | 
41 |     if (!args) {
42 |       if (jsonFiles.length === 0) {
43 |         return {
44 |           type: 'message',
45 |           messageType: 'info',
46 |           content: 'No restorable tool calls found.',
47 |         };
48 |       }
49 |       const truncatedFiles = jsonFiles.map((file) => {
50 |         const components = file.split('.');
51 |         if (components.length <= 1) {
52 |           return file;
53 |         }
54 |         components.pop();
55 |         return components.join('.');
56 |       });
57 |       const fileList = truncatedFiles.join('\n');
58 |       return {
59 |         type: 'message',
60 |         messageType: 'info',
61 |         content: `Available tool calls to restore:\n\n${fileList}`,
62 |       };
63 |     }
64 | 
65 |     const selectedFile = args.endsWith('.json') ? args : `${args}.json`;
66 | 
67 |     if (!jsonFiles.includes(selectedFile)) {
68 |       return {
69 |         type: 'message',
70 |         messageType: 'error',
71 |         content: `File not found: ${selectedFile}`,
72 |       };
73 |     }
74 | 
75 |     const filePath = path.join(checkpointDir, selectedFile);
76 |     const data = await fs.readFile(filePath, 'utf-8');
77 |     const toolCallData = JSON.parse(data);
78 | 
79 |     if (toolCallData.history) {
80 |       if (!loadHistory) {
81 |         // This should not happen
82 |         return {
83 |           type: 'message',
84 |           messageType: 'error',
85 |           content: 'loadHistory function is not available.',
86 |         };
87 |       }
88 |       loadHistory(toolCallData.history);
89 |     }
90 | 
91 |     if (toolCallData.clientHistory) {
92 |       await config?.getGeminiClient()?.setHistory(toolCallData.clientHistory);
93 |     }
94 | 
95 |     if (toolCallData.commitHash) {
96 |       await gitService?.restoreProjectFromSnapshot(toolCallData.commitHash);
97 |       addItem(
98 |         {
99 |           type: 'info',
100 |           text: 'Restored project to the state before the tool call.',
101 |         },
102 |         Date.now(),
103 |       );
104 |     }
105 | 
106 |     return {
107 |       type: 'tool',
108 |       toolName: toolCallData.toolCall.name,
109 |       toolArgs: toolCallData.toolCall.args,
110 |     };
111 |   } catch (error) {
112 |     return {
113 |       type: 'message',
114 |       messageType: 'error',
115 |       content: `Could not read restorable tool calls. This is the error: ${error}`,
116 |     };
117 |   }
118 | }
119 | 
120 | async function completion(
121 |   context: CommandContext,
122 |   _partialArg: string,
123 | ): Promise<string[]> {
124 |   const { services } = context;
125 |   const { config } = services;
126 |   const checkpointDir = config?.storage.getProjectTempCheckpointsDir();
127 |   if (!checkpointDir) {
128 |     return [];
129 |   }
130 |   try {
131 |     const files = await fs.readdir(checkpointDir);
132 |     return files
133 |       .filter((file) => file.endsWith('.json'))
134 |       .map((file) => file.replace('.json', ''));
135 |   } catch (_err) {
136 |     return [];
137 |   }
138 | }
139 | 
140 | export const restoreCommand = (config: Config | null): SlashCommand | null => {
141 |   if (!config?.getCheckpointingEnabled()) {
142 |     return null;
143 |   }
144 | 
145 |   return {
146 |     name: 'restore',
147 |     description:
148 |       'Restore a tool call. This will reset the conversation and file history to the state it was in when the tool call was suggested',
149 |     kind: CommandKind.BUILT_IN,
150 |     action: restoreAction,
151 |     completion,
152 |   };
153 | };
```

src/ui/commands/settingsCommand.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect, beforeEach } from 'vitest';
8 | import { settingsCommand } from './settingsCommand.js';
9 | import { type CommandContext } from './types.js';
10 | import { createMockCommandContext } from '../../test-utils/mockCommandContext.js';
11 | 
12 | describe('settingsCommand', () => {
13 |   let mockContext: CommandContext;
14 | 
15 |   beforeEach(() => {
16 |     mockContext = createMockCommandContext();
17 |   });
18 | 
19 |   it('should return a dialog action to open the settings dialog', () => {
20 |     if (!settingsCommand.action) {
21 |       throw new Error('The settings command must have an action.');
22 |     }
23 |     const result = settingsCommand.action(mockContext, '');
24 |     expect(result).toEqual({
25 |       type: 'dialog',
26 |       dialog: 'settings',
27 |     });
28 |   });
29 | 
30 |   it('should have the correct name and description', () => {
31 |     expect(settingsCommand.name).toBe('settings');
32 |     expect(settingsCommand.description).toBe(
33 |       'View and edit Gemini CLI settings',
34 |     );
35 |   });
36 | });
```

src/ui/commands/settingsCommand.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type { OpenDialogActionReturn, SlashCommand } from './types.js';
8 | import { CommandKind } from './types.js';
9 | 
10 | export const settingsCommand: SlashCommand = {
11 |   name: 'settings',
12 |   description: 'View and edit Gemini CLI settings',
13 |   kind: CommandKind.BUILT_IN,
14 |   action: (_context, _args): OpenDialogActionReturn => ({
15 |     type: 'dialog',
16 |     dialog: 'settings',
17 |   }),
18 | };
```

src/ui/commands/setupGithubCommand.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import os from 'node:os';
8 | import path from 'node:path';
9 | import fs from 'node:fs/promises';
10 | 
11 | import { vi, describe, expect, it, afterEach, beforeEach } from 'vitest';
12 | import * as gitUtils from '../../utils/gitUtils.js';
13 | import {
14 |   setupGithubCommand,
15 |   updateGitignore,
16 |   GITHUB_WORKFLOW_PATHS,
17 | } from './setupGithubCommand.js';
18 | import type { CommandContext, ToolActionReturn } from './types.js';
19 | import * as commandUtils from '../utils/commandUtils.js';
20 | 
21 | vi.mock('child_process');
22 | 
23 | // Mock fetch globally
24 | global.fetch = vi.fn();
25 | 
26 | vi.mock('../../utils/gitUtils.js', () => ({
27 |   isGitHubRepository: vi.fn(),
28 |   getGitRepoRoot: vi.fn(),
29 |   getLatestGitHubRelease: vi.fn(),
30 |   getGitHubRepoInfo: vi.fn(),
31 | }));
32 | 
33 | vi.mock('../utils/commandUtils.js', () => ({
34 |   getUrlOpenCommand: vi.fn(),
35 | }));
36 | 
37 | describe('setupGithubCommand', async () => {
38 |   let scratchDir = '';
39 | 
40 |   beforeEach(async () => {
41 |     vi.resetAllMocks();
42 |     scratchDir = await fs.mkdtemp(
43 |       path.join(os.tmpdir(), 'setup-github-command-'),
44 |     );
45 |   });
46 | 
47 |   afterEach(async () => {
48 |     vi.restoreAllMocks();
49 |     if (scratchDir) await fs.rm(scratchDir, { recursive: true });
50 |   });
51 | 
52 |   //TODO - https://github.com/google-gemini/gemini-cli/issues/10740
53 |   it.skip('returns a tool action to download github workflows and handles paths', async () => {
54 |     const fakeRepoOwner = 'fake';
55 |     const fakeRepoName = 'repo';
56 |     const fakeRepoRoot = scratchDir;
57 |     const fakeReleaseVersion = 'v1.2.3';
58 | 
59 |     const workflows = GITHUB_WORKFLOW_PATHS.map((p) => path.basename(p));
60 |     for (const workflow of workflows) {
61 |       vi.mocked(global.fetch).mockReturnValueOnce(
62 |         Promise.resolve(new Response(workflow)),
63 |       );
64 |     }
65 | 
66 |     vi.mocked(gitUtils.isGitHubRepository).mockReturnValueOnce(true);
67 |     vi.mocked(gitUtils.getGitRepoRoot).mockReturnValueOnce(fakeRepoRoot);
68 |     vi.mocked(gitUtils.getLatestGitHubRelease).mockResolvedValueOnce(
69 |       fakeReleaseVersion,
70 |     );
71 |     vi.mocked(gitUtils.getGitHubRepoInfo).mockReturnValue({
72 |       owner: fakeRepoOwner,
73 |       repo: fakeRepoName,
74 |     });
75 |     vi.mocked(commandUtils.getUrlOpenCommand).mockReturnValueOnce(
76 |       'fakeOpenCommand',
77 |     );
78 | 
79 |     const result = (await setupGithubCommand.action?.(
80 |       {} as CommandContext,
81 |       '',
82 |     )) as ToolActionReturn;
83 | 
84 |     const { command } = result.toolArgs;
85 | 
86 |     const expectedSubstrings = [
87 |       `set -eEuo pipefail`,
88 |       `fakeOpenCommand "https://github.com/google-github-actions/run-gemini-cli`,
89 |     ];
90 | 
91 |     for (const substring of expectedSubstrings) {
92 |       expect(command).toContain(substring);
93 |     }
94 | 
95 |     for (const workflow of workflows) {
96 |       const workflowFile = path.join(
97 |         scratchDir,
98 |         '.github',
99 |         'workflows',
100 |         workflow,
101 |       );
102 |       const contents = await fs.readFile(workflowFile, 'utf8');
103 |       expect(contents).toContain(workflow);
104 |     }
105 | 
106 |     // Verify that .gitignore was created with the expected entries
107 |     const gitignorePath = path.join(scratchDir, '.gitignore');
108 |     const gitignoreExists = await fs
109 |       .access(gitignorePath)
110 |       .then(() => true)
111 |       .catch(() => false);
112 |     expect(gitignoreExists).toBe(true);
113 | 
114 |     if (gitignoreExists) {
115 |       const gitignoreContent = await fs.readFile(gitignorePath, 'utf8');
116 |       expect(gitignoreContent).toContain('.gemini/');
117 |       expect(gitignoreContent).toContain('gha-creds-*.json');
118 |     }
119 |   });
120 | });
121 | 
122 | describe('updateGitignore', () => {
123 |   let scratchDir = '';
124 | 
125 |   beforeEach(async () => {
126 |     scratchDir = await fs.mkdtemp(path.join(os.tmpdir(), 'update-gitignore-'));
127 |   });
128 | 
129 |   afterEach(async () => {
130 |     if (scratchDir) await fs.rm(scratchDir, { recursive: true });
131 |   });
132 | 
133 |   it('creates a new .gitignore file when none exists', async () => {
134 |     await updateGitignore(scratchDir);
135 | 
136 |     const gitignorePath = path.join(scratchDir, '.gitignore');
137 |     const content = await fs.readFile(gitignorePath, 'utf8');
138 | 
139 |     expect(content).toBe('.gemini/\ngha-creds-*.json\n');
140 |   });
141 | 
142 |   it('appends entries to existing .gitignore file', async () => {
143 |     const gitignorePath = path.join(scratchDir, '.gitignore');
144 |     const existingContent = '# Existing content\nnode_modules/\n';
145 |     await fs.writeFile(gitignorePath, existingContent);
146 | 
147 |     await updateGitignore(scratchDir);
148 | 
149 |     const content = await fs.readFile(gitignorePath, 'utf8');
150 | 
151 |     expect(content).toBe(
152 |       '# Existing content\nnode_modules/\n\n.gemini/\ngha-creds-*.json\n',
153 |     );
154 |   });
155 | 
156 |   it('does not add duplicate entries', async () => {
157 |     const gitignorePath = path.join(scratchDir, '.gitignore');
158 |     const existingContent = '.gemini/\nsome-other-file\ngha-creds-*.json\n';
159 |     await fs.writeFile(gitignorePath, existingContent);
160 | 
161 |     await updateGitignore(scratchDir);
162 | 
163 |     const content = await fs.readFile(gitignorePath, 'utf8');
164 | 
165 |     expect(content).toBe(existingContent);
166 |   });
167 | 
168 |   it('adds only missing entries when some already exist', async () => {
169 |     const gitignorePath = path.join(scratchDir, '.gitignore');
170 |     const existingContent = '.gemini/\nsome-other-file\n';
171 |     await fs.writeFile(gitignorePath, existingContent);
172 | 
173 |     await updateGitignore(scratchDir);
174 | 
175 |     const content = await fs.readFile(gitignorePath, 'utf8');
176 | 
177 |     // Should add only the missing gha-creds-*.json entry
178 |     expect(content).toBe('.gemini/\nsome-other-file\n\ngha-creds-*.json\n');
179 |     expect(content).toContain('gha-creds-*.json');
180 |     // Should not duplicate .gemini/ entry
181 |     expect((content.match(/\.gemini\//g) || []).length).toBe(1);
182 |   });
183 | 
184 |   it('does not get confused by entries in comments or as substrings', async () => {
185 |     const gitignorePath = path.join(scratchDir, '.gitignore');
186 |     const existingContent = [
187 |       '# This is a comment mentioning .gemini/ folder',
188 |       'my-app.gemini/config',
189 |       '# Another comment with gha-creds-*.json pattern',
190 |       'some-other-gha-creds-file.json',
191 |       '',
192 |     ].join('\n');
193 |     await fs.writeFile(gitignorePath, existingContent);
194 | 
195 |     await updateGitignore(scratchDir);
196 | 
197 |     const content = await fs.readFile(gitignorePath, 'utf8');
198 | 
199 |     // Should add both entries since they don't actually exist as gitignore rules
200 |     expect(content).toContain('.gemini/');
201 |     expect(content).toContain('gha-creds-*.json');
202 | 
203 |     // Verify the entries were added (not just mentioned in comments)
204 |     const lines = content
205 |       .split('\n')
206 |       .map((line) => line.split('#')[0].trim())
207 |       .filter((line) => line);
208 |     expect(lines).toContain('.gemini/');
209 |     expect(lines).toContain('gha-creds-*.json');
210 |     expect(lines).toContain('my-app.gemini/config');
211 |     expect(lines).toContain('some-other-gha-creds-file.json');
212 |   });
213 | 
214 |   it('handles file system errors gracefully', async () => {
215 |     // Try to update gitignore in a non-existent directory
216 |     const nonExistentDir = path.join(scratchDir, 'non-existent');
217 | 
218 |     // This should not throw an error
219 |     await expect(updateGitignore(nonExistentDir)).resolves.toBeUndefined();
220 |   });
221 | 
222 |   it('handles permission errors gracefully', async () => {
223 |     const consoleSpy = vi.spyOn(console, 'debug').mockImplementation(() => {});
224 | 
225 |     const fsModule = await import('node:fs');
226 |     const writeFileSpy = vi
227 |       .spyOn(fsModule.promises, 'writeFile')
228 |       .mockRejectedValue(new Error('Permission denied'));
229 | 
230 |     await expect(updateGitignore(scratchDir)).resolves.toBeUndefined();
231 |     expect(consoleSpy).toHaveBeenCalledWith(
232 |       'Failed to update .gitignore:',
233 |       expect.any(Error),
234 |     );
235 | 
236 |     writeFileSpy.mockRestore();
237 |     consoleSpy.mockRestore();
238 |   });
239 | });
```

src/ui/commands/setupGithubCommand.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import path from 'node:path';
8 | import * as fs from 'node:fs';
9 | import { Writable } from 'node:stream';
10 | import { ProxyAgent } from 'undici';
11 | 
12 | import type { CommandContext } from '../../ui/commands/types.js';
13 | import {
14 |   getGitRepoRoot,
15 |   getLatestGitHubRelease,
16 |   isGitHubRepository,
17 |   getGitHubRepoInfo,
18 | } from '../../utils/gitUtils.js';
19 | 
20 | import type { SlashCommand, SlashCommandActionReturn } from './types.js';
21 | import { CommandKind } from './types.js';
22 | import { getUrlOpenCommand } from '../../ui/utils/commandUtils.js';
23 | 
24 | export const GITHUB_WORKFLOW_PATHS = [
25 |   'gemini-dispatch/gemini-dispatch.yml',
26 |   'gemini-assistant/gemini-invoke.yml',
27 |   'issue-triage/gemini-triage.yml',
28 |   'issue-triage/gemini-scheduled-triage.yml',
29 |   'pr-review/gemini-review.yml',
30 | ];
31 | 
32 | // Generate OS-specific commands to open the GitHub pages needed for setup.
33 | function getOpenUrlsCommands(readmeUrl: string): string[] {
34 |   // Determine the OS-specific command to open URLs, ex: 'open', 'xdg-open', etc
35 |   const openCmd = getUrlOpenCommand();
36 | 
37 |   // Build a list of URLs to open
38 |   const urlsToOpen = [readmeUrl];
39 | 
40 |   const repoInfo = getGitHubRepoInfo();
41 |   if (repoInfo) {
42 |     urlsToOpen.push(
43 |       `https://github.com/${repoInfo.owner}/${repoInfo.repo}/settings/secrets/actions`,
44 |     );
45 |   }
46 | 
47 |   // Create and join the individual commands
48 |   const commands = urlsToOpen.map((url) => `${openCmd} "${url}"`);
49 |   return commands;
50 | }
51 | 
52 | // Add Gemini CLI specific entries to .gitignore file
53 | export async function updateGitignore(gitRepoRoot: string): Promise<void> {
54 |   const gitignoreEntries = ['.gemini/', 'gha-creds-*.json'];
55 | 
56 |   const gitignorePath = path.join(gitRepoRoot, '.gitignore');
57 |   try {
58 |     // Check if .gitignore exists and read its content
59 |     let existingContent = '';
60 |     let fileExists = true;
61 |     try {
62 |       existingContent = await fs.promises.readFile(gitignorePath, 'utf8');
63 |     } catch (_error) {
64 |       // File doesn't exist
65 |       fileExists = false;
66 |     }
67 | 
68 |     if (!fileExists) {
69 |       // Create new .gitignore file with the entries
70 |       const contentToWrite = gitignoreEntries.join('\n') + '\n';
71 |       await fs.promises.writeFile(gitignorePath, contentToWrite);
72 |     } else {
73 |       // Check which entries are missing
74 |       const missingEntries = gitignoreEntries.filter(
75 |         (entry) =>
76 |           !existingContent
77 |             .split(/\r?\n/)
78 |             .some((line) => line.split('#')[0].trim() === entry),
79 |       );
80 | 
81 |       if (missingEntries.length > 0) {
82 |         const contentToAdd = '\n' + missingEntries.join('\n') + '\n';
83 |         await fs.promises.appendFile(gitignorePath, contentToAdd);
84 |       }
85 |     }
86 |   } catch (error) {
87 |     console.debug('Failed to update .gitignore:', error);
88 |     // Continue without failing the whole command
89 |   }
90 | }
91 | 
92 | export const setupGithubCommand: SlashCommand = {
93 |   name: 'setup-github',
94 |   description: 'Set up GitHub Actions',
95 |   kind: CommandKind.BUILT_IN,
96 |   action: async (
97 |     context: CommandContext,
98 |   ): Promise<SlashCommandActionReturn> => {
99 |     const abortController = new AbortController();
100 | 
101 |     if (!isGitHubRepository()) {
102 |       throw new Error(
103 |         'Unable to determine the GitHub repository. /setup-github must be run from a git repository.',
104 |       );
105 |     }
106 | 
107 |     // Find the root directory of the repo
108 |     let gitRepoRoot: string;
109 |     try {
110 |       gitRepoRoot = getGitRepoRoot();
111 |     } catch (_error) {
112 |       console.debug(`Failed to get git repo root:`, _error);
113 |       throw new Error(
114 |         'Unable to determine the GitHub repository. /setup-github must be run from a git repository.',
115 |       );
116 |     }
117 | 
118 |     // Get the latest release tag from GitHub
119 |     const proxy = context?.services?.config?.getProxy();
120 |     const releaseTag = await getLatestGitHubRelease(proxy);
121 |     const readmeUrl = `https://github.com/google-github-actions/run-gemini-cli/blob/${releaseTag}/README.md#quick-start`;
122 | 
123 |     // Create the .github/workflows directory to download the files into
124 |     const githubWorkflowsDir = path.join(gitRepoRoot, '.github', 'workflows');
125 |     try {
126 |       await fs.promises.mkdir(githubWorkflowsDir, { recursive: true });
127 |     } catch (_error) {
128 |       console.debug(
129 |         `Failed to create ${githubWorkflowsDir} directory:`,
130 |         _error,
131 |       );
132 |       throw new Error(
133 |         `Unable to create ${githubWorkflowsDir} directory. Do you have file permissions in the current directory?`,
134 |       );
135 |     }
136 | 
137 |     // Download each workflow in parallel - there aren't enough files to warrant
138 |     // a full workerpool model here.
139 |     const downloads = [];
140 |     for (const workflow of GITHUB_WORKFLOW_PATHS) {
141 |       downloads.push(
142 |         (async () => {
143 |           const endpoint = `https://raw.githubusercontent.com/google-github-actions/run-gemini-cli/refs/tags/${releaseTag}/examples/workflows/${workflow}`;
144 |           const response = await fetch(endpoint, {
145 |             method: 'GET',
146 |             dispatcher: proxy ? new ProxyAgent(proxy) : undefined,
147 |             signal: AbortSignal.any([
148 |               AbortSignal.timeout(30_000),
149 |               abortController.signal,
150 |             ]),
151 |           } as RequestInit);
152 | 
153 |           if (!response.ok) {
154 |             throw new Error(
155 |               `Invalid response code downloading ${endpoint}: ${response.status} - ${response.statusText}`,
156 |             );
157 |           }
158 |           const body = response.body;
159 |           if (!body) {
160 |             throw new Error(
161 |               `Empty body while downloading ${endpoint}: ${response.status} - ${response.statusText}`,
162 |             );
163 |           }
164 | 
165 |           const destination = path.resolve(
166 |             githubWorkflowsDir,
167 |             path.basename(workflow),
168 |           );
169 | 
170 |           const fileStream = fs.createWriteStream(destination, {
171 |             mode: 0o644, // -rw-r--r--, user(rw), group(r), other(r)
172 |             flags: 'w', // write and overwrite
173 |             flush: true,
174 |           });
175 | 
176 |           await body.pipeTo(Writable.toWeb(fileStream));
177 |         })(),
178 |       );
179 |     }
180 | 
181 |     // Wait for all downloads to complete
182 |     await Promise.all(downloads).finally(() => {
183 |       // Stop existing downloads
184 |       abortController.abort();
185 |     });
186 | 
187 |     // Add entries to .gitignore file
188 |     await updateGitignore(gitRepoRoot);
189 | 
190 |     // Print out a message
191 |     const commands = [];
192 |     commands.push('set -eEuo pipefail');
193 |     commands.push(
194 |       `echo "Successfully downloaded ${GITHUB_WORKFLOW_PATHS.length} workflows and updated .gitignore. Follow the steps in ${readmeUrl} (skipping the /setup-github step) to complete setup."`,
195 |     );
196 |     commands.push(...getOpenUrlsCommands(readmeUrl));
197 | 
198 |     const command = `(${commands.join(' && ')})`;
199 |     return {
200 |       type: 'tool',
201 |       toolName: 'run_shell_command',
202 |       toolArgs: {
203 |         description:
204 |           'Setting up GitHub Actions to triage issues and review PRs with Gemini.',
205 |         command,
206 |       },
207 |     };
208 |   },
209 | };
```

src/ui/commands/statsCommand.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { vi, describe, it, expect, beforeEach } from 'vitest';
8 | import { statsCommand } from './statsCommand.js';
9 | import { type CommandContext } from './types.js';
10 | import { createMockCommandContext } from '../../test-utils/mockCommandContext.js';
11 | import { MessageType } from '../types.js';
12 | import { formatDuration } from '../utils/formatters.js';
13 | 
14 | describe('statsCommand', () => {
15 |   let mockContext: CommandContext;
16 |   const startTime = new Date('2025-07-14T10:00:00.000Z');
17 |   const endTime = new Date('2025-07-14T10:00:30.000Z');
18 | 
19 |   beforeEach(() => {
20 |     vi.useFakeTimers();
21 |     vi.setSystemTime(endTime);
22 | 
23 |     // 1. Create the mock context with all default values
24 |     mockContext = createMockCommandContext();
25 | 
26 |     // 2. Directly set the property on the created mock context
27 |     mockContext.session.stats.sessionStartTime = startTime;
28 |   });
29 | 
30 |   it('should display general session stats when run with no subcommand', () => {
31 |     if (!statsCommand.action) throw new Error('Command has no action');
32 | 
33 |     statsCommand.action(mockContext, '');
34 | 
35 |     const expectedDuration = formatDuration(
36 |       endTime.getTime() - startTime.getTime(),
37 |     );
38 |     expect(mockContext.ui.addItem).toHaveBeenCalledWith(
39 |       {
40 |         type: MessageType.STATS,
41 |         duration: expectedDuration,
42 |       },
43 |       expect.any(Number),
44 |     );
45 |   });
46 | 
47 |   it('should display model stats when using the "model" subcommand', () => {
48 |     const modelSubCommand = statsCommand.subCommands?.find(
49 |       (sc) => sc.name === 'model',
50 |     );
51 |     if (!modelSubCommand?.action) throw new Error('Subcommand has no action');
52 | 
53 |     modelSubCommand.action(mockContext, '');
54 | 
55 |     expect(mockContext.ui.addItem).toHaveBeenCalledWith(
56 |       {
57 |         type: MessageType.MODEL_STATS,
58 |       },
59 |       expect.any(Number),
60 |     );
61 |   });
62 | 
63 |   it('should display tool stats when using the "tools" subcommand', () => {
64 |     const toolsSubCommand = statsCommand.subCommands?.find(
65 |       (sc) => sc.name === 'tools',
66 |     );
67 |     if (!toolsSubCommand?.action) throw new Error('Subcommand has no action');
68 | 
69 |     toolsSubCommand.action(mockContext, '');
70 | 
71 |     expect(mockContext.ui.addItem).toHaveBeenCalledWith(
72 |       {
73 |         type: MessageType.TOOL_STATS,
74 |       },
75 |       expect.any(Number),
76 |     );
77 |   });
78 | });
```

src/ui/commands/statsCommand.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type { HistoryItemStats } from '../types.js';
8 | import { MessageType } from '../types.js';
9 | import { formatDuration } from '../utils/formatters.js';
10 | import {
11 |   type CommandContext,
12 |   type SlashCommand,
13 |   CommandKind,
14 | } from './types.js';
15 | 
16 | export const statsCommand: SlashCommand = {
17 |   name: 'stats',
18 |   altNames: ['usage'],
19 |   description: 'check session stats. Usage: /stats [model|tools]',
20 |   kind: CommandKind.BUILT_IN,
21 |   action: (context: CommandContext) => {
22 |     const now = new Date();
23 |     const { sessionStartTime } = context.session.stats;
24 |     if (!sessionStartTime) {
25 |       context.ui.addItem(
26 |         {
27 |           type: MessageType.ERROR,
28 |           text: 'Session start time is unavailable, cannot calculate stats.',
29 |         },
30 |         Date.now(),
31 |       );
32 |       return;
33 |     }
34 |     const wallDuration = now.getTime() - sessionStartTime.getTime();
35 | 
36 |     const statsItem: HistoryItemStats = {
37 |       type: MessageType.STATS,
38 |       duration: formatDuration(wallDuration),
39 |     };
40 | 
41 |     context.ui.addItem(statsItem, Date.now());
42 |   },
43 |   subCommands: [
44 |     {
45 |       name: 'model',
46 |       description: 'Show model-specific usage statistics.',
47 |       kind: CommandKind.BUILT_IN,
48 |       action: (context: CommandContext) => {
49 |         context.ui.addItem(
50 |           {
51 |             type: MessageType.MODEL_STATS,
52 |           },
53 |           Date.now(),
54 |         );
55 |       },
56 |     },
57 |     {
58 |       name: 'tools',
59 |       description: 'Show tool-specific usage statistics.',
60 |       kind: CommandKind.BUILT_IN,
61 |       action: (context: CommandContext) => {
62 |         context.ui.addItem(
63 |           {
64 |             type: MessageType.TOOL_STATS,
65 |           },
66 |           Date.now(),
67 |         );
68 |       },
69 |     },
70 |   ],
71 | };
```

src/ui/commands/terminalSetupCommand.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect, vi, beforeEach } from 'vitest';
8 | import { terminalSetupCommand } from './terminalSetupCommand.js';
9 | import * as terminalSetupModule from '../utils/terminalSetup.js';
10 | import type { CommandContext } from './types.js';
11 | 
12 | vi.mock('../utils/terminalSetup.js');
13 | 
14 | describe('terminalSetupCommand', () => {
15 |   beforeEach(() => {
16 |     vi.clearAllMocks();
17 |   });
18 | 
19 |   it('should have correct metadata', () => {
20 |     expect(terminalSetupCommand.name).toBe('terminal-setup');
21 |     expect(terminalSetupCommand.description).toContain('multiline input');
22 |     expect(terminalSetupCommand.kind).toBe('built-in');
23 |   });
24 | 
25 |   it('should return success message when terminal setup succeeds', async () => {
26 |     vi.spyOn(terminalSetupModule, 'terminalSetup').mockResolvedValue({
27 |       success: true,
28 |       message: 'Terminal configured successfully',
29 |     });
30 | 
31 |     const result = await terminalSetupCommand.action({} as CommandContext, '');
32 | 
33 |     expect(result).toEqual({
34 |       type: 'message',
35 |       content: 'Terminal configured successfully',
36 |       messageType: 'info',
37 |     });
38 |   });
39 | 
40 |   it('should append restart message when terminal setup requires restart', async () => {
41 |     vi.spyOn(terminalSetupModule, 'terminalSetup').mockResolvedValue({
42 |       success: true,
43 |       message: 'Terminal configured successfully',
44 |       requiresRestart: true,
45 |     });
46 | 
47 |     const result = await terminalSetupCommand.action({} as CommandContext, '');
48 | 
49 |     expect(result).toEqual({
50 |       type: 'message',
51 |       content:
52 |         'Terminal configured successfully\n\nPlease restart your terminal for the changes to take effect.',
53 |       messageType: 'info',
54 |     });
55 |   });
56 | 
57 |   it('should return error message when terminal setup fails', async () => {
58 |     vi.spyOn(terminalSetupModule, 'terminalSetup').mockResolvedValue({
59 |       success: false,
60 |       message: 'Failed to detect terminal',
61 |     });
62 | 
63 |     const result = await terminalSetupCommand.action({} as CommandContext, '');
64 | 
65 |     expect(result).toEqual({
66 |       type: 'message',
67 |       content: 'Failed to detect terminal',
68 |       messageType: 'error',
69 |     });
70 |   });
71 | 
72 |   it('should handle exceptions from terminal setup', async () => {
73 |     vi.spyOn(terminalSetupModule, 'terminalSetup').mockRejectedValue(
74 |       new Error('Unexpected error'),
75 |     );
76 | 
77 |     const result = await terminalSetupCommand.action({} as CommandContext, '');
78 | 
79 |     expect(result).toEqual({
80 |       type: 'message',
81 |       content: 'Failed to configure terminal: Error: Unexpected error',
82 |       messageType: 'error',
83 |     });
84 |   });
85 | });
```

src/ui/commands/terminalSetupCommand.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type { MessageActionReturn, SlashCommand } from './types.js';
8 | import { CommandKind } from './types.js';
9 | import { terminalSetup } from '../utils/terminalSetup.js';
10 | 
11 | /**
12 |  * Command to configure terminal keybindings for multiline input support.
13 |  *
14 |  * This command automatically detects and configures VS Code, Cursor, and Windsurf
15 |  * to support Shift+Enter and Ctrl+Enter for multiline input.
16 |  */
17 | export const terminalSetupCommand: SlashCommand = {
18 |   name: 'terminal-setup',
19 |   description:
20 |     'Configure terminal keybindings for multiline input (VS Code, Cursor, Windsurf)',
21 |   kind: CommandKind.BUILT_IN,
22 | 
23 |   action: async (): Promise<MessageActionReturn> => {
24 |     try {
25 |       const result = await terminalSetup();
26 | 
27 |       let content = result.message;
28 |       if (result.requiresRestart) {
29 |         content +=
30 |           '\n\nPlease restart your terminal for the changes to take effect.';
31 |       }
32 | 
33 |       return {
34 |         type: 'message',
35 |         content,
36 |         messageType: result.success ? 'info' : 'error',
37 |       };
38 |     } catch (error) {
39 |       return {
40 |         type: 'message',
41 |         content: `Failed to configure terminal: ${error}`,
42 |         messageType: 'error',
43 |       };
44 |     }
45 |   },
46 | };
```

src/ui/commands/themeCommand.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect, beforeEach } from 'vitest';
8 | import { themeCommand } from './themeCommand.js';
9 | import { type CommandContext } from './types.js';
10 | import { createMockCommandContext } from '../../test-utils/mockCommandContext.js';
11 | 
12 | describe('themeCommand', () => {
13 |   let mockContext: CommandContext;
14 | 
15 |   beforeEach(() => {
16 |     mockContext = createMockCommandContext();
17 |   });
18 | 
19 |   it('should return a dialog action to open the theme dialog', () => {
20 |     // Ensure the command has an action to test.
21 |     if (!themeCommand.action) {
22 |       throw new Error('The theme command must have an action.');
23 |     }
24 | 
25 |     const result = themeCommand.action(mockContext, '');
26 | 
27 |     // Assert that the action returns the correct object to trigger the theme dialog.
28 |     expect(result).toEqual({
29 |       type: 'dialog',
30 |       dialog: 'theme',
31 |     });
32 |   });
33 | 
34 |   it('should have the correct name and description', () => {
35 |     expect(themeCommand.name).toBe('theme');
36 |     expect(themeCommand.description).toBe('change the theme');
37 |   });
38 | });
```

src/ui/commands/themeCommand.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type { OpenDialogActionReturn, SlashCommand } from './types.js';
8 | import { CommandKind } from './types.js';
9 | 
10 | export const themeCommand: SlashCommand = {
11 |   name: 'theme',
12 |   description: 'change the theme',
13 |   kind: CommandKind.BUILT_IN,
14 |   action: (_context, _args): OpenDialogActionReturn => ({
15 |     type: 'dialog',
16 |     dialog: 'theme',
17 |   }),
18 | };
```

src/ui/commands/toolsCommand.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type { vi } from 'vitest';
8 | import { describe, it, expect } from 'vitest';
9 | import { toolsCommand } from './toolsCommand.js';
10 | import { createMockCommandContext } from '../../test-utils/mockCommandContext.js';
11 | import { MessageType } from '../types.js';
12 | import type { Tool } from '@google/gemini-cli-core';
13 | 
14 | // Mock tools for testing
15 | const mockTools = [
16 |   {
17 |     name: 'file-reader',
18 |     displayName: 'File Reader',
19 |     description: 'Reads files from the local system.',
20 |     schema: {},
21 |   },
22 |   {
23 |     name: 'code-editor',
24 |     displayName: 'Code Editor',
25 |     description: 'Edits code files.',
26 |     schema: {},
27 |   },
28 | ] as Tool[];
29 | 
30 | describe('toolsCommand', () => {
31 |   it('should display an error if the tool registry is unavailable', async () => {
32 |     const mockContext = createMockCommandContext({
33 |       services: {
34 |         config: {
35 |           getToolRegistry: () => undefined,
36 |         },
37 |       },
38 |     });
39 | 
40 |     if (!toolsCommand.action) throw new Error('Action not defined');
41 |     await toolsCommand.action(mockContext, '');
42 | 
43 |     expect(mockContext.ui.addItem).toHaveBeenCalledWith(
44 |       {
45 |         type: MessageType.ERROR,
46 |         text: 'Could not retrieve tool registry.',
47 |       },
48 |       expect.any(Number),
49 |     );
50 |   });
51 | 
52 |   it('should display "No tools available" when none are found', async () => {
53 |     const mockContext = createMockCommandContext({
54 |       services: {
55 |         config: {
56 |           getToolRegistry: () => ({ getAllTools: () => [] as Tool[] }),
57 |         },
58 |       },
59 |     });
60 | 
61 |     if (!toolsCommand.action) throw new Error('Action not defined');
62 |     await toolsCommand.action(mockContext, '');
63 | 
64 |     expect(mockContext.ui.addItem).toHaveBeenCalledWith(
65 |       {
66 |         type: MessageType.TOOLS_LIST,
67 |         tools: [],
68 |         showDescriptions: false,
69 |       },
70 |       expect.any(Number),
71 |     );
72 |   });
73 | 
74 |   it('should list tools without descriptions by default', async () => {
75 |     const mockContext = createMockCommandContext({
76 |       services: {
77 |         config: {
78 |           getToolRegistry: () => ({ getAllTools: () => mockTools }),
79 |         },
80 |       },
81 |     });
82 | 
83 |     if (!toolsCommand.action) throw new Error('Action not defined');
84 |     await toolsCommand.action(mockContext, '');
85 | 
86 |     const [message] = (mockContext.ui.addItem as vi.Mock).mock.calls[0];
87 |     expect(message.type).toBe(MessageType.TOOLS_LIST);
88 |     expect(message.showDescriptions).toBe(false);
89 |     expect(message.tools).toHaveLength(2);
90 |     expect(message.tools[0].displayName).toBe('File Reader');
91 |     expect(message.tools[1].displayName).toBe('Code Editor');
92 |   });
93 | 
94 |   it('should list tools with descriptions when "desc" arg is passed', async () => {
95 |     const mockContext = createMockCommandContext({
96 |       services: {
97 |         config: {
98 |           getToolRegistry: () => ({ getAllTools: () => mockTools }),
99 |         },
100 |       },
101 |     });
102 | 
103 |     if (!toolsCommand.action) throw new Error('Action not defined');
104 |     await toolsCommand.action(mockContext, 'desc');
105 | 
106 |     const [message] = (mockContext.ui.addItem as vi.Mock).mock.calls[0];
107 |     expect(message.type).toBe(MessageType.TOOLS_LIST);
108 |     expect(message.showDescriptions).toBe(true);
109 |     expect(message.tools).toHaveLength(2);
110 |     expect(message.tools[0].description).toBe(
111 |       'Reads files from the local system.',
112 |     );
113 |     expect(message.tools[1].description).toBe('Edits code files.');
114 |   });
115 | });
```

src/ui/commands/toolsCommand.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import {
8 |   type CommandContext,
9 |   type SlashCommand,
10 |   CommandKind,
11 | } from './types.js';
12 | import { MessageType, type HistoryItemToolsList } from '../types.js';
13 | 
14 | export const toolsCommand: SlashCommand = {
15 |   name: 'tools',
16 |   description: 'list available Gemini CLI tools. Usage: /tools [desc]',
17 |   kind: CommandKind.BUILT_IN,
18 |   action: async (context: CommandContext, args?: string): Promise<void> => {
19 |     const subCommand = args?.trim();
20 | 
21 |     // Default to NOT showing descriptions. The user must opt in with an argument.
22 |     let useShowDescriptions = false;
23 |     if (subCommand === 'desc' || subCommand === 'descriptions') {
24 |       useShowDescriptions = true;
25 |     }
26 | 
27 |     const toolRegistry = context.services.config?.getToolRegistry();
28 |     if (!toolRegistry) {
29 |       context.ui.addItem(
30 |         {
31 |           type: MessageType.ERROR,
32 |           text: 'Could not retrieve tool registry.',
33 |         },
34 |         Date.now(),
35 |       );
36 |       return;
37 |     }
38 | 
39 |     const tools = toolRegistry.getAllTools();
40 |     // Filter out MCP tools by checking for the absence of a serverName property
41 |     const geminiTools = tools.filter((tool) => !('serverName' in tool));
42 | 
43 |     const toolsListItem: HistoryItemToolsList = {
44 |       type: MessageType.TOOLS_LIST,
45 |       tools: geminiTools.map((tool) => ({
46 |         name: tool.name,
47 |         displayName: tool.displayName,
48 |         description: tool.description,
49 |       })),
50 |       showDescriptions: useShowDescriptions,
51 |     };
52 | 
53 |     context.ui.addItem(toolsListItem, Date.now());
54 |   },
55 | };
```

src/ui/commands/types.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type { ReactNode } from 'react';
8 | import type { Content, PartListUnion } from '@google/genai';
9 | import type {
10 |   HistoryItemWithoutId,
11 |   HistoryItem,
12 |   ConfirmationRequest,
13 | } from '../types.js';
14 | import type { Config, GitService, Logger } from '@google/gemini-cli-core';
15 | import type { LoadedSettings } from '../../config/settings.js';
16 | import type { UseHistoryManagerReturn } from '../hooks/useHistoryManager.js';
17 | import type { SessionStatsState } from '../contexts/SessionContext.js';
18 | import type {
19 |   ExtensionUpdateAction,
20 |   ExtensionUpdateStatus,
21 | } from '../state/extensions.js';
22 | 
23 | // Grouped dependencies for clarity and easier mocking
24 | export interface CommandContext {
25 |   // Invocation properties for when commands are called.
26 |   invocation?: {
27 |     /** The raw, untrimmed input string from the user. */
28 |     raw: string;
29 |     /** The primary name of the command that was matched. */
30 |     name: string;
31 |     /** The arguments string that follows the command name. */
32 |     args: string;
33 |   };
34 |   // Core services and configuration
35 |   services: {
36 |     // TODO(abhipatel12): Ensure that config is never null.
37 |     config: Config | null;
38 |     settings: LoadedSettings;
39 |     git: GitService | undefined;
40 |     logger: Logger;
41 |   };
42 |   // UI state and history management
43 |   ui: {
44 |     /** Adds a new item to the history display. */
45 |     addItem: UseHistoryManagerReturn['addItem'];
46 |     /** Clears all history items and the console screen. */
47 |     clear: () => void;
48 |     /**
49 |      * Sets the transient debug message displayed in the application footer in debug mode.
50 |      */
51 |     setDebugMessage: (message: string) => void;
52 |     /** The currently pending history item, if any. */
53 |     pendingItem: HistoryItemWithoutId | null;
54 |     /**
55 |      * Sets a pending item in the history, which is useful for indicating
56 |      * that a long-running operation is in progress.
57 |      *
58 |      * @param item The history item to display as pending, or `null` to clear.
59 |      */
60 |     setPendingItem: (item: HistoryItemWithoutId | null) => void;
61 |     /**
62 |      * Loads a new set of history items, replacing the current history.
63 |      *
64 |      * @param history The array of history items to load.
65 |      */
66 |     loadHistory: UseHistoryManagerReturn['loadHistory'];
67 |     /** Toggles a special display mode. */
68 |     toggleCorgiMode: () => void;
69 |     toggleDebugProfiler: () => void;
70 |     toggleVimEnabled: () => Promise<boolean>;
71 |     setGeminiMdFileCount: (count: number) => void;
72 |     reloadCommands: () => void;
73 |     extensionsUpdateState: Map<string, ExtensionUpdateStatus>;
74 |     dispatchExtensionStateUpdate: (action: ExtensionUpdateAction) => void;
75 |     addConfirmUpdateExtensionRequest: (value: ConfirmationRequest) => void;
76 |   };
77 |   // Session-specific data
78 |   session: {
79 |     stats: SessionStatsState;
80 |     /** A transient list of shell commands the user has approved for this session. */
81 |     sessionShellAllowlist: Set<string>;
82 |   };
83 |   // Flag to indicate if an overwrite has been confirmed
84 |   overwriteConfirmed?: boolean;
85 | }
86 | 
87 | /**
88 |  * The return type for a command action that results in scheduling a tool call.
89 |  */
90 | export interface ToolActionReturn {
91 |   type: 'tool';
92 |   toolName: string;
93 |   toolArgs: Record<string, unknown>;
94 | }
95 | 
96 | /** The return type for a command action that results in the app quitting. */
97 | export interface QuitActionReturn {
98 |   type: 'quit';
99 |   messages: HistoryItem[];
100 | }
101 | 
102 | /**
103 |  * The return type for a command action that results in a simple message
104 |  * being displayed to the user.
105 |  */
106 | export interface MessageActionReturn {
107 |   type: 'message';
108 |   messageType: 'info' | 'error';
109 |   content: string;
110 | }
111 | 
112 | /**
113 |  * The return type for a command action that needs to open a dialog.
114 |  */
115 | export interface OpenDialogActionReturn {
116 |   type: 'dialog';
117 | 
118 |   dialog:
119 |     | 'help'
120 |     | 'auth'
121 |     | 'theme'
122 |     | 'editor'
123 |     | 'privacy'
124 |     | 'settings'
125 |     | 'model'
126 |     | 'permissions';
127 | }
128 | 
129 | /**
130 |  * The return type for a command action that results in replacing
131 |  * the entire conversation history.
132 |  */
133 | export interface LoadHistoryActionReturn {
134 |   type: 'load_history';
135 |   history: HistoryItemWithoutId[];
136 |   clientHistory: Content[]; // The history for the generative client
137 | }
138 | 
139 | /**
140 |  * The return type for a command action that should immediately submit
141 |  * content as a prompt to the Gemini model.
142 |  */
143 | export interface SubmitPromptActionReturn {
144 |   type: 'submit_prompt';
145 |   content: PartListUnion;
146 | }
147 | 
148 | /**
149 |  * The return type for a command action that needs to pause and request
150 |  * confirmation for a set of shell commands before proceeding.
151 |  */
152 | export interface ConfirmShellCommandsActionReturn {
153 |   type: 'confirm_shell_commands';
154 |   /** The list of shell commands that require user confirmation. */
155 |   commandsToConfirm: string[];
156 |   /** The original invocation context to be re-run after confirmation. */
157 |   originalInvocation: {
158 |     raw: string;
159 |   };
160 | }
161 | 
162 | export interface ConfirmActionReturn {
163 |   type: 'confirm_action';
164 |   /** The React node to display as the confirmation prompt. */
165 |   prompt: ReactNode;
166 |   /** The original invocation context to be re-run after confirmation. */
167 |   originalInvocation: {
168 |     raw: string;
169 |   };
170 | }
171 | 
172 | export type SlashCommandActionReturn =
173 |   | ToolActionReturn
174 |   | MessageActionReturn
175 |   | QuitActionReturn
176 |   | OpenDialogActionReturn
177 |   | LoadHistoryActionReturn
178 |   | SubmitPromptActionReturn
179 |   | ConfirmShellCommandsActionReturn
180 |   | ConfirmActionReturn;
181 | 
182 | export enum CommandKind {
183 |   BUILT_IN = 'built-in',
184 |   FILE = 'file',
185 |   MCP_PROMPT = 'mcp-prompt',
186 | }
187 | 
188 | // The standardized contract for any command in the system.
189 | export interface SlashCommand {
190 |   name: string;
191 |   altNames?: string[];
192 |   description: string;
193 |   hidden?: boolean;
194 | 
195 |   kind: CommandKind;
196 | 
197 |   // Optional metadata for extension commands
198 |   extensionName?: string;
199 | 
200 |   // The action to run. Optional for parent commands that only group sub-commands.
201 |   action?: (
202 |     context: CommandContext,
203 |     args: string, // TODO: Remove args. CommandContext now contains the complete invocation.
204 |   ) =>
205 |     | void
206 |     | SlashCommandActionReturn
207 |     | Promise<void | SlashCommandActionReturn>;
208 | 
209 |   // Provides argument completion (e.g., completing a tag for `/chat resume <tag>`).
210 |   completion?: (
211 |     context: CommandContext,
212 |     partialArg: string,
213 |   ) => Promise<string[]>;
214 | 
215 |   subCommands?: SlashCommand[];
216 | }
```

src/ui/commands/vimCommand.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type { SlashCommand } from './types.js';
8 | import { CommandKind } from './types.js';
9 | 
10 | export const vimCommand: SlashCommand = {
11 |   name: 'vim',
12 |   description: 'toggle vim mode on/off',
13 |   kind: CommandKind.BUILT_IN,
14 |   action: async (context, _args) => {
15 |     const newVimState = await context.ui.toggleVimEnabled();
16 | 
17 |     const message = newVimState
18 |       ? 'Entered Vim mode. Run /vim again to exit.'
19 |       : 'Exited Vim mode.';
20 |     return {
21 |       type: 'message',
22 |       messageType: 'info',
23 |       content: message,
24 |     };
25 |   },
26 | };
```

src/ui/components/AboutBox.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type React from 'react';
8 | import { Box, Text } from 'ink';
9 | import { theme } from '../semantic-colors.js';
10 | import { GIT_COMMIT_INFO } from '../../generated/git-commit.js';
11 | 
12 | interface AboutBoxProps {
13 |   cliVersion: string;
14 |   osVersion: string;
15 |   sandboxEnv: string;
16 |   modelVersion: string;
17 |   selectedAuthType: string;
18 |   gcpProject: string;
19 |   ideClient: string;
20 | }
21 | 
22 | export const AboutBox: React.FC<AboutBoxProps> = ({
23 |   cliVersion,
24 |   osVersion,
25 |   sandboxEnv,
26 |   modelVersion,
27 |   selectedAuthType,
28 |   gcpProject,
29 |   ideClient,
30 | }) => (
31 |   <Box
32 |     borderStyle="round"
33 |     borderColor={theme.border.default}
34 |     flexDirection="column"
35 |     padding={1}
36 |     marginY={1}
37 |     width="100%"
38 |   >
39 |     <Box marginBottom={1}>
40 |       <Text bold color={theme.text.accent}>
41 |         About Gemini CLI
42 |       </Text>
43 |     </Box>
44 |     <Box flexDirection="row">
45 |       <Box width="35%">
46 |         <Text bold color={theme.text.link}>
47 |           CLI Version
48 |         </Text>
49 |       </Box>
50 |       <Box>
51 |         <Text color={theme.text.primary}>{cliVersion}</Text>
52 |       </Box>
53 |     </Box>
54 |     {GIT_COMMIT_INFO && !['N/A'].includes(GIT_COMMIT_INFO) && (
55 |       <Box flexDirection="row">
56 |         <Box width="35%">
57 |           <Text bold color={theme.text.link}>
58 |             Git Commit
59 |           </Text>
60 |         </Box>
61 |         <Box>
62 |           <Text color={theme.text.primary}>{GIT_COMMIT_INFO}</Text>
63 |         </Box>
64 |       </Box>
65 |     )}
66 |     <Box flexDirection="row">
67 |       <Box width="35%">
68 |         <Text bold color={theme.text.link}>
69 |           Model
70 |         </Text>
71 |       </Box>
72 |       <Box>
73 |         <Text color={theme.text.primary}>{modelVersion}</Text>
74 |       </Box>
75 |     </Box>
76 |     <Box flexDirection="row">
77 |       <Box width="35%">
78 |         <Text bold color={theme.text.link}>
79 |           Sandbox
80 |         </Text>
81 |       </Box>
82 |       <Box>
83 |         <Text color={theme.text.primary}>{sandboxEnv}</Text>
84 |       </Box>
85 |     </Box>
86 |     <Box flexDirection="row">
87 |       <Box width="35%">
88 |         <Text bold color={theme.text.link}>
89 |           OS
90 |         </Text>
91 |       </Box>
92 |       <Box>
93 |         <Text color={theme.text.primary}>{osVersion}</Text>
94 |       </Box>
95 |     </Box>
96 |     <Box flexDirection="row">
97 |       <Box width="35%">
98 |         <Text bold color={theme.text.link}>
99 |           Auth Method
100 |         </Text>
101 |       </Box>
102 |       <Box>
103 |         <Text color={theme.text.primary}>
104 |           {selectedAuthType.startsWith('oauth') ? 'OAuth' : selectedAuthType}
105 |         </Text>
106 |       </Box>
107 |     </Box>
108 |     {gcpProject && (
109 |       <Box flexDirection="row">
110 |         <Box width="35%">
111 |           <Text bold color={theme.text.link}>
112 |             GCP Project
113 |           </Text>
114 |         </Box>
115 |         <Box>
116 |           <Text color={theme.text.primary}>{gcpProject}</Text>
117 |         </Box>
118 |       </Box>
119 |     )}
120 |     {ideClient && (
121 |       <Box flexDirection="row">
122 |         <Box width="35%">
123 |           <Text bold color={theme.text.link}>
124 |             IDE Client
125 |           </Text>
126 |         </Box>
127 |         <Box>
128 |           <Text color={theme.text.primary}>{ideClient}</Text>
129 |         </Box>
130 |       </Box>
131 |     )}
132 |   </Box>
133 | );
```

src/ui/components/AnsiOutput.test.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { render } from 'ink-testing-library';
8 | import { AnsiOutputText } from './AnsiOutput.js';
9 | import type { AnsiOutput, AnsiToken } from '@google/gemini-cli-core';
10 | 
11 | // Helper to create a valid AnsiToken with default values
12 | const createAnsiToken = (overrides: Partial<AnsiToken>): AnsiToken => ({
13 |   text: '',
14 |   bold: false,
15 |   italic: false,
16 |   underline: false,
17 |   dim: false,
18 |   inverse: false,
19 |   fg: '#ffffff',
20 |   bg: '#000000',
21 |   ...overrides,
22 | });
23 | 
24 | describe('<AnsiOutputText />', () => {
25 |   it('renders a simple AnsiOutput object correctly', () => {
26 |     const data: AnsiOutput = [
27 |       [
28 |         createAnsiToken({ text: 'Hello, ' }),
29 |         createAnsiToken({ text: 'world!' }),
30 |       ],
31 |     ];
32 |     const { lastFrame } = render(<AnsiOutputText data={data} width={80} />);
33 |     expect(lastFrame()).toBe('Hello, world!');
34 |   });
35 | 
36 |   it('correctly applies all the styles', () => {
37 |     const data: AnsiOutput = [
38 |       [
39 |         createAnsiToken({ text: 'Bold', bold: true }),
40 |         createAnsiToken({ text: 'Italic', italic: true }),
41 |         createAnsiToken({ text: 'Underline', underline: true }),
42 |         createAnsiToken({ text: 'Dim', dim: true }),
43 |         createAnsiToken({ text: 'Inverse', inverse: true }),
44 |       ],
45 |     ];
46 |     // Note: ink-testing-library doesn't render styles, so we can only check the text.
47 |     // We are testing that it renders without crashing.
48 |     const { lastFrame } = render(<AnsiOutputText data={data} width={80} />);
49 |     expect(lastFrame()).toBe('BoldItalicUnderlineDimInverse');
50 |   });
51 | 
52 |   it('correctly applies foreground and background colors', () => {
53 |     const data: AnsiOutput = [
54 |       [
55 |         createAnsiToken({ text: 'Red FG', fg: '#ff0000' }),
56 |         createAnsiToken({ text: 'Blue BG', bg: '#0000ff' }),
57 |       ],
58 |     ];
59 |     // Note: ink-testing-library doesn't render colors, so we can only check the text.
60 |     // We are testing that it renders without crashing.
61 |     const { lastFrame } = render(<AnsiOutputText data={data} width={80} />);
62 |     expect(lastFrame()).toBe('Red FGBlue BG');
63 |   });
64 | 
65 |   it('handles empty lines and empty tokens', () => {
66 |     const data: AnsiOutput = [
67 |       [createAnsiToken({ text: 'First line' })],
68 |       [],
69 |       [createAnsiToken({ text: 'Third line' })],
70 |       [createAnsiToken({ text: '' })],
71 |     ];
72 |     const { lastFrame } = render(<AnsiOutputText data={data} width={80} />);
73 |     const output = lastFrame();
74 |     expect(output).toBeDefined();
75 |     const lines = output!.split('\n');
76 |     expect(lines[0]).toBe('First line');
77 |     expect(lines[1]).toBe('Third line');
78 |   });
79 | 
80 |   it('respects the availableTerminalHeight prop and slices the lines correctly', () => {
81 |     const data: AnsiOutput = [
82 |       [createAnsiToken({ text: 'Line 1' })],
83 |       [createAnsiToken({ text: 'Line 2' })],
84 |       [createAnsiToken({ text: 'Line 3' })],
85 |       [createAnsiToken({ text: 'Line 4' })],
86 |     ];
87 |     const { lastFrame } = render(
88 |       <AnsiOutputText data={data} availableTerminalHeight={2} width={80} />,
89 |     );
90 |     const output = lastFrame();
91 |     expect(output).not.toContain('Line 1');
92 |     expect(output).not.toContain('Line 2');
93 |     expect(output).toContain('Line 3');
94 |     expect(output).toContain('Line 4');
95 |   });
96 | 
97 |   it('renders a large AnsiOutput object without crashing', () => {
98 |     const largeData: AnsiOutput = [];
99 |     for (let i = 0; i < 1000; i++) {
100 |       largeData.push([createAnsiToken({ text: `Line ${i}` })]);
101 |     }
102 |     const { lastFrame } = render(
103 |       <AnsiOutputText data={largeData} width={80} />,
104 |     );
105 |     // We are just checking that it renders something without crashing.
106 |     expect(lastFrame()).toBeDefined();
107 |   });
108 | });
```

src/ui/components/AnsiOutput.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type React from 'react';
8 | import { Box, Text } from 'ink';
9 | import type { AnsiLine, AnsiOutput, AnsiToken } from '@google/gemini-cli-core';
10 | 
11 | const DEFAULT_HEIGHT = 24;
12 | 
13 | interface AnsiOutputProps {
14 |   data: AnsiOutput;
15 |   availableTerminalHeight?: number;
16 |   width: number;
17 | }
18 | 
19 | export const AnsiOutputText: React.FC<AnsiOutputProps> = ({
20 |   data,
21 |   availableTerminalHeight,
22 |   width,
23 | }) => {
24 |   const lastLines = data.slice(
25 |     -(availableTerminalHeight && availableTerminalHeight > 0
26 |       ? availableTerminalHeight
27 |       : DEFAULT_HEIGHT),
28 |   );
29 |   return (
30 |     <Box flexDirection="column" width={width} flexShrink={0}>
31 |       {lastLines.map((line: AnsiLine, lineIndex: number) => (
32 |         <Text key={lineIndex} wrap="truncate">
33 |           {line.length > 0
34 |             ? line.map((token: AnsiToken, tokenIndex: number) => (
35 |                 <Text
36 |                   key={tokenIndex}
37 |                   color={token.inverse ? token.bg : token.fg}
38 |                   backgroundColor={token.inverse ? token.fg : token.bg}
39 |                   dimColor={token.dim}
40 |                   bold={token.bold}
41 |                   italic={token.italic}
42 |                   underline={token.underline}
43 |                 >
44 |                   {token.text}
45 |                 </Text>
46 |               ))
47 |             : null}
48 |         </Text>
49 |       ))}
50 |     </Box>
51 |   );
52 | };
```

src/ui/components/AppHeader.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { Box } from 'ink';
8 | import { Header } from './Header.js';
9 | import { Tips } from './Tips.js';
10 | import { useSettings } from '../contexts/SettingsContext.js';
11 | import { useConfig } from '../contexts/ConfigContext.js';
12 | import { useUIState } from '../contexts/UIStateContext.js';
13 | 
14 | interface AppHeaderProps {
15 |   version: string;
16 | }
17 | 
18 | export const AppHeader = ({ version }: AppHeaderProps) => {
19 |   const settings = useSettings();
20 |   const config = useConfig();
21 |   const { nightly } = useUIState();
22 | 
23 |   return (
24 |     <Box flexDirection="column">
25 |       {!(settings.merged.ui?.hideBanner || config.getScreenReader()) && (
26 |         <Header version={version} nightly={nightly} />
27 |       )}
28 |       {!(settings.merged.ui?.hideTips || config.getScreenReader()) && (
29 |         <Tips config={config} />
30 |       )}
31 |     </Box>
32 |   );
33 | };
```

src/ui/components/AsciiArt.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | export const shortAsciiLogo = `
8 |    █████████  ██████████ ██████   ██████ █████ ██████   █████ █████
9 |   ███░░░░░███░░███░░░░░█░░██████ ██████ ░░███ ░░██████ ░░███ ░░███
10 |  ███     ░░░  ░███  █ ░  ░███░█████░███  ░███  ░███░███ ░███  ░███
11 | ░███          ░██████    ░███░░███ ░███  ░███  ░███░░███░███  ░███
12 | ░███    █████ ░███░░█    ░███ ░░░  ░███  ░███  ░███ ░░██████  ░███
13 | ░░███  ░░███  ░███ ░   █ ░███      ░███  ░███  ░███  ░░█████  ░███
14 |  ░░█████████  ██████████ █████     █████ █████ █████  ░░█████ █████
15 |   ░░░░░░░░░  ░░░░░░░░░░ ░░░░░     ░░░░░ ░░░░░ ░░░░░    ░░░░░ ░░░░░
16 | `;
17 | 
18 | export const longAsciiLogo = `
19 |  ███            █████████  ██████████ ██████   ██████ █████ ██████   █████ █████
20 | ░░░███         ███░░░░░███░░███░░░░░█░░██████ ██████ ░░███ ░░██████ ░░███ ░░███
21 |   ░░░███      ███     ░░░  ░███  █ ░  ░███░█████░███  ░███  ░███░███ ░███  ░███
22 |     ░░░███   ░███          ░██████    ░███░░███ ░███  ░███  ░███░░███░███  ░███
23 |      ███░    ░███    █████ ░███░░█    ░███ ░░░  ░███  ░███  ░███ ░░██████  ░███
24 |    ███░      ░░███  ░░███  ░███ ░   █ ░███      ░███  ░███  ░███  ░░█████  ░███
25 |  ███░         ░░█████████  ██████████ █████     █████ █████ █████  ░░█████ █████
26 | ░░░            ░░░░░░░░░  ░░░░░░░░░░ ░░░░░     ░░░░░ ░░░░░ ░░░░░    ░░░░░ ░░░░░
27 | `;
28 | 
29 | export const tinyAsciiLogo = `
30 |  ███         █████████ 
31 | ░░░███      ███░░░░░███
32 |   ░░░███   ███     ░░░ 
33 |     ░░░███░███         
34 |      ███░ ░███    █████
35 |    ███░   ░░███  ░░███ 
36 |  ███░      ░░█████████ 
37 | ░░░         ░░░░░░░░░  
38 | `;
```

src/ui/components/AutoAcceptIndicator.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type React from 'react';
8 | import { Box, Text } from 'ink';
9 | import { theme } from '../semantic-colors.js';
10 | import { ApprovalMode } from '@google/gemini-cli-core';
11 | 
12 | interface AutoAcceptIndicatorProps {
13 |   approvalMode: ApprovalMode;
14 | }
15 | 
16 | export const AutoAcceptIndicator: React.FC<AutoAcceptIndicatorProps> = ({
17 |   approvalMode,
18 | }) => {
19 |   let textColor = '';
20 |   let textContent = '';
21 |   let subText = '';
22 | 
23 |   switch (approvalMode) {
24 |     case ApprovalMode.AUTO_EDIT:
25 |       textColor = theme.status.warning;
26 |       textContent = 'accepting edits';
27 |       subText = ' (shift + tab to toggle)';
28 |       break;
29 |     case ApprovalMode.YOLO:
30 |       textColor = theme.status.error;
31 |       textContent = 'YOLO mode';
32 |       subText = ' (ctrl + y to toggle)';
33 |       break;
34 |     case ApprovalMode.DEFAULT:
35 |     default:
36 |       break;
37 |   }
38 | 
39 |   return (
40 |     <Box>
41 |       <Text color={textColor}>
42 |         {textContent}
43 |         {subText && <Text color={theme.text.secondary}>{subText}</Text>}
44 |       </Text>
45 |     </Box>
46 |   );
47 | };
```

src/ui/components/CliSpinner.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import Spinner from 'ink-spinner';
8 | import { type ComponentProps, useEffect } from 'react';
9 | 
10 | // A top-level field to track the total number of active spinners.
11 | export let debugNumSpinners = 0;
12 | 
13 | export type SpinnerProps = ComponentProps<typeof Spinner>;
14 | 
15 | export const CliSpinner = (props: SpinnerProps) => {
16 |   useEffect(() => {
17 |     debugNumSpinners++;
18 |     return () => {
19 |       debugNumSpinners--;
20 |     };
21 |   }, []);
22 | 
23 |   return <Spinner {...props} />;
24 | };
```

src/ui/components/Composer.test.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect, vi } from 'vitest';
8 | import { render } from 'ink-testing-library';
9 | import { Text } from 'ink';
10 | import { Composer } from './Composer.js';
11 | import { UIStateContext, type UIState } from '../contexts/UIStateContext.js';
12 | import {
13 |   UIActionsContext,
14 |   type UIActions,
15 | } from '../contexts/UIActionsContext.js';
16 | import { ConfigContext } from '../contexts/ConfigContext.js';
17 | import { SettingsContext } from '../contexts/SettingsContext.js';
18 | // Mock VimModeContext hook
19 | vi.mock('../contexts/VimModeContext.js', () => ({
20 |   useVimMode: vi.fn(() => ({
21 |     vimEnabled: false,
22 |     vimMode: 'NORMAL',
23 |   })),
24 | }));
25 | import { ApprovalMode } from '@google/gemini-cli-core';
26 | import { StreamingState } from '../types.js';
27 | 
28 | // Mock child components
29 | vi.mock('./LoadingIndicator.js', () => ({
30 |   LoadingIndicator: ({ thought }: { thought?: string }) => (
31 |     <Text>LoadingIndicator{thought ? `: ${thought}` : ''}</Text>
32 |   ),
33 | }));
34 | 
35 | vi.mock('./ContextSummaryDisplay.js', () => ({
36 |   ContextSummaryDisplay: () => <Text>ContextSummaryDisplay</Text>,
37 | }));
38 | 
39 | vi.mock('./AutoAcceptIndicator.js', () => ({
40 |   AutoAcceptIndicator: () => <Text>AutoAcceptIndicator</Text>,
41 | }));
42 | 
43 | vi.mock('./ShellModeIndicator.js', () => ({
44 |   ShellModeIndicator: () => <Text>ShellModeIndicator</Text>,
45 | }));
46 | 
47 | vi.mock('./DetailedMessagesDisplay.js', () => ({
48 |   DetailedMessagesDisplay: () => <Text>DetailedMessagesDisplay</Text>,
49 | }));
50 | 
51 | vi.mock('./InputPrompt.js', () => ({
52 |   InputPrompt: () => <Text>InputPrompt</Text>,
53 |   calculatePromptWidths: vi.fn(() => ({
54 |     inputWidth: 80,
55 |     suggestionsWidth: 40,
56 |     containerWidth: 84,
57 |   })),
58 | }));
59 | 
60 | vi.mock('./Footer.js', () => ({
61 |   Footer: () => <Text>Footer</Text>,
62 | }));
63 | 
64 | vi.mock('./ShowMoreLines.js', () => ({
65 |   ShowMoreLines: () => <Text>ShowMoreLines</Text>,
66 | }));
67 | 
68 | vi.mock('./QueuedMessageDisplay.js', () => ({
69 |   QueuedMessageDisplay: ({ messageQueue }: { messageQueue: string[] }) => {
70 |     if (messageQueue.length === 0) {
71 |       return null;
72 |     }
73 |     return (
74 |       <>
75 |         {messageQueue.map((message, index) => (
76 |           <Text key={index}>{message}</Text>
77 |         ))}
78 |       </>
79 |     );
80 |   },
81 | }));
82 | 
83 | // Mock contexts
84 | vi.mock('../contexts/OverflowContext.js', () => ({
85 |   OverflowProvider: ({ children }: { children: React.ReactNode }) => children,
86 | }));
87 | 
88 | // Create mock context providers
89 | const createMockUIState = (overrides: Partial<UIState> = {}): UIState =>
90 |   ({
91 |     streamingState: null,
92 |     contextFileNames: [],
93 |     showAutoAcceptIndicator: ApprovalMode.DEFAULT,
94 |     messageQueue: [],
95 |     showErrorDetails: false,
96 |     constrainHeight: false,
97 |     isInputActive: true,
98 |     buffer: '',
99 |     inputWidth: 80,
100 |     suggestionsWidth: 40,
101 |     userMessages: [],
102 |     slashCommands: [],
103 |     commandContext: null,
104 |     shellModeActive: false,
105 |     isFocused: true,
106 |     thought: '',
107 |     currentLoadingPhrase: '',
108 |     elapsedTime: 0,
109 |     ctrlCPressedOnce: false,
110 |     ctrlDPressedOnce: false,
111 |     showEscapePrompt: false,
112 |     ideContextState: null,
113 |     geminiMdFileCount: 0,
114 |     showToolDescriptions: false,
115 |     filteredConsoleMessages: [],
116 |     sessionStats: {
117 |       lastPromptTokenCount: 0,
118 |       sessionTokenCount: 0,
119 |       totalPrompts: 0,
120 |     },
121 |     branchName: 'main',
122 |     debugMessage: '',
123 |     corgiMode: false,
124 |     errorCount: 0,
125 |     nightly: false,
126 |     isTrustedFolder: true,
127 |     ...overrides,
128 |   }) as UIState;
129 | 
130 | const createMockUIActions = (): UIActions =>
131 |   ({
132 |     handleFinalSubmit: vi.fn(),
133 |     handleClearScreen: vi.fn(),
134 |     setShellModeActive: vi.fn(),
135 |     onEscapePromptChange: vi.fn(),
136 |     vimHandleInput: vi.fn(),
137 |     // eslint-disable-next-line @typescript-eslint/no-explicit-any
138 |   }) as any;
139 | 
140 | const createMockConfig = (overrides = {}) => ({
141 |   getModel: vi.fn(() => 'gemini-1.5-pro'),
142 |   getTargetDir: vi.fn(() => '/test/dir'),
143 |   getDebugMode: vi.fn(() => false),
144 |   getAccessibility: vi.fn(() => ({})),
145 |   getMcpServers: vi.fn(() => ({})),
146 |   getBlockedMcpServers: vi.fn(() => []),
147 |   ...overrides,
148 | });
149 | 
150 | const createMockSettings = (merged = {}) => ({
151 |   merged: {
152 |     hideFooter: false,
153 |     showMemoryUsage: false,
154 |     ...merged,
155 |   },
156 | });
157 | 
158 | /* eslint-disable @typescript-eslint/no-explicit-any */
159 | const renderComposer = (
160 |   uiState: UIState,
161 |   settings = createMockSettings(),
162 |   config = createMockConfig(),
163 |   uiActions = createMockUIActions(),
164 | ) =>
165 |   render(
166 |     <ConfigContext.Provider value={config as any}>
167 |       <SettingsContext.Provider value={settings as any}>
168 |         <UIStateContext.Provider value={uiState}>
169 |           <UIActionsContext.Provider value={uiActions}>
170 |             <Composer />
171 |           </UIActionsContext.Provider>
172 |         </UIStateContext.Provider>
173 |       </SettingsContext.Provider>
174 |     </ConfigContext.Provider>,
175 |   );
176 | /* eslint-enable @typescript-eslint/no-explicit-any */
177 | 
178 | describe('Composer', () => {
179 |   describe('Footer Display Settings', () => {
180 |     it('renders Footer by default when hideFooter is false', () => {
181 |       const uiState = createMockUIState();
182 |       const settings = createMockSettings({ hideFooter: false });
183 | 
184 |       const { lastFrame } = renderComposer(uiState, settings);
185 | 
186 |       expect(lastFrame()).toContain('Footer');
187 |     });
188 | 
189 |     it('does NOT render Footer when hideFooter is true', () => {
190 |       const uiState = createMockUIState();
191 |       const settings = createMockSettings({ hideFooter: true });
192 | 
193 |       const { lastFrame } = renderComposer(uiState, settings);
194 | 
195 |       // Check for content that only appears IN the Footer component itself
196 |       expect(lastFrame()).not.toContain('[NORMAL]'); // Vim mode indicator
197 |       expect(lastFrame()).not.toContain('(main'); // Branch name with parentheses
198 |     });
199 | 
200 |     it('passes correct props to Footer including vim mode when enabled', async () => {
201 |       const uiState = createMockUIState({
202 |         branchName: 'feature-branch',
203 |         corgiMode: true,
204 |         errorCount: 2,
205 |         sessionStats: {
206 |           sessionId: 'test-session',
207 |           sessionStartTime: new Date(),
208 |           // eslint-disable-next-line @typescript-eslint/no-explicit-any
209 |           metrics: {} as any,
210 |           lastPromptTokenCount: 150,
211 |           promptCount: 5,
212 |         },
213 |       });
214 |       const config = createMockConfig({
215 |         getModel: vi.fn(() => 'gemini-1.5-flash'),
216 |         getTargetDir: vi.fn(() => '/project/path'),
217 |         getDebugMode: vi.fn(() => true),
218 |       });
219 |       const settings = createMockSettings({
220 |         hideFooter: false,
221 |         showMemoryUsage: true,
222 |       });
223 |       // Mock vim mode for this test
224 |       const { useVimMode } = await import('../contexts/VimModeContext.js');
225 |       vi.mocked(useVimMode).mockReturnValueOnce({
226 |         vimEnabled: true,
227 |         vimMode: 'INSERT',
228 |         // eslint-disable-next-line @typescript-eslint/no-explicit-any
229 |       } as any);
230 | 
231 |       const { lastFrame } = renderComposer(uiState, settings, config);
232 | 
233 |       expect(lastFrame()).toContain('Footer');
234 |       // Footer should be rendered with all the state passed through
235 |     });
236 |   });
237 | 
238 |   describe('Loading Indicator', () => {
239 |     it('renders LoadingIndicator with thought when streaming', () => {
240 |       const uiState = createMockUIState({
241 |         streamingState: StreamingState.Responding,
242 |         thought: {
243 |           subject: 'Processing',
244 |           description: 'Processing your request...',
245 |         },
246 |         currentLoadingPhrase: 'Analyzing',
247 |         elapsedTime: 1500,
248 |       });
249 | 
250 |       const { lastFrame } = renderComposer(uiState);
251 | 
252 |       const output = lastFrame();
253 |       expect(output).toContain('LoadingIndicator');
254 |     });
255 | 
256 |     it('renders LoadingIndicator without thought when accessibility disables loading phrases', () => {
257 |       const uiState = createMockUIState({
258 |         streamingState: StreamingState.Responding,
259 |         thought: { subject: 'Hidden', description: 'Should not show' },
260 |       });
261 |       const config = createMockConfig({
262 |         getAccessibility: vi.fn(() => ({ disableLoadingPhrases: true })),
263 |       });
264 | 
265 |       const { lastFrame } = renderComposer(uiState, undefined, config);
266 | 
267 |       const output = lastFrame();
268 |       expect(output).toContain('LoadingIndicator');
269 |       expect(output).not.toContain('Should not show');
270 |     });
271 | 
272 |     it('suppresses thought when waiting for confirmation', () => {
273 |       const uiState = createMockUIState({
274 |         streamingState: StreamingState.WaitingForConfirmation,
275 |         thought: {
276 |           subject: 'Confirmation',
277 |           description: 'Should not show during confirmation',
278 |         },
279 |       });
280 | 
281 |       const { lastFrame } = renderComposer(uiState);
282 | 
283 |       const output = lastFrame();
284 |       expect(output).toContain('LoadingIndicator');
285 |       expect(output).not.toContain('Should not show during confirmation');
286 |     });
287 |   });
288 | 
289 |   describe('Message Queue Display', () => {
290 |     it('displays queued messages when present', () => {
291 |       const uiState = createMockUIState({
292 |         messageQueue: [
293 |           'First queued message',
294 |           'Second queued message',
295 |           'Third queued message',
296 |         ],
297 |       });
298 | 
299 |       const { lastFrame } = renderComposer(uiState);
300 | 
301 |       const output = lastFrame();
302 |       expect(output).toContain('First queued message');
303 |       expect(output).toContain('Second queued message');
304 |       expect(output).toContain('Third queued message');
305 |     });
306 | 
307 |     it('renders QueuedMessageDisplay with empty message queue', () => {
308 |       const uiState = createMockUIState({
309 |         messageQueue: [],
310 |       });
311 | 
312 |       const { lastFrame } = renderComposer(uiState);
313 | 
314 |       // The component should render but return null for empty queue
315 |       // This test verifies that the component receives the correct prop
316 |       const output = lastFrame();
317 |       expect(output).toContain('InputPrompt'); // Verify basic Composer rendering
318 |     });
319 |   });
320 | 
321 |   describe('Context and Status Display', () => {
322 |     it('shows ContextSummaryDisplay in normal state', () => {
323 |       const uiState = createMockUIState({
324 |         ctrlCPressedOnce: false,
325 |         ctrlDPressedOnce: false,
326 |         showEscapePrompt: false,
327 |       });
328 | 
329 |       const { lastFrame } = renderComposer(uiState);
330 | 
331 |       expect(lastFrame()).toContain('ContextSummaryDisplay');
332 |     });
333 | 
334 |     it('shows Ctrl+C exit prompt when ctrlCPressedOnce is true', () => {
335 |       const uiState = createMockUIState({
336 |         ctrlCPressedOnce: true,
337 |       });
338 | 
339 |       const { lastFrame } = renderComposer(uiState);
340 | 
341 |       expect(lastFrame()).toContain('Press Ctrl+C again to exit');
342 |     });
343 | 
344 |     it('shows Ctrl+D exit prompt when ctrlDPressedOnce is true', () => {
345 |       const uiState = createMockUIState({
346 |         ctrlDPressedOnce: true,
347 |       });
348 | 
349 |       const { lastFrame } = renderComposer(uiState);
350 | 
351 |       expect(lastFrame()).toContain('Press Ctrl+D again to exit');
352 |     });
353 | 
354 |     it('shows escape prompt when showEscapePrompt is true', () => {
355 |       const uiState = createMockUIState({
356 |         showEscapePrompt: true,
357 |       });
358 | 
359 |       const { lastFrame } = renderComposer(uiState);
360 | 
361 |       expect(lastFrame()).toContain('Press Esc again to clear');
362 |     });
363 |   });
364 | 
365 |   describe('Input and Indicators', () => {
366 |     it('renders InputPrompt when input is active', () => {
367 |       const uiState = createMockUIState({
368 |         isInputActive: true,
369 |       });
370 | 
371 |       const { lastFrame } = renderComposer(uiState);
372 | 
373 |       expect(lastFrame()).toContain('InputPrompt');
374 |     });
375 | 
376 |     it('does not render InputPrompt when input is inactive', () => {
377 |       const uiState = createMockUIState({
378 |         isInputActive: false,
379 |       });
380 | 
381 |       const { lastFrame } = renderComposer(uiState);
382 | 
383 |       expect(lastFrame()).not.toContain('InputPrompt');
384 |     });
385 | 
386 |     it('shows AutoAcceptIndicator when approval mode is not default and shell mode is inactive', () => {
387 |       const uiState = createMockUIState({
388 |         showAutoAcceptIndicator: ApprovalMode.YOLO,
389 |         shellModeActive: false,
390 |       });
391 | 
392 |       const { lastFrame } = renderComposer(uiState);
[TRUNCATED]
```

src/ui/components/Composer.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { Box, Text, useIsScreenReaderEnabled } from 'ink';
8 | import { LoadingIndicator } from './LoadingIndicator.js';
9 | import { ContextSummaryDisplay } from './ContextSummaryDisplay.js';
10 | import { AutoAcceptIndicator } from './AutoAcceptIndicator.js';
11 | import { ShellModeIndicator } from './ShellModeIndicator.js';
12 | import { DetailedMessagesDisplay } from './DetailedMessagesDisplay.js';
13 | import { InputPrompt } from './InputPrompt.js';
14 | import { Footer } from './Footer.js';
15 | import { ShowMoreLines } from './ShowMoreLines.js';
16 | import { QueuedMessageDisplay } from './QueuedMessageDisplay.js';
17 | import { OverflowProvider } from '../contexts/OverflowContext.js';
18 | import { theme } from '../semantic-colors.js';
19 | import { isNarrowWidth } from '../utils/isNarrowWidth.js';
20 | import { useUIState } from '../contexts/UIStateContext.js';
21 | import { useUIActions } from '../contexts/UIActionsContext.js';
22 | import { useVimMode } from '../contexts/VimModeContext.js';
23 | import { useConfig } from '../contexts/ConfigContext.js';
24 | import { useSettings } from '../contexts/SettingsContext.js';
25 | import { ApprovalMode } from '@google/gemini-cli-core';
26 | import { StreamingState } from '../types.js';
27 | import { ConfigInitDisplay } from '../components/ConfigInitDisplay.js';
28 | 
29 | export const Composer = () => {
30 |   const config = useConfig();
31 |   const settings = useSettings();
32 |   const isScreenReaderEnabled = useIsScreenReaderEnabled();
33 |   const uiState = useUIState();
34 |   const uiActions = useUIActions();
35 |   const { vimEnabled } = useVimMode();
36 |   const terminalWidth = process.stdout.columns;
37 |   const isNarrow = isNarrowWidth(terminalWidth);
38 |   const debugConsoleMaxHeight = Math.floor(Math.max(terminalWidth * 0.2, 5));
39 | 
40 |   const { contextFileNames, showAutoAcceptIndicator } = uiState;
41 | 
42 |   return (
43 |     <Box flexDirection="column" width={uiState.mainAreaWidth} flexShrink={0}>
44 |       {!uiState.embeddedShellFocused && (
45 |         <LoadingIndicator
46 |           thought={
47 |             uiState.streamingState === StreamingState.WaitingForConfirmation ||
48 |             config.getAccessibility()?.disableLoadingPhrases
49 |               ? undefined
50 |               : uiState.thought
51 |           }
52 |           currentLoadingPhrase={
53 |             config.getAccessibility()?.disableLoadingPhrases
54 |               ? undefined
55 |               : uiState.currentLoadingPhrase
56 |           }
57 |           elapsedTime={uiState.elapsedTime}
58 |         />
59 |       )}
60 | 
61 |       {!uiState.isConfigInitialized && <ConfigInitDisplay />}
62 | 
63 |       <QueuedMessageDisplay messageQueue={uiState.messageQueue} />
64 | 
65 |       <Box
66 |         marginTop={1}
67 |         justifyContent={
68 |           settings.merged.ui?.hideContextSummary
69 |             ? 'flex-start'
70 |             : 'space-between'
71 |         }
72 |         width="100%"
73 |         flexDirection={isNarrow ? 'column' : 'row'}
74 |         alignItems={isNarrow ? 'flex-start' : 'center'}
75 |       >
76 |         <Box marginRight={1}>
77 |           {process.env['GEMINI_SYSTEM_MD'] && (
78 |             <Text color={theme.status.error}>|⌐■_■| </Text>
79 |           )}
80 |           {uiState.ctrlCPressedOnce ? (
81 |             <Text color={theme.status.warning}>
82 |               Press Ctrl+C again to exit.
83 |             </Text>
84 |           ) : uiState.ctrlDPressedOnce ? (
85 |             <Text color={theme.status.warning}>
86 |               Press Ctrl+D again to exit.
87 |             </Text>
88 |           ) : uiState.showEscapePrompt ? (
89 |             <Text color={theme.text.secondary}>Press Esc again to clear.</Text>
90 |           ) : (
91 |             !settings.merged.ui?.hideContextSummary && (
92 |               <ContextSummaryDisplay
93 |                 ideContext={uiState.ideContextState}
94 |                 geminiMdFileCount={uiState.geminiMdFileCount}
95 |                 contextFileNames={contextFileNames}
96 |                 mcpServers={config.getMcpServers()}
97 |                 blockedMcpServers={config.getBlockedMcpServers()}
98 |                 showToolDescriptions={uiState.showToolDescriptions}
99 |               />
100 |             )
101 |           )}
102 |         </Box>
103 |         <Box paddingTop={isNarrow ? 1 : 0}>
104 |           {showAutoAcceptIndicator !== ApprovalMode.DEFAULT &&
105 |             !uiState.shellModeActive && (
106 |               <AutoAcceptIndicator approvalMode={showAutoAcceptIndicator} />
107 |             )}
108 |           {uiState.shellModeActive && <ShellModeIndicator />}
109 |         </Box>
110 |       </Box>
111 | 
112 |       {uiState.showErrorDetails && (
113 |         <OverflowProvider>
114 |           <Box flexDirection="column">
115 |             <DetailedMessagesDisplay
116 |               messages={uiState.filteredConsoleMessages}
117 |               maxHeight={
118 |                 uiState.constrainHeight ? debugConsoleMaxHeight : undefined
119 |               }
120 |               width={uiState.mainAreaWidth}
121 |             />
122 |             <ShowMoreLines constrainHeight={uiState.constrainHeight} />
123 |           </Box>
124 |         </OverflowProvider>
125 |       )}
126 | 
127 |       {uiState.isInputActive && (
128 |         <InputPrompt
129 |           buffer={uiState.buffer}
130 |           inputWidth={uiState.inputWidth}
131 |           suggestionsWidth={uiState.suggestionsWidth}
132 |           onSubmit={uiActions.handleFinalSubmit}
133 |           userMessages={uiState.userMessages}
134 |           onClearScreen={uiActions.handleClearScreen}
135 |           config={config}
136 |           slashCommands={uiState.slashCommands}
137 |           commandContext={uiState.commandContext}
138 |           shellModeActive={uiState.shellModeActive}
139 |           setShellModeActive={uiActions.setShellModeActive}
140 |           approvalMode={showAutoAcceptIndicator}
141 |           onEscapePromptChange={uiActions.onEscapePromptChange}
142 |           focus={true}
143 |           vimHandleInput={uiActions.vimHandleInput}
144 |           isEmbeddedShellFocused={uiState.embeddedShellFocused}
145 |           placeholder={
146 |             vimEnabled
147 |               ? "  Press 'i' for INSERT mode and 'Esc' for NORMAL mode."
148 |               : '  Type your message or @path/to/file'
149 |           }
150 |         />
151 |       )}
152 | 
153 |       {!settings.merged.ui?.hideFooter && !isScreenReaderEnabled && <Footer />}
154 |     </Box>
155 |   );
156 | };
```

src/ui/components/ConfigInitDisplay.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { useEffect, useState } from 'react';
8 | import { appEvents } from './../../utils/events.js';
9 | import { Box, Text } from 'ink';
10 | import { useConfig } from '../contexts/ConfigContext.js';
11 | import { type McpClient, MCPServerStatus } from '@google/gemini-cli-core';
12 | import { GeminiSpinner } from './GeminiRespondingSpinner.js';
13 | import { theme } from '../semantic-colors.js';
14 | 
15 | export const ConfigInitDisplay = () => {
16 |   const config = useConfig();
17 |   const [message, setMessage] = useState('Initializing...');
18 | 
19 |   useEffect(() => {
20 |     const onChange = (clients?: Map<string, McpClient>) => {
21 |       if (!clients || clients.size === 0) {
22 |         setMessage(`Initializing...`);
23 |         return;
24 |       }
25 |       let connected = 0;
26 |       for (const client of clients.values()) {
27 |         if (client.getStatus() === MCPServerStatus.CONNECTED) {
28 |           connected++;
29 |         }
30 |       }
31 |       setMessage(`Connecting to MCP servers... (${connected}/${clients.size})`);
32 |     };
33 | 
34 |     appEvents.on('mcp-client-update', onChange);
35 |     return () => {
36 |       appEvents.off('mcp-client-update', onChange);
37 |     };
38 |   }, [config]);
39 | 
40 |   return (
41 |     <Box marginTop={1}>
42 |       <Text>
43 |         <GeminiSpinner /> <Text color={theme.text.primary}>{message}</Text>
44 |       </Text>
45 |     </Box>
46 |   );
47 | };
```

src/ui/components/ConsentPrompt.test.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { Text } from 'ink';
8 | import { describe, it, expect, vi, beforeEach } from 'vitest';
9 | import { render } from 'ink-testing-library';
10 | import { ConsentPrompt } from './ConsentPrompt.js';
11 | import { RadioButtonSelect } from './shared/RadioButtonSelect.js';
12 | import { MarkdownDisplay } from '../utils/MarkdownDisplay.js';
13 | 
14 | vi.mock('./shared/RadioButtonSelect.js', () => ({
15 |   RadioButtonSelect: vi.fn(() => null),
16 | }));
17 | 
18 | vi.mock('../utils/MarkdownDisplay.js', () => ({
19 |   MarkdownDisplay: vi.fn(() => null),
20 | }));
21 | 
22 | const MockedRadioButtonSelect = vi.mocked(RadioButtonSelect);
23 | const MockedMarkdownDisplay = vi.mocked(MarkdownDisplay);
24 | 
25 | describe('ConsentPrompt', () => {
26 |   const onConfirm = vi.fn();
27 |   const terminalWidth = 80;
28 | 
29 |   beforeEach(() => {
30 |     vi.clearAllMocks();
31 |   });
32 | 
33 |   it('renders a string prompt with MarkdownDisplay', () => {
34 |     const prompt = 'Are you sure?';
35 |     render(
36 |       <ConsentPrompt
37 |         prompt={prompt}
38 |         onConfirm={onConfirm}
39 |         terminalWidth={terminalWidth}
40 |       />,
41 |     );
42 | 
43 |     expect(MockedMarkdownDisplay).toHaveBeenCalledWith(
44 |       {
45 |         isPending: true,
46 |         text: prompt,
47 |         terminalWidth,
48 |       },
49 |       undefined,
50 |     );
51 |   });
52 | 
53 |   it('renders a ReactNode prompt directly', () => {
54 |     const prompt = <Text>Are you sure?</Text>;
55 |     const { lastFrame } = render(
56 |       <ConsentPrompt
57 |         prompt={prompt}
58 |         onConfirm={onConfirm}
59 |         terminalWidth={terminalWidth}
60 |       />,
61 |     );
62 | 
63 |     expect(MockedMarkdownDisplay).not.toHaveBeenCalled();
64 |     expect(lastFrame()).toContain('Are you sure?');
65 |   });
66 | 
67 |   it('calls onConfirm with true when "Yes" is selected', () => {
68 |     const prompt = 'Are you sure?';
69 |     render(
70 |       <ConsentPrompt
71 |         prompt={prompt}
72 |         onConfirm={onConfirm}
73 |         terminalWidth={terminalWidth}
74 |       />,
75 |     );
76 | 
77 |     const onSelect = MockedRadioButtonSelect.mock.calls[0][0].onSelect;
78 |     onSelect(true);
79 | 
80 |     expect(onConfirm).toHaveBeenCalledWith(true);
81 |   });
82 | 
83 |   it('calls onConfirm with false when "No" is selected', () => {
84 |     const prompt = 'Are you sure?';
85 |     render(
86 |       <ConsentPrompt
87 |         prompt={prompt}
88 |         onConfirm={onConfirm}
89 |         terminalWidth={terminalWidth}
90 |       />,
91 |     );
92 | 
93 |     const onSelect = MockedRadioButtonSelect.mock.calls[0][0].onSelect;
94 |     onSelect(false);
95 | 
96 |     expect(onConfirm).toHaveBeenCalledWith(false);
97 |   });
98 | 
99 |   it('passes correct items to RadioButtonSelect', () => {
100 |     const prompt = 'Are you sure?';
101 |     render(
102 |       <ConsentPrompt
103 |         prompt={prompt}
104 |         onConfirm={onConfirm}
105 |         terminalWidth={terminalWidth}
106 |       />,
107 |     );
108 | 
109 |     expect(MockedRadioButtonSelect).toHaveBeenCalledWith(
110 |       expect.objectContaining({
111 |         items: [
112 |           { label: 'Yes', value: true, key: 'Yes' },
113 |           { label: 'No', value: false, key: 'No' },
114 |         ],
115 |       }),
116 |       undefined,
117 |     );
118 |   });
119 | });
```

src/ui/components/ConsentPrompt.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { Box } from 'ink';
8 | import { type ReactNode } from 'react';
9 | import { theme } from '../semantic-colors.js';
10 | import { MarkdownDisplay } from '../utils/MarkdownDisplay.js';
11 | import { RadioButtonSelect } from './shared/RadioButtonSelect.js';
12 | 
13 | type ConsentPromptProps = {
14 |   // If a simple string is given, it will render using markdown by default.
15 |   prompt: ReactNode;
16 |   onConfirm: (value: boolean) => void;
17 |   terminalWidth: number;
18 | };
19 | 
20 | export const ConsentPrompt = (props: ConsentPromptProps) => {
21 |   const { prompt, onConfirm, terminalWidth } = props;
22 | 
23 |   return (
24 |     <Box
25 |       borderStyle="round"
26 |       borderColor={theme.border.default}
27 |       flexDirection="column"
28 |       paddingY={1}
29 |       paddingX={2}
30 |     >
31 |       {typeof prompt === 'string' ? (
32 |         <MarkdownDisplay
33 |           isPending={true}
34 |           text={prompt}
35 |           terminalWidth={terminalWidth}
36 |         />
37 |       ) : (
38 |         prompt
39 |       )}
40 |       <Box marginTop={1}>
41 |         <RadioButtonSelect
42 |           items={[
43 |             { label: 'Yes', value: true, key: 'Yes' },
44 |             { label: 'No', value: false, key: 'No' },
45 |           ]}
46 |           onSelect={onConfirm}
47 |         />
48 |       </Box>
49 |     </Box>
50 |   );
51 | };
```

src/ui/components/ConsoleSummaryDisplay.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type React from 'react';
8 | import { Box, Text } from 'ink';
9 | import { theme } from '../semantic-colors.js';
10 | 
11 | interface ConsoleSummaryDisplayProps {
12 |   errorCount: number;
13 |   // logCount is not currently in the plan to be displayed in summary
14 | }
15 | 
16 | export const ConsoleSummaryDisplay: React.FC<ConsoleSummaryDisplayProps> = ({
17 |   errorCount,
18 | }) => {
19 |   if (errorCount === 0) {
20 |     return null;
21 |   }
22 | 
23 |   const errorIcon = '\u2716'; // Heavy multiplication x (✖)
24 | 
25 |   return (
26 |     <Box>
27 |       {errorCount > 0 && (
28 |         <Text color={theme.status.error}>
29 |           {errorIcon} {errorCount} error{errorCount > 1 ? 's' : ''}{' '}
30 |           <Text color={theme.text.secondary}>(ctrl+o for details)</Text>
31 |         </Text>
32 |       )}
33 |     </Box>
34 |   );
35 | };
```

src/ui/components/ContextSummaryDisplay.test.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type React from 'react';
8 | import { render } from 'ink-testing-library';
9 | import { describe, it, expect, vi } from 'vitest';
10 | import { ContextSummaryDisplay } from './ContextSummaryDisplay.js';
11 | import * as useTerminalSize from '../hooks/useTerminalSize.js';
12 | 
13 | vi.mock('../hooks/useTerminalSize.js', () => ({
14 |   useTerminalSize: vi.fn(),
15 | }));
16 | 
17 | const useTerminalSizeMock = vi.mocked(useTerminalSize.useTerminalSize);
18 | 
19 | const renderWithWidth = (
20 |   width: number,
21 |   props: React.ComponentProps<typeof ContextSummaryDisplay>,
22 | ) => {
23 |   useTerminalSizeMock.mockReturnValue({ columns: width, rows: 24 });
24 |   return render(<ContextSummaryDisplay {...props} />);
25 | };
26 | 
27 | describe('<ContextSummaryDisplay />', () => {
28 |   const baseProps = {
29 |     geminiMdFileCount: 1,
30 |     contextFileNames: ['GEMINI.md'],
31 |     mcpServers: { 'test-server': { command: 'test' } },
32 |     showToolDescriptions: false,
33 |     ideContext: {
34 |       workspaceState: {
35 |         openFiles: [{ path: '/a/b/c' }],
36 |       },
37 |     },
38 |   };
39 | 
40 |   it('should render on a single line on a wide screen', () => {
41 |     const { lastFrame } = renderWithWidth(120, baseProps);
42 |     const output = lastFrame();
43 |     expect(output).toContain(
44 |       'Using: 1 open file (ctrl+g to view) | 1 GEMINI.md file | 1 MCP server (ctrl+t to view)',
45 |     );
46 |     // Check for absence of newlines
47 |     expect(output.includes('\n')).toBe(false);
48 |   });
49 | 
50 |   it('should render on multiple lines on a narrow screen', () => {
51 |     const { lastFrame } = renderWithWidth(60, baseProps);
52 |     const output = lastFrame();
53 |     const expectedLines = [
54 |       ' Using:',
55 |       '   - 1 open file (ctrl+g to view)',
56 |       '   - 1 GEMINI.md file',
57 |       '   - 1 MCP server (ctrl+t to view)',
58 |     ];
59 |     const actualLines = output.split('\n');
60 |     expect(actualLines).toEqual(expectedLines);
61 |   });
62 | 
63 |   it('should switch layout at the 80-column breakpoint', () => {
64 |     // At 80 columns, should be on one line
65 |     const { lastFrame: wideFrame } = renderWithWidth(80, baseProps);
66 |     expect(wideFrame().includes('\n')).toBe(false);
67 | 
68 |     // At 79 columns, should be on multiple lines
69 |     const { lastFrame: narrowFrame } = renderWithWidth(79, baseProps);
70 |     expect(narrowFrame().includes('\n')).toBe(true);
71 |     expect(narrowFrame().split('\n').length).toBe(4);
72 |   });
73 | 
74 |   it('should not render empty parts', () => {
75 |     const props = {
76 |       ...baseProps,
77 |       geminiMdFileCount: 0,
78 |       contextFileNames: [],
79 |       mcpServers: {},
80 |     };
81 |     const { lastFrame } = renderWithWidth(60, props);
82 |     const expectedLines = [' Using:', '   - 1 open file (ctrl+g to view)'];
83 |     const actualLines = lastFrame().split('\n');
84 |     expect(actualLines).toEqual(expectedLines);
85 |   });
86 | });
```

src/ui/components/ContextSummaryDisplay.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type React from 'react';
8 | import { Box, Text } from 'ink';
9 | import { theme } from '../semantic-colors.js';
10 | import { type IdeContext, type MCPServerConfig } from '@google/gemini-cli-core';
11 | import { useTerminalSize } from '../hooks/useTerminalSize.js';
12 | import { isNarrowWidth } from '../utils/isNarrowWidth.js';
13 | 
14 | interface ContextSummaryDisplayProps {
15 |   geminiMdFileCount: number;
16 |   contextFileNames: string[];
17 |   mcpServers?: Record<string, MCPServerConfig>;
18 |   blockedMcpServers?: Array<{ name: string; extensionName: string }>;
19 |   showToolDescriptions?: boolean;
20 |   ideContext?: IdeContext;
21 | }
22 | 
23 | export const ContextSummaryDisplay: React.FC<ContextSummaryDisplayProps> = ({
24 |   geminiMdFileCount,
25 |   contextFileNames,
26 |   mcpServers,
27 |   blockedMcpServers,
28 |   showToolDescriptions,
29 |   ideContext,
30 | }) => {
31 |   const { columns: terminalWidth } = useTerminalSize();
32 |   const isNarrow = isNarrowWidth(terminalWidth);
33 |   const mcpServerCount = Object.keys(mcpServers || {}).length;
34 |   const blockedMcpServerCount = blockedMcpServers?.length || 0;
35 |   const openFileCount = ideContext?.workspaceState?.openFiles?.length ?? 0;
36 | 
37 |   if (
38 |     geminiMdFileCount === 0 &&
39 |     mcpServerCount === 0 &&
40 |     blockedMcpServerCount === 0 &&
41 |     openFileCount === 0
42 |   ) {
43 |     return <Text> </Text>; // Render an empty space to reserve height
44 |   }
45 | 
46 |   const openFilesText = (() => {
47 |     if (openFileCount === 0) {
48 |       return '';
49 |     }
50 |     return `${openFileCount} open file${
51 |       openFileCount > 1 ? 's' : ''
52 |     } (ctrl+g to view)`;
53 |   })();
54 | 
55 |   const geminiMdText = (() => {
56 |     if (geminiMdFileCount === 0) {
57 |       return '';
58 |     }
59 |     const allNamesTheSame = new Set(contextFileNames).size < 2;
60 |     const name = allNamesTheSame ? contextFileNames[0] : 'context';
61 |     return `${geminiMdFileCount} ${name} file${
62 |       geminiMdFileCount > 1 ? 's' : ''
63 |     }`;
64 |   })();
65 | 
66 |   const mcpText = (() => {
67 |     if (mcpServerCount === 0 && blockedMcpServerCount === 0) {
68 |       return '';
69 |     }
70 | 
71 |     const parts = [];
72 |     if (mcpServerCount > 0) {
73 |       parts.push(
74 |         `${mcpServerCount} MCP server${mcpServerCount > 1 ? 's' : ''}`,
75 |       );
76 |     }
77 | 
78 |     if (blockedMcpServerCount > 0) {
79 |       let blockedText = `${blockedMcpServerCount} Blocked`;
80 |       if (mcpServerCount === 0) {
81 |         blockedText += ` MCP server${blockedMcpServerCount > 1 ? 's' : ''}`;
82 |       }
83 |       parts.push(blockedText);
84 |     }
85 |     let text = parts.join(', ');
86 |     // Add ctrl+t hint when MCP servers are available
87 |     if (mcpServers && Object.keys(mcpServers).length > 0) {
88 |       if (showToolDescriptions) {
89 |         text += ' (ctrl+t to toggle)';
90 |       } else {
91 |         text += ' (ctrl+t to view)';
92 |       }
93 |     }
94 |     return text;
95 |   })();
96 | 
97 |   const summaryParts = [openFilesText, geminiMdText, mcpText].filter(Boolean);
98 | 
99 |   if (isNarrow) {
100 |     return (
101 |       <Box flexDirection="column" paddingX={1}>
102 |         <Text color={theme.text.secondary}>Using:</Text>
103 |         {summaryParts.map((part, index) => (
104 |           <Text key={index} color={theme.text.secondary}>
105 |             {'  '}- {part}
106 |           </Text>
107 |         ))}
108 |       </Box>
109 |     );
110 |   }
111 | 
112 |   return (
113 |     <Box paddingX={1}>
114 |       <Text color={theme.text.secondary}>
115 |         Using: {summaryParts.join(' | ')}
116 |       </Text>
117 |     </Box>
118 |   );
119 | };
```

src/ui/components/ContextUsageDisplay.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { Text } from 'ink';
8 | import { theme } from '../semantic-colors.js';
9 | import { tokenLimit } from '@google/gemini-cli-core';
10 | 
11 | export const ContextUsageDisplay = ({
12 |   promptTokenCount,
13 |   model,
14 |   terminalWidth,
15 | }: {
16 |   promptTokenCount: number;
17 |   model: string;
18 |   terminalWidth: number;
19 | }) => {
20 |   const percentage = promptTokenCount / tokenLimit(model);
21 |   const percentageLeft = ((1 - percentage) * 100).toFixed(0);
22 | 
23 |   const label = terminalWidth < 100 ? '%' : '% context left';
24 | 
25 |   return (
26 |     <Text color={theme.text.secondary}>
27 |       ({percentageLeft}
28 |       {label})
29 |     </Text>
30 |   );
31 | };
```

src/ui/components/DebugProfiler.test.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
8 | import { appEvents, AppEvent } from '../../utils/events.js';
9 | import {
10 |   profiler,
11 |   ACTION_TIMESTAMP_CAPACITY,
12 |   FRAME_TIMESTAMP_CAPACITY,
13 | } from './DebugProfiler.js';
14 | import { FixedDeque } from 'mnemonist';
15 | 
16 | describe('DebugProfiler', () => {
17 |   beforeEach(() => {
18 |     vi.useFakeTimers();
19 |     profiler.numFrames = 0;
20 |     profiler.totalIdleFrames = 0;
21 |     profiler.lastFrameStartTime = 0;
22 |     profiler.openedDebugConsole = false;
23 |     profiler.lastActionTimestamp = 0;
24 |     profiler.possiblyIdleFrameTimestamps = new FixedDeque<number>(
25 |       Array,
26 |       FRAME_TIMESTAMP_CAPACITY,
27 |     );
28 |     profiler.actionTimestamps = new FixedDeque<number>(
29 |       Array,
30 |       ACTION_TIMESTAMP_CAPACITY,
31 |     );
32 |   });
33 | 
34 |   afterEach(() => {
35 |     vi.restoreAllMocks();
36 |     profiler.actionTimestamps.clear();
37 |     profiler.possiblyIdleFrameTimestamps.clear();
38 |   });
39 | 
40 |   it('should not exceed action timestamp capacity', () => {
41 |     for (let i = 0; i < ACTION_TIMESTAMP_CAPACITY + 10; i++) {
42 |       profiler.reportAction();
43 |       // To ensure we don't trigger the debounce
44 |       profiler.lastActionTimestamp = 0;
45 |     }
46 |     expect(profiler.actionTimestamps.size).toBe(ACTION_TIMESTAMP_CAPACITY);
47 |   });
48 | 
49 |   it('should not exceed frame timestamp capacity', () => {
50 |     for (let i = 0; i < FRAME_TIMESTAMP_CAPACITY + 10; i++) {
51 |       profiler.reportFrameRendered();
52 |       // To ensure we don't trigger the debounce
53 |       profiler.lastFrameStartTime = 0;
54 |     }
55 |     expect(profiler.possiblyIdleFrameTimestamps.size).toBe(
56 |       FRAME_TIMESTAMP_CAPACITY,
57 |     );
58 |   });
59 | 
60 |   it('should drop oldest action timestamps when capacity is reached', () => {
61 |     for (let i = 0; i < ACTION_TIMESTAMP_CAPACITY; i++) {
62 |       profiler.actionTimestamps.push(i);
63 |     }
64 |     profiler.lastActionTimestamp = 0;
65 |     profiler.reportAction();
66 | 
67 |     expect(profiler.actionTimestamps.size).toBe(ACTION_TIMESTAMP_CAPACITY);
68 |     expect(profiler.actionTimestamps.peekFirst()).toBe(1);
69 |   });
70 | 
71 |   it('should drop oldest frame timestamps when capacity is reached', () => {
72 |     for (let i = 0; i < FRAME_TIMESTAMP_CAPACITY; i++) {
73 |       profiler.possiblyIdleFrameTimestamps.push(i);
74 |     }
75 |     profiler.lastFrameStartTime = 0;
76 |     profiler.reportFrameRendered();
77 | 
78 |     expect(profiler.possiblyIdleFrameTimestamps.size).toBe(
79 |       FRAME_TIMESTAMP_CAPACITY,
80 |     );
81 |     expect(profiler.possiblyIdleFrameTimestamps.peekFirst()).toBe(1);
82 |   });
83 | 
84 |   it('should not report frames as idle if an action happens shortly after', async () => {
85 |     const startTime = Date.now();
86 |     vi.setSystemTime(startTime);
87 | 
88 |     for (let i = 0; i < 5; i++) {
89 |       profiler.reportFrameRendered();
90 |       vi.advanceTimersByTime(20);
91 |     }
92 | 
93 |     vi.setSystemTime(startTime + 400);
94 |     profiler.reportAction();
95 | 
96 |     vi.advanceTimersByTime(600);
97 |     profiler.checkForIdleFrames();
98 | 
99 |     expect(profiler.totalIdleFrames).toBe(0);
100 |   });
101 | 
102 |   it('should report frames as idle if no action happens nearby', async () => {
103 |     const startTime = Date.now();
104 |     vi.setSystemTime(startTime);
105 | 
106 |     for (let i = 0; i < 5; i++) {
107 |       profiler.reportFrameRendered();
108 |       vi.advanceTimersByTime(20);
109 |     }
110 | 
111 |     vi.advanceTimersByTime(1000);
112 |     profiler.checkForIdleFrames();
113 | 
114 |     expect(profiler.totalIdleFrames).toBe(5);
115 |   });
116 | 
117 |   it('should not report frames as idle if an action happens shortly before', async () => {
118 |     const startTime = Date.now();
119 |     vi.setSystemTime(startTime);
120 | 
121 |     profiler.reportAction();
122 | 
123 |     vi.advanceTimersByTime(400);
124 | 
125 |     for (let i = 0; i < 5; i++) {
126 |       profiler.reportFrameRendered();
127 |       vi.advanceTimersByTime(20);
128 |     }
129 | 
130 |     vi.advanceTimersByTime(600);
131 |     profiler.checkForIdleFrames();
132 | 
133 |     expect(profiler.totalIdleFrames).toBe(0);
134 |   });
135 | 
136 |   it('should correctly identify mixed idle and non-idle frames', async () => {
137 |     const startTime = Date.now();
138 |     vi.setSystemTime(startTime);
139 | 
140 |     for (let i = 0; i < 3; i++) {
141 |       profiler.reportFrameRendered();
142 |       vi.advanceTimersByTime(20);
143 |     }
144 | 
145 |     vi.advanceTimersByTime(1000);
146 | 
147 |     profiler.reportAction();
148 |     vi.advanceTimersByTime(100);
149 | 
150 |     for (let i = 0; i < 3; i++) {
151 |       profiler.reportFrameRendered();
152 |       vi.advanceTimersByTime(20);
153 |     }
154 | 
155 |     vi.advanceTimersByTime(600);
156 |     profiler.checkForIdleFrames();
157 | 
158 |     expect(profiler.totalIdleFrames).toBe(3);
159 |   });
160 | 
161 |   it('should report flicker frames', () => {
162 |     const reportActionSpy = vi.spyOn(profiler, 'reportAction');
163 |     const cleanup = profiler.registerFlickerHandler(true);
164 | 
165 |     appEvents.emit(AppEvent.Flicker);
166 | 
167 |     expect(profiler.totalFlickerFrames).toBe(1);
168 |     expect(reportActionSpy).toHaveBeenCalled();
169 | 
170 |     cleanup();
171 |   });
172 | 
173 |   it('should not report idle frames when actions are interleaved', async () => {
174 |     const startTime = Date.now();
175 |     vi.setSystemTime(startTime);
176 | 
177 |     profiler.reportFrameRendered();
178 |     vi.advanceTimersByTime(20);
179 | 
180 |     profiler.reportFrameRendered();
181 |     vi.advanceTimersByTime(200);
182 | 
183 |     profiler.reportAction();
184 |     vi.advanceTimersByTime(200);
185 | 
186 |     profiler.reportFrameRendered();
187 |     vi.advanceTimersByTime(20);
188 | 
189 |     profiler.reportFrameRendered();
190 | 
191 |     vi.advanceTimersByTime(600);
192 |     profiler.checkForIdleFrames();
193 | 
194 |     expect(profiler.totalIdleFrames).toBe(0);
195 |   });
196 | });
```

src/ui/components/DebugProfiler.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { Text } from 'ink';
8 | import { useEffect, useState } from 'react';
9 | import { FixedDeque } from 'mnemonist';
10 | import { theme } from '../semantic-colors.js';
11 | import { useUIState } from '../contexts/UIStateContext.js';
12 | import { debugNumSpinners } from './CliSpinner.js';
13 | import { appEvents, AppEvent } from '../../utils/events.js';
14 | 
15 | // Frames that render at least this far before or after an action are considered
16 | // idle frames.
17 | const MIN_TIME_FROM_ACTION_TO_BE_IDLE = 500;
18 | 
19 | export const ACTION_TIMESTAMP_CAPACITY = 2048;
20 | export const FRAME_TIMESTAMP_CAPACITY = 2048;
21 | 
22 | // Exported for testing purposes.
23 | export const profiler = {
24 |   numFrames: 0,
25 |   totalIdleFrames: 0,
26 |   totalFlickerFrames: 0,
27 |   hasLoggedFirstFlicker: false,
28 |   lastFrameStartTime: 0,
29 |   openedDebugConsole: false,
30 |   lastActionTimestamp: 0,
31 | 
32 |   possiblyIdleFrameTimestamps: new FixedDeque<number>(
33 |     Array,
34 |     FRAME_TIMESTAMP_CAPACITY,
35 |   ),
36 |   actionTimestamps: new FixedDeque<number>(Array, ACTION_TIMESTAMP_CAPACITY),
37 | 
38 |   reportAction() {
39 |     const now = Date.now();
40 |     if (now - this.lastActionTimestamp > 16) {
41 |       if (this.actionTimestamps.size >= ACTION_TIMESTAMP_CAPACITY) {
42 |         this.actionTimestamps.shift();
43 |       }
44 |       this.actionTimestamps.push(now);
45 |       this.lastActionTimestamp = now;
46 |     }
47 |   },
48 | 
49 |   reportFrameRendered() {
50 |     const now = Date.now();
51 |     // Simple frame detection logic (a write after at least 16ms is a new frame)
52 |     if (now - this.lastFrameStartTime > 16) {
53 |       this.lastFrameStartTime = now;
54 |       this.numFrames++;
55 |       if (debugNumSpinners === 0) {
56 |         if (this.possiblyIdleFrameTimestamps.size >= FRAME_TIMESTAMP_CAPACITY) {
57 |           this.possiblyIdleFrameTimestamps.shift();
58 |         }
59 |         this.possiblyIdleFrameTimestamps.push(now);
60 |       } else {
61 |         // If a spinner is present, consider this an action that both prevents
62 |         // this frame from being idle and also should prevent a follow on frame
63 |         // from being considered idle.
64 |         if (this.actionTimestamps.size >= ACTION_TIMESTAMP_CAPACITY) {
65 |           this.actionTimestamps.shift();
66 |         }
67 |         this.actionTimestamps.push(now);
68 |       }
69 |     }
70 |   },
71 | 
72 |   checkForIdleFrames() {
73 |     const now = Date.now();
74 |     const judgementCutoff = now - MIN_TIME_FROM_ACTION_TO_BE_IDLE;
75 |     const oneSecondIntervalFromJudgementCutoff = judgementCutoff - 1000;
76 | 
77 |     let idleInPastSecond = 0;
78 | 
79 |     while (
80 |       this.possiblyIdleFrameTimestamps.size > 0 &&
81 |       this.possiblyIdleFrameTimestamps.peekFirst()! <= judgementCutoff
82 |     ) {
83 |       const frameTime = this.possiblyIdleFrameTimestamps.shift()!;
84 |       const start = frameTime - MIN_TIME_FROM_ACTION_TO_BE_IDLE;
85 |       const end = frameTime + MIN_TIME_FROM_ACTION_TO_BE_IDLE;
86 | 
87 |       while (
88 |         this.actionTimestamps.size > 0 &&
89 |         this.actionTimestamps.peekFirst()! < start
90 |       ) {
91 |         this.actionTimestamps.shift();
92 |       }
93 | 
94 |       const hasAction =
95 |         this.actionTimestamps.size > 0 &&
96 |         this.actionTimestamps.peekFirst()! <= end;
97 | 
98 |       if (!hasAction) {
99 |         if (frameTime >= oneSecondIntervalFromJudgementCutoff) {
100 |           idleInPastSecond++;
101 |         }
102 |         this.totalIdleFrames++;
103 |       }
104 |     }
105 | 
106 |     if (idleInPastSecond >= 5) {
107 |       if (this.openedDebugConsole === false) {
108 |         this.openedDebugConsole = true;
109 |         appEvents.emit(AppEvent.OpenDebugConsole);
110 |       }
111 |       appEvents.emit(
112 |         AppEvent.LogError,
113 |         `${idleInPastSecond} frames rendered while the app was ` +
114 |           `idle in the past second. This likely indicates severe infinite loop ` +
115 |           `React state management bugs.`,
116 |       );
117 |     }
118 |   },
119 | 
120 |   registerFlickerHandler(constrainHeight: boolean) {
121 |     const flickerHandler = () => {
122 |       // If we are not constraining the height, we are intentionally
123 |       // overflowing the screen.
124 |       if (!constrainHeight) {
125 |         return;
126 |       }
127 | 
128 |       this.totalFlickerFrames++;
129 |       this.reportAction();
130 | 
131 |       if (!this.hasLoggedFirstFlicker) {
132 |         this.hasLoggedFirstFlicker = true;
133 |         appEvents.emit(
134 |           AppEvent.LogError,
135 |           'A flicker frame was detected. This will cause UI instability. Type `/profile` for more info.',
136 |         );
137 |       }
138 |     };
139 |     appEvents.on(AppEvent.Flicker, flickerHandler);
140 |     return () => {
141 |       appEvents.off(AppEvent.Flicker, flickerHandler);
142 |     };
143 |   },
144 | };
145 | 
146 | export const DebugProfiler = () => {
147 |   const { showDebugProfiler, constrainHeight } = useUIState();
148 |   const [forceRefresh, setForceRefresh] = useState(0);
149 | 
150 |   // Effect for listening to stdin for keypresses and stdout for resize events.
151 |   useEffect(() => {
152 |     const stdin = process.stdin;
153 |     const stdout = process.stdout;
154 | 
155 |     const handler = () => {
156 |       profiler.reportAction();
157 |     };
158 | 
159 |     stdin.on('data', handler);
160 |     stdout.on('resize', handler);
161 | 
162 |     return () => {
163 |       stdin.off('data', handler);
164 |       stdout.off('resize', handler);
165 |     };
166 |   }, []);
167 | 
168 |   // Effect for patching stdout to count frames and detect idle ones
169 |   useEffect(() => {
170 |     const originalWrite = process.stdout.write;
171 |     const boundOriginalWrite = originalWrite.bind(process.stdout);
172 | 
173 |     process.stdout.write = (
174 |       chunk: Uint8Array | string,
175 |       encodingOrCb?:
176 |         | BufferEncoding
177 |         | ((err?: NodeJS.ErrnoException | null) => void),
178 |       cb?: (err?: NodeJS.ErrnoException | null) => void,
179 |     ) => {
180 |       profiler.reportFrameRendered();
181 | 
182 |       if (typeof encodingOrCb === 'function') {
183 |         return boundOriginalWrite(chunk, encodingOrCb);
184 |       }
185 |       return boundOriginalWrite(chunk, encodingOrCb, cb);
186 |     };
187 | 
188 |     return () => {
189 |       process.stdout.write = originalWrite;
190 |     };
191 |   }, []);
192 | 
193 |   useEffect(() => {
194 |     const updateInterval = setInterval(() => {
195 |       profiler.checkForIdleFrames();
196 |     }, 1000);
197 |     return () => clearInterval(updateInterval);
198 |   }, []);
199 | 
200 |   useEffect(
201 |     () => profiler.registerFlickerHandler(constrainHeight),
202 |     [constrainHeight],
203 |   );
204 | 
205 |   // Effect for updating stats
206 |   useEffect(() => {
207 |     if (!showDebugProfiler) {
208 |       return;
209 |     }
210 |     // Only update the UX infrequently as updating the UX itself will cause
211 |     // frames to run so can disturb what we are measuing.
212 |     const forceRefreshInterval = setInterval(() => {
213 |       setForceRefresh((f) => f + 1);
214 |       profiler.reportAction();
215 |     }, 4000);
216 |     return () => clearInterval(forceRefreshInterval);
217 |   }, [showDebugProfiler]);
218 | 
219 |   if (!showDebugProfiler) {
220 |     return null;
221 |   }
222 | 
223 |   return (
224 |     <Text color={theme.status.warning} key={forceRefresh}>
225 |       Renders: {profiler.numFrames} (total),{' '}
226 |       <Text color={theme.status.error}>{profiler.totalIdleFrames} (idle)</Text>,{' '}
227 |       <Text color={theme.status.error}>
228 |         {profiler.totalFlickerFrames} (flicker)
229 |       </Text>
230 |     </Text>
231 |   );
232 | };
```

src/ui/components/DetailedMessagesDisplay.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type React from 'react';
8 | import { Box, Text } from 'ink';
9 | import { theme } from '../semantic-colors.js';
10 | import type { ConsoleMessageItem } from '../types.js';
11 | import { MaxSizedBox } from './shared/MaxSizedBox.js';
12 | 
13 | interface DetailedMessagesDisplayProps {
14 |   messages: ConsoleMessageItem[];
15 |   maxHeight: number | undefined;
16 |   width: number;
17 |   // debugMode is not needed here if App.tsx filters debug messages before passing them.
18 |   // If DetailedMessagesDisplay should handle filtering, add debugMode prop.
19 | }
20 | 
21 | export const DetailedMessagesDisplay: React.FC<
22 |   DetailedMessagesDisplayProps
23 | > = ({ messages, maxHeight, width }) => {
24 |   if (messages.length === 0) {
25 |     return null; // Don't render anything if there are no messages
26 |   }
27 | 
28 |   const borderAndPadding = 4;
29 |   return (
30 |     <Box
31 |       flexDirection="column"
32 |       marginTop={1}
33 |       borderStyle="round"
34 |       borderColor={theme.border.default}
35 |       paddingX={1}
36 |       width={width}
37 |     >
38 |       <Box marginBottom={1}>
39 |         <Text bold color={theme.text.primary}>
40 |           Debug Console{' '}
41 |           <Text color={theme.text.secondary}>(ctrl+o to close)</Text>
42 |         </Text>
43 |       </Box>
44 |       <MaxSizedBox maxHeight={maxHeight} maxWidth={width - borderAndPadding}>
45 |         {messages.map((msg, index) => {
46 |           let textColor = theme.text.primary;
47 |           let icon = '\u2139'; // Information source (ℹ)
48 | 
49 |           switch (msg.type) {
50 |             case 'warn':
51 |               textColor = theme.status.warning;
52 |               icon = '\u26A0'; // Warning sign (⚠)
53 |               break;
54 |             case 'error':
55 |               textColor = theme.status.error;
56 |               icon = '\u2716'; // Heavy multiplication x (✖)
57 |               break;
58 |             case 'debug':
59 |               textColor = theme.text.secondary; // Or theme.text.secondary
60 |               icon = '\u{1F50D}'; // Left-pointing magnifying glass (🔍)
61 |               break;
62 |             case 'log':
63 |             default:
64 |               // Default textColor and icon are already set
65 |               break;
66 |           }
67 | 
68 |           return (
69 |             <Box key={index} flexDirection="row">
70 |               <Text color={textColor}>{icon} </Text>
71 |               <Text color={textColor} wrap="wrap">
72 |                 {msg.content}
73 |                 {msg.count && msg.count > 1 && (
74 |                   <Text color={theme.text.secondary}> (x{msg.count})</Text>
75 |                 )}
76 |               </Text>
77 |             </Box>
78 |           );
79 |         })}
80 |       </MaxSizedBox>
81 |     </Box>
82 |   );
83 | };
```

src/ui/components/DialogManager.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { Box, Text } from 'ink';
8 | import { IdeIntegrationNudge } from '../IdeIntegrationNudge.js';
9 | import { LoopDetectionConfirmation } from './LoopDetectionConfirmation.js';
10 | import { FolderTrustDialog } from './FolderTrustDialog.js';
11 | import { ShellConfirmationDialog } from './ShellConfirmationDialog.js';
12 | import { ConsentPrompt } from './ConsentPrompt.js';
13 | import { ThemeDialog } from './ThemeDialog.js';
14 | import { SettingsDialog } from './SettingsDialog.js';
15 | import { AuthInProgress } from '../auth/AuthInProgress.js';
16 | import { AuthDialog } from '../auth/AuthDialog.js';
17 | import { EditorSettingsDialog } from './EditorSettingsDialog.js';
18 | import { PrivacyNotice } from '../privacy/PrivacyNotice.js';
19 | import { WorkspaceMigrationDialog } from './WorkspaceMigrationDialog.js';
20 | import { ProQuotaDialog } from './ProQuotaDialog.js';
21 | import { PermissionsModifyTrustDialog } from './PermissionsModifyTrustDialog.js';
22 | import { ModelDialog } from './ModelDialog.js';
23 | import { theme } from '../semantic-colors.js';
24 | import { useUIState } from '../contexts/UIStateContext.js';
25 | import { useUIActions } from '../contexts/UIActionsContext.js';
26 | import { useConfig } from '../contexts/ConfigContext.js';
27 | import { useSettings } from '../contexts/SettingsContext.js';
28 | import process from 'node:process';
29 | import { type UseHistoryManagerReturn } from '../hooks/useHistoryManager.js';
30 | import { IdeTrustChangeDialog } from './IdeTrustChangeDialog.js';
31 | 
32 | interface DialogManagerProps {
33 |   addItem: UseHistoryManagerReturn['addItem'];
34 |   terminalWidth: number;
35 | }
36 | 
37 | // Props for DialogManager
38 | export const DialogManager = ({
39 |   addItem,
40 |   terminalWidth,
41 | }: DialogManagerProps) => {
42 |   const config = useConfig();
43 |   const settings = useSettings();
44 | 
45 |   const uiState = useUIState();
46 |   const uiActions = useUIActions();
47 |   const { constrainHeight, terminalHeight, staticExtraHeight, mainAreaWidth } =
48 |     uiState;
49 | 
50 |   if (uiState.showIdeRestartPrompt) {
51 |     return <IdeTrustChangeDialog reason={uiState.ideTrustRestartReason} />;
52 |   }
53 |   if (uiState.showWorkspaceMigrationDialog) {
54 |     return (
55 |       <WorkspaceMigrationDialog
56 |         workspaceExtensions={uiState.workspaceExtensions}
57 |         onOpen={uiActions.onWorkspaceMigrationDialogOpen}
58 |         onClose={uiActions.onWorkspaceMigrationDialogClose}
59 |       />
60 |     );
61 |   }
62 |   if (uiState.proQuotaRequest) {
63 |     return (
64 |       <ProQuotaDialog
65 |         failedModel={uiState.proQuotaRequest.failedModel}
66 |         fallbackModel={uiState.proQuotaRequest.fallbackModel}
67 |         onChoice={uiActions.handleProQuotaChoice}
68 |       />
69 |     );
70 |   }
71 |   if (uiState.shouldShowIdePrompt) {
72 |     return (
73 |       <IdeIntegrationNudge
74 |         ide={uiState.currentIDE!}
75 |         onComplete={uiActions.handleIdePromptComplete}
76 |       />
77 |     );
78 |   }
79 |   if (uiState.isFolderTrustDialogOpen) {
80 |     return (
81 |       <FolderTrustDialog
82 |         onSelect={uiActions.handleFolderTrustSelect}
83 |         isRestarting={uiState.isRestarting}
84 |       />
85 |     );
86 |   }
87 |   if (uiState.shellConfirmationRequest) {
88 |     return (
89 |       <ShellConfirmationDialog request={uiState.shellConfirmationRequest} />
90 |     );
91 |   }
92 |   if (uiState.loopDetectionConfirmationRequest) {
93 |     return (
94 |       <LoopDetectionConfirmation
95 |         onComplete={uiState.loopDetectionConfirmationRequest.onComplete}
96 |       />
97 |     );
98 |   }
99 |   if (uiState.confirmationRequest) {
100 |     return (
101 |       <ConsentPrompt
102 |         prompt={uiState.confirmationRequest.prompt}
103 |         onConfirm={uiState.confirmationRequest.onConfirm}
104 |         terminalWidth={terminalWidth}
105 |       />
106 |     );
107 |   }
108 |   if (uiState.confirmUpdateExtensionRequests.length > 0) {
109 |     const request = uiState.confirmUpdateExtensionRequests[0];
110 |     return (
111 |       <ConsentPrompt
112 |         prompt={request.prompt}
113 |         onConfirm={request.onConfirm}
114 |         terminalWidth={terminalWidth}
115 |       />
116 |     );
117 |   }
118 |   if (uiState.isThemeDialogOpen) {
119 |     return (
120 |       <Box flexDirection="column">
121 |         {uiState.themeError && (
122 |           <Box marginBottom={1}>
123 |             <Text color={theme.status.error}>{uiState.themeError}</Text>
124 |           </Box>
125 |         )}
126 |         <ThemeDialog
127 |           onSelect={uiActions.handleThemeSelect}
128 |           onHighlight={uiActions.handleThemeHighlight}
129 |           settings={settings}
130 |           availableTerminalHeight={
131 |             constrainHeight ? terminalHeight - staticExtraHeight : undefined
132 |           }
133 |           terminalWidth={mainAreaWidth}
134 |         />
135 |       </Box>
136 |     );
137 |   }
138 |   if (uiState.isSettingsDialogOpen) {
139 |     return (
140 |       <Box flexDirection="column">
141 |         <SettingsDialog
142 |           settings={settings}
143 |           onSelect={() => uiActions.closeSettingsDialog()}
144 |           onRestartRequest={() => process.exit(0)}
145 |           availableTerminalHeight={terminalHeight - staticExtraHeight}
146 |         />
147 |       </Box>
148 |     );
149 |   }
150 |   if (uiState.isModelDialogOpen) {
151 |     return <ModelDialog onClose={uiActions.closeModelDialog} />;
152 |   }
153 |   if (uiState.isAuthenticating) {
154 |     return (
155 |       <AuthInProgress
156 |         onTimeout={() => {
157 |           uiActions.onAuthError('Authentication cancelled.');
158 |         }}
159 |       />
160 |     );
161 |   }
162 |   if (uiState.isAuthDialogOpen) {
163 |     return (
164 |       <Box flexDirection="column">
165 |         <AuthDialog
166 |           config={config}
167 |           settings={settings}
168 |           setAuthState={uiActions.setAuthState}
169 |           authError={uiState.authError}
170 |           onAuthError={uiActions.onAuthError}
171 |         />
172 |       </Box>
173 |     );
174 |   }
175 |   if (uiState.isEditorDialogOpen) {
176 |     return (
177 |       <Box flexDirection="column">
178 |         {uiState.editorError && (
179 |           <Box marginBottom={1}>
180 |             <Text color={theme.status.error}>{uiState.editorError}</Text>
181 |           </Box>
182 |         )}
183 |         <EditorSettingsDialog
184 |           onSelect={uiActions.handleEditorSelect}
185 |           settings={settings}
186 |           onExit={uiActions.exitEditorDialog}
187 |         />
188 |       </Box>
189 |     );
190 |   }
191 |   if (uiState.showPrivacyNotice) {
192 |     return (
193 |       <PrivacyNotice
194 |         onExit={() => uiActions.exitPrivacyNotice()}
195 |         config={config}
196 |       />
197 |     );
198 |   }
199 | 
200 |   if (uiState.isPermissionsDialogOpen) {
201 |     return (
202 |       <PermissionsModifyTrustDialog
203 |         onExit={uiActions.closePermissionsDialog}
204 |         addItem={addItem}
205 |       />
206 |     );
207 |   }
208 | 
209 |   return null;
210 | };
```

src/ui/components/EditorSettingsDialog.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type React from 'react';
8 | import { useState } from 'react';
9 | import { Box, Text } from 'ink';
10 | import { theme } from '../semantic-colors.js';
11 | import {
12 |   EDITOR_DISPLAY_NAMES,
13 |   editorSettingsManager,
14 |   type EditorDisplay,
15 | } from '../editors/editorSettingsManager.js';
16 | import { RadioButtonSelect } from './shared/RadioButtonSelect.js';
17 | import type { LoadedSettings } from '../../config/settings.js';
18 | import { SettingScope } from '../../config/settings.js';
19 | import type { EditorType } from '@google/gemini-cli-core';
20 | import { isEditorAvailable } from '@google/gemini-cli-core';
21 | import { useKeypress } from '../hooks/useKeypress.js';
22 | 
23 | interface EditorDialogProps {
24 |   onSelect: (editorType: EditorType | undefined, scope: SettingScope) => void;
25 |   settings: LoadedSettings;
26 |   onExit: () => void;
27 | }
28 | 
29 | export function EditorSettingsDialog({
30 |   onSelect,
31 |   settings,
32 |   onExit,
33 | }: EditorDialogProps): React.JSX.Element {
34 |   const [selectedScope, setSelectedScope] = useState<SettingScope>(
35 |     SettingScope.User,
36 |   );
37 |   const [focusedSection, setFocusedSection] = useState<'editor' | 'scope'>(
38 |     'editor',
39 |   );
40 |   useKeypress(
41 |     (key) => {
42 |       if (key.name === 'tab') {
43 |         setFocusedSection((prev) => (prev === 'editor' ? 'scope' : 'editor'));
44 |       }
45 |       if (key.name === 'escape') {
46 |         onExit();
47 |       }
48 |     },
49 |     { isActive: true },
50 |   );
51 | 
52 |   const editorItems: EditorDisplay[] =
53 |     editorSettingsManager.getAvailableEditorDisplays();
54 | 
55 |   const currentPreference =
56 |     settings.forScope(selectedScope).settings.general?.preferredEditor;
57 |   let editorIndex = currentPreference
58 |     ? editorItems.findIndex(
59 |         (item: EditorDisplay) => item.type === currentPreference,
60 |       )
61 |     : 0;
62 |   if (editorIndex === -1) {
63 |     console.error(`Editor is not supported: ${currentPreference}`);
64 |     editorIndex = 0;
65 |   }
66 | 
67 |   const scopeItems = [
68 |     {
69 |       label: 'User Settings',
70 |       value: SettingScope.User,
71 |       key: SettingScope.User,
72 |     },
73 |     {
74 |       label: 'Workspace Settings',
75 |       value: SettingScope.Workspace,
76 |       key: SettingScope.Workspace,
77 |     },
78 |   ];
79 | 
80 |   const handleEditorSelect = (editorType: EditorType | 'not_set') => {
81 |     if (editorType === 'not_set') {
82 |       onSelect(undefined, selectedScope);
83 |       return;
84 |     }
85 |     onSelect(editorType, selectedScope);
86 |   };
87 | 
88 |   const handleScopeSelect = (scope: SettingScope) => {
89 |     setSelectedScope(scope);
90 |     setFocusedSection('editor');
91 |   };
92 | 
93 |   let otherScopeModifiedMessage = '';
94 |   const otherScope =
95 |     selectedScope === SettingScope.User
96 |       ? SettingScope.Workspace
97 |       : SettingScope.User;
98 |   if (
99 |     settings.forScope(otherScope).settings.general?.preferredEditor !==
100 |     undefined
101 |   ) {
102 |     otherScopeModifiedMessage =
103 |       settings.forScope(selectedScope).settings.general?.preferredEditor !==
104 |       undefined
105 |         ? `(Also modified in ${otherScope})`
106 |         : `(Modified in ${otherScope})`;
107 |   }
108 | 
109 |   let mergedEditorName = 'None';
110 |   if (
111 |     settings.merged.general?.preferredEditor &&
112 |     isEditorAvailable(settings.merged.general?.preferredEditor)
113 |   ) {
114 |     mergedEditorName =
115 |       EDITOR_DISPLAY_NAMES[
116 |         settings.merged.general?.preferredEditor as EditorType
117 |       ];
118 |   }
119 | 
120 |   return (
121 |     <Box
122 |       borderStyle="round"
123 |       borderColor={theme.border.default}
124 |       flexDirection="row"
125 |       padding={1}
126 |       width="100%"
127 |     >
128 |       <Box flexDirection="column" width="45%" paddingRight={2}>
129 |         <Text bold={focusedSection === 'editor'}>
130 |           {focusedSection === 'editor' ? '> ' : '  '}Select Editor{' '}
131 |           <Text color={theme.text.secondary}>{otherScopeModifiedMessage}</Text>
132 |         </Text>
133 |         <RadioButtonSelect
134 |           items={editorItems.map((item) => ({
135 |             label: item.name,
136 |             value: item.type,
137 |             disabled: item.disabled,
138 |             key: item.type,
139 |           }))}
140 |           initialIndex={editorIndex}
141 |           onSelect={handleEditorSelect}
142 |           isFocused={focusedSection === 'editor'}
143 |           key={selectedScope}
144 |         />
145 | 
146 |         <Box marginTop={1} flexDirection="column">
147 |           <Text bold={focusedSection === 'scope'}>
148 |             {focusedSection === 'scope' ? '> ' : '  '}Apply To
149 |           </Text>
150 |           <RadioButtonSelect
151 |             items={scopeItems}
152 |             initialIndex={0}
153 |             onSelect={handleScopeSelect}
154 |             isFocused={focusedSection === 'scope'}
155 |           />
156 |         </Box>
157 | 
158 |         <Box marginTop={1}>
159 |           <Text color={theme.text.secondary}>
160 |             (Use Enter to select, Tab to change focus)
161 |           </Text>
162 |         </Box>
163 |       </Box>
164 | 
165 |       <Box flexDirection="column" width="55%" paddingLeft={2}>
166 |         <Text bold color={theme.text.primary}>
167 |           Editor Preference
168 |         </Text>
169 |         <Box flexDirection="column" gap={1} marginTop={1}>
170 |           <Text color={theme.text.secondary}>
171 |             These editors are currently supported. Please note that some editors
172 |             cannot be used in sandbox mode.
173 |           </Text>
174 |           <Text color={theme.text.secondary}>
175 |             Your preferred editor is:{' '}
176 |             <Text
177 |               color={
178 |                 mergedEditorName === 'None'
179 |                   ? theme.status.error
180 |                   : theme.text.link
181 |               }
182 |               bold
183 |             >
184 |               {mergedEditorName}
185 |             </Text>
186 |             .
187 |           </Text>
188 |         </Box>
189 |       </Box>
190 |     </Box>
191 |   );
192 | }
```

src/ui/components/ExitWarning.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type React from 'react';
8 | import { Box, Text } from 'ink';
9 | import { useUIState } from '../contexts/UIStateContext.js';
10 | import { theme } from '../semantic-colors.js';
11 | 
12 | export const ExitWarning: React.FC = () => {
13 |   const uiState = useUIState();
14 |   return (
15 |     <>
16 |       {uiState.dialogsVisible && uiState.ctrlCPressedOnce && (
17 |         <Box marginTop={1}>
18 |           <Text color={theme.status.warning}>Press Ctrl+C again to exit.</Text>
19 |         </Box>
20 |       )}
21 | 
22 |       {uiState.dialogsVisible && uiState.ctrlDPressedOnce && (
23 |         <Box marginTop={1}>
24 |           <Text color={theme.status.warning}>Press Ctrl+D again to exit.</Text>
25 |         </Box>
26 |       )}
27 |     </>
28 |   );
29 | };
```

src/ui/components/FolderTrustDialog.test.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { renderWithProviders } from '../../test-utils/render.js';
8 | import { waitFor } from '@testing-library/react';
9 | import { vi } from 'vitest';
10 | import { FolderTrustDialog, FolderTrustChoice } from './FolderTrustDialog.js';
11 | import * as processUtils from '../../utils/processUtils.js';
12 | 
13 | vi.mock('../../utils/processUtils.js', () => ({
14 |   relaunchApp: vi.fn(),
15 | }));
16 | 
17 | const mockedExit = vi.hoisted(() => vi.fn());
18 | const mockedCwd = vi.hoisted(() => vi.fn());
19 | 
20 | vi.mock('node:process', async () => {
21 |   const actual =
22 |     await vi.importActual<typeof import('node:process')>('node:process');
23 |   return {
24 |     ...actual,
25 |     exit: mockedExit,
26 |     cwd: mockedCwd,
27 |   };
28 | });
29 | 
30 | describe('FolderTrustDialog', () => {
31 |   beforeEach(() => {
32 |     vi.clearAllMocks();
33 |     mockedCwd.mockReturnValue('/home/user/project');
34 |   });
35 | 
36 |   it('should render the dialog with title and description', () => {
37 |     const { lastFrame } = renderWithProviders(
38 |       <FolderTrustDialog onSelect={vi.fn()} />,
39 |     );
40 | 
41 |     expect(lastFrame()).toContain('Do you trust this folder?');
42 |     expect(lastFrame()).toContain(
43 |       'Trusting a folder allows Gemini to execute commands it suggests.',
44 |     );
45 |   });
46 | 
47 |   it('should call onSelect with DO_NOT_TRUST when escape is pressed and not restarting', async () => {
48 |     const onSelect = vi.fn();
49 |     const { stdin } = renderWithProviders(
50 |       <FolderTrustDialog onSelect={onSelect} isRestarting={false} />,
51 |     );
52 | 
53 |     stdin.write('\x1b'); // escape key
54 | 
55 |     await waitFor(() => {
56 |       expect(onSelect).toHaveBeenCalledWith(FolderTrustChoice.DO_NOT_TRUST);
57 |     });
58 |   });
59 | 
60 |   it('should not call onSelect when escape is pressed and is restarting', async () => {
61 |     const onSelect = vi.fn();
62 |     const { stdin } = renderWithProviders(
63 |       <FolderTrustDialog onSelect={onSelect} isRestarting={true} />,
64 |     );
65 | 
66 |     stdin.write('\x1b'); // escape key
67 | 
68 |     await waitFor(() => {
69 |       expect(onSelect).not.toHaveBeenCalled();
70 |     });
71 |   });
72 | 
73 |   it('should display restart message when isRestarting is true', () => {
74 |     const { lastFrame } = renderWithProviders(
75 |       <FolderTrustDialog onSelect={vi.fn()} isRestarting={true} />,
76 |     );
77 | 
78 |     expect(lastFrame()).toContain(' Gemini CLI is restarting');
79 |   });
80 | 
81 |   it('should call relaunchApp when isRestarting is true', async () => {
82 |     vi.useFakeTimers();
83 |     const relaunchApp = vi.spyOn(processUtils, 'relaunchApp');
84 |     renderWithProviders(
85 |       <FolderTrustDialog onSelect={vi.fn()} isRestarting={true} />,
86 |     );
87 |     await vi.advanceTimersByTimeAsync(1000);
88 |     expect(relaunchApp).toHaveBeenCalled();
89 |     vi.useRealTimers();
90 |   });
91 | 
92 |   it('should not call process.exit when "r" is pressed and isRestarting is false', async () => {
93 |     const { stdin } = renderWithProviders(
94 |       <FolderTrustDialog onSelect={vi.fn()} isRestarting={false} />,
95 |     );
96 | 
97 |     stdin.write('r');
98 | 
99 |     await waitFor(() => {
100 |       expect(mockedExit).not.toHaveBeenCalled();
101 |     });
102 |   });
103 | 
104 |   describe('directory display', () => {
105 |     it('should correctly display the folder name for a nested directory', () => {
106 |       mockedCwd.mockReturnValue('/home/user/project');
107 |       const { lastFrame } = renderWithProviders(
108 |         <FolderTrustDialog onSelect={vi.fn()} />,
109 |       );
110 |       expect(lastFrame()).toContain('Trust folder (project)');
111 |     });
112 | 
113 |     it('should correctly display the parent folder name for a nested directory', () => {
114 |       mockedCwd.mockReturnValue('/home/user/project');
115 |       const { lastFrame } = renderWithProviders(
116 |         <FolderTrustDialog onSelect={vi.fn()} />,
117 |       );
118 |       expect(lastFrame()).toContain('Trust parent folder (user)');
119 |     });
120 | 
121 |     it('should correctly display an empty parent folder name for a directory directly under root', () => {
122 |       mockedCwd.mockReturnValue('/project');
123 |       const { lastFrame } = renderWithProviders(
124 |         <FolderTrustDialog onSelect={vi.fn()} />,
125 |       );
126 |       expect(lastFrame()).toContain('Trust parent folder ()');
127 |     });
128 |   });
129 | });
```

src/ui/components/FolderTrustDialog.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { Box, Text } from 'ink';
8 | import type React from 'react';
9 | import { useEffect } from 'react';
10 | import { theme } from '../semantic-colors.js';
11 | import type { RadioSelectItem } from './shared/RadioButtonSelect.js';
12 | import { RadioButtonSelect } from './shared/RadioButtonSelect.js';
13 | import { useKeypress } from '../hooks/useKeypress.js';
14 | import * as process from 'node:process';
15 | import * as path from 'node:path';
16 | import { relaunchApp } from '../../utils/processUtils.js';
17 | 
18 | export enum FolderTrustChoice {
19 |   TRUST_FOLDER = 'trust_folder',
20 |   TRUST_PARENT = 'trust_parent',
21 |   DO_NOT_TRUST = 'do_not_trust',
22 | }
23 | 
24 | interface FolderTrustDialogProps {
25 |   onSelect: (choice: FolderTrustChoice) => void;
26 |   isRestarting?: boolean;
27 | }
28 | 
29 | export const FolderTrustDialog: React.FC<FolderTrustDialogProps> = ({
30 |   onSelect,
31 |   isRestarting,
32 | }) => {
33 |   useEffect(() => {
34 |     const doRelaunch = async () => {
35 |       if (isRestarting) {
36 |         setTimeout(async () => {
37 |           await relaunchApp();
38 |         }, 250);
39 |       }
40 |     };
41 |     doRelaunch();
42 |   }, [isRestarting]);
43 | 
44 |   useKeypress(
45 |     (key) => {
46 |       if (key.name === 'escape') {
47 |         onSelect(FolderTrustChoice.DO_NOT_TRUST);
48 |       }
49 |     },
50 |     { isActive: !isRestarting },
51 |   );
52 | 
53 |   const dirName = path.basename(process.cwd());
54 |   const parentFolder = path.basename(path.dirname(process.cwd()));
55 | 
56 |   const options: Array<RadioSelectItem<FolderTrustChoice>> = [
57 |     {
58 |       label: `Trust folder (${dirName})`,
59 |       value: FolderTrustChoice.TRUST_FOLDER,
60 |       key: `Trust folder (${dirName})`,
61 |     },
62 |     {
63 |       label: `Trust parent folder (${parentFolder})`,
64 |       value: FolderTrustChoice.TRUST_PARENT,
65 |       key: `Trust parent folder (${parentFolder})`,
66 |     },
67 |     {
68 |       label: "Don't trust (esc)",
69 |       value: FolderTrustChoice.DO_NOT_TRUST,
70 |       key: "Don't trust (esc)",
71 |     },
72 |   ];
73 | 
74 |   return (
75 |     <Box flexDirection="column">
76 |       <Box
77 |         flexDirection="column"
78 |         borderStyle="round"
79 |         borderColor={theme.status.warning}
80 |         padding={1}
81 |         width="100%"
82 |         marginLeft={1}
83 |       >
84 |         <Box flexDirection="column" marginBottom={1}>
85 |           <Text bold color={theme.text.primary}>
86 |             Do you trust this folder?
87 |           </Text>
88 |           <Text color={theme.text.primary}>
89 |             Trusting a folder allows Gemini to execute commands it suggests.
90 |             This is a security feature to prevent accidental execution in
91 |             untrusted directories.
92 |           </Text>
93 |         </Box>
94 | 
95 |         <RadioButtonSelect
96 |           items={options}
97 |           onSelect={onSelect}
98 |           isFocused={!isRestarting}
99 |         />
100 |       </Box>
101 |       {isRestarting && (
102 |         <Box marginLeft={1} marginTop={1}>
103 |           <Text color={theme.status.warning}>
104 |             Gemini CLI is restarting to apply the trust changes...
105 |           </Text>
106 |         </Box>
107 |       )}
108 |     </Box>
109 |   );
110 | };
```

src/ui/components/Footer.test.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import {
8 |   renderWithProviders,
9 |   createMockSettings,
10 | } from '../../test-utils/render.js';
11 | import { Footer } from './Footer.js';
12 | import { tildeifyPath } from '@google/gemini-cli-core';
13 | 
14 | vi.mock('@google/gemini-cli-core', async (importOriginal) => {
15 |   const original =
16 |     await importOriginal<typeof import('@google/gemini-cli-core')>();
17 |   return {
18 |     ...original,
19 |     shortenPath: (p: string, len: number) => {
20 |       if (p.length > len) {
21 |         return '...' + p.slice(p.length - len + 3);
22 |       }
23 |       return p;
24 |     },
25 |   };
26 | });
27 | 
28 | const defaultProps = {
29 |   model: 'gemini-pro',
30 |   targetDir:
31 |     '/Users/test/project/foo/bar/and/some/more/directories/to/make/it/long',
32 |   branchName: 'main',
33 | };
34 | 
35 | const sessionStats = {
36 |   sessionStats: { lastPromptTokenCount: 0, lastResponseTokenCount: 0 },
37 | };
38 | 
39 | describe('<Footer />', () => {
40 |   it('renders the component', () => {
41 |     const { lastFrame } = renderWithProviders(<Footer />, {
42 |       width: 120,
43 |       uiState: { branchName: defaultProps.branchName, ...sessionStats },
44 |     });
45 |     expect(lastFrame()).toBeDefined();
46 |   });
47 | 
48 |   describe('path display', () => {
49 |     it('should display a shortened path on a narrow terminal', () => {
50 |       const { lastFrame } = renderWithProviders(<Footer />, {
51 |         width: 79,
52 |         uiState: { ...sessionStats },
53 |       });
54 |       const tildePath = tildeifyPath(defaultProps.targetDir);
55 |       const pathLength = Math.max(20, Math.floor(79 * 0.25));
56 |       const expectedPath =
57 |         '...' + tildePath.slice(tildePath.length - pathLength + 3);
58 |       expect(lastFrame()).toContain(expectedPath);
59 |     });
60 | 
61 |     it('should use wide layout at 80 columns', () => {
62 |       const { lastFrame } = renderWithProviders(<Footer />, {
63 |         width: 80,
64 |         uiState: { ...sessionStats },
65 |       });
66 |       const tildePath = tildeifyPath(defaultProps.targetDir);
67 |       const expectedPath =
68 |         '...' + tildePath.slice(tildePath.length - 80 * 0.25 + 3);
69 |       expect(lastFrame()).toContain(expectedPath);
70 |     });
71 |   });
72 | 
73 |   it('displays the branch name when provided', () => {
74 |     const { lastFrame } = renderWithProviders(<Footer />, {
75 |       width: 120,
76 |       uiState: { branchName: defaultProps.branchName, ...sessionStats },
77 |     });
78 |     expect(lastFrame()).toContain(`(${defaultProps.branchName}*)`);
79 |   });
80 | 
81 |   it('does not display the branch name when not provided', () => {
82 |     const { lastFrame } = renderWithProviders(<Footer />, {
83 |       width: 120,
84 |       uiState: { branchName: undefined, ...sessionStats },
85 |     });
86 |     expect(lastFrame()).not.toContain(`(${defaultProps.branchName}*)`);
87 |   });
88 | 
89 |   it('displays the model name and context percentage', () => {
90 |     const { lastFrame } = renderWithProviders(<Footer />, {
91 |       width: 120,
92 |       uiState: { ...sessionStats },
93 |     });
94 |     expect(lastFrame()).toContain(defaultProps.model);
95 |     expect(lastFrame()).toMatch(/\(\d+% context left\)/);
96 |   });
97 | 
98 |   it('displays the model name and abbreviated context percentage', () => {
99 |     const { lastFrame } = renderWithProviders(<Footer />, {
100 |       width: 99,
101 |       uiState: { ...sessionStats },
102 |     });
103 |     expect(lastFrame()).toContain(defaultProps.model);
104 |     expect(lastFrame()).toMatch(/\(\d+%\)/);
105 |   });
106 | 
107 |   describe('sandbox and trust info', () => {
108 |     it('should display untrusted when isTrustedFolder is false', () => {
109 |       const { lastFrame } = renderWithProviders(<Footer />, {
110 |         width: 120,
111 |         uiState: { isTrustedFolder: false, ...sessionStats },
112 |       });
113 |       expect(lastFrame()).toContain('untrusted');
114 |     });
115 | 
116 |     it('should display custom sandbox info when SANDBOX env is set', () => {
117 |       vi.stubEnv('SANDBOX', 'gemini-cli-test-sandbox');
118 |       const { lastFrame } = renderWithProviders(<Footer />, {
119 |         width: 120,
120 |         uiState: { isTrustedFolder: undefined, ...sessionStats },
121 |       });
122 |       expect(lastFrame()).toContain('test');
123 |       vi.unstubAllEnvs();
124 |     });
125 | 
126 |     it('should display macOS Seatbelt info when SANDBOX is sandbox-exec', () => {
127 |       vi.stubEnv('SANDBOX', 'sandbox-exec');
128 |       vi.stubEnv('SEATBELT_PROFILE', 'test-profile');
129 |       const { lastFrame } = renderWithProviders(<Footer />, {
130 |         width: 120,
131 |         uiState: { isTrustedFolder: true, ...sessionStats },
132 |       });
133 |       expect(lastFrame()).toMatch(/macOS Seatbelt.*\(test-profile\)/s);
134 |       vi.unstubAllEnvs();
135 |     });
136 | 
137 |     it('should display "no sandbox" when SANDBOX is not set and folder is trusted', () => {
138 |       // Clear any SANDBOX env var that might be set.
139 |       vi.stubEnv('SANDBOX', '');
140 |       const { lastFrame } = renderWithProviders(<Footer />, {
141 |         width: 120,
142 |         uiState: { isTrustedFolder: true, ...sessionStats },
143 |       });
144 |       expect(lastFrame()).toContain('no sandbox');
145 |       vi.unstubAllEnvs();
146 |     });
147 | 
148 |     it('should prioritize untrusted message over sandbox info', () => {
149 |       vi.stubEnv('SANDBOX', 'gemini-cli-test-sandbox');
150 |       const { lastFrame } = renderWithProviders(<Footer />, {
151 |         width: 120,
152 |         uiState: { isTrustedFolder: false, ...sessionStats },
153 |       });
154 |       expect(lastFrame()).toContain('untrusted');
155 |       expect(lastFrame()).not.toMatch(/test-sandbox/s);
156 |       vi.unstubAllEnvs();
157 |     });
158 |   });
159 | 
160 |   describe('footer configuration filtering (golden snapshots)', () => {
161 |     it('renders complete footer with all sections visible (baseline)', () => {
162 |       const { lastFrame } = renderWithProviders(<Footer />, {
163 |         width: 120,
164 |         uiState: { ...sessionStats },
165 |       });
166 |       expect(lastFrame()).toMatchSnapshot('complete-footer-wide');
167 |     });
168 | 
169 |     it('renders footer with all optional sections hidden (minimal footer)', () => {
170 |       const { lastFrame } = renderWithProviders(<Footer />, {
171 |         width: 120,
172 |         uiState: { ...sessionStats },
173 |         settings: createMockSettings({
174 |           ui: {
175 |             footer: {
176 |               hideCWD: true,
177 |               hideSandboxStatus: true,
178 |               hideModelInfo: true,
179 |             },
180 |           },
181 |         }),
182 |       });
183 |       expect(lastFrame()).toMatchSnapshot('footer-minimal');
184 |     });
185 | 
186 |     it('renders footer with only model info hidden (partial filtering)', () => {
187 |       const { lastFrame } = renderWithProviders(<Footer />, {
188 |         width: 120,
189 |         uiState: { ...sessionStats },
190 |         settings: createMockSettings({
191 |           ui: {
192 |             footer: {
193 |               hideCWD: false,
194 |               hideSandboxStatus: false,
195 |               hideModelInfo: true,
196 |             },
197 |           },
198 |         }),
199 |       });
200 |       expect(lastFrame()).toMatchSnapshot('footer-no-model');
201 |     });
202 | 
203 |     it('renders footer with CWD and model info hidden to test alignment (only sandbox visible)', () => {
204 |       const { lastFrame } = renderWithProviders(<Footer />, {
205 |         width: 120,
206 |         uiState: { ...sessionStats },
207 |         settings: createMockSettings({
208 |           ui: {
209 |             footer: {
210 |               hideCWD: true,
211 |               hideSandboxStatus: false,
212 |               hideModelInfo: true,
213 |             },
214 |           },
215 |         }),
216 |       });
217 |       expect(lastFrame()).toMatchSnapshot('footer-only-sandbox');
218 |     });
219 | 
220 |     it('renders complete footer in narrow terminal (baseline narrow)', () => {
221 |       const { lastFrame } = renderWithProviders(<Footer />, {
222 |         width: 79,
223 |         uiState: { ...sessionStats },
224 |       });
225 |       expect(lastFrame()).toMatchSnapshot('complete-footer-narrow');
226 |     });
227 |   });
228 | });
```

src/ui/components/Footer.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type React from 'react';
8 | import { Box, Text } from 'ink';
9 | import { theme } from '../semantic-colors.js';
10 | import { shortenPath, tildeifyPath } from '@google/gemini-cli-core';
11 | import { ConsoleSummaryDisplay } from './ConsoleSummaryDisplay.js';
12 | import process from 'node:process';
13 | import Gradient from 'ink-gradient';
14 | import { MemoryUsageDisplay } from './MemoryUsageDisplay.js';
15 | import { ContextUsageDisplay } from './ContextUsageDisplay.js';
16 | import { DebugProfiler } from './DebugProfiler.js';
17 | import { isDevelopment } from '../../utils/installationInfo.js';
18 | 
19 | import { useUIState } from '../contexts/UIStateContext.js';
20 | import { useConfig } from '../contexts/ConfigContext.js';
21 | import { useSettings } from '../contexts/SettingsContext.js';
22 | import { useVimMode } from '../contexts/VimModeContext.js';
23 | 
24 | export const Footer: React.FC = () => {
25 |   const uiState = useUIState();
26 |   const config = useConfig();
27 |   const settings = useSettings();
28 |   const { vimEnabled, vimMode } = useVimMode();
29 | 
30 |   const {
31 |     model,
32 |     targetDir,
33 |     debugMode,
34 |     branchName,
35 |     debugMessage,
36 |     corgiMode,
37 |     errorCount,
38 |     showErrorDetails,
39 |     promptTokenCount,
40 |     nightly,
41 |     isTrustedFolder,
42 |     mainAreaWidth,
43 |   } = {
44 |     model: config.getModel(),
45 |     targetDir: config.getTargetDir(),
46 |     debugMode: config.getDebugMode(),
47 |     branchName: uiState.branchName,
48 |     debugMessage: uiState.debugMessage,
49 |     corgiMode: uiState.corgiMode,
50 |     errorCount: uiState.errorCount,
51 |     showErrorDetails: uiState.showErrorDetails,
52 |     promptTokenCount: uiState.sessionStats.lastPromptTokenCount,
53 |     nightly: uiState.nightly,
54 |     isTrustedFolder: uiState.isTrustedFolder,
55 |     mainAreaWidth: uiState.mainAreaWidth,
56 |   };
57 | 
58 |   const showMemoryUsage =
59 |     config.getDebugMode() || settings.merged.ui?.showMemoryUsage || false;
60 |   const hideCWD = settings.merged.ui?.footer?.hideCWD || false;
61 |   const hideSandboxStatus =
62 |     settings.merged.ui?.footer?.hideSandboxStatus || false;
63 |   const hideModelInfo = settings.merged.ui?.footer?.hideModelInfo || false;
64 | 
65 |   const pathLength = Math.max(20, Math.floor(mainAreaWidth * 0.25));
66 |   const displayPath = shortenPath(tildeifyPath(targetDir), pathLength);
67 | 
68 |   const justifyContent = hideCWD && hideModelInfo ? 'center' : 'space-between';
69 |   const displayVimMode = vimEnabled ? vimMode : undefined;
70 | 
71 |   const showDebugProfiler = debugMode || isDevelopment;
72 | 
73 |   return (
74 |     <Box
75 |       justifyContent={justifyContent}
76 |       width={mainAreaWidth}
77 |       flexDirection="row"
78 |       alignItems="center"
79 |       paddingX={1}
80 |     >
81 |       {(showDebugProfiler || displayVimMode || !hideCWD) && (
82 |         <Box>
83 |           {showDebugProfiler && <DebugProfiler />}
84 |           {displayVimMode && (
85 |             <Text color={theme.text.secondary}>[{displayVimMode}] </Text>
86 |           )}
87 |           {!hideCWD &&
88 |             (nightly ? (
89 |               <Gradient colors={theme.ui.gradient}>
90 |                 <Text>
91 |                   {displayPath}
92 |                   {branchName && <Text> ({branchName}*)</Text>}
93 |                 </Text>
94 |               </Gradient>
95 |             ) : (
96 |               <Text color={theme.text.link}>
97 |                 {displayPath}
98 |                 {branchName && (
99 |                   <Text color={theme.text.secondary}> ({branchName}*)</Text>
100 |                 )}
101 |               </Text>
102 |             ))}
103 |           {debugMode && (
104 |             <Text color={theme.status.error}>
105 |               {' ' + (debugMessage || '--debug')}
106 |             </Text>
107 |           )}
108 |         </Box>
109 |       )}
110 | 
111 |       {/* Middle Section: Centered Trust/Sandbox Info */}
112 |       {!hideSandboxStatus && (
113 |         <Box
114 |           flexGrow={1}
115 |           alignItems="center"
116 |           justifyContent="center"
117 |           display="flex"
118 |         >
119 |           {isTrustedFolder === false ? (
120 |             <Text color={theme.status.warning}>untrusted</Text>
121 |           ) : process.env['SANDBOX'] &&
122 |             process.env['SANDBOX'] !== 'sandbox-exec' ? (
123 |             <Text color="green">
124 |               {process.env['SANDBOX'].replace(/^gemini-(?:cli-)?/, '')}
125 |             </Text>
126 |           ) : process.env['SANDBOX'] === 'sandbox-exec' ? (
127 |             <Text color={theme.status.warning}>
128 |               macOS Seatbelt{' '}
129 |               <Text color={theme.text.secondary}>
130 |                 ({process.env['SEATBELT_PROFILE']})
131 |               </Text>
132 |             </Text>
133 |           ) : (
134 |             <Text color={theme.status.error}>
135 |               no sandbox
136 |               {mainAreaWidth >= 100 && (
137 |                 <Text color={theme.text.secondary}> (see /docs)</Text>
138 |               )}
139 |             </Text>
140 |           )}
141 |         </Box>
142 |       )}
143 | 
144 |       {/* Right Section: Gemini Label and Console Summary */}
145 |       {!hideModelInfo && (
146 |         <Box alignItems="center" justifyContent="flex-end">
147 |           <Box alignItems="center">
148 |             <Text color={theme.text.accent}>
149 |               {model}{' '}
150 |               <ContextUsageDisplay
151 |                 promptTokenCount={promptTokenCount}
152 |                 model={model}
153 |                 terminalWidth={mainAreaWidth}
154 |               />
155 |             </Text>
156 |             {showMemoryUsage && <MemoryUsageDisplay />}
157 |           </Box>
158 |           <Box alignItems="center">
159 |             {corgiMode && (
160 |               <Box paddingLeft={1} flexDirection="row">
161 |                 <Text>
162 |                   <Text color={theme.ui.symbol}>| </Text>
163 |                   <Text color={theme.status.error}>▼</Text>
164 |                   <Text color={theme.text.primary}>(´</Text>
165 |                   <Text color={theme.status.error}>ᴥ</Text>
166 |                   <Text color={theme.text.primary}>`)</Text>
167 |                   <Text color={theme.status.error}>▼</Text>
168 |                 </Text>
169 |               </Box>
170 |             )}
171 |             {!showErrorDetails && errorCount > 0 && (
172 |               <Box paddingLeft={1} flexDirection="row">
173 |                 <Text color={theme.ui.symbol}>| </Text>
174 |                 <ConsoleSummaryDisplay errorCount={errorCount} />
175 |               </Box>
176 |             )}
177 |           </Box>
178 |         </Box>
179 |       )}
180 |     </Box>
181 |   );
182 | };
```

src/ui/components/GeminiRespondingSpinner.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type React from 'react';
8 | import { Text, useIsScreenReaderEnabled } from 'ink';
9 | import { CliSpinner } from './CliSpinner.js';
10 | import type { SpinnerName } from 'cli-spinners';
11 | import { useStreamingContext } from '../contexts/StreamingContext.js';
12 | import { StreamingState } from '../types.js';
13 | import {
14 |   SCREEN_READER_LOADING,
15 |   SCREEN_READER_RESPONDING,
16 | } from '../textConstants.js';
17 | import { theme } from '../semantic-colors.js';
18 | 
19 | interface GeminiRespondingSpinnerProps {
20 |   /**
21 |    * Optional string to display when not in Responding state.
22 |    * If not provided and not Responding, renders null.
23 |    */
24 |   nonRespondingDisplay?: string;
25 |   spinnerType?: SpinnerName;
26 | }
27 | 
28 | export const GeminiRespondingSpinner: React.FC<
29 |   GeminiRespondingSpinnerProps
30 | > = ({ nonRespondingDisplay, spinnerType = 'dots' }) => {
31 |   const streamingState = useStreamingContext();
32 |   const isScreenReaderEnabled = useIsScreenReaderEnabled();
33 |   if (streamingState === StreamingState.Responding) {
34 |     return (
35 |       <GeminiSpinner
36 |         spinnerType={spinnerType}
37 |         altText={SCREEN_READER_RESPONDING}
38 |       />
39 |     );
40 |   } else if (nonRespondingDisplay) {
41 |     return isScreenReaderEnabled ? (
42 |       <Text>{SCREEN_READER_LOADING}</Text>
43 |     ) : (
44 |       <Text color={theme.text.primary}>{nonRespondingDisplay}</Text>
45 |     );
46 |   }
47 |   return null;
48 | };
49 | 
50 | interface GeminiSpinnerProps {
51 |   spinnerType?: SpinnerName;
52 |   altText?: string;
53 | }
54 | 
55 | export const GeminiSpinner: React.FC<GeminiSpinnerProps> = ({
56 |   spinnerType = 'dots',
57 |   altText,
58 | }) => {
59 |   const isScreenReaderEnabled = useIsScreenReaderEnabled();
60 |   return isScreenReaderEnabled ? (
61 |     <Text>{altText}</Text>
62 |   ) : (
63 |     <Text color={theme.text.primary}>
64 |       <CliSpinner type={spinnerType} />
65 |     </Text>
66 |   );
67 | };
```

src/ui/components/Header.test.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { render } from 'ink-testing-library';
8 | import { describe, it, expect, vi, beforeEach } from 'vitest';
9 | import { Header } from './Header.js';
10 | import * as useTerminalSize from '../hooks/useTerminalSize.js';
11 | import { longAsciiLogo } from './AsciiArt.js';
12 | 
13 | vi.mock('../hooks/useTerminalSize.js');
14 | 
15 | describe('<Header />', () => {
16 |   beforeEach(() => {});
17 | 
18 |   it('renders the long logo on a wide terminal', () => {
19 |     vi.spyOn(useTerminalSize, 'useTerminalSize').mockReturnValue({
20 |       columns: 120,
21 |       rows: 20,
22 |     });
23 |     const { lastFrame } = render(<Header version="1.0.0" nightly={false} />);
24 |     expect(lastFrame()).toContain(longAsciiLogo);
25 |   });
26 | 
27 |   it('renders custom ASCII art when provided', () => {
28 |     const customArt = 'CUSTOM ART';
29 |     const { lastFrame } = render(
30 |       <Header version="1.0.0" nightly={false} customAsciiArt={customArt} />,
31 |     );
32 |     expect(lastFrame()).toContain(customArt);
33 |   });
34 | 
35 |   it('displays the version number when nightly is true', () => {
36 |     const { lastFrame } = render(<Header version="1.0.0" nightly={true} />);
37 |     expect(lastFrame()).toContain('v1.0.0');
38 |   });
39 | 
40 |   it('does not display the version number when nightly is false', () => {
41 |     const { lastFrame } = render(<Header version="1.0.0" nightly={false} />);
42 |     expect(lastFrame()).not.toContain('v1.0.0');
43 |   });
44 | });
```

src/ui/components/Header.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type React from 'react';
8 | import { Box, Text } from 'ink';
9 | import Gradient from 'ink-gradient';
10 | import { theme } from '../semantic-colors.js';
11 | import { shortAsciiLogo, longAsciiLogo, tinyAsciiLogo } from './AsciiArt.js';
12 | import { getAsciiArtWidth } from '../utils/textUtils.js';
13 | import { useTerminalSize } from '../hooks/useTerminalSize.js';
14 | 
15 | interface HeaderProps {
16 |   customAsciiArt?: string; // For user-defined ASCII art
17 |   version: string;
18 |   nightly: boolean;
19 | }
20 | 
21 | export const Header: React.FC<HeaderProps> = ({
22 |   customAsciiArt,
23 |   version,
24 |   nightly,
25 | }) => {
26 |   const { columns: terminalWidth } = useTerminalSize();
27 |   let displayTitle;
28 |   const widthOfLongLogo = getAsciiArtWidth(longAsciiLogo);
29 |   const widthOfShortLogo = getAsciiArtWidth(shortAsciiLogo);
30 | 
31 |   if (customAsciiArt) {
32 |     displayTitle = customAsciiArt;
33 |   } else if (terminalWidth >= widthOfLongLogo) {
34 |     displayTitle = longAsciiLogo;
35 |   } else if (terminalWidth >= widthOfShortLogo) {
36 |     displayTitle = shortAsciiLogo;
37 |   } else {
38 |     displayTitle = tinyAsciiLogo;
39 |   }
40 | 
41 |   const artWidth = getAsciiArtWidth(displayTitle);
42 | 
43 |   return (
44 |     <Box
45 |       alignItems="flex-start"
46 |       width={artWidth}
47 |       flexShrink={0}
48 |       flexDirection="column"
49 |     >
50 |       {theme.ui.gradient ? (
51 |         <Gradient colors={theme.ui.gradient}>
52 |           <Text>{displayTitle}</Text>
53 |         </Gradient>
54 |       ) : (
55 |         <Text>{displayTitle}</Text>
56 |       )}
57 |       {nightly && (
58 |         <Box width="100%" flexDirection="row" justifyContent="flex-end">
59 |           {theme.ui.gradient ? (
60 |             <Gradient colors={theme.ui.gradient}>
61 |               <Text>v{version}</Text>
62 |             </Gradient>
63 |           ) : (
64 |             <Text>v{version}</Text>
65 |           )}
66 |         </Box>
67 |       )}
68 |     </Box>
69 |   );
70 | };
```

src/ui/components/Help.test.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | /** @vitest-environment jsdom */
8 | 
9 | import { render } from 'ink-testing-library';
10 | import { describe, it, expect } from 'vitest';
11 | import { Help } from './Help.js';
12 | import type { SlashCommand } from '../commands/types.js';
13 | import { CommandKind } from '../commands/types.js';
14 | 
15 | const mockCommands: readonly SlashCommand[] = [
16 |   {
17 |     name: 'test',
18 |     description: 'A test command',
19 |     kind: CommandKind.BUILT_IN,
20 |   },
21 |   {
22 |     name: 'hidden',
23 |     description: 'A hidden command',
24 |     hidden: true,
25 |     kind: CommandKind.BUILT_IN,
26 |   },
27 |   {
28 |     name: 'parent',
29 |     description: 'A parent command',
30 |     kind: CommandKind.BUILT_IN,
31 |     subCommands: [
32 |       {
33 |         name: 'visible-child',
34 |         description: 'A visible child command',
35 |         kind: CommandKind.BUILT_IN,
36 |       },
37 |       {
38 |         name: 'hidden-child',
39 |         description: 'A hidden child command',
40 |         hidden: true,
41 |         kind: CommandKind.BUILT_IN,
42 |       },
43 |     ],
44 |   },
45 | ];
46 | 
47 | describe('Help Component', () => {
48 |   it('should not render hidden commands', () => {
49 |     const { lastFrame } = render(<Help commands={mockCommands} />);
50 |     const output = lastFrame();
51 | 
52 |     expect(output).toContain('/test');
53 |     expect(output).not.toContain('/hidden');
54 |   });
55 | 
56 |   it('should not render hidden subcommands', () => {
57 |     const { lastFrame } = render(<Help commands={mockCommands} />);
58 |     const output = lastFrame();
59 | 
60 |     expect(output).toContain('visible-child');
61 |     expect(output).not.toContain('hidden-child');
62 |   });
63 | });
```

src/ui/components/Help.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type React from 'react';
8 | import { Box, Text } from 'ink';
9 | import { theme } from '../semantic-colors.js';
10 | import { type SlashCommand, CommandKind } from '../commands/types.js';
11 | 
12 | interface Help {
13 |   commands: readonly SlashCommand[];
14 | }
15 | 
16 | export const Help: React.FC<Help> = ({ commands }) => (
17 |   <Box
18 |     flexDirection="column"
19 |     marginBottom={1}
20 |     borderColor={theme.border.default}
21 |     borderStyle="round"
22 |     padding={1}
23 |   >
24 |     {/* Basics */}
25 |     <Text bold color={theme.text.primary}>
26 |       Basics:
27 |     </Text>
28 |     <Text color={theme.text.primary}>
29 |       <Text bold color={theme.text.accent}>
30 |         Add context
31 |       </Text>
32 |       : Use{' '}
33 |       <Text bold color={theme.text.accent}>
34 |         @
35 |       </Text>{' '}
36 |       to specify files for context (e.g.,{' '}
37 |       <Text bold color={theme.text.accent}>
38 |         @src/myFile.ts
39 |       </Text>
40 |       ) to target specific files or folders.
41 |     </Text>
42 |     <Text color={theme.text.primary}>
43 |       <Text bold color={theme.text.accent}>
44 |         Shell mode
45 |       </Text>
46 |       : Execute shell commands via{' '}
47 |       <Text bold color={theme.text.accent}>
48 |         !
49 |       </Text>{' '}
50 |       (e.g.,{' '}
51 |       <Text bold color={theme.text.accent}>
52 |         !npm run start
53 |       </Text>
54 |       ) or use natural language (e.g.{' '}
55 |       <Text bold color={theme.text.accent}>
56 |         start server
57 |       </Text>
58 |       ).
59 |     </Text>
60 | 
61 |     <Box height={1} />
62 | 
63 |     {/* Commands */}
64 |     <Text bold color={theme.text.primary}>
65 |       Commands:
66 |     </Text>
67 |     {commands
68 |       .filter((command) => command.description && !command.hidden)
69 |       .map((command: SlashCommand) => (
70 |         <Box key={command.name} flexDirection="column">
71 |           <Text color={theme.text.primary}>
72 |             <Text bold color={theme.text.accent}>
73 |               {' '}
74 |               /{command.name}
75 |             </Text>
76 |             {command.kind === CommandKind.MCP_PROMPT && (
77 |               <Text color={theme.text.secondary}> [MCP]</Text>
78 |             )}
79 |             {command.description && ' - ' + command.description}
80 |           </Text>
81 |           {command.subCommands &&
82 |             command.subCommands
83 |               .filter((subCommand) => !subCommand.hidden)
84 |               .map((subCommand) => (
85 |                 <Text key={subCommand.name} color={theme.text.primary}>
86 |                   <Text bold color={theme.text.accent}>
87 |                     {'   '}
88 |                     {subCommand.name}
89 |                   </Text>
90 |                   {subCommand.description && ' - ' + subCommand.description}
91 |                 </Text>
92 |               ))}
93 |         </Box>
94 |       ))}
95 |     <Text color={theme.text.primary}>
96 |       <Text bold color={theme.text.accent}>
97 |         {' '}
98 |         !{' '}
99 |       </Text>
100 |       - shell command
101 |     </Text>
102 |     <Text color={theme.text.primary}>
103 |       <Text color={theme.text.secondary}>[MCP]</Text> - Model Context Protocol
104 |       command (from external servers)
105 |     </Text>
106 | 
107 |     <Box height={1} />
108 | 
109 |     {/* Shortcuts */}
110 |     <Text bold color={theme.text.primary}>
111 |       Keyboard Shortcuts:
112 |     </Text>
113 |     <Text color={theme.text.primary}>
114 |       <Text bold color={theme.text.accent}>
115 |         Alt+Left/Right
116 |       </Text>{' '}
117 |       - Jump through words in the input
118 |     </Text>
119 |     <Text color={theme.text.primary}>
120 |       <Text bold color={theme.text.accent}>
121 |         Ctrl+C
122 |       </Text>{' '}
123 |       - Quit application
124 |     </Text>
125 |     <Text color={theme.text.primary}>
126 |       <Text bold color={theme.text.accent}>
127 |         {process.platform === 'win32' ? 'Ctrl+Enter' : 'Ctrl+J'}
128 |       </Text>{' '}
129 |       {process.platform === 'linux'
130 |         ? '- New line (Alt+Enter works for certain linux distros)'
131 |         : '- New line'}
132 |     </Text>
133 |     <Text color={theme.text.primary}>
134 |       <Text bold color={theme.text.accent}>
135 |         Ctrl+L
136 |       </Text>{' '}
137 |       - Clear the screen
138 |     </Text>
139 |     <Text color={theme.text.primary}>
140 |       <Text bold color={theme.text.accent}>
141 |         {process.platform === 'darwin' ? 'Ctrl+X / Meta+Enter' : 'Ctrl+X'}
142 |       </Text>{' '}
143 |       - Open input in external editor
144 |     </Text>
145 |     <Text color={theme.text.primary}>
146 |       <Text bold color={theme.text.accent}>
147 |         Ctrl+Y
148 |       </Text>{' '}
149 |       - Toggle YOLO mode
150 |     </Text>
151 |     <Text color={theme.text.primary}>
152 |       <Text bold color={theme.text.accent}>
153 |         Enter
154 |       </Text>{' '}
155 |       - Send message
156 |     </Text>
157 |     <Text color={theme.text.primary}>
158 |       <Text bold color={theme.text.accent}>
159 |         Esc
160 |       </Text>{' '}
161 |       - Cancel operation / Clear input (double press)
162 |     </Text>
163 |     <Text color={theme.text.primary}>
164 |       <Text bold color={theme.text.accent}>
165 |         Shift+Tab
166 |       </Text>{' '}
167 |       - Toggle auto-accepting edits
168 |     </Text>
169 |     <Text color={theme.text.primary}>
170 |       <Text bold color={theme.text.accent}>
171 |         Up/Down
172 |       </Text>{' '}
173 |       - Cycle through your prompt history
174 |     </Text>
175 |     <Box height={1} />
176 |     <Text color={theme.text.primary}>
177 |       For a full list of shortcuts, see{' '}
178 |       <Text bold color={theme.text.accent}>
179 |         docs/cli/keyboard-shortcuts.md
180 |       </Text>
181 |     </Text>
182 |   </Box>
183 | );
```

src/ui/components/HistoryItemDisplay.test.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect, vi } from 'vitest';
8 | import { HistoryItemDisplay } from './HistoryItemDisplay.js';
9 | import { type HistoryItem, ToolCallStatus } from '../types.js';
10 | import { MessageType } from '../types.js';
11 | import { SessionStatsProvider } from '../contexts/SessionContext.js';
12 | import type {
13 |   Config,
14 |   ToolExecuteConfirmationDetails,
15 | } from '@google/gemini-cli-core';
16 | import { ToolGroupMessage } from './messages/ToolGroupMessage.js';
17 | import { renderWithProviders } from '../../test-utils/render.js';
18 | 
19 | // Mock child components
20 | vi.mock('./messages/ToolGroupMessage.js', () => ({
21 |   ToolGroupMessage: vi.fn(() => <div />),
22 | }));
23 | 
24 | describe('<HistoryItemDisplay />', () => {
25 |   const mockConfig = {} as unknown as Config;
26 |   const baseItem = {
27 |     id: 1,
28 |     timestamp: 12345,
29 |     isPending: false,
30 |     terminalWidth: 80,
31 |     config: mockConfig,
32 |   };
33 | 
34 |   it('renders UserMessage for "user" type', () => {
35 |     const item: HistoryItem = {
36 |       ...baseItem,
37 |       type: MessageType.USER,
38 |       text: 'Hello',
39 |     };
40 |     const { lastFrame } = renderWithProviders(
41 |       <HistoryItemDisplay {...baseItem} item={item} />,
42 |     );
43 |     expect(lastFrame()).toContain('Hello');
44 |   });
45 | 
46 |   it('renders UserMessage for "user" type with slash command', () => {
47 |     const item: HistoryItem = {
48 |       ...baseItem,
49 |       type: MessageType.USER,
50 |       text: '/theme',
51 |     };
52 |     const { lastFrame } = renderWithProviders(
53 |       <HistoryItemDisplay {...baseItem} item={item} />,
54 |     );
55 |     expect(lastFrame()).toContain('/theme');
56 |   });
57 | 
58 |   it('renders StatsDisplay for "stats" type', () => {
59 |     const item: HistoryItem = {
60 |       ...baseItem,
61 |       type: MessageType.STATS,
62 |       duration: '1s',
63 |     };
64 |     const { lastFrame } = renderWithProviders(
65 |       <SessionStatsProvider>
66 |         <HistoryItemDisplay {...baseItem} item={item} />
67 |       </SessionStatsProvider>,
68 |     );
69 |     expect(lastFrame()).toContain('Stats');
70 |   });
71 | 
72 |   it('renders AboutBox for "about" type', () => {
73 |     const item: HistoryItem = {
74 |       ...baseItem,
75 |       type: MessageType.ABOUT,
76 |       cliVersion: '1.0.0',
77 |       osVersion: 'test-os',
78 |       sandboxEnv: 'test-env',
79 |       modelVersion: 'test-model',
80 |       selectedAuthType: 'test-auth',
81 |       gcpProject: 'test-project',
82 |       ideClient: 'test-ide',
83 |     };
84 |     const { lastFrame } = renderWithProviders(
85 |       <HistoryItemDisplay {...baseItem} item={item} />,
86 |     );
87 |     expect(lastFrame()).toContain('About Gemini CLI');
88 |   });
89 | 
90 |   it('renders ModelStatsDisplay for "model_stats" type', () => {
91 |     const item: HistoryItem = {
92 |       ...baseItem,
93 |       type: 'model_stats',
94 |     };
95 |     const { lastFrame } = renderWithProviders(
96 |       <SessionStatsProvider>
97 |         <HistoryItemDisplay {...baseItem} item={item} />
98 |       </SessionStatsProvider>,
99 |     );
100 |     expect(lastFrame()).toContain(
101 |       'No API calls have been made in this session.',
102 |     );
103 |   });
104 | 
105 |   it('renders ToolStatsDisplay for "tool_stats" type', () => {
106 |     const item: HistoryItem = {
107 |       ...baseItem,
108 |       type: 'tool_stats',
109 |     };
110 |     const { lastFrame } = renderWithProviders(
111 |       <SessionStatsProvider>
112 |         <HistoryItemDisplay {...baseItem} item={item} />
113 |       </SessionStatsProvider>,
114 |     );
115 |     expect(lastFrame()).toContain(
116 |       'No tool calls have been made in this session.',
117 |     );
118 |   });
119 | 
120 |   it('renders SessionSummaryDisplay for "quit" type', () => {
121 |     const item: HistoryItem = {
122 |       ...baseItem,
123 |       type: 'quit',
124 |       duration: '1s',
125 |     };
126 |     const { lastFrame } = renderWithProviders(
127 |       <SessionStatsProvider>
128 |         <HistoryItemDisplay {...baseItem} item={item} />
129 |       </SessionStatsProvider>,
130 |     );
131 |     expect(lastFrame()).toContain('Agent powering down. Goodbye!');
132 |   });
133 | 
134 |   it('should escape ANSI codes in text content', () => {
135 |     const historyItem: HistoryItem = {
136 |       id: 1,
137 |       type: 'user',
138 |       text: 'Hello, \u001b[31mred\u001b[0m world!',
139 |     };
140 | 
141 |     const { lastFrame } = renderWithProviders(
142 |       <HistoryItemDisplay
143 |         item={historyItem}
144 |         terminalWidth={80}
145 |         isPending={false}
146 |       />,
147 |     );
148 | 
149 |     // The ANSI codes should be escaped for display.
150 |     expect(lastFrame()).toContain('Hello, \\u001b[31mred\\u001b[0m world!');
151 |     // The raw ANSI codes should not be present.
152 |     expect(lastFrame()).not.toContain('Hello, \u001b[31mred\u001b[0m world!');
153 |   });
154 | 
155 |   it('should escape ANSI codes in tool confirmation details', () => {
156 |     const historyItem: HistoryItem = {
157 |       id: 1,
158 |       type: 'tool_group',
159 |       tools: [
160 |         {
161 |           callId: '123',
162 |           name: 'run_shell_command',
163 |           description: 'Run a shell command',
164 |           resultDisplay: 'blank',
165 |           status: ToolCallStatus.Confirming,
166 |           confirmationDetails: {
167 |             type: 'exec',
168 |             title: 'Run Shell Command',
169 |             command: 'echo "\u001b[31mhello\u001b[0m"',
170 |             rootCommand: 'echo',
171 |             onConfirm: async () => {},
172 |           },
173 |         },
174 |       ],
175 |     };
176 | 
177 |     renderWithProviders(
178 |       <HistoryItemDisplay
179 |         item={historyItem}
180 |         terminalWidth={80}
181 |         isPending={false}
182 |       />,
183 |     );
184 | 
185 |     const passedProps = vi.mocked(ToolGroupMessage).mock.calls[0][0];
186 |     const confirmationDetails = passedProps.toolCalls[0]
187 |       .confirmationDetails as ToolExecuteConfirmationDetails;
188 | 
189 |     expect(confirmationDetails.command).toBe(
190 |       'echo "\\u001b[31mhello\\u001b[0m"',
191 |     );
192 |   });
193 | 
194 |   const longCode =
195 |     '# Example code block:\n' +
196 |     '```python\n' +
197 |     Array.from({ length: 50 }, (_, i) => `Line ${i + 1}`).join('\n') +
198 |     '\n```';
199 | 
200 |   it('should render a truncated gemini item', () => {
201 |     const item: HistoryItem = {
202 |       id: 1,
203 |       type: 'gemini',
204 |       text: longCode,
205 |     };
206 |     const { lastFrame } = renderWithProviders(
207 |       <HistoryItemDisplay
208 |         item={item}
209 |         isPending={false}
210 |         terminalWidth={80}
211 |         availableTerminalHeight={10}
212 |       />,
213 |     );
214 | 
215 |     expect(lastFrame()).toMatchSnapshot();
216 |   });
217 | 
218 |   it('should render a full gemini item when using availableTerminalHeightGemini', () => {
219 |     const item: HistoryItem = {
220 |       id: 1,
221 |       type: 'gemini',
222 |       text: longCode,
223 |     };
224 |     const { lastFrame } = renderWithProviders(
225 |       <HistoryItemDisplay
226 |         item={item}
227 |         isPending={false}
228 |         terminalWidth={80}
229 |         availableTerminalHeight={10}
230 |         availableTerminalHeightGemini={Number.MAX_SAFE_INTEGER}
231 |       />,
232 |     );
233 | 
234 |     expect(lastFrame()).toMatchSnapshot();
235 |   });
236 | 
237 |   it('should render a truncated gemini_content item', () => {
238 |     const item: HistoryItem = {
239 |       id: 1,
240 |       type: 'gemini_content',
241 |       text: longCode,
242 |     };
243 |     const { lastFrame } = renderWithProviders(
244 |       <HistoryItemDisplay
245 |         item={item}
246 |         isPending={false}
247 |         terminalWidth={80}
248 |         availableTerminalHeight={10}
249 |       />,
250 |     );
251 | 
252 |     expect(lastFrame()).toMatchSnapshot();
253 |   });
254 | 
255 |   it('should render a full gemini_content item when using availableTerminalHeightGemini', () => {
256 |     const item: HistoryItem = {
257 |       id: 1,
258 |       type: 'gemini_content',
259 |       text: longCode,
260 |     };
261 |     const { lastFrame } = renderWithProviders(
262 |       <HistoryItemDisplay
263 |         item={item}
264 |         isPending={false}
265 |         terminalWidth={80}
266 |         availableTerminalHeight={10}
267 |         availableTerminalHeightGemini={Number.MAX_SAFE_INTEGER}
268 |       />,
269 |     );
270 | 
271 |     expect(lastFrame()).toMatchSnapshot();
272 |   });
273 | });
```

src/ui/components/HistoryItemDisplay.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type React from 'react';
8 | import { useMemo } from 'react';
9 | import { escapeAnsiCtrlCodes } from '../utils/textUtils.js';
10 | import type { HistoryItem } from '../types.js';
11 | import { UserMessage } from './messages/UserMessage.js';
12 | import { UserShellMessage } from './messages/UserShellMessage.js';
13 | import { GeminiMessage } from './messages/GeminiMessage.js';
14 | import { InfoMessage } from './messages/InfoMessage.js';
15 | import { ErrorMessage } from './messages/ErrorMessage.js';
16 | import { ToolGroupMessage } from './messages/ToolGroupMessage.js';
17 | import { GeminiMessageContent } from './messages/GeminiMessageContent.js';
18 | import { CompressionMessage } from './messages/CompressionMessage.js';
19 | import { WarningMessage } from './messages/WarningMessage.js';
20 | import { Box } from 'ink';
21 | import { AboutBox } from './AboutBox.js';
22 | import { StatsDisplay } from './StatsDisplay.js';
23 | import { ModelStatsDisplay } from './ModelStatsDisplay.js';
24 | import { ToolStatsDisplay } from './ToolStatsDisplay.js';
25 | import { SessionSummaryDisplay } from './SessionSummaryDisplay.js';
26 | import { Help } from './Help.js';
27 | import type { SlashCommand } from '../commands/types.js';
28 | import { ExtensionsList } from './views/ExtensionsList.js';
29 | import { getMCPServerStatus } from '@google/gemini-cli-core';
30 | import { ToolsList } from './views/ToolsList.js';
31 | import { McpStatus } from './views/McpStatus.js';
32 | import { ChatList } from './views/ChatList.js';
33 | 
34 | interface HistoryItemDisplayProps {
35 |   item: HistoryItem;
36 |   availableTerminalHeight?: number;
37 |   terminalWidth: number;
38 |   isPending: boolean;
39 |   isFocused?: boolean;
40 |   commands?: readonly SlashCommand[];
41 |   activeShellPtyId?: number | null;
42 |   embeddedShellFocused?: boolean;
43 |   availableTerminalHeightGemini?: number;
44 | }
45 | 
46 | export const HistoryItemDisplay: React.FC<HistoryItemDisplayProps> = ({
47 |   item,
48 |   availableTerminalHeight,
49 |   terminalWidth,
50 |   isPending,
51 |   commands,
52 |   isFocused = true,
53 |   activeShellPtyId,
54 |   embeddedShellFocused,
55 |   availableTerminalHeightGemini,
56 | }) => {
57 |   const itemForDisplay = useMemo(() => escapeAnsiCtrlCodes(item), [item]);
58 | 
59 |   return (
60 |     <Box flexDirection="column" key={itemForDisplay.id}>
61 |       {/* Render standard message types */}
62 |       {itemForDisplay.type === 'user' && (
63 |         <UserMessage text={itemForDisplay.text} />
64 |       )}
65 |       {itemForDisplay.type === 'user_shell' && (
66 |         <UserShellMessage text={itemForDisplay.text} />
67 |       )}
68 |       {itemForDisplay.type === 'gemini' && (
69 |         <GeminiMessage
70 |           text={itemForDisplay.text}
71 |           isPending={isPending}
72 |           availableTerminalHeight={
73 |             availableTerminalHeightGemini ?? availableTerminalHeight
74 |           }
75 |           terminalWidth={terminalWidth}
76 |         />
77 |       )}
78 |       {itemForDisplay.type === 'gemini_content' && (
79 |         <GeminiMessageContent
80 |           text={itemForDisplay.text}
81 |           isPending={isPending}
82 |           availableTerminalHeight={
83 |             availableTerminalHeightGemini ?? availableTerminalHeight
84 |           }
85 |           terminalWidth={terminalWidth}
86 |         />
87 |       )}
88 |       {itemForDisplay.type === 'info' && (
89 |         <InfoMessage text={itemForDisplay.text} />
90 |       )}
91 |       {itemForDisplay.type === 'warning' && (
92 |         <WarningMessage text={itemForDisplay.text} />
93 |       )}
94 |       {itemForDisplay.type === 'error' && (
95 |         <ErrorMessage text={itemForDisplay.text} />
96 |       )}
97 |       {itemForDisplay.type === 'about' && (
98 |         <AboutBox
99 |           cliVersion={itemForDisplay.cliVersion}
100 |           osVersion={itemForDisplay.osVersion}
101 |           sandboxEnv={itemForDisplay.sandboxEnv}
102 |           modelVersion={itemForDisplay.modelVersion}
103 |           selectedAuthType={itemForDisplay.selectedAuthType}
104 |           gcpProject={itemForDisplay.gcpProject}
105 |           ideClient={itemForDisplay.ideClient}
106 |         />
107 |       )}
108 |       {itemForDisplay.type === 'help' && commands && (
109 |         <Help commands={commands} />
110 |       )}
111 |       {itemForDisplay.type === 'stats' && (
112 |         <StatsDisplay duration={itemForDisplay.duration} />
113 |       )}
114 |       {itemForDisplay.type === 'model_stats' && <ModelStatsDisplay />}
115 |       {itemForDisplay.type === 'tool_stats' && <ToolStatsDisplay />}
116 |       {itemForDisplay.type === 'quit' && (
117 |         <SessionSummaryDisplay duration={itemForDisplay.duration} />
118 |       )}
119 |       {itemForDisplay.type === 'tool_group' && (
120 |         <ToolGroupMessage
121 |           toolCalls={itemForDisplay.tools}
122 |           groupId={itemForDisplay.id}
123 |           availableTerminalHeight={availableTerminalHeight}
124 |           terminalWidth={terminalWidth}
125 |           isFocused={isFocused}
126 |           activeShellPtyId={activeShellPtyId}
127 |           embeddedShellFocused={embeddedShellFocused}
128 |         />
129 |       )}
130 |       {itemForDisplay.type === 'compression' && (
131 |         <CompressionMessage compression={itemForDisplay.compression} />
132 |       )}
133 |       {itemForDisplay.type === 'extensions_list' && <ExtensionsList />}
134 |       {itemForDisplay.type === 'tools_list' && (
135 |         <ToolsList
136 |           terminalWidth={terminalWidth}
137 |           tools={itemForDisplay.tools}
138 |           showDescriptions={itemForDisplay.showDescriptions}
139 |         />
140 |       )}
141 |       {itemForDisplay.type === 'mcp_status' && (
142 |         <McpStatus {...itemForDisplay} serverStatus={getMCPServerStatus} />
143 |       )}
144 |       {itemForDisplay.type === 'chat_list' && (
145 |         <ChatList chats={itemForDisplay.chats} />
146 |       )}
147 |     </Box>
148 |   );
149 | };
```

src/ui/components/IdeTrustChangeDialog.test.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { vi, describe, it, expect, beforeEach } from 'vitest';
8 | import * as processUtils from '../../utils/processUtils.js';
9 | import { renderWithProviders } from '../../test-utils/render.js';
10 | import { IdeTrustChangeDialog } from './IdeTrustChangeDialog.js';
11 | 
12 | describe('IdeTrustChangeDialog', () => {
13 |   beforeEach(() => {
14 |     vi.clearAllMocks();
15 |   });
16 | 
17 |   it('renders the correct message for CONNECTION_CHANGE', () => {
18 |     const { lastFrame } = renderWithProviders(
19 |       <IdeTrustChangeDialog reason="CONNECTION_CHANGE" />,
20 |     );
21 | 
22 |     const frameText = lastFrame();
23 |     expect(frameText).toContain(
24 |       'Workspace trust has changed due to a change in the IDE connection.',
25 |     );
26 |     expect(frameText).toContain("Press 'r' to restart Gemini");
27 |   });
28 | 
29 |   it('renders the correct message for TRUST_CHANGE', () => {
30 |     const { lastFrame } = renderWithProviders(
31 |       <IdeTrustChangeDialog reason="TRUST_CHANGE" />,
32 |     );
33 | 
34 |     const frameText = lastFrame();
35 |     expect(frameText).toContain(
36 |       'Workspace trust has changed due to a change in the IDE trust.',
37 |     );
38 |     expect(frameText).toContain("Press 'r' to restart Gemini");
39 |   });
40 | 
41 |   it('renders a generic message and logs an error for NONE reason', () => {
42 |     const consoleErrorSpy = vi
43 |       .spyOn(console, 'error')
44 |       .mockImplementation(() => {});
45 |     const { lastFrame } = renderWithProviders(
46 |       <IdeTrustChangeDialog reason="NONE" />,
47 |     );
48 | 
49 |     const frameText = lastFrame();
50 |     expect(frameText).toContain('Workspace trust has changed.');
51 |     expect(consoleErrorSpy).toHaveBeenCalledWith(
52 |       'IdeTrustChangeDialog rendered with unexpected reason "NONE"',
53 |     );
54 |   });
55 | 
56 |   it('calls relaunchApp when "r" is pressed', () => {
57 |     const relaunchAppSpy = vi.spyOn(processUtils, 'relaunchApp');
58 |     const { stdin } = renderWithProviders(
59 |       <IdeTrustChangeDialog reason="NONE" />,
60 |     );
61 | 
62 |     stdin.write('r');
63 | 
64 |     expect(relaunchAppSpy).toHaveBeenCalledTimes(1);
65 |   });
66 | 
67 |   it('calls relaunchApp when "R" is pressed', () => {
68 |     const relaunchAppSpy = vi.spyOn(processUtils, 'relaunchApp');
69 |     const { stdin } = renderWithProviders(
70 |       <IdeTrustChangeDialog reason="CONNECTION_CHANGE" />,
71 |     );
72 | 
73 |     stdin.write('R');
74 | 
75 |     expect(relaunchAppSpy).toHaveBeenCalledTimes(1);
76 |   });
77 | 
78 |   it('does not call relaunchApp when another key is pressed', async () => {
79 |     const relaunchAppSpy = vi.spyOn(processUtils, 'relaunchApp');
80 |     const { stdin } = renderWithProviders(
81 |       <IdeTrustChangeDialog reason="CONNECTION_CHANGE" />,
82 |     );
83 | 
84 |     stdin.write('a');
85 | 
86 |     // Give it a moment to ensure no async actions are triggered
87 |     await new Promise((resolve) => setTimeout(resolve, 50));
88 | 
89 |     expect(relaunchAppSpy).not.toHaveBeenCalled();
90 |   });
91 | });
```

src/ui/components/IdeTrustChangeDialog.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { Box, Text } from 'ink';
8 | import { theme } from '../semantic-colors.js';
9 | import { useKeypress } from '../hooks/useKeypress.js';
10 | import { relaunchApp } from '../../utils/processUtils.js';
11 | import { type RestartReason } from '../hooks/useIdeTrustListener.js';
12 | 
13 | interface IdeTrustChangeDialogProps {
14 |   reason: RestartReason;
15 | }
16 | 
17 | export const IdeTrustChangeDialog = ({ reason }: IdeTrustChangeDialogProps) => {
18 |   useKeypress(
19 |     (key) => {
20 |       if (key.name === 'r' || key.name === 'R') {
21 |         relaunchApp();
22 |       }
23 |     },
24 |     { isActive: true },
25 |   );
26 | 
27 |   let message = 'Workspace trust has changed.';
28 |   if (reason === 'NONE') {
29 |     // This should not happen, but provides a fallback and a debug log.
30 |     console.error(
31 |       'IdeTrustChangeDialog rendered with unexpected reason "NONE"',
32 |     );
33 |   } else if (reason === 'CONNECTION_CHANGE') {
34 |     message =
35 |       'Workspace trust has changed due to a change in the IDE connection.';
36 |   } else if (reason === 'TRUST_CHANGE') {
37 |     message = 'Workspace trust has changed due to a change in the IDE trust.';
38 |   }
39 | 
40 |   return (
41 |     <Box borderStyle="round" borderColor={theme.status.warning} paddingX={1}>
42 |       <Text color={theme.status.warning}>
43 |         {message} Press &apos;r&apos; to restart Gemini to apply the changes.
44 |       </Text>
45 |     </Box>
46 |   );
47 | };
```

src/ui/components/InputPrompt.test.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { renderWithProviders } from '../../test-utils/render.js';
8 | import { waitFor, act } from '@testing-library/react';
9 | import type { InputPromptProps } from './InputPrompt.js';
10 | import { InputPrompt } from './InputPrompt.js';
11 | import type { TextBuffer } from './shared/text-buffer.js';
12 | import type { Config } from '@google/gemini-cli-core';
13 | import { ApprovalMode } from '@google/gemini-cli-core';
14 | import * as path from 'node:path';
15 | import type { CommandContext, SlashCommand } from '../commands/types.js';
16 | import { CommandKind } from '../commands/types.js';
17 | import { describe, it, expect, beforeEach, vi, afterEach } from 'vitest';
18 | import type { UseShellHistoryReturn } from '../hooks/useShellHistory.js';
19 | import { useShellHistory } from '../hooks/useShellHistory.js';
20 | import type { UseCommandCompletionReturn } from '../hooks/useCommandCompletion.js';
21 | import { useCommandCompletion } from '../hooks/useCommandCompletion.js';
22 | import type { UseInputHistoryReturn } from '../hooks/useInputHistory.js';
23 | import { useInputHistory } from '../hooks/useInputHistory.js';
24 | import type { UseReverseSearchCompletionReturn } from '../hooks/useReverseSearchCompletion.js';
25 | import { useReverseSearchCompletion } from '../hooks/useReverseSearchCompletion.js';
26 | import * as clipboardUtils from '../utils/clipboardUtils.js';
27 | import { useKittyKeyboardProtocol } from '../hooks/useKittyKeyboardProtocol.js';
28 | import { createMockCommandContext } from '../../test-utils/mockCommandContext.js';
29 | import stripAnsi from 'strip-ansi';
30 | import chalk from 'chalk';
31 | 
32 | vi.mock('../hooks/useShellHistory.js');
33 | vi.mock('../hooks/useCommandCompletion.js');
34 | vi.mock('../hooks/useInputHistory.js');
35 | vi.mock('../hooks/useReverseSearchCompletion.js');
36 | vi.mock('../utils/clipboardUtils.js');
37 | vi.mock('../hooks/useKittyKeyboardProtocol.js');
38 | 
39 | const mockSlashCommands: SlashCommand[] = [
40 |   {
41 |     name: 'clear',
42 |     kind: CommandKind.BUILT_IN,
43 |     description: 'Clear screen',
44 |     action: vi.fn(),
45 |   },
46 |   {
47 |     name: 'memory',
48 |     kind: CommandKind.BUILT_IN,
49 |     description: 'Manage memory',
50 |     subCommands: [
51 |       {
52 |         name: 'show',
53 |         kind: CommandKind.BUILT_IN,
54 |         description: 'Show memory',
55 |         action: vi.fn(),
56 |       },
57 |       {
58 |         name: 'add',
59 |         kind: CommandKind.BUILT_IN,
60 |         description: 'Add to memory',
61 |         action: vi.fn(),
62 |       },
63 |       {
64 |         name: 'refresh',
65 |         kind: CommandKind.BUILT_IN,
66 |         description: 'Refresh memory',
67 |         action: vi.fn(),
68 |       },
69 |     ],
70 |   },
71 |   {
72 |     name: 'chat',
73 |     description: 'Manage chats',
74 |     kind: CommandKind.BUILT_IN,
75 |     subCommands: [
76 |       {
77 |         name: 'resume',
78 |         description: 'Resume a chat',
79 |         kind: CommandKind.BUILT_IN,
80 |         action: vi.fn(),
81 |         completion: async () => ['fix-foo', 'fix-bar'],
82 |       },
83 |     ],
84 |   },
85 | ];
86 | 
87 | describe('InputPrompt', () => {
88 |   let props: InputPromptProps;
89 |   let mockShellHistory: UseShellHistoryReturn;
90 |   let mockCommandCompletion: UseCommandCompletionReturn;
91 |   let mockInputHistory: UseInputHistoryReturn;
92 |   let mockReverseSearchCompletion: UseReverseSearchCompletionReturn;
93 |   let mockBuffer: TextBuffer;
94 |   let mockCommandContext: CommandContext;
95 | 
96 |   const mockedUseShellHistory = vi.mocked(useShellHistory);
97 |   const mockedUseCommandCompletion = vi.mocked(useCommandCompletion);
98 |   const mockedUseInputHistory = vi.mocked(useInputHistory);
99 |   const mockedUseReverseSearchCompletion = vi.mocked(
100 |     useReverseSearchCompletion,
101 |   );
102 |   const mockedUseKittyKeyboardProtocol = vi.mocked(useKittyKeyboardProtocol);
103 | 
104 |   beforeEach(() => {
105 |     vi.resetAllMocks();
106 | 
107 |     mockCommandContext = createMockCommandContext();
108 | 
109 |     mockBuffer = {
110 |       text: '',
111 |       cursor: [0, 0],
112 |       lines: [''],
113 |       setText: vi.fn((newText: string) => {
114 |         mockBuffer.text = newText;
115 |         mockBuffer.lines = [newText];
116 |         mockBuffer.cursor = [0, newText.length];
117 |         mockBuffer.viewportVisualLines = [newText];
118 |         mockBuffer.allVisualLines = [newText];
119 |         mockBuffer.visualToLogicalMap = [[0, 0]];
120 |       }),
121 |       replaceRangeByOffset: vi.fn(),
122 |       viewportVisualLines: [''],
123 |       allVisualLines: [''],
124 |       visualCursor: [0, 0],
125 |       visualScrollRow: 0,
126 |       handleInput: vi.fn(),
127 |       move: vi.fn(),
128 |       moveToOffset: vi.fn((offset: number) => {
129 |         mockBuffer.cursor = [0, offset];
130 |       }),
131 |       killLineRight: vi.fn(),
132 |       killLineLeft: vi.fn(),
133 |       openInExternalEditor: vi.fn(),
134 |       newline: vi.fn(),
135 |       undo: vi.fn(),
136 |       redo: vi.fn(),
137 |       backspace: vi.fn(),
138 |       preferredCol: null,
139 |       selectionAnchor: null,
140 |       insert: vi.fn(),
141 |       del: vi.fn(),
142 |       replaceRange: vi.fn(),
143 |       deleteWordLeft: vi.fn(),
144 |       deleteWordRight: vi.fn(),
145 |       visualToLogicalMap: [[0, 0]],
146 |     } as unknown as TextBuffer;
147 | 
148 |     mockShellHistory = {
149 |       history: [],
150 |       addCommandToHistory: vi.fn(),
151 |       getPreviousCommand: vi.fn().mockReturnValue(null),
152 |       getNextCommand: vi.fn().mockReturnValue(null),
153 |       resetHistoryPosition: vi.fn(),
154 |     };
155 |     mockedUseShellHistory.mockReturnValue(mockShellHistory);
156 | 
157 |     mockCommandCompletion = {
158 |       suggestions: [],
159 |       activeSuggestionIndex: -1,
160 |       isLoadingSuggestions: false,
161 |       showSuggestions: false,
162 |       visibleStartIndex: 0,
163 |       isPerfectMatch: false,
164 |       navigateUp: vi.fn(),
165 |       navigateDown: vi.fn(),
166 |       resetCompletionState: vi.fn(),
167 |       setActiveSuggestionIndex: vi.fn(),
168 |       setShowSuggestions: vi.fn(),
169 |       handleAutocomplete: vi.fn(),
170 |       promptCompletion: {
171 |         text: '',
172 |         accept: vi.fn(),
173 |         clear: vi.fn(),
174 |       },
175 |     };
176 |     mockedUseCommandCompletion.mockReturnValue(mockCommandCompletion);
177 | 
178 |     mockInputHistory = {
179 |       navigateUp: vi.fn(),
180 |       navigateDown: vi.fn(),
181 |       handleSubmit: vi.fn(),
182 |     };
183 |     mockedUseInputHistory.mockReturnValue(mockInputHistory);
184 | 
185 |     mockReverseSearchCompletion = {
186 |       suggestions: [],
187 |       activeSuggestionIndex: -1,
188 |       visibleStartIndex: 0,
189 |       showSuggestions: false,
190 |       isLoadingSuggestions: false,
191 |       navigateUp: vi.fn(),
192 |       navigateDown: vi.fn(),
193 |       handleAutocomplete: vi.fn(),
194 |       resetCompletionState: vi.fn(),
195 |     };
196 |     mockedUseReverseSearchCompletion.mockReturnValue(
197 |       mockReverseSearchCompletion,
198 |     );
199 | 
200 |     mockedUseKittyKeyboardProtocol.mockReturnValue({
201 |       supported: false,
202 |     });
203 | 
204 |     props = {
205 |       buffer: mockBuffer,
206 |       onSubmit: vi.fn(),
207 |       userMessages: [],
208 |       onClearScreen: vi.fn(),
209 |       config: {
210 |         getProjectRoot: () => path.join('test', 'project'),
211 |         getTargetDir: () => path.join('test', 'project', 'src'),
212 |         getVimMode: () => false,
213 |         getWorkspaceContext: () => ({
214 |           getDirectories: () => ['/test/project/src'],
215 |         }),
216 |       } as unknown as Config,
217 |       slashCommands: mockSlashCommands,
218 |       commandContext: mockCommandContext,
219 |       shellModeActive: false,
220 |       setShellModeActive: vi.fn(),
221 |       approvalMode: ApprovalMode.DEFAULT,
222 |       inputWidth: 80,
223 |       suggestionsWidth: 80,
224 |       focus: true,
225 |     };
226 |   });
227 | 
228 |   const wait = (ms = 50) => new Promise((resolve) => setTimeout(resolve, ms));
229 | 
230 |   it('should call shellHistory.getPreviousCommand on up arrow in shell mode', async () => {
231 |     props.shellModeActive = true;
232 |     const { stdin, unmount } = renderWithProviders(<InputPrompt {...props} />);
233 |     await wait();
234 | 
235 |     stdin.write('\u001B[A');
236 |     await wait();
237 | 
238 |     expect(mockShellHistory.getPreviousCommand).toHaveBeenCalled();
239 |     unmount();
240 |   });
241 | 
242 |   it('should call shellHistory.getNextCommand on down arrow in shell mode', async () => {
243 |     props.shellModeActive = true;
244 |     const { stdin, unmount } = renderWithProviders(<InputPrompt {...props} />);
245 |     await wait();
246 | 
247 |     stdin.write('\u001B[B');
248 |     await wait();
249 | 
250 |     expect(mockShellHistory.getNextCommand).toHaveBeenCalled();
251 |     unmount();
252 |   });
253 | 
254 |   it('should set the buffer text when a shell history command is retrieved', async () => {
255 |     props.shellModeActive = true;
256 |     vi.mocked(mockShellHistory.getPreviousCommand).mockReturnValue(
257 |       'previous command',
258 |     );
259 |     const { stdin, unmount } = renderWithProviders(<InputPrompt {...props} />);
260 |     await wait();
261 | 
262 |     stdin.write('\u001B[A');
263 |     await wait();
264 | 
265 |     expect(mockShellHistory.getPreviousCommand).toHaveBeenCalled();
266 |     expect(props.buffer.setText).toHaveBeenCalledWith('previous command');
267 |     unmount();
268 |   });
269 | 
270 |   it('should call shellHistory.addCommandToHistory on submit in shell mode', async () => {
271 |     props.shellModeActive = true;
272 |     props.buffer.setText('ls -l');
273 |     const { stdin, unmount } = renderWithProviders(<InputPrompt {...props} />);
274 |     await wait();
275 | 
276 |     stdin.write('\r');
277 |     await wait();
278 | 
279 |     expect(mockShellHistory.addCommandToHistory).toHaveBeenCalledWith('ls -l');
280 |     expect(props.onSubmit).toHaveBeenCalledWith('ls -l');
281 |     unmount();
282 |   });
283 | 
284 |   it('should NOT call shell history methods when not in shell mode', async () => {
285 |     props.buffer.setText('some text');
286 |     const { stdin, unmount } = renderWithProviders(<InputPrompt {...props} />);
287 |     await wait();
288 | 
289 |     stdin.write('\u001B[A'); // Up arrow
290 |     await wait();
291 |     stdin.write('\u001B[B'); // Down arrow
292 |     await wait();
293 |     stdin.write('\r'); // Enter
294 |     await wait();
295 | 
296 |     expect(mockShellHistory.getPreviousCommand).not.toHaveBeenCalled();
297 |     expect(mockShellHistory.getNextCommand).not.toHaveBeenCalled();
298 |     expect(mockShellHistory.addCommandToHistory).not.toHaveBeenCalled();
299 | 
300 |     expect(mockInputHistory.navigateUp).toHaveBeenCalled();
301 |     expect(mockInputHistory.navigateDown).toHaveBeenCalled();
302 |     expect(props.onSubmit).toHaveBeenCalledWith('some text');
303 |     unmount();
304 |   });
305 | 
306 |   it('should call completion.navigateUp for both up arrow and Ctrl+P when suggestions are showing', async () => {
307 |     mockedUseCommandCompletion.mockReturnValue({
308 |       ...mockCommandCompletion,
309 |       showSuggestions: true,
310 |       suggestions: [
311 |         { label: 'memory', value: 'memory' },
312 |         { label: 'memcache', value: 'memcache' },
313 |       ],
314 |     });
315 | 
316 |     props.buffer.setText('/mem');
317 | 
318 |     const { stdin, unmount } = renderWithProviders(<InputPrompt {...props} />);
319 |     await wait();
320 | 
321 |     // Test up arrow
322 |     stdin.write('\u001B[A'); // Up arrow
323 |     await wait();
324 | 
325 |     stdin.write('\u0010'); // Ctrl+P
326 |     await wait();
327 |     expect(mockCommandCompletion.navigateUp).toHaveBeenCalledTimes(2);
328 |     expect(mockCommandCompletion.navigateDown).not.toHaveBeenCalled();
329 | 
330 |     unmount();
331 |   });
332 | 
333 |   it('should call completion.navigateDown for both down arrow and Ctrl+N when suggestions are showing', async () => {
334 |     mockedUseCommandCompletion.mockReturnValue({
335 |       ...mockCommandCompletion,
336 |       showSuggestions: true,
337 |       suggestions: [
338 |         { label: 'memory', value: 'memory' },
339 |         { label: 'memcache', value: 'memcache' },
340 |       ],
341 |     });
342 |     props.buffer.setText('/mem');
343 | 
344 |     const { stdin, unmount } = renderWithProviders(<InputPrompt {...props} />);
345 |     await wait();
346 | 
347 |     // Test down arrow
348 |     stdin.write('\u001B[B'); // Down arrow
349 |     await wait();
350 | 
351 |     stdin.write('\u000E'); // Ctrl+N
352 |     await wait();
353 |     expect(mockCommandCompletion.navigateDown).toHaveBeenCalledTimes(2);
354 |     expect(mockCommandCompletion.navigateUp).not.toHaveBeenCalled();
355 | 
356 |     unmount();
357 |   });
358 | 
359 |   it('should NOT call completion navigation when suggestions are not showing', async () => {
360 |     mockedUseCommandCompletion.mockReturnValue({
361 |       ...mockCommandCompletion,
362 |       showSuggestions: false,
363 |     });
364 |     props.buffer.setText('some text');
365 | 
366 |     const { stdin, unmount } = renderWithProviders(<InputPrompt {...props} />);
367 |     await wait();
368 | 
369 |     stdin.write('\u001B[A'); // Up arrow
370 |     await wait();
371 |     stdin.write('\u001B[B'); // Down arrow
372 |     await wait();
373 |     stdin.write('\u0010'); // Ctrl+P
374 |     await wait();
375 |     stdin.write('\u000E'); // Ctrl+N
376 |     await wait();
377 | 
378 |     expect(mockCommandCompletion.navigateUp).not.toHaveBeenCalled();
379 |     expect(mockCommandCompletion.navigateDown).not.toHaveBeenCalled();
380 |     unmount();
381 |   });
382 | 
383 |   describe('clipboard image paste', () => {
384 |     beforeEach(() => {
385 |       vi.mocked(clipboardUtils.clipboardHasImage).mockResolvedValue(false);
386 |       vi.mocked(clipboardUtils.saveClipboardImage).mockResolvedValue(null);
[TRUNCATED]
```

src/ui/components/InputPrompt.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type React from 'react';
8 | import { useCallback, useEffect, useState, useRef } from 'react';
9 | import { Box, Text } from 'ink';
10 | import { SuggestionsDisplay, MAX_WIDTH } from './SuggestionsDisplay.js';
11 | import { theme } from '../semantic-colors.js';
12 | import { useInputHistory } from '../hooks/useInputHistory.js';
13 | import type { TextBuffer } from './shared/text-buffer.js';
14 | import { logicalPosToOffset } from './shared/text-buffer.js';
15 | import { cpSlice, cpLen, toCodePoints } from '../utils/textUtils.js';
16 | import chalk from 'chalk';
17 | import stringWidth from 'string-width';
18 | import { useShellHistory } from '../hooks/useShellHistory.js';
19 | import { useReverseSearchCompletion } from '../hooks/useReverseSearchCompletion.js';
20 | import { useCommandCompletion } from '../hooks/useCommandCompletion.js';
21 | import type { Key } from '../hooks/useKeypress.js';
22 | import { useKeypress } from '../hooks/useKeypress.js';
23 | import { keyMatchers, Command } from '../keyMatchers.js';
24 | import type { CommandContext, SlashCommand } from '../commands/types.js';
25 | import type { Config } from '@google/gemini-cli-core';
26 | import { ApprovalMode } from '@google/gemini-cli-core';
27 | import {
28 |   parseInputForHighlighting,
29 |   buildSegmentsForVisualSlice,
30 | } from '../utils/highlight.js';
31 | import { useKittyKeyboardProtocol } from '../hooks/useKittyKeyboardProtocol.js';
32 | import {
33 |   clipboardHasImage,
34 |   saveClipboardImage,
35 |   cleanupOldClipboardImages,
36 | } from '../utils/clipboardUtils.js';
37 | import * as path from 'node:path';
38 | import { SCREEN_READER_USER_PREFIX } from '../textConstants.js';
39 | import { useShellFocusState } from '../contexts/ShellFocusContext.js';
40 | import { useUIState } from '../contexts/UIStateContext.js';
41 | 
42 | /**
43 |  * Returns if the terminal can be trusted to handle paste events atomically
44 |  * rather than potentially sending multiple paste events separated by line
45 |  * breaks which could trigger unintended command execution.
46 |  */
47 | export function isTerminalPasteTrusted(
48 |   kittyProtocolSupported: boolean,
49 | ): boolean {
50 |   // Ideally we could trust all VSCode family terminals as well but it appears
51 |   // we cannot as Cursor users on windows reported being impacted by this
52 |   // issue (https://github.com/google-gemini/gemini-cli/issues/3763).
53 |   return kittyProtocolSupported;
54 | }
55 | 
56 | export interface InputPromptProps {
57 |   buffer: TextBuffer;
58 |   onSubmit: (value: string) => void;
59 |   userMessages: readonly string[];
60 |   onClearScreen: () => void;
61 |   config: Config;
62 |   slashCommands: readonly SlashCommand[];
63 |   commandContext: CommandContext;
64 |   placeholder?: string;
65 |   focus?: boolean;
66 |   inputWidth: number;
67 |   suggestionsWidth: number;
68 |   shellModeActive: boolean;
69 |   setShellModeActive: (value: boolean) => void;
70 |   approvalMode: ApprovalMode;
71 |   onEscapePromptChange?: (showPrompt: boolean) => void;
72 |   vimHandleInput?: (key: Key) => boolean;
73 |   isEmbeddedShellFocused?: boolean;
74 | }
75 | 
76 | // The input content, input container, and input suggestions list may have different widths
77 | export const calculatePromptWidths = (mainContentWidth: number) => {
78 |   const FRAME_PADDING_AND_BORDER = 4; // Border (2) + padding (2)
79 |   const PROMPT_PREFIX_WIDTH = 2; // '> ' or '! '
80 | 
81 |   const FRAME_OVERHEAD = FRAME_PADDING_AND_BORDER + PROMPT_PREFIX_WIDTH;
82 |   const suggestionsWidth = Math.max(20, mainContentWidth);
83 | 
84 |   return {
85 |     inputWidth: Math.max(mainContentWidth - FRAME_OVERHEAD, 1),
86 |     containerWidth: mainContentWidth,
87 |     suggestionsWidth,
88 |     frameOverhead: FRAME_OVERHEAD,
89 |   } as const;
90 | };
91 | 
92 | export const InputPrompt: React.FC<InputPromptProps> = ({
93 |   buffer,
94 |   onSubmit,
95 |   userMessages,
96 |   onClearScreen,
97 |   config,
98 |   slashCommands,
99 |   commandContext,
100 |   placeholder = '  Type your message or @path/to/file',
101 |   focus = true,
102 |   inputWidth,
103 |   suggestionsWidth,
104 |   shellModeActive,
105 |   setShellModeActive,
106 |   approvalMode,
107 |   onEscapePromptChange,
108 |   vimHandleInput,
109 |   isEmbeddedShellFocused,
110 | }) => {
111 |   const kittyProtocol = useKittyKeyboardProtocol();
112 |   const isShellFocused = useShellFocusState();
113 |   const { mainAreaWidth } = useUIState();
114 |   const [justNavigatedHistory, setJustNavigatedHistory] = useState(false);
115 |   const [escPressCount, setEscPressCount] = useState(0);
116 |   const [showEscapePrompt, setShowEscapePrompt] = useState(false);
117 |   const escapeTimerRef = useRef<NodeJS.Timeout | null>(null);
118 |   const [recentUnsafePasteTime, setRecentUnsafePasteTime] = useState<
119 |     number | null
120 |   >(null);
121 |   const pasteTimeoutRef = useRef<NodeJS.Timeout | null>(null);
122 | 
123 |   const [dirs, setDirs] = useState<readonly string[]>(
124 |     config.getWorkspaceContext().getDirectories(),
125 |   );
126 |   const dirsChanged = config.getWorkspaceContext().getDirectories();
127 |   useEffect(() => {
128 |     if (dirs.length !== dirsChanged.length) {
129 |       setDirs(dirsChanged);
130 |     }
131 |   }, [dirs.length, dirsChanged]);
132 |   const [reverseSearchActive, setReverseSearchActive] = useState(false);
133 |   const [commandSearchActive, setCommandSearchActive] = useState(false);
134 |   const [textBeforeReverseSearch, setTextBeforeReverseSearch] = useState('');
135 |   const [cursorPosition, setCursorPosition] = useState<[number, number]>([
136 |     0, 0,
137 |   ]);
138 |   const [expandedSuggestionIndex, setExpandedSuggestionIndex] =
139 |     useState<number>(-1);
140 |   const shellHistory = useShellHistory(config.getProjectRoot());
141 |   const shellHistoryData = shellHistory.history;
142 | 
143 |   const completion = useCommandCompletion(
144 |     buffer,
145 |     dirs,
146 |     config.getTargetDir(),
147 |     slashCommands,
148 |     commandContext,
149 |     reverseSearchActive,
150 |     config,
151 |   );
152 | 
153 |   const reverseSearchCompletion = useReverseSearchCompletion(
154 |     buffer,
155 |     shellHistoryData,
156 |     reverseSearchActive,
157 |   );
158 | 
159 |   const commandSearchCompletion = useReverseSearchCompletion(
160 |     buffer,
161 |     userMessages,
162 |     commandSearchActive,
163 |   );
164 | 
165 |   const resetCompletionState = completion.resetCompletionState;
166 |   const resetReverseSearchCompletionState =
167 |     reverseSearchCompletion.resetCompletionState;
168 |   const resetCommandSearchCompletionState =
169 |     commandSearchCompletion.resetCompletionState;
170 | 
171 |   const showCursor = focus && isShellFocused && !isEmbeddedShellFocused;
172 | 
173 |   const resetEscapeState = useCallback(() => {
174 |     if (escapeTimerRef.current) {
175 |       clearTimeout(escapeTimerRef.current);
176 |       escapeTimerRef.current = null;
177 |     }
178 |     setEscPressCount(0);
179 |     setShowEscapePrompt(false);
180 |   }, []);
181 | 
182 |   // Notify parent component about escape prompt state changes
183 |   useEffect(() => {
184 |     if (onEscapePromptChange) {
185 |       onEscapePromptChange(showEscapePrompt);
186 |     }
187 |   }, [showEscapePrompt, onEscapePromptChange]);
188 | 
189 |   // Clear escape prompt timer on unmount
190 |   useEffect(
191 |     () => () => {
192 |       if (escapeTimerRef.current) {
193 |         clearTimeout(escapeTimerRef.current);
194 |       }
195 |       if (pasteTimeoutRef.current) {
196 |         clearTimeout(pasteTimeoutRef.current);
197 |       }
198 |     },
199 |     [],
200 |   );
201 | 
202 |   const handleSubmitAndClear = useCallback(
203 |     (submittedValue: string) => {
204 |       if (shellModeActive) {
205 |         shellHistory.addCommandToHistory(submittedValue);
206 |       }
207 |       // Clear the buffer *before* calling onSubmit to prevent potential re-submission
208 |       // if onSubmit triggers a re-render while the buffer still holds the old value.
209 |       buffer.setText('');
210 |       onSubmit(submittedValue);
211 |       resetCompletionState();
212 |       resetReverseSearchCompletionState();
213 |     },
214 |     [
215 |       onSubmit,
216 |       buffer,
217 |       resetCompletionState,
218 |       shellModeActive,
219 |       shellHistory,
220 |       resetReverseSearchCompletionState,
221 |     ],
222 |   );
223 | 
224 |   const customSetTextAndResetCompletionSignal = useCallback(
225 |     (newText: string) => {
226 |       buffer.setText(newText);
227 |       setJustNavigatedHistory(true);
228 |     },
229 |     [buffer, setJustNavigatedHistory],
230 |   );
231 | 
232 |   const inputHistory = useInputHistory({
233 |     userMessages,
234 |     onSubmit: handleSubmitAndClear,
235 |     isActive:
236 |       (!completion.showSuggestions || completion.suggestions.length === 1) &&
237 |       !shellModeActive,
238 |     currentQuery: buffer.text,
239 |     onChange: customSetTextAndResetCompletionSignal,
240 |   });
241 | 
242 |   // Effect to reset completion if history navigation just occurred and set the text
243 |   useEffect(() => {
244 |     if (justNavigatedHistory) {
245 |       resetCompletionState();
246 |       resetReverseSearchCompletionState();
247 |       resetCommandSearchCompletionState();
248 |       setExpandedSuggestionIndex(-1);
249 |       setJustNavigatedHistory(false);
250 |     }
251 |   }, [
252 |     justNavigatedHistory,
253 |     buffer.text,
254 |     resetCompletionState,
255 |     setJustNavigatedHistory,
256 |     resetReverseSearchCompletionState,
257 |     resetCommandSearchCompletionState,
258 |   ]);
259 | 
260 |   // Handle clipboard image pasting with Ctrl+V
261 |   const handleClipboardImage = useCallback(async () => {
262 |     try {
263 |       if (await clipboardHasImage()) {
264 |         const imagePath = await saveClipboardImage(config.getTargetDir());
265 |         if (imagePath) {
266 |           // Clean up old images
267 |           cleanupOldClipboardImages(config.getTargetDir()).catch(() => {
268 |             // Ignore cleanup errors
269 |           });
270 | 
271 |           // Get relative path from current directory
272 |           const relativePath = path.relative(config.getTargetDir(), imagePath);
273 | 
274 |           // Insert @path reference at cursor position
275 |           const insertText = `@${relativePath}`;
276 |           const currentText = buffer.text;
277 |           const [row, col] = buffer.cursor;
278 | 
279 |           // Calculate offset from row/col
280 |           let offset = 0;
281 |           for (let i = 0; i < row; i++) {
282 |             offset += buffer.lines[i].length + 1; // +1 for newline
283 |           }
284 |           offset += col;
285 | 
286 |           // Add spaces around the path if needed
287 |           let textToInsert = insertText;
288 |           const charBefore = offset > 0 ? currentText[offset - 1] : '';
289 |           const charAfter =
290 |             offset < currentText.length ? currentText[offset] : '';
291 | 
292 |           if (charBefore && charBefore !== ' ' && charBefore !== '\n') {
293 |             textToInsert = ' ' + textToInsert;
294 |           }
295 |           if (!charAfter || (charAfter !== ' ' && charAfter !== '\n')) {
296 |             textToInsert = textToInsert + ' ';
297 |           }
298 | 
299 |           // Insert at cursor position
300 |           buffer.replaceRangeByOffset(offset, offset, textToInsert);
301 |         }
302 |       }
303 |     } catch (error) {
304 |       console.error('Error handling clipboard image:', error);
305 |     }
306 |   }, [buffer, config]);
307 | 
308 |   const handleInput = useCallback(
309 |     (key: Key) => {
310 |       // TODO(jacobr): this special case is likely not needed anymore.
311 |       // We should probably stop supporting paste if the InputPrompt is not
312 |       // focused.
313 |       /// We want to handle paste even when not focused to support drag and drop.
314 |       if (!focus && !key.paste) {
315 |         return;
316 |       }
317 | 
318 |       if (key.paste) {
319 |         // Record paste time to prevent accidental auto-submission
320 |         if (!isTerminalPasteTrusted(kittyProtocol.supported)) {
321 |           setRecentUnsafePasteTime(Date.now());
322 | 
323 |           // Clear any existing paste timeout
324 |           if (pasteTimeoutRef.current) {
325 |             clearTimeout(pasteTimeoutRef.current);
326 |           }
327 | 
328 |           // Clear the paste protection after a very short delay to prevent
329 |           // false positives.
330 |           // Due to how we use a reducer for text buffer state updates, it is
331 |           // reasonable to expect that key events that are really part of the
332 |           // same paste will be processed in the same event loop tick. 40ms
333 |           // is chosen arbitrarily as it is faster than a typical human
334 |           // could go from pressing paste to pressing enter. The fastest typists
335 |           // can type at 200 words per minute which roughly translates to 50ms
336 |           // per letter.
337 |           pasteTimeoutRef.current = setTimeout(() => {
338 |             setRecentUnsafePasteTime(null);
339 |             pasteTimeoutRef.current = null;
340 |           }, 40);
341 |         }
342 |         // Ensure we never accidentally interpret paste as regular input.
343 |         buffer.handleInput(key);
344 |         return;
345 |       }
346 | 
347 |       if (vimHandleInput && vimHandleInput(key)) {
348 |         return;
349 |       }
350 | 
351 |       // Reset ESC count and hide prompt on any non-ESC key
352 |       if (key.name !== 'escape') {
353 |         if (escPressCount > 0 || showEscapePrompt) {
354 |           resetEscapeState();
355 |         }
356 |       }
357 | 
358 |       if (
359 |         key.sequence === '!' &&
360 |         buffer.text === '' &&
361 |         !completion.showSuggestions
362 |       ) {
363 |         setShellModeActive(!shellModeActive);
364 |         buffer.setText(''); // Clear the '!' from input
365 |         return;
366 |       }
367 | 
[TRUNCATED]
```

src/ui/components/LoadingIndicator.test.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import React from 'react';
8 | import { render } from 'ink-testing-library';
9 | import { Text } from 'ink';
10 | import { LoadingIndicator } from './LoadingIndicator.js';
11 | import { StreamingContext } from '../contexts/StreamingContext.js';
12 | import { StreamingState } from '../types.js';
13 | import { vi } from 'vitest';
14 | import * as useTerminalSize from '../hooks/useTerminalSize.js';
15 | 
16 | // Mock GeminiRespondingSpinner
17 | vi.mock('./GeminiRespondingSpinner.js', () => ({
18 |   GeminiRespondingSpinner: ({
19 |     nonRespondingDisplay,
20 |   }: {
21 |     nonRespondingDisplay?: string;
22 |   }) => {
23 |     const streamingState = React.useContext(StreamingContext)!;
24 |     if (streamingState === StreamingState.Responding) {
25 |       return <Text>MockRespondingSpinner</Text>;
26 |     } else if (nonRespondingDisplay) {
27 |       return <Text>{nonRespondingDisplay}</Text>;
28 |     }
29 |     return null;
30 |   },
31 | }));
32 | 
33 | vi.mock('../hooks/useTerminalSize.js', () => ({
34 |   useTerminalSize: vi.fn(),
35 | }));
36 | 
37 | const useTerminalSizeMock = vi.mocked(useTerminalSize.useTerminalSize);
38 | 
39 | const renderWithContext = (
40 |   ui: React.ReactElement,
41 |   streamingStateValue: StreamingState,
42 |   width = 120,
43 | ) => {
44 |   useTerminalSizeMock.mockReturnValue({ columns: width, rows: 24 });
45 |   const contextValue: StreamingState = streamingStateValue;
46 |   return render(
47 |     <StreamingContext.Provider value={contextValue}>
48 |       {ui}
49 |     </StreamingContext.Provider>,
50 |   );
51 | };
52 | 
53 | describe('<LoadingIndicator />', () => {
54 |   const defaultProps = {
55 |     currentLoadingPhrase: 'Loading...',
56 |     elapsedTime: 5,
57 |   };
58 | 
59 |   it('should not render when streamingState is Idle', () => {
60 |     const { lastFrame } = renderWithContext(
61 |       <LoadingIndicator {...defaultProps} />,
62 |       StreamingState.Idle,
63 |     );
64 |     expect(lastFrame()).toBe('');
65 |   });
66 | 
67 |   it('should render spinner, phrase, and time when streamingState is Responding', () => {
68 |     const { lastFrame } = renderWithContext(
69 |       <LoadingIndicator {...defaultProps} />,
70 |       StreamingState.Responding,
71 |     );
72 |     const output = lastFrame();
73 |     expect(output).toContain('MockRespondingSpinner');
74 |     expect(output).toContain('Loading...');
75 |     expect(output).toContain('(esc to cancel, 5s)');
76 |   });
77 | 
78 |   it('should render spinner (static), phrase but no time/cancel when streamingState is WaitingForConfirmation', () => {
79 |     const props = {
80 |       currentLoadingPhrase: 'Confirm action',
81 |       elapsedTime: 10,
82 |     };
83 |     const { lastFrame } = renderWithContext(
84 |       <LoadingIndicator {...props} />,
85 |       StreamingState.WaitingForConfirmation,
86 |     );
87 |     const output = lastFrame();
88 |     expect(output).toContain('⠏'); // Static char for WaitingForConfirmation
89 |     expect(output).toContain('Confirm action');
90 |     expect(output).not.toContain('(esc to cancel)');
91 |     expect(output).not.toContain(', 10s');
92 |   });
93 | 
94 |   it('should display the currentLoadingPhrase correctly', () => {
95 |     const props = {
96 |       currentLoadingPhrase: 'Processing data...',
97 |       elapsedTime: 3,
98 |     };
99 |     const { lastFrame } = renderWithContext(
100 |       <LoadingIndicator {...props} />,
101 |       StreamingState.Responding,
102 |     );
103 |     expect(lastFrame()).toContain('Processing data...');
104 |   });
105 | 
106 |   it('should display the elapsedTime correctly when Responding', () => {
107 |     const props = {
108 |       currentLoadingPhrase: 'Working...',
109 |       elapsedTime: 60,
110 |     };
111 |     const { lastFrame } = renderWithContext(
112 |       <LoadingIndicator {...props} />,
113 |       StreamingState.Responding,
114 |     );
115 |     expect(lastFrame()).toContain('(esc to cancel, 1m)');
116 |   });
117 | 
118 |   it('should display the elapsedTime correctly in human-readable format', () => {
119 |     const props = {
120 |       currentLoadingPhrase: 'Working...',
121 |       elapsedTime: 125,
122 |     };
123 |     const { lastFrame } = renderWithContext(
124 |       <LoadingIndicator {...props} />,
125 |       StreamingState.Responding,
126 |     );
127 |     expect(lastFrame()).toContain('(esc to cancel, 2m 5s)');
128 |   });
129 | 
130 |   it('should render rightContent when provided', () => {
131 |     const rightContent = <Text>Extra Info</Text>;
132 |     const { lastFrame } = renderWithContext(
133 |       <LoadingIndicator {...defaultProps} rightContent={rightContent} />,
134 |       StreamingState.Responding,
135 |     );
136 |     expect(lastFrame()).toContain('Extra Info');
137 |   });
138 | 
139 |   it('should transition correctly between states using rerender', () => {
140 |     const { lastFrame, rerender } = renderWithContext(
141 |       <LoadingIndicator {...defaultProps} />,
142 |       StreamingState.Idle,
143 |     );
144 |     expect(lastFrame()).toBe(''); // Initial: Idle
145 | 
146 |     // Transition to Responding
147 |     rerender(
148 |       <StreamingContext.Provider value={StreamingState.Responding}>
149 |         <LoadingIndicator
150 |           currentLoadingPhrase="Now Responding"
151 |           elapsedTime={2}
152 |         />
153 |       </StreamingContext.Provider>,
154 |     );
155 |     let output = lastFrame();
156 |     expect(output).toContain('MockRespondingSpinner');
157 |     expect(output).toContain('Now Responding');
158 |     expect(output).toContain('(esc to cancel, 2s)');
159 | 
160 |     // Transition to WaitingForConfirmation
161 |     rerender(
162 |       <StreamingContext.Provider value={StreamingState.WaitingForConfirmation}>
163 |         <LoadingIndicator
164 |           currentLoadingPhrase="Please Confirm"
165 |           elapsedTime={15}
166 |         />
167 |       </StreamingContext.Provider>,
168 |     );
169 |     output = lastFrame();
170 |     expect(output).toContain('⠏');
171 |     expect(output).toContain('Please Confirm');
172 |     expect(output).not.toContain('(esc to cancel)');
173 |     expect(output).not.toContain(', 15s');
174 | 
175 |     // Transition back to Idle
176 |     rerender(
177 |       <StreamingContext.Provider value={StreamingState.Idle}>
178 |         <LoadingIndicator {...defaultProps} />
179 |       </StreamingContext.Provider>,
180 |     );
181 |     expect(lastFrame()).toBe('');
182 |   });
183 | 
184 |   it('should display fallback phrase if thought is empty', () => {
185 |     const props = {
186 |       thought: null,
187 |       currentLoadingPhrase: 'Loading...',
188 |       elapsedTime: 5,
189 |     };
190 |     const { lastFrame } = renderWithContext(
191 |       <LoadingIndicator {...props} />,
192 |       StreamingState.Responding,
193 |     );
194 |     const output = lastFrame();
195 |     expect(output).toContain('Loading...');
196 |   });
197 | 
198 |   it('should display the subject of a thought', () => {
199 |     const props = {
200 |       thought: {
201 |         subject: 'Thinking about something...',
202 |         description: 'and other stuff.',
203 |       },
204 |       elapsedTime: 5,
205 |     };
206 |     const { lastFrame } = renderWithContext(
207 |       <LoadingIndicator {...props} />,
208 |       StreamingState.Responding,
209 |     );
210 |     const output = lastFrame();
211 |     expect(output).toBeDefined();
212 |     if (output) {
213 |       expect(output).toContain('Thinking about something...');
214 |       expect(output).not.toContain('and other stuff.');
215 |     }
216 |   });
217 | 
218 |   it('should prioritize thought.subject over currentLoadingPhrase', () => {
219 |     const props = {
220 |       thought: {
221 |         subject: 'This should be displayed',
222 |         description: 'A description',
223 |       },
224 |       currentLoadingPhrase: 'This should not be displayed',
225 |       elapsedTime: 5,
226 |     };
227 |     const { lastFrame } = renderWithContext(
228 |       <LoadingIndicator {...props} />,
229 |       StreamingState.Responding,
230 |     );
231 |     const output = lastFrame();
232 |     expect(output).toContain('This should be displayed');
233 |     expect(output).not.toContain('This should not be displayed');
234 |   });
235 | 
236 |   it('should truncate long primary text instead of wrapping', () => {
237 |     const { lastFrame } = renderWithContext(
238 |       <LoadingIndicator
239 |         {...defaultProps}
240 |         currentLoadingPhrase={
241 |           'This is an extremely long loading phrase that should be truncated in the UI to keep the primary line concise.'
242 |         }
243 |       />,
244 |       StreamingState.Responding,
245 |       80,
246 |     );
247 | 
248 |     expect(lastFrame()).toMatchSnapshot();
249 |   });
250 | 
251 |   describe('responsive layout', () => {
252 |     it('should render on a single line on a wide terminal', () => {
253 |       const { lastFrame } = renderWithContext(
254 |         <LoadingIndicator
255 |           {...defaultProps}
256 |           rightContent={<Text>Right</Text>}
257 |         />,
258 |         StreamingState.Responding,
259 |         120,
260 |       );
261 |       const output = lastFrame();
262 |       // Check for single line output
263 |       expect(output?.includes('\n')).toBe(false);
264 |       expect(output).toContain('Loading...');
265 |       expect(output).toContain('(esc to cancel, 5s)');
266 |       expect(output).toContain('Right');
267 |     });
268 | 
269 |     it('should render on multiple lines on a narrow terminal', () => {
270 |       const { lastFrame } = renderWithContext(
271 |         <LoadingIndicator
272 |           {...defaultProps}
273 |           rightContent={<Text>Right</Text>}
274 |         />,
275 |         StreamingState.Responding,
276 |         79,
277 |       );
278 |       const output = lastFrame();
279 |       const lines = output?.split('\n');
280 |       // Expecting 3 lines:
281 |       // 1. Spinner + Primary Text
282 |       // 2. Cancel + Timer
283 |       // 3. Right Content
284 |       expect(lines).toHaveLength(3);
285 |       if (lines) {
286 |         expect(lines[0]).toContain('Loading...');
287 |         expect(lines[0]).not.toContain('(esc to cancel, 5s)');
288 |         expect(lines[1]).toContain('(esc to cancel, 5s)');
289 |         expect(lines[2]).toContain('Right');
290 |       }
291 |     });
292 | 
293 |     it('should use wide layout at 80 columns', () => {
294 |       const { lastFrame } = renderWithContext(
295 |         <LoadingIndicator {...defaultProps} />,
296 |         StreamingState.Responding,
297 |         80,
298 |       );
299 |       expect(lastFrame()?.includes('\n')).toBe(false);
300 |     });
301 | 
302 |     it('should use narrow layout at 79 columns', () => {
303 |       const { lastFrame } = renderWithContext(
304 |         <LoadingIndicator {...defaultProps} />,
305 |         StreamingState.Responding,
306 |         79,
307 |       );
308 |       expect(lastFrame()?.includes('\n')).toBe(true);
309 |     });
310 |   });
311 | });
```

src/ui/components/LoadingIndicator.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type { ThoughtSummary } from '@google/gemini-cli-core';
8 | import type React from 'react';
9 | import { Box, Text } from 'ink';
10 | import { theme } from '../semantic-colors.js';
11 | import { useStreamingContext } from '../contexts/StreamingContext.js';
12 | import { StreamingState } from '../types.js';
13 | import { GeminiRespondingSpinner } from './GeminiRespondingSpinner.js';
14 | import { formatDuration } from '../utils/formatters.js';
15 | import { useTerminalSize } from '../hooks/useTerminalSize.js';
16 | import { isNarrowWidth } from '../utils/isNarrowWidth.js';
17 | 
18 | interface LoadingIndicatorProps {
19 |   currentLoadingPhrase?: string;
20 |   elapsedTime: number;
21 |   rightContent?: React.ReactNode;
22 |   thought?: ThoughtSummary | null;
23 | }
24 | 
25 | export const LoadingIndicator: React.FC<LoadingIndicatorProps> = ({
26 |   currentLoadingPhrase,
27 |   elapsedTime,
28 |   rightContent,
29 |   thought,
30 | }) => {
31 |   const streamingState = useStreamingContext();
32 |   const { columns: terminalWidth } = useTerminalSize();
33 |   const isNarrow = isNarrowWidth(terminalWidth);
34 | 
35 |   if (streamingState === StreamingState.Idle) {
36 |     return null;
37 |   }
38 | 
39 |   const primaryText = thought?.subject || currentLoadingPhrase;
40 | 
41 |   const cancelAndTimerContent =
42 |     streamingState !== StreamingState.WaitingForConfirmation
43 |       ? `(esc to cancel, ${elapsedTime < 60 ? `${elapsedTime}s` : formatDuration(elapsedTime * 1000)})`
44 |       : null;
45 | 
46 |   return (
47 |     <Box paddingLeft={0} flexDirection="column">
48 |       {/* Main loading line */}
49 |       <Box
50 |         width="100%"
51 |         flexDirection={isNarrow ? 'column' : 'row'}
52 |         alignItems={isNarrow ? 'flex-start' : 'center'}
53 |       >
54 |         <Box>
55 |           <Box marginRight={1}>
56 |             <GeminiRespondingSpinner
57 |               nonRespondingDisplay={
58 |                 streamingState === StreamingState.WaitingForConfirmation
59 |                   ? '⠏'
60 |                   : ''
61 |               }
62 |             />
63 |           </Box>
64 |           {primaryText && (
65 |             <Text color={theme.text.accent} wrap="truncate-end">
66 |               {primaryText}
67 |             </Text>
68 |           )}
69 |           {!isNarrow && cancelAndTimerContent && (
70 |             <Text color={theme.text.secondary}> {cancelAndTimerContent}</Text>
71 |           )}
72 |         </Box>
73 |         {!isNarrow && <Box flexGrow={1}>{/* Spacer */}</Box>}
74 |         {!isNarrow && rightContent && <Box>{rightContent}</Box>}
75 |       </Box>
76 |       {isNarrow && cancelAndTimerContent && (
77 |         <Box>
78 |           <Text color={theme.text.secondary}>{cancelAndTimerContent}</Text>
79 |         </Box>
80 |       )}
81 |       {isNarrow && rightContent && <Box>{rightContent}</Box>}
82 |     </Box>
83 |   );
84 | };
```

src/ui/components/LoopDetectionConfirmation.test.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { renderWithProviders } from '../../test-utils/render.js';
8 | import { describe, it, expect, vi } from 'vitest';
9 | import { LoopDetectionConfirmation } from './LoopDetectionConfirmation.js';
10 | 
11 | describe('LoopDetectionConfirmation', () => {
12 |   const onComplete = vi.fn();
13 | 
14 |   it('renders correctly', () => {
15 |     const { lastFrame } = renderWithProviders(
16 |       <LoopDetectionConfirmation onComplete={onComplete} />,
17 |     );
18 |     expect(lastFrame()).toMatchSnapshot();
19 |   });
20 | 
21 |   it('contains the expected options', () => {
22 |     const { lastFrame } = renderWithProviders(
23 |       <LoopDetectionConfirmation onComplete={onComplete} />,
24 |     );
25 |     const output = lastFrame()!.toString();
26 | 
27 |     expect(output).toContain('A potential loop was detected');
28 |     expect(output).toContain('Keep loop detection enabled (esc)');
29 |     expect(output).toContain('Disable loop detection for this session');
30 |     expect(output).toContain(
31 |       'This can happen due to repetitive tool calls or other model behavior',
32 |     );
33 |   });
34 | });
```

src/ui/components/LoopDetectionConfirmation.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { Box, Text } from 'ink';
8 | import type { RadioSelectItem } from './shared/RadioButtonSelect.js';
9 | import { RadioButtonSelect } from './shared/RadioButtonSelect.js';
10 | import { useKeypress } from '../hooks/useKeypress.js';
11 | import { theme } from '../semantic-colors.js';
12 | 
13 | export type LoopDetectionConfirmationResult = {
14 |   userSelection: 'disable' | 'keep';
15 | };
16 | 
17 | interface LoopDetectionConfirmationProps {
18 |   onComplete: (result: LoopDetectionConfirmationResult) => void;
19 | }
20 | 
21 | export function LoopDetectionConfirmation({
22 |   onComplete,
23 | }: LoopDetectionConfirmationProps) {
24 |   useKeypress(
25 |     (key) => {
26 |       if (key.name === 'escape') {
27 |         onComplete({
28 |           userSelection: 'keep',
29 |         });
30 |       }
31 |     },
32 |     { isActive: true },
33 |   );
34 | 
35 |   const OPTIONS: Array<RadioSelectItem<LoopDetectionConfirmationResult>> = [
36 |     {
37 |       label: 'Keep loop detection enabled (esc)',
38 |       value: {
39 |         userSelection: 'keep',
40 |       },
41 |       key: 'Keep loop detection enabled (esc)',
42 |     },
43 |     {
44 |       label: 'Disable loop detection for this session',
45 |       value: {
46 |         userSelection: 'disable',
47 |       },
48 |       key: 'Disable loop detection for this session',
49 |     },
50 |   ];
51 | 
52 |   return (
53 |     <Box
54 |       flexDirection="column"
55 |       borderStyle="round"
56 |       borderColor={theme.status.warning}
57 |       width="100%"
58 |       marginLeft={1}
59 |     >
60 |       <Box paddingX={1} paddingY={0} flexDirection="column">
61 |         <Box minHeight={1}>
62 |           <Box minWidth={3}>
63 |             <Text color={theme.status.warning} aria-label="Loop detected:">
64 |               ?
65 |             </Text>
66 |           </Box>
67 |           <Box>
68 |             <Text wrap="truncate-end">
69 |               <Text color={theme.text.primary} bold>
70 |                 A potential loop was detected
71 |               </Text>{' '}
72 |             </Text>
73 |           </Box>
74 |         </Box>
75 |         <Box width="100%" marginTop={1}>
76 |           <Box flexDirection="column">
77 |             <Text color={theme.text.secondary}>
78 |               This can happen due to repetitive tool calls or other model
79 |               behavior. Do you want to keep loop detection enabled or disable it
80 |               for this session?
81 |             </Text>
82 |             <Box marginTop={1}>
83 |               <RadioButtonSelect items={OPTIONS} onSelect={onComplete} />
84 |             </Box>
85 |           </Box>
86 |         </Box>
87 |       </Box>
88 |     </Box>
89 |   );
90 | }
```

src/ui/components/MainContent.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { Box, Static } from 'ink';
8 | import { HistoryItemDisplay } from './HistoryItemDisplay.js';
9 | import { ShowMoreLines } from './ShowMoreLines.js';
10 | import { OverflowProvider } from '../contexts/OverflowContext.js';
11 | import { useUIState } from '../contexts/UIStateContext.js';
12 | import { useAppContext } from '../contexts/AppContext.js';
13 | import { AppHeader } from './AppHeader.js';
14 | 
15 | // Limit Gemini messages to a very high number of lines to mitigate performance
16 | // issues in the worst case if we somehow get an enormous response from Gemini.
17 | // This threshold is arbitrary but should be high enough to never impact normal
18 | // usage.
19 | const MAX_GEMINI_MESSAGE_LINES = 65536;
20 | 
21 | export const MainContent = () => {
22 |   const { version } = useAppContext();
23 |   const uiState = useUIState();
24 |   const {
25 |     pendingHistoryItems,
26 |     mainAreaWidth,
27 |     staticAreaMaxItemHeight,
28 |     availableTerminalHeight,
29 |   } = uiState;
30 | 
31 |   return (
32 |     <>
33 |       <Static
34 |         key={uiState.historyRemountKey}
35 |         items={[
36 |           <AppHeader key="app-header" version={version} />,
37 |           ...uiState.history.map((h) => (
38 |             <HistoryItemDisplay
39 |               terminalWidth={mainAreaWidth}
40 |               availableTerminalHeight={staticAreaMaxItemHeight}
41 |               availableTerminalHeightGemini={MAX_GEMINI_MESSAGE_LINES}
42 |               key={h.id}
43 |               item={h}
44 |               isPending={false}
45 |               commands={uiState.slashCommands}
46 |             />
47 |           )),
48 |         ]}
49 |       >
50 |         {(item) => item}
51 |       </Static>
52 |       <OverflowProvider>
53 |         <Box flexDirection="column" width={mainAreaWidth}>
54 |           {pendingHistoryItems.map((item, i) => (
55 |             <HistoryItemDisplay
56 |               key={i}
57 |               availableTerminalHeight={
58 |                 uiState.constrainHeight ? availableTerminalHeight : undefined
59 |               }
60 |               terminalWidth={mainAreaWidth}
61 |               item={{ ...item, id: 0 }}
62 |               isPending={true}
63 |               isFocused={!uiState.isEditorDialogOpen}
64 |               activeShellPtyId={uiState.activePtyId}
65 |               embeddedShellFocused={uiState.embeddedShellFocused}
66 |             />
67 |           ))}
68 |           <ShowMoreLines constrainHeight={uiState.constrainHeight} />
69 |         </Box>
70 |       </OverflowProvider>
71 |     </>
72 |   );
73 | };
```

src/ui/components/MemoryUsageDisplay.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type React from 'react';
8 | import { useEffect, useState } from 'react';
9 | import { Box, Text } from 'ink';
10 | import { theme } from '../semantic-colors.js';
11 | import process from 'node:process';
12 | import { formatMemoryUsage } from '../utils/formatters.js';
13 | 
14 | export const MemoryUsageDisplay: React.FC = () => {
15 |   const [memoryUsage, setMemoryUsage] = useState<string>('');
16 |   const [memoryUsageColor, setMemoryUsageColor] = useState<string>(
17 |     theme.text.secondary,
18 |   );
19 | 
20 |   useEffect(() => {
21 |     const updateMemory = () => {
22 |       const usage = process.memoryUsage().rss;
23 |       setMemoryUsage(formatMemoryUsage(usage));
24 |       setMemoryUsageColor(
25 |         usage >= 2 * 1024 * 1024 * 1024
26 |           ? theme.status.error
27 |           : theme.text.secondary,
28 |       );
29 |     };
30 |     const intervalId = setInterval(updateMemory, 2000);
31 |     updateMemory(); // Initial update
32 |     return () => clearInterval(intervalId);
33 |   }, []);
34 | 
35 |   return (
36 |     <Box>
37 |       <Text color={theme.text.secondary}> | </Text>
38 |       <Text color={memoryUsageColor}>{memoryUsage}</Text>
39 |     </Box>
40 |   );
41 | };
```

src/ui/components/ModelDialog.test.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { render, cleanup } from '@testing-library/react';
8 | import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
9 | import {
10 |   DEFAULT_GEMINI_FLASH_LITE_MODEL,
11 |   DEFAULT_GEMINI_FLASH_MODEL,
12 |   DEFAULT_GEMINI_MODEL,
13 |   DEFAULT_GEMINI_MODEL_AUTO,
14 | } from '@google/gemini-cli-core';
15 | import { ModelDialog } from './ModelDialog.js';
16 | import { useKeypress } from '../hooks/useKeypress.js';
17 | import { DescriptiveRadioButtonSelect } from './shared/DescriptiveRadioButtonSelect.js';
18 | import { ConfigContext } from '../contexts/ConfigContext.js';
19 | import type { Config } from '@google/gemini-cli-core';
20 | 
21 | vi.mock('../hooks/useKeypress.js', () => ({
22 |   useKeypress: vi.fn(),
23 | }));
24 | const mockedUseKeypress = vi.mocked(useKeypress);
25 | 
26 | vi.mock('./shared/DescriptiveRadioButtonSelect.js', () => ({
27 |   DescriptiveRadioButtonSelect: vi.fn(() => null),
28 | }));
29 | const mockedSelect = vi.mocked(DescriptiveRadioButtonSelect);
30 | 
31 | const renderComponent = (
32 |   props: Partial<React.ComponentProps<typeof ModelDialog>> = {},
33 |   contextValue: Partial<Config> | undefined = undefined,
34 | ) => {
35 |   const defaultProps = {
36 |     onClose: vi.fn(),
37 |   };
38 |   const combinedProps = { ...defaultProps, ...props };
39 | 
40 |   const mockConfig = contextValue
41 |     ? ({
42 |         // --- Functions used by ModelDialog ---
43 |         getModel: vi.fn(() => DEFAULT_GEMINI_MODEL_AUTO),
44 |         setModel: vi.fn(),
45 | 
46 |         // --- Functions used by ClearcutLogger ---
47 |         getUsageStatisticsEnabled: vi.fn(() => true),
48 |         getSessionId: vi.fn(() => 'mock-session-id'),
49 |         getDebugMode: vi.fn(() => false),
50 |         getContentGeneratorConfig: vi.fn(() => ({ authType: 'mock' })),
51 |         getUseSmartEdit: vi.fn(() => false),
52 |         getUseModelRouter: vi.fn(() => false),
53 |         getProxy: vi.fn(() => undefined),
54 | 
55 |         // --- Spread test-specific overrides ---
56 |         ...contextValue,
57 |       } as Config)
58 |     : undefined;
59 | 
60 |   const renderResult = render(
61 |     <ConfigContext.Provider value={mockConfig}>
62 |       <ModelDialog {...combinedProps} />
63 |     </ConfigContext.Provider>,
64 |   );
65 | 
66 |   return {
67 |     ...renderResult,
68 |     props: combinedProps,
69 |     mockConfig,
70 |   };
71 | };
72 | 
73 | describe('<ModelDialog />', () => {
74 |   beforeEach(() => {
75 |     vi.clearAllMocks();
76 |   });
77 | 
78 |   afterEach(() => {
79 |     cleanup();
80 |   });
81 | 
82 |   it('renders the title and help text', () => {
83 |     const { getByText } = renderComponent();
84 |     expect(getByText('Select Model')).toBeDefined();
85 |     expect(getByText('(Press Esc to close)')).toBeDefined();
86 |     expect(
87 |       getByText('> To use a specific Gemini model, use the --model flag.'),
88 |     ).toBeDefined();
89 |   });
90 | 
91 |   it('passes all model options to DescriptiveRadioButtonSelect', () => {
92 |     renderComponent();
93 |     expect(mockedSelect).toHaveBeenCalledTimes(1);
94 | 
95 |     const props = mockedSelect.mock.calls[0][0];
96 |     expect(props.items).toHaveLength(4);
97 |     expect(props.items[0].value).toBe(DEFAULT_GEMINI_MODEL_AUTO);
98 |     expect(props.items[1].value).toBe(DEFAULT_GEMINI_MODEL);
99 |     expect(props.items[2].value).toBe(DEFAULT_GEMINI_FLASH_MODEL);
100 |     expect(props.items[3].value).toBe(DEFAULT_GEMINI_FLASH_LITE_MODEL);
101 |     expect(props.showNumbers).toBe(true);
102 |   });
103 | 
104 |   it('initializes with the model from ConfigContext', () => {
105 |     const mockGetModel = vi.fn(() => DEFAULT_GEMINI_FLASH_MODEL);
106 |     renderComponent({}, { getModel: mockGetModel });
107 | 
108 |     expect(mockGetModel).toHaveBeenCalled();
109 |     expect(mockedSelect).toHaveBeenCalledWith(
110 |       expect.objectContaining({
111 |         initialIndex: 2,
112 |       }),
113 |       undefined,
114 |     );
115 |   });
116 | 
117 |   it('initializes with "auto" model if context is not provided', () => {
118 |     renderComponent({}, undefined);
119 | 
120 |     expect(mockedSelect).toHaveBeenCalledWith(
121 |       expect.objectContaining({
122 |         initialIndex: 0,
123 |       }),
124 |       undefined,
125 |     );
126 |   });
127 | 
128 |   it('initializes with "auto" model if getModel returns undefined', () => {
129 |     const mockGetModel = vi.fn(() => undefined);
130 |     // @ts-expect-error This test validates component robustness when getModel
131 |     // returns an unexpected undefined value.
132 |     renderComponent({}, { getModel: mockGetModel });
133 | 
134 |     expect(mockGetModel).toHaveBeenCalled();
135 | 
136 |     // When getModel returns undefined, preferredModel falls back to DEFAULT_GEMINI_MODEL_AUTO
137 |     // which has index 0, so initialIndex should be 0
138 |     expect(mockedSelect).toHaveBeenCalledWith(
139 |       expect.objectContaining({
140 |         initialIndex: 0,
141 |       }),
142 |       undefined,
143 |     );
144 |     expect(mockedSelect).toHaveBeenCalledTimes(1);
145 |   });
146 | 
147 |   it('calls config.setModel and onClose when DescriptiveRadioButtonSelect.onSelect is triggered', () => {
148 |     const { props, mockConfig } = renderComponent({}, {}); // Pass empty object for contextValue
149 | 
150 |     const childOnSelect = mockedSelect.mock.calls[0][0].onSelect;
151 |     expect(childOnSelect).toBeDefined();
152 | 
153 |     childOnSelect(DEFAULT_GEMINI_MODEL);
154 | 
155 |     // Assert against the default mock provided by renderComponent
156 |     expect(mockConfig?.setModel).toHaveBeenCalledWith(DEFAULT_GEMINI_MODEL);
157 |     expect(props.onClose).toHaveBeenCalledTimes(1);
158 |   });
159 | 
160 |   it('does not pass onHighlight to DescriptiveRadioButtonSelect', () => {
161 |     renderComponent();
162 | 
163 |     const childOnHighlight = mockedSelect.mock.calls[0][0].onHighlight;
164 |     expect(childOnHighlight).toBeUndefined();
165 |   });
166 | 
167 |   it('calls onClose prop when "escape" key is pressed', () => {
168 |     const { props } = renderComponent();
169 | 
170 |     expect(mockedUseKeypress).toHaveBeenCalled();
171 | 
172 |     const keyPressHandler = mockedUseKeypress.mock.calls[0][0];
173 |     const options = mockedUseKeypress.mock.calls[0][1];
174 | 
175 |     expect(options).toEqual({ isActive: true });
176 | 
177 |     keyPressHandler({
178 |       name: 'escape',
179 |       ctrl: false,
180 |       meta: false,
181 |       shift: false,
182 |       paste: false,
183 |       sequence: '',
184 |     });
185 |     expect(props.onClose).toHaveBeenCalledTimes(1);
186 | 
187 |     keyPressHandler({
188 |       name: 'a',
189 |       ctrl: false,
190 |       meta: false,
191 |       shift: false,
192 |       paste: false,
193 |       sequence: '',
194 |     });
195 |     expect(props.onClose).toHaveBeenCalledTimes(1);
196 |   });
197 | 
198 |   it('updates initialIndex when config context changes', () => {
199 |     const mockGetModel = vi.fn(() => DEFAULT_GEMINI_MODEL_AUTO);
200 |     const { rerender } = render(
201 |       <ConfigContext.Provider
202 |         value={{ getModel: mockGetModel } as unknown as Config}
203 |       >
204 |         <ModelDialog onClose={vi.fn()} />
205 |       </ConfigContext.Provider>,
206 |     );
207 | 
208 |     expect(mockedSelect.mock.calls[0][0].initialIndex).toBe(0);
209 | 
210 |     mockGetModel.mockReturnValue(DEFAULT_GEMINI_FLASH_LITE_MODEL);
211 |     const newMockConfig = { getModel: mockGetModel } as unknown as Config;
212 | 
213 |     rerender(
214 |       <ConfigContext.Provider value={newMockConfig}>
215 |         <ModelDialog onClose={vi.fn()} />
216 |       </ConfigContext.Provider>,
217 |     );
218 | 
219 |     // Should be called at least twice: initial render + re-render after context change
220 |     expect(mockedSelect).toHaveBeenCalledTimes(2);
221 |     expect(mockedSelect.mock.calls[1][0].initialIndex).toBe(3);
222 |   });
223 | });
```

src/ui/components/ModelDialog.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type React from 'react';
8 | import { useCallback, useContext, useMemo } from 'react';
9 | import { Box, Text } from 'ink';
10 | import {
11 |   DEFAULT_GEMINI_FLASH_LITE_MODEL,
12 |   DEFAULT_GEMINI_FLASH_MODEL,
13 |   DEFAULT_GEMINI_MODEL,
14 |   DEFAULT_GEMINI_MODEL_AUTO,
15 |   ModelSlashCommandEvent,
16 |   logModelSlashCommand,
17 | } from '@google/gemini-cli-core';
18 | import { useKeypress } from '../hooks/useKeypress.js';
19 | import { theme } from '../semantic-colors.js';
20 | import { DescriptiveRadioButtonSelect } from './shared/DescriptiveRadioButtonSelect.js';
21 | import { ConfigContext } from '../contexts/ConfigContext.js';
22 | 
23 | interface ModelDialogProps {
24 |   onClose: () => void;
25 | }
26 | 
27 | const MODEL_OPTIONS = [
28 |   {
29 |     value: DEFAULT_GEMINI_MODEL_AUTO,
30 |     title: 'Auto (recommended)',
31 |     description: 'Let the system choose the best model for your task',
32 |     key: DEFAULT_GEMINI_MODEL_AUTO,
33 |   },
34 |   {
35 |     value: DEFAULT_GEMINI_MODEL,
36 |     title: 'Pro',
37 |     description: 'For complex tasks that require deep reasoning and creativity',
38 |     key: DEFAULT_GEMINI_MODEL,
39 |   },
40 |   {
41 |     value: DEFAULT_GEMINI_FLASH_MODEL,
42 |     title: 'Flash',
43 |     description: 'For tasks that need a balance of speed and reasoning',
44 |     key: DEFAULT_GEMINI_FLASH_MODEL,
45 |   },
46 |   {
47 |     value: DEFAULT_GEMINI_FLASH_LITE_MODEL,
48 |     title: 'Flash-Lite',
49 |     description: 'For simple tasks that need to be done quickly',
50 |     key: DEFAULT_GEMINI_FLASH_LITE_MODEL,
51 |   },
52 | ];
53 | 
54 | export function ModelDialog({ onClose }: ModelDialogProps): React.JSX.Element {
55 |   const config = useContext(ConfigContext);
56 | 
57 |   // Determine the Preferred Model (read once when the dialog opens).
58 |   const preferredModel = config?.getModel() || DEFAULT_GEMINI_MODEL_AUTO;
59 | 
60 |   useKeypress(
61 |     (key) => {
62 |       if (key.name === 'escape') {
63 |         onClose();
64 |       }
65 |     },
66 |     { isActive: true },
67 |   );
68 | 
69 |   // Calculate the initial index based on the preferred model.
70 |   const initialIndex = useMemo(
71 |     () => MODEL_OPTIONS.findIndex((option) => option.value === preferredModel),
72 |     [preferredModel],
73 |   );
74 | 
75 |   // Handle selection internally (Autonomous Dialog).
76 |   const handleSelect = useCallback(
77 |     (model: string) => {
78 |       if (config) {
79 |         config.setModel(model);
80 |         const event = new ModelSlashCommandEvent(model);
81 |         logModelSlashCommand(config, event);
82 |       }
83 |       onClose();
84 |     },
85 |     [config, onClose],
86 |   );
87 | 
88 |   return (
89 |     <Box
90 |       borderStyle="round"
91 |       borderColor={theme.border.default}
92 |       flexDirection="column"
93 |       padding={1}
94 |       width="100%"
95 |     >
96 |       <Text bold>Select Model</Text>
97 |       <Box marginTop={1}>
98 |         <DescriptiveRadioButtonSelect
99 |           items={MODEL_OPTIONS}
100 |           onSelect={handleSelect}
101 |           initialIndex={initialIndex}
102 |           showNumbers={true}
103 |         />
104 |       </Box>
105 |       <Box flexDirection="column">
106 |         <Text color={theme.text.secondary}>
107 |           {'> To use a specific Gemini model, use the --model flag.'}
108 |         </Text>
109 |       </Box>
110 |       <Box marginTop={1} flexDirection="column">
111 |         <Text color={theme.text.secondary}>(Press Esc to close)</Text>
112 |       </Box>
113 |     </Box>
114 |   );
115 | }
```

src/ui/components/ModelStatsDisplay.test.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { render } from 'ink-testing-library';
8 | import { describe, it, expect, vi, beforeAll, afterAll } from 'vitest';
9 | import { ModelStatsDisplay } from './ModelStatsDisplay.js';
10 | import * as SessionContext from '../contexts/SessionContext.js';
11 | import type { SessionMetrics } from '../contexts/SessionContext.js';
12 | 
13 | // Mock the context to provide controlled data for testing
14 | vi.mock('../contexts/SessionContext.js', async (importOriginal) => {
15 |   const actual = await importOriginal<typeof SessionContext>();
16 |   return {
17 |     ...actual,
18 |     useSessionStats: vi.fn(),
19 |   };
20 | });
21 | 
22 | const useSessionStatsMock = vi.mocked(SessionContext.useSessionStats);
23 | 
24 | const renderWithMockedStats = (metrics: SessionMetrics) => {
25 |   useSessionStatsMock.mockReturnValue({
26 |     stats: {
27 |       sessionStartTime: new Date(),
28 |       metrics,
29 |       lastPromptTokenCount: 0,
30 |       promptCount: 5,
31 |     },
32 | 
33 |     getPromptCount: () => 5,
34 |     startNewPrompt: vi.fn(),
35 |   });
36 | 
37 |   return render(<ModelStatsDisplay />);
38 | };
39 | 
40 | describe('<ModelStatsDisplay />', () => {
41 |   beforeAll(() => {
42 |     vi.spyOn(Number.prototype, 'toLocaleString').mockImplementation(function (
43 |       this: number,
44 |     ) {
45 |       // Use a stable 'en-US' format for test consistency.
46 |       return new Intl.NumberFormat('en-US').format(this);
47 |     });
48 |   });
49 | 
50 |   afterAll(() => {
51 |     vi.restoreAllMocks();
52 |   });
53 | 
54 |   it('should render "no API calls" message when there are no active models', () => {
55 |     const { lastFrame } = renderWithMockedStats({
56 |       models: {},
57 |       tools: {
58 |         totalCalls: 0,
59 |         totalSuccess: 0,
60 |         totalFail: 0,
61 |         totalDurationMs: 0,
62 |         totalDecisions: { accept: 0, reject: 0, modify: 0 },
63 |         byName: {},
64 |       },
65 |     });
66 | 
67 |     expect(lastFrame()).toContain(
68 |       'No API calls have been made in this session.',
69 |     );
70 |     expect(lastFrame()).toMatchSnapshot();
71 |   });
72 | 
73 |   it('should not display conditional rows if no model has data for them', () => {
74 |     const { lastFrame } = renderWithMockedStats({
75 |       models: {
76 |         'gemini-2.5-pro': {
77 |           api: { totalRequests: 1, totalErrors: 0, totalLatencyMs: 100 },
78 |           tokens: {
79 |             prompt: 10,
80 |             candidates: 20,
81 |             total: 30,
82 |             cached: 0,
83 |             thoughts: 0,
84 |             tool: 0,
85 |           },
86 |         },
87 |       },
88 |       tools: {
89 |         totalCalls: 0,
90 |         totalSuccess: 0,
91 |         totalFail: 0,
92 |         totalDurationMs: 0,
93 |         totalDecisions: { accept: 0, reject: 0, modify: 0 },
94 |         byName: {},
95 |       },
96 |     });
97 | 
98 |     const output = lastFrame();
99 |     expect(output).not.toContain('Cached');
100 |     expect(output).not.toContain('Thoughts');
101 |     expect(output).not.toContain('Tool');
102 |     expect(output).toMatchSnapshot();
103 |   });
104 | 
105 |   it('should display conditional rows if at least one model has data', () => {
106 |     const { lastFrame } = renderWithMockedStats({
107 |       models: {
108 |         'gemini-2.5-pro': {
109 |           api: { totalRequests: 1, totalErrors: 0, totalLatencyMs: 100 },
110 |           tokens: {
111 |             prompt: 10,
112 |             candidates: 20,
113 |             total: 30,
114 |             cached: 5,
115 |             thoughts: 2,
116 |             tool: 0,
117 |           },
118 |         },
119 |         'gemini-2.5-flash': {
120 |           api: { totalRequests: 1, totalErrors: 0, totalLatencyMs: 50 },
121 |           tokens: {
122 |             prompt: 5,
123 |             candidates: 10,
124 |             total: 15,
125 |             cached: 0,
126 |             thoughts: 0,
127 |             tool: 3,
128 |           },
129 |         },
130 |       },
131 |       tools: {
132 |         totalCalls: 0,
133 |         totalSuccess: 0,
134 |         totalFail: 0,
135 |         totalDurationMs: 0,
136 |         totalDecisions: { accept: 0, reject: 0, modify: 0 },
137 |         byName: {},
138 |       },
139 |     });
140 | 
141 |     const output = lastFrame();
142 |     expect(output).toContain('Cached');
143 |     expect(output).toContain('Thoughts');
144 |     expect(output).toContain('Tool');
145 |     expect(output).toMatchSnapshot();
146 |   });
147 | 
148 |   it('should display stats for multiple models correctly', () => {
149 |     const { lastFrame } = renderWithMockedStats({
150 |       models: {
151 |         'gemini-2.5-pro': {
152 |           api: { totalRequests: 10, totalErrors: 1, totalLatencyMs: 1000 },
153 |           tokens: {
154 |             prompt: 100,
155 |             candidates: 200,
156 |             total: 300,
157 |             cached: 50,
158 |             thoughts: 10,
159 |             tool: 5,
160 |           },
161 |         },
162 |         'gemini-2.5-flash': {
163 |           api: { totalRequests: 20, totalErrors: 2, totalLatencyMs: 500 },
164 |           tokens: {
165 |             prompt: 200,
166 |             candidates: 400,
167 |             total: 600,
168 |             cached: 100,
169 |             thoughts: 20,
170 |             tool: 10,
171 |           },
172 |         },
173 |       },
174 |       tools: {
175 |         totalCalls: 0,
176 |         totalSuccess: 0,
177 |         totalFail: 0,
178 |         totalDurationMs: 0,
179 |         totalDecisions: { accept: 0, reject: 0, modify: 0 },
180 |         byName: {},
181 |       },
182 |     });
183 | 
184 |     const output = lastFrame();
185 |     expect(output).toContain('gemini-2.5-pro');
186 |     expect(output).toContain('gemini-2.5-flash');
187 |     expect(output).toMatchSnapshot();
188 |   });
189 | 
190 |   it('should handle large values without wrapping or overlapping', () => {
191 |     const { lastFrame } = renderWithMockedStats({
192 |       models: {
193 |         'gemini-2.5-pro': {
194 |           api: {
195 |             totalRequests: 999999999,
196 |             totalErrors: 123456789,
197 |             totalLatencyMs: 9876,
198 |           },
199 |           tokens: {
200 |             prompt: 987654321,
201 |             candidates: 123456789,
202 |             total: 999999999,
203 |             cached: 123456789,
204 |             thoughts: 111111111,
205 |             tool: 222222222,
206 |           },
207 |         },
208 |       },
209 |       tools: {
210 |         totalCalls: 0,
211 |         totalSuccess: 0,
212 |         totalFail: 0,
213 |         totalDurationMs: 0,
214 |         totalDecisions: { accept: 0, reject: 0, modify: 0 },
215 |         byName: {},
216 |       },
217 |     });
218 | 
219 |     expect(lastFrame()).toMatchSnapshot();
220 |   });
221 | 
222 |   it('should display a single model correctly', () => {
223 |     const { lastFrame } = renderWithMockedStats({
224 |       models: {
225 |         'gemini-2.5-pro': {
226 |           api: { totalRequests: 1, totalErrors: 0, totalLatencyMs: 100 },
227 |           tokens: {
228 |             prompt: 10,
229 |             candidates: 20,
230 |             total: 30,
231 |             cached: 5,
232 |             thoughts: 2,
233 |             tool: 1,
234 |           },
235 |         },
236 |       },
237 |       tools: {
238 |         totalCalls: 0,
239 |         totalSuccess: 0,
240 |         totalFail: 0,
241 |         totalDurationMs: 0,
242 |         totalDecisions: { accept: 0, reject: 0, modify: 0 },
243 |         byName: {},
244 |       },
245 |     });
246 | 
247 |     const output = lastFrame();
248 |     expect(output).toContain('gemini-2.5-pro');
249 |     expect(output).not.toContain('gemini-2.5-flash');
250 |     expect(output).toMatchSnapshot();
251 |   });
252 | });
```

src/ui/components/ModelStatsDisplay.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type React from 'react';
8 | import { Box, Text } from 'ink';
9 | import { theme } from '../semantic-colors.js';
10 | import { formatDuration } from '../utils/formatters.js';
11 | import {
12 |   calculateAverageLatency,
13 |   calculateCacheHitRate,
14 |   calculateErrorRate,
15 | } from '../utils/computeStats.js';
16 | import type { ModelMetrics } from '../contexts/SessionContext.js';
17 | import { useSessionStats } from '../contexts/SessionContext.js';
18 | 
19 | const METRIC_COL_WIDTH = 28;
20 | const MODEL_COL_WIDTH = 22;
21 | 
22 | interface StatRowProps {
23 |   title: string;
24 |   values: Array<string | React.ReactElement>;
25 |   isSubtle?: boolean;
26 |   isSection?: boolean;
27 | }
28 | 
29 | const StatRow: React.FC<StatRowProps> = ({
30 |   title,
31 |   values,
32 |   isSubtle = false,
33 |   isSection = false,
34 | }) => (
35 |   <Box>
36 |     <Box width={METRIC_COL_WIDTH}>
37 |       <Text
38 |         bold={isSection}
39 |         color={isSection ? theme.text.primary : theme.text.link}
40 |       >
41 |         {isSubtle ? `  ↳ ${title}` : title}
42 |       </Text>
43 |     </Box>
44 |     {values.map((value, index) => (
45 |       <Box width={MODEL_COL_WIDTH} key={index}>
46 |         <Text color={theme.text.primary}>{value}</Text>
47 |       </Box>
48 |     ))}
49 |   </Box>
50 | );
51 | 
52 | export const ModelStatsDisplay: React.FC = () => {
53 |   const { stats } = useSessionStats();
54 |   const { models } = stats.metrics;
55 |   const activeModels = Object.entries(models).filter(
56 |     ([, metrics]) => metrics.api.totalRequests > 0,
57 |   );
58 | 
59 |   if (activeModels.length === 0) {
60 |     return (
61 |       <Box
62 |         borderStyle="round"
63 |         borderColor={theme.border.default}
64 |         paddingY={1}
65 |         paddingX={2}
66 |       >
67 |         <Text color={theme.text.primary}>
68 |           No API calls have been made in this session.
69 |         </Text>
70 |       </Box>
71 |     );
72 |   }
73 | 
74 |   const modelNames = activeModels.map(([name]) => name);
75 | 
76 |   const getModelValues = (
77 |     getter: (metrics: ModelMetrics) => string | React.ReactElement,
78 |   ) => activeModels.map(([, metrics]) => getter(metrics));
79 | 
80 |   const hasThoughts = activeModels.some(
81 |     ([, metrics]) => metrics.tokens.thoughts > 0,
82 |   );
83 |   const hasTool = activeModels.some(([, metrics]) => metrics.tokens.tool > 0);
84 |   const hasCached = activeModels.some(
85 |     ([, metrics]) => metrics.tokens.cached > 0,
86 |   );
87 | 
88 |   return (
89 |     <Box
90 |       borderStyle="round"
91 |       borderColor={theme.border.default}
92 |       flexDirection="column"
93 |       paddingY={1}
94 |       paddingX={2}
95 |     >
96 |       <Text bold color={theme.text.accent}>
97 |         Model Stats For Nerds
98 |       </Text>
99 |       <Box height={1} />
100 | 
101 |       {/* Header */}
102 |       <Box>
103 |         <Box width={METRIC_COL_WIDTH}>
104 |           <Text bold color={theme.text.primary}>
105 |             Metric
106 |           </Text>
107 |         </Box>
108 |         {modelNames.map((name) => (
109 |           <Box width={MODEL_COL_WIDTH} key={name}>
110 |             <Text bold color={theme.text.primary}>
111 |               {name}
112 |             </Text>
113 |           </Box>
114 |         ))}
115 |       </Box>
116 | 
117 |       {/* Divider */}
118 |       <Box
119 |         borderStyle="single"
120 |         borderBottom={true}
121 |         borderTop={false}
122 |         borderLeft={false}
123 |         borderRight={false}
124 |         borderColor={theme.border.default}
125 |       />
126 | 
127 |       {/* API Section */}
128 |       <StatRow title="API" values={[]} isSection />
129 |       <StatRow
130 |         title="Requests"
131 |         values={getModelValues((m) => m.api.totalRequests.toLocaleString())}
132 |       />
133 |       <StatRow
134 |         title="Errors"
135 |         values={getModelValues((m) => {
136 |           const errorRate = calculateErrorRate(m);
137 |           return (
138 |             <Text
139 |               color={
140 |                 m.api.totalErrors > 0 ? theme.status.error : theme.text.primary
141 |               }
142 |             >
143 |               {m.api.totalErrors.toLocaleString()} ({errorRate.toFixed(1)}%)
144 |             </Text>
145 |           );
146 |         })}
147 |       />
148 |       <StatRow
149 |         title="Avg Latency"
150 |         values={getModelValues((m) => {
151 |           const avgLatency = calculateAverageLatency(m);
152 |           return formatDuration(avgLatency);
153 |         })}
154 |       />
155 | 
156 |       <Box height={1} />
157 | 
158 |       {/* Tokens Section */}
159 |       <StatRow title="Tokens" values={[]} isSection />
160 |       <StatRow
161 |         title="Total"
162 |         values={getModelValues((m) => (
163 |           <Text color={theme.status.warning}>
164 |             {m.tokens.total.toLocaleString()}
165 |           </Text>
166 |         ))}
167 |       />
168 |       <StatRow
169 |         title="Prompt"
170 |         isSubtle
171 |         values={getModelValues((m) => m.tokens.prompt.toLocaleString())}
172 |       />
173 |       {hasCached && (
174 |         <StatRow
175 |           title="Cached"
176 |           isSubtle
177 |           values={getModelValues((m) => {
178 |             const cacheHitRate = calculateCacheHitRate(m);
179 |             return (
180 |               <Text color={theme.status.success}>
181 |                 {m.tokens.cached.toLocaleString()} ({cacheHitRate.toFixed(1)}%)
182 |               </Text>
183 |             );
184 |           })}
185 |         />
186 |       )}
187 |       {hasThoughts && (
188 |         <StatRow
189 |           title="Thoughts"
190 |           isSubtle
191 |           values={getModelValues((m) => m.tokens.thoughts.toLocaleString())}
192 |         />
193 |       )}
194 |       {hasTool && (
195 |         <StatRow
196 |           title="Tool"
197 |           isSubtle
198 |           values={getModelValues((m) => m.tokens.tool.toLocaleString())}
199 |         />
200 |       )}
201 |       <StatRow
202 |         title="Output"
203 |         isSubtle
204 |         values={getModelValues((m) => m.tokens.candidates.toLocaleString())}
205 |       />
206 |     </Box>
207 |   );
208 | };
```

src/ui/components/Notifications.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { Box, Text, useIsScreenReaderEnabled } from 'ink';
8 | import { useAppContext } from '../contexts/AppContext.js';
9 | import { useUIState } from '../contexts/UIStateContext.js';
10 | import { theme } from '../semantic-colors.js';
11 | import { StreamingState } from '../types.js';
12 | import { UpdateNotification } from './UpdateNotification.js';
13 | 
14 | import { homedir } from 'node:os';
15 | import path from 'node:path';
16 | 
17 | const settingsPath = path.join(homedir(), '.gemini', 'settings.json');
18 | 
19 | export const Notifications = () => {
20 |   const { startupWarnings } = useAppContext();
21 |   const { initError, streamingState, updateInfo } = useUIState();
22 |   const isScreenReaderEnabled = useIsScreenReaderEnabled();
23 |   const showStartupWarnings = startupWarnings.length > 0;
24 |   const showInitError =
25 |     initError && streamingState !== StreamingState.Responding;
26 | 
27 |   if (
28 |     !showStartupWarnings &&
29 |     !showInitError &&
30 |     !updateInfo &&
31 |     !isScreenReaderEnabled
32 |   ) {
33 |     return null;
34 |   }
35 | 
36 |   return (
37 |     <>
38 |       {isScreenReaderEnabled && (
39 |         <Text>
40 |           You are currently in screen reader-friendly view. To switch out, open{' '}
41 |           {settingsPath} and remove the entry for {'"screenReader"'}.
42 |         </Text>
43 |       )}
44 |       {updateInfo && <UpdateNotification message={updateInfo.message} />}
45 |       {showStartupWarnings && (
46 |         <Box
47 |           borderStyle="round"
48 |           borderColor={theme.status.warning}
49 |           paddingX={1}
50 |           marginY={1}
51 |           flexDirection="column"
52 |         >
53 |           {startupWarnings.map((warning, index) => (
54 |             <Text key={index} color={theme.status.warning}>
55 |               {warning}
56 |             </Text>
57 |           ))}
58 |         </Box>
59 |       )}
60 |       {showInitError && (
61 |         <Box
62 |           borderStyle="round"
63 |           borderColor={theme.status.error}
64 |           paddingX={1}
65 |           marginBottom={1}
66 |         >
67 |           <Text color={theme.status.error}>
68 |             Initialization Error: {initError}
69 |           </Text>
70 |           <Text color={theme.status.error}>
71 |             {' '}
72 |             Please check API key and configuration.
73 |           </Text>
74 |         </Box>
75 |       )}
76 |     </>
77 |   );
78 | };
```

src/ui/components/PermissionsModifyTrustDialog.test.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | /// <reference types="vitest/globals" />
8 | 
9 | import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
10 | import type { Mock } from 'vitest';
11 | import { renderWithProviders } from '../../test-utils/render.js';
12 | import { PermissionsModifyTrustDialog } from './PermissionsModifyTrustDialog.js';
13 | import { TrustLevel } from '../../config/trustedFolders.js';
14 | import { waitFor, act } from '@testing-library/react';
15 | import * as processUtils from '../../utils/processUtils.js';
16 | import { usePermissionsModifyTrust } from '../hooks/usePermissionsModifyTrust.js';
17 | 
18 | // Hoist mocks for dependencies of the usePermissionsModifyTrust hook
19 | const mockedCwd = vi.hoisted(() => vi.fn());
20 | const mockedLoadTrustedFolders = vi.hoisted(() => vi.fn());
21 | const mockedIsWorkspaceTrusted = vi.hoisted(() => vi.fn());
22 | 
23 | // Mock the modules themselves
24 | vi.mock('node:process', async (importOriginal) => {
25 |   const actual = await importOriginal<typeof import('node:process')>();
26 |   return {
27 |     ...actual,
28 |     cwd: mockedCwd,
29 |   };
30 | });
31 | 
32 | vi.mock('../../config/trustedFolders.js', () => ({
33 |   loadTrustedFolders: mockedLoadTrustedFolders,
34 |   isWorkspaceTrusted: mockedIsWorkspaceTrusted,
35 |   TrustLevel: {
36 |     TRUST_FOLDER: 'TRUST_FOLDER',
37 |     TRUST_PARENT: 'TRUST_PARENT',
38 |     DO_NOT_TRUST: 'DO_NOT_TRUST',
39 |   },
40 | }));
41 | 
42 | vi.mock('../hooks/usePermissionsModifyTrust.js');
43 | 
44 | describe('PermissionsModifyTrustDialog', () => {
45 |   let mockUpdateTrustLevel: Mock;
46 |   let mockCommitTrustLevelChange: Mock;
47 | 
48 |   beforeEach(() => {
49 |     mockUpdateTrustLevel = vi.fn();
50 |     mockCommitTrustLevelChange = vi.fn();
51 |     vi.mocked(usePermissionsModifyTrust).mockReturnValue({
52 |       cwd: '/test/dir',
53 |       currentTrustLevel: TrustLevel.DO_NOT_TRUST,
54 |       isInheritedTrustFromParent: false,
55 |       isInheritedTrustFromIde: false,
56 |       needsRestart: false,
57 |       updateTrustLevel: mockUpdateTrustLevel,
58 |       commitTrustLevelChange: mockCommitTrustLevelChange,
59 |       isFolderTrustEnabled: true,
60 |     });
61 |   });
62 | 
63 |   afterEach(() => {
64 |     vi.resetAllMocks();
65 |   });
66 | 
67 |   it('should render the main dialog with current trust level', async () => {
68 |     const { lastFrame } = renderWithProviders(
69 |       <PermissionsModifyTrustDialog onExit={vi.fn()} addItem={vi.fn()} />,
70 |     );
71 | 
72 |     await waitFor(() => {
73 |       expect(lastFrame()).toContain('Modify Trust Level');
74 |       expect(lastFrame()).toContain('Folder: /test/dir');
75 |       expect(lastFrame()).toContain('Current Level: DO_NOT_TRUST');
76 |     });
77 |   });
78 | 
79 |   it('should display the inherited trust note from parent', async () => {
80 |     vi.mocked(usePermissionsModifyTrust).mockReturnValue({
81 |       cwd: '/test/dir',
82 |       currentTrustLevel: TrustLevel.DO_NOT_TRUST,
83 |       isInheritedTrustFromParent: true,
84 |       isInheritedTrustFromIde: false,
85 |       needsRestart: false,
86 |       updateTrustLevel: mockUpdateTrustLevel,
87 |       commitTrustLevelChange: mockCommitTrustLevelChange,
88 |       isFolderTrustEnabled: true,
89 |     });
90 |     const { lastFrame } = renderWithProviders(
91 |       <PermissionsModifyTrustDialog onExit={vi.fn()} addItem={vi.fn()} />,
92 |     );
93 | 
94 |     await waitFor(() => {
95 |       expect(lastFrame()).toContain(
96 |         'Note: This folder behaves as a trusted folder because one of the parent folders is trusted.',
97 |       );
98 |     });
99 |   });
100 | 
101 |   it('should display the inherited trust note from IDE', async () => {
102 |     vi.mocked(usePermissionsModifyTrust).mockReturnValue({
103 |       cwd: '/test/dir',
104 |       currentTrustLevel: TrustLevel.DO_NOT_TRUST,
105 |       isInheritedTrustFromParent: false,
106 |       isInheritedTrustFromIde: true,
107 |       needsRestart: false,
108 |       updateTrustLevel: mockUpdateTrustLevel,
109 |       commitTrustLevelChange: mockCommitTrustLevelChange,
110 |       isFolderTrustEnabled: true,
111 |     });
112 |     const { lastFrame } = renderWithProviders(
113 |       <PermissionsModifyTrustDialog onExit={vi.fn()} addItem={vi.fn()} />,
114 |     );
115 | 
116 |     await waitFor(() => {
117 |       expect(lastFrame()).toContain(
118 |         'Note: This folder behaves as a trusted folder because the connected IDE workspace is trusted.',
119 |       );
120 |     });
121 |   });
122 | 
123 |   it('should call onExit when escape is pressed', async () => {
124 |     const onExit = vi.fn();
125 |     const { stdin, lastFrame } = renderWithProviders(
126 |       <PermissionsModifyTrustDialog onExit={onExit} addItem={vi.fn()} />,
127 |     );
128 | 
129 |     await waitFor(() => expect(lastFrame()).not.toContain('Loading...'));
130 | 
131 |     act(() => {
132 |       stdin.write('\x1b'); // escape key
133 |     });
134 | 
135 |     await waitFor(() => {
136 |       expect(onExit).toHaveBeenCalled();
137 |     });
138 |   });
139 | 
140 |   it('should commit, restart, and exit on `r` keypress', async () => {
141 |     const mockRelaunchApp = vi
142 |       .spyOn(processUtils, 'relaunchApp')
143 |       .mockResolvedValue(undefined);
144 |     vi.mocked(usePermissionsModifyTrust).mockReturnValue({
145 |       cwd: '/test/dir',
146 |       currentTrustLevel: TrustLevel.DO_NOT_TRUST,
147 |       isInheritedTrustFromParent: false,
148 |       isInheritedTrustFromIde: false,
149 |       needsRestart: true,
150 |       updateTrustLevel: mockUpdateTrustLevel,
151 |       commitTrustLevelChange: mockCommitTrustLevelChange,
152 |       isFolderTrustEnabled: true,
153 |     });
154 | 
155 |     const onExit = vi.fn();
156 |     const { stdin, lastFrame } = renderWithProviders(
157 |       <PermissionsModifyTrustDialog onExit={onExit} addItem={vi.fn()} />,
158 |     );
159 | 
160 |     await waitFor(() => expect(lastFrame()).not.toContain('Loading...'));
161 | 
162 |     act(() => stdin.write('r')); // Press 'r' to restart
163 | 
164 |     await waitFor(() => {
165 |       expect(mockCommitTrustLevelChange).toHaveBeenCalled();
166 |       expect(mockRelaunchApp).toHaveBeenCalled();
167 |       expect(onExit).toHaveBeenCalled();
168 |     });
169 | 
170 |     mockRelaunchApp.mockRestore();
171 |   });
172 | 
173 |   it('should not commit when escape is pressed during restart prompt', async () => {
174 |     vi.mocked(usePermissionsModifyTrust).mockReturnValue({
175 |       cwd: '/test/dir',
176 |       currentTrustLevel: TrustLevel.DO_NOT_TRUST,
177 |       isInheritedTrustFromParent: false,
178 |       isInheritedTrustFromIde: false,
179 |       needsRestart: true,
180 |       updateTrustLevel: mockUpdateTrustLevel,
181 |       commitTrustLevelChange: mockCommitTrustLevelChange,
182 |       isFolderTrustEnabled: true,
183 |     });
184 | 
185 |     const onExit = vi.fn();
186 |     const { stdin, lastFrame } = renderWithProviders(
187 |       <PermissionsModifyTrustDialog onExit={onExit} addItem={vi.fn()} />,
188 |     );
189 | 
190 |     await waitFor(() => expect(lastFrame()).not.toContain('Loading...'));
191 | 
192 |     act(() => stdin.write('\x1b')); // Press escape
193 | 
194 |     await waitFor(() => {
195 |       expect(mockCommitTrustLevelChange).not.toHaveBeenCalled();
196 |       expect(onExit).toHaveBeenCalled();
197 |     });
198 |   });
199 | });
```

src/ui/components/PermissionsModifyTrustDialog.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { Box, Text } from 'ink';
8 | import type React from 'react';
9 | import { TrustLevel } from '../../config/trustedFolders.js';
10 | import { useKeypress } from '../hooks/useKeypress.js';
11 | import { usePermissionsModifyTrust } from '../hooks/usePermissionsModifyTrust.js';
12 | import { theme } from '../semantic-colors.js';
13 | import { RadioButtonSelect } from './shared/RadioButtonSelect.js';
14 | import { relaunchApp } from '../../utils/processUtils.js';
15 | import { type UseHistoryManagerReturn } from '../hooks/useHistoryManager.js';
16 | 
17 | interface PermissionsModifyTrustDialogProps {
18 |   onExit: () => void;
19 |   addItem: UseHistoryManagerReturn['addItem'];
20 | }
21 | 
22 | const TRUST_LEVEL_ITEMS = [
23 |   {
24 |     label: 'Trust this folder',
25 |     value: TrustLevel.TRUST_FOLDER,
26 |     key: TrustLevel.TRUST_FOLDER,
27 |   },
28 |   {
29 |     label: 'Trust parent folder',
30 |     value: TrustLevel.TRUST_PARENT,
31 |     key: TrustLevel.TRUST_PARENT,
32 |   },
33 |   {
34 |     label: "Don't trust",
35 |     value: TrustLevel.DO_NOT_TRUST,
36 |     key: TrustLevel.DO_NOT_TRUST,
37 |   },
38 | ];
39 | 
40 | export function PermissionsModifyTrustDialog({
41 |   onExit,
42 |   addItem,
43 | }: PermissionsModifyTrustDialogProps): React.JSX.Element {
44 |   const {
45 |     cwd,
46 |     currentTrustLevel,
47 |     isInheritedTrustFromParent,
48 |     isInheritedTrustFromIde,
49 |     needsRestart,
50 |     updateTrustLevel,
51 |     commitTrustLevelChange,
52 |   } = usePermissionsModifyTrust(onExit, addItem);
53 | 
54 |   useKeypress(
55 |     (key) => {
56 |       if (key.name === 'escape') {
57 |         onExit();
58 |       }
59 |       if (needsRestart && key.name === 'r') {
60 |         commitTrustLevelChange();
61 |         relaunchApp();
62 |         onExit();
63 |       }
64 |     },
65 |     { isActive: true },
66 |   );
67 | 
68 |   const index = TRUST_LEVEL_ITEMS.findIndex(
69 |     (item) => item.value === currentTrustLevel,
70 |   );
71 |   const initialIndex = index === -1 ? 0 : index;
72 | 
73 |   return (
74 |     <>
75 |       <Box
76 |         borderStyle="round"
77 |         borderColor={theme.border.default}
78 |         flexDirection="column"
79 |         padding={1}
80 |       >
81 |         <Box flexDirection="column" paddingBottom={1}>
82 |           <Text bold>{'> '}Modify Trust Level</Text>
83 |           <Box marginTop={1} />
84 |           <Text>Folder: {cwd}</Text>
85 |           <Text>
86 |             Current Level: <Text bold>{currentTrustLevel || 'Not Set'}</Text>
87 |           </Text>
88 |           {isInheritedTrustFromParent && (
89 |             <Text color={theme.text.secondary}>
90 |               Note: This folder behaves as a trusted folder because one of the
91 |               parent folders is trusted. It will remain trusted even if you set
92 |               a different trust level here. To change this, you need to modify
93 |               the trust setting in the parent folder.
94 |             </Text>
95 |           )}
96 |           {isInheritedTrustFromIde && (
97 |             <Text color={theme.text.secondary}>
98 |               Note: This folder behaves as a trusted folder because the
99 |               connected IDE workspace is trusted. It will remain trusted even if
100 |               you set a different trust level here.
101 |             </Text>
102 |           )}
103 |         </Box>
104 | 
105 |         <RadioButtonSelect
106 |           items={TRUST_LEVEL_ITEMS}
107 |           onSelect={updateTrustLevel}
108 |           isFocused={true}
109 |           initialIndex={initialIndex}
110 |         />
111 |         <Box marginTop={1}>
112 |           <Text color={theme.text.secondary}>(Use Enter to select)</Text>
113 |         </Box>
114 |       </Box>
115 |       {needsRestart && (
116 |         <Box marginLeft={1} marginTop={1}>
117 |           <Text color={theme.status.warning}>
118 |             To apply the trust changes, Gemini CLI must be restarted. Press
119 |             &apos;r&apos; to restart CLI now.
120 |           </Text>
121 |         </Box>
122 |       )}
123 |     </>
124 |   );
125 | }
```

src/ui/components/PrepareLabel.test.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect } from 'vitest';
8 | import { render } from 'ink-testing-library';
9 | import { PrepareLabel, MAX_WIDTH } from './PrepareLabel.js';
10 | 
11 | describe('PrepareLabel', () => {
12 |   const color = 'white';
13 |   const flat = (s: string | undefined) => (s ?? '').replace(/\n/g, '');
14 | 
15 |   it('renders plain label when no match (short label)', () => {
16 |     const { lastFrame } = render(
17 |       <PrepareLabel
18 |         label="simple command"
19 |         userInput=""
20 |         matchedIndex={undefined}
21 |         textColor={color}
22 |         isExpanded={false}
23 |       />,
24 |     );
25 |     expect(lastFrame()).toMatchSnapshot();
26 |   });
27 | 
28 |   it('truncates long label when collapsed and no match', () => {
29 |     const long = 'x'.repeat(MAX_WIDTH + 25);
30 |     const { lastFrame } = render(
31 |       <PrepareLabel
32 |         label={long}
33 |         userInput=""
34 |         textColor={color}
35 |         isExpanded={false}
36 |       />,
37 |     );
38 |     const out = lastFrame();
39 |     const f = flat(out);
40 |     expect(f.endsWith('...')).toBe(true);
41 |     expect(f.length).toBe(MAX_WIDTH + 3);
42 |     expect(out).toMatchSnapshot();
43 |   });
44 | 
45 |   it('shows full long label when expanded and no match', () => {
46 |     const long = 'y'.repeat(MAX_WIDTH + 25);
47 |     const { lastFrame } = render(
48 |       <PrepareLabel
49 |         label={long}
50 |         userInput=""
51 |         textColor={color}
52 |         isExpanded={true}
53 |       />,
54 |     );
55 |     const out = lastFrame();
56 |     const f = flat(out);
57 |     expect(f.length).toBe(long.length);
58 |     expect(out).toMatchSnapshot();
59 |   });
60 | 
61 |   it('highlights matched substring when expanded (text only visible)', () => {
62 |     const label = 'run: git commit -m "feat: add search"';
63 |     const userInput = 'commit';
64 |     const matchedIndex = label.indexOf(userInput);
65 |     const { lastFrame } = render(
66 |       <PrepareLabel
67 |         label={label}
68 |         userInput={userInput}
69 |         matchedIndex={matchedIndex}
70 |         textColor={color}
71 |         isExpanded={true}
72 |       />,
73 |     );
74 |     expect(lastFrame()).toMatchSnapshot();
75 |   });
76 | 
77 |   it('creates centered window around match when collapsed', () => {
78 |     const prefix = 'cd /very/long/path/that/keeps/going/'.repeat(3);
79 |     const core = 'search-here';
80 |     const suffix = '/and/then/some/more/components/'.repeat(3);
81 |     const label = prefix + core + suffix;
82 |     const matchedIndex = prefix.length;
83 |     const { lastFrame } = render(
84 |       <PrepareLabel
85 |         label={label}
86 |         userInput={core}
87 |         matchedIndex={matchedIndex}
88 |         textColor={color}
89 |         isExpanded={false}
90 |       />,
91 |     );
92 |     const out = lastFrame();
93 |     const f = flat(out);
94 |     expect(f.includes(core)).toBe(true);
95 |     expect(f.startsWith('...')).toBe(true);
96 |     expect(f.endsWith('...')).toBe(true);
97 |     expect(out).toMatchSnapshot();
98 |   });
99 | 
100 |   it('truncates match itself when match is very long', () => {
101 |     const prefix = 'find ';
102 |     const core = 'x'.repeat(MAX_WIDTH + 25);
103 |     const suffix = ' in this text';
104 |     const label = prefix + core + suffix;
105 |     const matchedIndex = prefix.length;
106 |     const { lastFrame } = render(
107 |       <PrepareLabel
108 |         label={label}
109 |         userInput={core}
110 |         matchedIndex={matchedIndex}
111 |         textColor={color}
112 |         isExpanded={false}
113 |       />,
114 |     );
115 |     const out = lastFrame();
116 |     const f = flat(out);
117 |     expect(f.includes('...')).toBe(true);
118 |     expect(f.startsWith('...')).toBe(false);
119 |     expect(f.endsWith('...')).toBe(true);
120 |     expect(f.length).toBe(MAX_WIDTH + 2);
121 |     expect(out).toMatchSnapshot();
122 |   });
123 | });
```

src/ui/components/PrepareLabel.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import React from 'react';
8 | import { Text } from 'ink';
9 | import { theme } from '../semantic-colors.js';
10 | 
11 | export const MAX_WIDTH = 150; // Maximum width for the text that is shown
12 | 
13 | export interface PrepareLabelProps {
14 |   label: string;
15 |   matchedIndex?: number;
16 |   userInput: string;
17 |   textColor: string;
18 |   isExpanded?: boolean;
19 | }
20 | 
21 | const _PrepareLabel: React.FC<PrepareLabelProps> = ({
22 |   label,
23 |   matchedIndex,
24 |   userInput,
25 |   textColor,
26 |   isExpanded = false,
27 | }) => {
28 |   const hasMatch =
29 |     matchedIndex !== undefined &&
30 |     matchedIndex >= 0 &&
31 |     matchedIndex < label.length &&
32 |     userInput.length > 0;
33 | 
34 |   // Render the plain label if there's no match
35 |   if (!hasMatch) {
36 |     const display = isExpanded
37 |       ? label
38 |       : label.length > MAX_WIDTH
39 |         ? label.slice(0, MAX_WIDTH) + '...'
40 |         : label;
41 |     return (
42 |       <Text wrap="wrap" color={textColor}>
43 |         {display}
44 |       </Text>
45 |     );
46 |   }
47 | 
48 |   const matchLength = userInput.length;
49 |   let before = '';
50 |   let match = '';
51 |   let after = '';
52 | 
53 |   // Case 1: Show the full string if it's expanded or already fits
54 |   if (isExpanded || label.length <= MAX_WIDTH) {
55 |     before = label.slice(0, matchedIndex);
56 |     match = label.slice(matchedIndex, matchedIndex + matchLength);
57 |     after = label.slice(matchedIndex + matchLength);
58 |   }
59 |   // Case 2: The match itself is too long, so we only show a truncated portion of the match
60 |   else if (matchLength >= MAX_WIDTH) {
61 |     match = label.slice(matchedIndex, matchedIndex + MAX_WIDTH - 1) + '...';
62 |   }
63 |   // Case 3: Truncate the string to create a window around the match
64 |   else {
65 |     const contextSpace = MAX_WIDTH - matchLength;
66 |     const beforeSpace = Math.floor(contextSpace / 2);
67 |     const afterSpace = Math.ceil(contextSpace / 2);
68 | 
69 |     let start = matchedIndex - beforeSpace;
70 |     let end = matchedIndex + matchLength + afterSpace;
71 | 
72 |     if (start < 0) {
73 |       end += -start; // Slide window right
74 |       start = 0;
75 |     }
76 |     if (end > label.length) {
77 |       start -= end - label.length; // Slide window left
78 |       end = label.length;
79 |     }
80 |     start = Math.max(0, start);
81 | 
82 |     const finalMatchIndex = matchedIndex - start;
83 |     const slicedLabel = label.slice(start, end);
84 | 
85 |     before = slicedLabel.slice(0, finalMatchIndex);
86 |     match = slicedLabel.slice(finalMatchIndex, finalMatchIndex + matchLength);
87 |     after = slicedLabel.slice(finalMatchIndex + matchLength);
88 | 
89 |     if (start > 0) {
90 |       before = before.length >= 3 ? '...' + before.slice(3) : '...';
91 |     }
92 |     if (end < label.length) {
93 |       after = after.length >= 3 ? after.slice(0, -3) + '...' : '...';
94 |     }
95 |   }
96 | 
97 |   return (
98 |     <Text color={textColor} wrap="wrap">
99 |       {before}
100 |       {match
101 |         ? match.split(/(\s+)/).map((part, index) => (
102 |             <Text
103 |               key={`match-${index}`}
104 |               color={theme.background.primary}
105 |               backgroundColor={theme.text.primary}
106 |             >
107 |               {part}
108 |             </Text>
109 |           ))
110 |         : null}
111 |       {after}
112 |     </Text>
113 |   );
114 | };
115 | 
116 | export const PrepareLabel = React.memo(_PrepareLabel);
```

src/ui/components/ProQuotaDialog.test.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { render } from 'ink-testing-library';
8 | import { describe, it, expect, vi, beforeEach, type Mock } from 'vitest';
9 | import { ProQuotaDialog } from './ProQuotaDialog.js';
10 | import { RadioButtonSelect } from './shared/RadioButtonSelect.js';
11 | 
12 | // Mock the child component to make it easier to test the parent
13 | vi.mock('./shared/RadioButtonSelect.js', () => ({
14 |   RadioButtonSelect: vi.fn(),
15 | }));
16 | 
17 | describe('ProQuotaDialog', () => {
18 |   beforeEach(() => {
19 |     vi.clearAllMocks();
20 |   });
21 | 
22 |   it('should render with correct title and options', () => {
23 |     const { lastFrame } = render(
24 |       <ProQuotaDialog
25 |         failedModel="gemini-2.5-pro"
26 |         fallbackModel="gemini-2.5-flash"
27 |         onChoice={() => {}}
28 |       />,
29 |     );
30 | 
31 |     const output = lastFrame();
32 |     expect(output).toContain('Pro quota limit reached for gemini-2.5-pro.');
33 | 
34 |     // Check that RadioButtonSelect was called with the correct items
35 |     expect(RadioButtonSelect).toHaveBeenCalledWith(
36 |       expect.objectContaining({
37 |         items: [
38 |           {
39 |             label: 'Change auth (executes the /auth command)',
40 |             value: 'auth',
41 |             key: 'auth',
42 |           },
43 |           {
44 |             label: `Continue with gemini-2.5-flash`,
45 |             value: 'continue',
46 |             key: 'continue',
47 |           },
48 |         ],
49 |       }),
50 |       undefined,
51 |     );
52 |   });
53 | 
54 |   it('should call onChoice with "auth" when "Change auth" is selected', () => {
55 |     const mockOnChoice = vi.fn();
56 |     render(
57 |       <ProQuotaDialog
58 |         failedModel="gemini-2.5-pro"
59 |         fallbackModel="gemini-2.5-flash"
60 |         onChoice={mockOnChoice}
61 |       />,
62 |     );
63 | 
64 |     // Get the onSelect function passed to RadioButtonSelect
65 |     const onSelect = (RadioButtonSelect as Mock).mock.calls[0][0].onSelect;
66 | 
67 |     // Simulate the selection
68 |     onSelect('auth');
69 | 
70 |     expect(mockOnChoice).toHaveBeenCalledWith('auth');
71 |   });
72 | 
73 |   it('should call onChoice with "continue" when "Continue with flash" is selected', () => {
74 |     const mockOnChoice = vi.fn();
75 |     render(
76 |       <ProQuotaDialog
77 |         failedModel="gemini-2.5-pro"
78 |         fallbackModel="gemini-2.5-flash"
79 |         onChoice={mockOnChoice}
80 |       />,
81 |     );
82 | 
83 |     // Get the onSelect function passed to RadioButtonSelect
84 |     const onSelect = (RadioButtonSelect as Mock).mock.calls[0][0].onSelect;
85 | 
86 |     // Simulate the selection
87 |     onSelect('continue');
88 | 
89 |     expect(mockOnChoice).toHaveBeenCalledWith('continue');
90 |   });
91 | });
```

src/ui/components/ProQuotaDialog.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type React from 'react';
8 | import { Box, Text } from 'ink';
9 | import { RadioButtonSelect } from './shared/RadioButtonSelect.js';
10 | import { theme } from '../semantic-colors.js';
11 | 
12 | interface ProQuotaDialogProps {
13 |   failedModel: string;
14 |   fallbackModel: string;
15 |   onChoice: (choice: 'auth' | 'continue') => void;
16 | }
17 | 
18 | export function ProQuotaDialog({
19 |   failedModel,
20 |   fallbackModel,
21 |   onChoice,
22 | }: ProQuotaDialogProps): React.JSX.Element {
23 |   const items = [
24 |     {
25 |       label: 'Change auth (executes the /auth command)',
26 |       value: 'auth' as const,
27 |       key: 'auth',
28 |     },
29 |     {
30 |       label: `Continue with ${fallbackModel}`,
31 |       value: 'continue' as const,
32 |       key: 'continue',
33 |     },
34 |   ];
35 | 
36 |   const handleSelect = (choice: 'auth' | 'continue') => {
37 |     onChoice(choice);
38 |   };
39 | 
40 |   return (
41 |     <Box borderStyle="round" flexDirection="column" paddingX={1}>
42 |       <Text bold color={theme.status.warning}>
43 |         Pro quota limit reached for {failedModel}.
44 |       </Text>
45 |       <Box marginTop={1}>
46 |         <RadioButtonSelect
47 |           items={items}
48 |           initialIndex={1}
49 |           onSelect={handleSelect}
50 |         />
51 |       </Box>
52 |     </Box>
53 |   );
54 | }
```

src/ui/components/QueuedMessageDisplay.test.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect } from 'vitest';
8 | import { render } from 'ink-testing-library';
9 | import { QueuedMessageDisplay } from './QueuedMessageDisplay.js';
10 | 
11 | describe('QueuedMessageDisplay', () => {
12 |   it('renders nothing when message queue is empty', () => {
13 |     const { lastFrame } = render(<QueuedMessageDisplay messageQueue={[]} />);
14 | 
15 |     expect(lastFrame()).toBe('');
16 |   });
17 | 
18 |   it('displays single queued message', () => {
19 |     const { lastFrame } = render(
20 |       <QueuedMessageDisplay messageQueue={['First message']} />,
21 |     );
22 | 
23 |     const output = lastFrame();
24 |     expect(output).toContain('First message');
25 |   });
26 | 
27 |   it('displays multiple queued messages', () => {
28 |     const messageQueue = [
29 |       'First queued message',
30 |       'Second queued message',
31 |       'Third queued message',
32 |     ];
33 | 
34 |     const { lastFrame } = render(
35 |       <QueuedMessageDisplay messageQueue={messageQueue} />,
36 |     );
37 | 
38 |     const output = lastFrame();
39 |     expect(output).toContain('First queued message');
40 |     expect(output).toContain('Second queued message');
41 |     expect(output).toContain('Third queued message');
42 |   });
43 | 
44 |   it('shows overflow indicator when more than 3 messages are queued', () => {
45 |     const messageQueue = [
46 |       'Message 1',
47 |       'Message 2',
48 |       'Message 3',
49 |       'Message 4',
50 |       'Message 5',
51 |     ];
52 | 
53 |     const { lastFrame } = render(
54 |       <QueuedMessageDisplay messageQueue={messageQueue} />,
55 |     );
56 | 
57 |     const output = lastFrame();
58 |     expect(output).toContain('Message 1');
59 |     expect(output).toContain('Message 2');
60 |     expect(output).toContain('Message 3');
61 |     expect(output).toContain('... (+2 more)');
62 |     expect(output).not.toContain('Message 4');
63 |     expect(output).not.toContain('Message 5');
64 |   });
65 | 
66 |   it('normalizes whitespace in messages', () => {
67 |     const messageQueue = ['Message   with\tmultiple\n  whitespace'];
68 | 
69 |     const { lastFrame } = render(
70 |       <QueuedMessageDisplay messageQueue={messageQueue} />,
71 |     );
72 | 
73 |     const output = lastFrame();
74 |     expect(output).toContain('Message with multiple whitespace');
75 |   });
76 | });
```

src/ui/components/QueuedMessageDisplay.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { Box, Text } from 'ink';
8 | 
9 | const MAX_DISPLAYED_QUEUED_MESSAGES = 3;
10 | 
11 | export interface QueuedMessageDisplayProps {
12 |   messageQueue: string[];
13 | }
14 | 
15 | export const QueuedMessageDisplay = ({
16 |   messageQueue,
17 | }: QueuedMessageDisplayProps) => {
18 |   if (messageQueue.length === 0) {
19 |     return null;
20 |   }
21 | 
22 |   return (
23 |     <Box flexDirection="column" marginTop={1}>
24 |       {messageQueue
25 |         .slice(0, MAX_DISPLAYED_QUEUED_MESSAGES)
26 |         .map((message, index) => {
27 |           const preview = message.replace(/\s+/g, ' ');
28 | 
29 |           return (
30 |             <Box key={index} paddingLeft={2} width="100%">
31 |               <Text dimColor wrap="truncate">
32 |                 {preview}
33 |               </Text>
34 |             </Box>
35 |           );
36 |         })}
37 |       {messageQueue.length > MAX_DISPLAYED_QUEUED_MESSAGES && (
38 |         <Box paddingLeft={2}>
39 |           <Text dimColor>
40 |             ... (+
41 |             {messageQueue.length - MAX_DISPLAYED_QUEUED_MESSAGES} more)
42 |           </Text>
43 |         </Box>
44 |       )}
45 |     </Box>
46 |   );
47 | };
```

src/ui/components/QuittingDisplay.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { Box } from 'ink';
8 | import { useUIState } from '../contexts/UIStateContext.js';
9 | import { HistoryItemDisplay } from './HistoryItemDisplay.js';
10 | import { useTerminalSize } from '../hooks/useTerminalSize.js';
11 | 
12 | export const QuittingDisplay = () => {
13 |   const uiState = useUIState();
14 |   const { rows: terminalHeight, columns: terminalWidth } = useTerminalSize();
15 | 
16 |   const availableTerminalHeight = terminalHeight;
17 | 
18 |   if (!uiState.quittingMessages) {
19 |     return null;
20 |   }
21 | 
22 |   return (
23 |     <Box flexDirection="column" marginBottom={1}>
24 |       {uiState.quittingMessages.map((item) => (
25 |         <HistoryItemDisplay
26 |           key={item.id}
27 |           availableTerminalHeight={
28 |             uiState.constrainHeight ? availableTerminalHeight : undefined
29 |           }
30 |           terminalWidth={terminalWidth}
31 |           item={item}
32 |           isPending={false}
33 |         />
34 |       ))}
35 |     </Box>
36 |   );
37 | };
```

src/ui/components/SessionSummaryDisplay.test.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { render } from 'ink-testing-library';
8 | import { describe, it, expect, vi } from 'vitest';
9 | import { SessionSummaryDisplay } from './SessionSummaryDisplay.js';
10 | import * as SessionContext from '../contexts/SessionContext.js';
11 | import type { SessionMetrics } from '../contexts/SessionContext.js';
12 | 
13 | vi.mock('../contexts/SessionContext.js', async (importOriginal) => {
14 |   const actual = await importOriginal<typeof SessionContext>();
15 |   return {
16 |     ...actual,
17 |     useSessionStats: vi.fn(),
18 |   };
19 | });
20 | 
21 | const useSessionStatsMock = vi.mocked(SessionContext.useSessionStats);
22 | 
23 | const renderWithMockedStats = (metrics: SessionMetrics) => {
24 |   useSessionStatsMock.mockReturnValue({
25 |     stats: {
26 |       sessionStartTime: new Date(),
27 |       metrics,
28 |       lastPromptTokenCount: 0,
29 |       promptCount: 5,
30 |     },
31 | 
32 |     getPromptCount: () => 5,
33 |     startNewPrompt: vi.fn(),
34 |   });
35 | 
36 |   return render(<SessionSummaryDisplay duration="1h 23m 45s" />);
37 | };
38 | 
39 | describe('<SessionSummaryDisplay />', () => {
40 |   it('renders the summary display with a title', () => {
41 |     const metrics: SessionMetrics = {
42 |       models: {
43 |         'gemini-2.5-pro': {
44 |           api: { totalRequests: 10, totalErrors: 1, totalLatencyMs: 50234 },
45 |           tokens: {
46 |             prompt: 1000,
47 |             candidates: 2000,
48 |             total: 3500,
49 |             cached: 500,
50 |             thoughts: 300,
51 |             tool: 200,
52 |           },
53 |         },
54 |       },
55 |       tools: {
56 |         totalCalls: 0,
57 |         totalSuccess: 0,
58 |         totalFail: 0,
59 |         totalDurationMs: 0,
60 |         totalDecisions: { accept: 0, reject: 0, modify: 0 },
61 |         byName: {},
62 |       },
63 |       files: {
64 |         totalLinesAdded: 42,
65 |         totalLinesRemoved: 15,
66 |       },
67 |     };
68 | 
69 |     const { lastFrame } = renderWithMockedStats(metrics);
70 |     const output = lastFrame();
71 | 
72 |     expect(output).toContain('Agent powering down. Goodbye!');
73 |     expect(output).toMatchSnapshot();
74 |   });
75 | });
```

src/ui/components/SessionSummaryDisplay.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type React from 'react';
8 | import { StatsDisplay } from './StatsDisplay.js';
9 | 
10 | interface SessionSummaryDisplayProps {
11 |   duration: string;
12 | }
13 | 
14 | export const SessionSummaryDisplay: React.FC<SessionSummaryDisplayProps> = ({
15 |   duration,
16 | }) => (
17 |   <StatsDisplay title="Agent powering down. Goodbye!" duration={duration} />
18 | );
```

src/ui/components/SettingsDialog.test.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | /**
8 |  *
9 |  *
10 |  * This test suite covers:
11 |  * - Initial rendering and display state
12 |  * - Keyboard navigation (arrows, vim keys, Tab)
13 |  * - Settings toggling (Enter, Space)
14 |  * - Focus section switching between settings and scope selector
15 |  * - Scope selection and settings persistence across scopes
16 |  * - Restart-required vs immediate settings behavior
17 |  * - VimModeContext integration
18 |  * - Complex user interaction workflows
19 |  * - Error handling and edge cases
20 |  * - Display values for inherited and overridden settings
21 |  *
22 |  */
23 | 
24 | import { render } from 'ink-testing-library';
25 | import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
26 | import { SettingsDialog } from './SettingsDialog.js';
27 | import { LoadedSettings, SettingScope } from '../../config/settings.js';
28 | import { VimModeProvider } from '../contexts/VimModeContext.js';
29 | import { KeypressProvider } from '../contexts/KeypressContext.js';
30 | import { act } from 'react';
31 | import { saveModifiedSettings, TEST_ONLY } from '../../utils/settingsUtils.js';
32 | import {
33 |   getSettingsSchema,
34 |   type SettingDefinition,
35 |   type SettingsSchemaType,
36 | } from '../../config/settingsSchema.js';
37 | 
38 | // Mock the VimModeContext
39 | const mockToggleVimEnabled = vi.fn();
40 | const mockSetVimMode = vi.fn();
41 | 
42 | enum TerminalKeys {
43 |   ENTER = '\u000D',
44 |   TAB = '\t',
45 |   UP_ARROW = '\u001B[A',
46 |   DOWN_ARROW = '\u001B[B',
47 |   LEFT_ARROW = '\u001B[D',
48 |   RIGHT_ARROW = '\u001B[C',
49 |   ESCAPE = '\u001B',
50 | }
51 | 
52 | const createMockSettings = (
53 |   userSettings = {},
54 |   systemSettings = {},
55 |   workspaceSettings = {},
56 | ) =>
57 |   new LoadedSettings(
58 |     {
59 |       settings: { ui: { customThemes: {} }, mcpServers: {}, ...systemSettings },
60 |       originalSettings: {
61 |         ui: { customThemes: {} },
62 |         mcpServers: {},
63 |         ...systemSettings,
64 |       },
65 |       path: '/system/settings.json',
66 |     },
67 |     {
68 |       settings: {},
69 |       originalSettings: {},
70 |       path: '/system/system-defaults.json',
71 |     },
72 |     {
73 |       settings: {
74 |         ui: { customThemes: {} },
75 |         mcpServers: {},
76 |         ...userSettings,
77 |       },
78 |       originalSettings: {
79 |         ui: { customThemes: {} },
80 |         mcpServers: {},
81 |         ...userSettings,
82 |       },
83 |       path: '/user/settings.json',
84 |     },
85 |     {
86 |       settings: {
87 |         ui: { customThemes: {} },
88 |         mcpServers: {},
89 |         ...workspaceSettings,
90 |       },
91 |       originalSettings: {
92 |         ui: { customThemes: {} },
93 |         mcpServers: {},
94 |         ...workspaceSettings,
95 |       },
96 |       path: '/workspace/settings.json',
97 |     },
98 |     true,
99 |     new Set(),
100 |   );
101 | 
102 | vi.mock('../../config/settingsSchema.js', async (importOriginal) => {
103 |   const original =
104 |     await importOriginal<typeof import('../../config/settingsSchema.js')>();
105 |   return {
106 |     ...original,
107 |     getSettingsSchema: vi.fn(original.getSettingsSchema),
108 |   };
109 | });
110 | 
111 | vi.mock('../contexts/VimModeContext.js', async () => {
112 |   const actual = await vi.importActual('../contexts/VimModeContext.js');
113 |   return {
114 |     ...actual,
115 |     useVimMode: () => ({
116 |       vimEnabled: false,
117 |       vimMode: 'INSERT' as const,
118 |       toggleVimEnabled: mockToggleVimEnabled,
119 |       setVimMode: mockSetVimMode,
120 |     }),
121 |   };
122 | });
123 | 
124 | vi.mock('../../utils/settingsUtils.js', async () => {
125 |   const actual = await vi.importActual('../../utils/settingsUtils.js');
126 |   return {
127 |     ...actual,
128 |     saveModifiedSettings: vi.fn(),
129 |   };
130 | });
131 | 
132 | // Helper function to simulate key presses (commented out for now)
133 | // const simulateKeyPress = async (keyData: Partial<Key> & { name: string }) => {
134 | //   if (currentKeypressHandler) {
135 | //     const key: Key = {
136 | //       ctrl: false,
137 | //       meta: false,
138 | //       shift: false,
139 | //       paste: false,
140 | //       sequence: keyData.sequence || keyData.name,
141 | //       ...keyData,
142 | //     };
143 | //     currentKeypressHandler(key);
144 | //     // Allow React to process the state update
145 | //     await new Promise(resolve => setTimeout(resolve, 10));
146 | //   }
147 | // };
148 | 
149 | // Mock console.log to avoid noise in tests
150 | // const originalConsoleLog = console.log;
151 | // const originalConsoleError = console.error;
152 | 
153 | describe('SettingsDialog', () => {
154 |   // Simple delay function for remaining tests that need gradual migration
155 |   const wait = (ms = 50) => new Promise((resolve) => setTimeout(resolve, ms));
156 | 
157 |   // Custom waitFor utility for ink testing environment (not compatible with @testing-library/react)
158 |   const waitFor = async (
159 |     predicate: () => void,
160 |     options: { timeout?: number; interval?: number } = {},
161 |   ) => {
162 |     const { timeout = 1000, interval = 10 } = options;
163 |     const start = Date.now();
164 |     let lastError: unknown;
165 |     while (Date.now() - start < timeout) {
166 |       try {
167 |         predicate();
168 |         return;
169 |       } catch (e) {
170 |         lastError = e;
171 |       }
172 |       await new Promise((resolve) => setTimeout(resolve, interval));
173 |     }
174 |     if (lastError) {
175 |       throw lastError;
176 |     }
177 |     throw new Error('waitFor timed out');
178 |   };
179 | 
180 |   beforeEach(() => {
181 |     // Reset keypress mock state (variables are commented out)
182 |     // currentKeypressHandler = null;
183 |     // isKeypressActive = false;
184 |     // console.log = vi.fn();
185 |     // console.error = vi.fn();
186 |     mockToggleVimEnabled.mockResolvedValue(true);
187 |   });
188 | 
189 |   afterEach(() => {
190 |     TEST_ONLY.clearFlattenedSchema();
191 |     vi.clearAllMocks();
192 |     vi.resetAllMocks();
193 |     // Reset keypress mock state (variables are commented out)
194 |     // currentKeypressHandler = null;
195 |     // isKeypressActive = false;
196 |     // console.log = originalConsoleLog;
197 |     // console.error = originalConsoleError;
198 |   });
199 | 
200 |   describe('Initial Rendering', () => {
201 |     it('should render the settings dialog with default state', () => {
202 |       const settings = createMockSettings();
203 |       const onSelect = vi.fn();
204 | 
205 |       const { lastFrame } = render(
206 |         <KeypressProvider kittyProtocolEnabled={false}>
207 |           <SettingsDialog settings={settings} onSelect={onSelect} />
208 |         </KeypressProvider>,
209 |       );
210 | 
211 |       const output = lastFrame();
212 |       expect(output).toContain('Settings');
213 |       expect(output).toContain('Apply To');
214 |       expect(output).toContain('Use Enter to select, Tab to change focus');
215 |     });
216 | 
217 |     it('should accept availableTerminalHeight prop without errors', () => {
218 |       const settings = createMockSettings();
219 |       const onSelect = vi.fn();
220 | 
221 |       const { lastFrame } = render(
222 |         <KeypressProvider kittyProtocolEnabled={false}>
223 |           <SettingsDialog
224 |             settings={settings}
225 |             onSelect={onSelect}
226 |             availableTerminalHeight={20}
227 |           />
228 |         </KeypressProvider>,
229 |       );
230 | 
231 |       const output = lastFrame();
232 |       // Should still render properly with the height prop
233 |       expect(output).toContain('Settings');
234 |       expect(output).toContain('Use Enter to select');
235 |     });
236 | 
237 |     it('should show settings list with default values', () => {
238 |       const settings = createMockSettings();
239 |       const onSelect = vi.fn();
240 | 
241 |       const { lastFrame } = render(
242 |         <KeypressProvider kittyProtocolEnabled={false}>
243 |           <SettingsDialog settings={settings} onSelect={onSelect} />
244 |         </KeypressProvider>,
245 |       );
246 | 
247 |       const output = lastFrame();
248 |       // Should show some default settings
249 |       expect(output).toContain('●'); // Active indicator
250 |     });
251 | 
252 |     it('should highlight first setting by default', () => {
253 |       const settings = createMockSettings();
254 |       const onSelect = vi.fn();
255 | 
256 |       const { lastFrame } = render(
257 |         <KeypressProvider kittyProtocolEnabled={false}>
258 |           <SettingsDialog settings={settings} onSelect={onSelect} />
259 |         </KeypressProvider>,
260 |       );
261 | 
262 |       const output = lastFrame();
263 |       // First item should be highlighted with green color and active indicator
264 |       expect(output).toContain('●');
265 |     });
266 |   });
267 | 
268 |   describe('Settings Navigation', () => {
269 |     it('should navigate down with arrow key', async () => {
270 |       const settings = createMockSettings();
271 |       const onSelect = vi.fn();
272 | 
273 |       const { stdin, unmount, lastFrame } = render(
274 |         <KeypressProvider kittyProtocolEnabled={false}>
275 |           <SettingsDialog settings={settings} onSelect={onSelect} />
276 |         </KeypressProvider>,
277 |       );
278 | 
279 |       // Press down arrow
280 |       act(() => {
281 |         stdin.write(TerminalKeys.DOWN_ARROW as string); // Down arrow
282 |       });
283 | 
284 |       expect(lastFrame()).toContain('● Disable Auto Update');
285 | 
286 |       // The active index should have changed (tested indirectly through behavior)
287 |       unmount();
288 |     });
289 | 
290 |     it('should navigate up with arrow key', async () => {
291 |       const settings = createMockSettings();
292 |       const onSelect = vi.fn();
293 | 
294 |       const { stdin, unmount } = render(
295 |         <KeypressProvider kittyProtocolEnabled={false}>
296 |           <SettingsDialog settings={settings} onSelect={onSelect} />
297 |         </KeypressProvider>,
298 |       );
299 | 
300 |       // First go down, then up
301 |       stdin.write(TerminalKeys.DOWN_ARROW as string); // Down arrow
302 |       await wait();
303 |       stdin.write(TerminalKeys.UP_ARROW as string);
304 |       await wait();
305 | 
306 |       unmount();
307 |     });
308 | 
309 |     it('should navigate with vim keys (j/k)', async () => {
310 |       const settings = createMockSettings();
311 |       const onSelect = vi.fn();
312 | 
313 |       const { stdin, unmount } = render(
314 |         <KeypressProvider kittyProtocolEnabled={false}>
315 |           <SettingsDialog settings={settings} onSelect={onSelect} />
316 |         </KeypressProvider>,
317 |       );
318 | 
319 |       // Navigate with vim keys
320 |       stdin.write('j'); // Down
321 |       await wait();
322 |       stdin.write('k'); // Up
323 |       await wait();
324 | 
325 |       unmount();
326 |     });
327 | 
328 |     it('wraps around when at the top of the list', async () => {
329 |       const settings = createMockSettings();
330 |       const onSelect = vi.fn();
331 | 
332 |       const { stdin, unmount, lastFrame } = render(
333 |         <KeypressProvider kittyProtocolEnabled={false}>
334 |           <SettingsDialog settings={settings} onSelect={onSelect} />
335 |         </KeypressProvider>,
336 |       );
337 | 
338 |       // Try to go up from first item
339 |       act(() => {
340 |         stdin.write(TerminalKeys.UP_ARROW);
341 |       });
342 | 
343 |       await wait();
344 | 
345 |       expect(lastFrame()).toContain('● Use Model Router');
346 | 
347 |       unmount();
348 |     });
349 |   });
350 | 
351 |   describe('Settings Toggling', () => {
352 |     it('should toggle setting with Enter key', async () => {
353 |       vi.mocked(saveModifiedSettings).mockClear();
354 | 
355 |       const settings = createMockSettings();
356 |       const onSelect = vi.fn();
357 |       const component = (
358 |         <KeypressProvider kittyProtocolEnabled={false}>
359 |           <SettingsDialog settings={settings} onSelect={onSelect} />
360 |         </KeypressProvider>
361 |       );
362 | 
363 |       const { stdin, unmount, lastFrame } = render(component);
364 | 
365 |       // Wait for initial render and verify we're on Vim Mode (first setting)
366 |       await waitFor(() => {
367 |         expect(lastFrame()).toContain('● Vim Mode');
368 |       });
369 | 
370 |       // Navigate to Disable Auto Update setting and verify we're there
371 |       act(() => {
372 |         stdin.write(TerminalKeys.DOWN_ARROW as string);
373 |       });
374 |       await waitFor(() => {
375 |         expect(lastFrame()).toContain('● Disable Auto Update');
376 |       });
377 | 
378 |       // Toggle the setting
379 |       act(() => {
380 |         stdin.write(TerminalKeys.ENTER as string);
381 |       });
382 |       // Wait for the setting change to be processed
383 |       await waitFor(() => {
384 |         expect(
[TRUNCATED]
```

src/ui/components/SettingsDialog.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import React, { useState, useEffect } from 'react';
8 | import { Box, Text } from 'ink';
9 | import { theme } from '../semantic-colors.js';
10 | import type { LoadedSettings, Settings } from '../../config/settings.js';
11 | import { SettingScope } from '../../config/settings.js';
12 | import {
13 |   getScopeItems,
14 |   getScopeMessageForSetting,
15 | } from '../../utils/dialogScopeUtils.js';
16 | import { RadioButtonSelect } from './shared/RadioButtonSelect.js';
17 | import {
18 |   getDialogSettingKeys,
19 |   setPendingSettingValue,
20 |   getDisplayValue,
21 |   hasRestartRequiredSettings,
22 |   saveModifiedSettings,
23 |   getSettingDefinition,
24 |   isDefaultValue,
25 |   requiresRestart,
26 |   getRestartRequiredFromModified,
27 |   getDefaultValue,
28 |   setPendingSettingValueAny,
29 |   getNestedValue,
30 |   getEffectiveValue,
31 | } from '../../utils/settingsUtils.js';
32 | import { useVimMode } from '../contexts/VimModeContext.js';
33 | import { useKeypress } from '../hooks/useKeypress.js';
34 | import chalk from 'chalk';
35 | import { cpSlice, cpLen, stripUnsafeCharacters } from '../utils/textUtils.js';
36 | import {
37 |   type SettingsValue,
38 |   TOGGLE_TYPES,
39 | } from '../../config/settingsSchema.js';
40 | 
41 | interface SettingsDialogProps {
42 |   settings: LoadedSettings;
43 |   onSelect: (settingName: string | undefined, scope: SettingScope) => void;
44 |   onRestartRequest?: () => void;
45 |   availableTerminalHeight?: number;
46 | }
47 | 
48 | const maxItemsToShow = 8;
49 | 
50 | export function SettingsDialog({
51 |   settings,
52 |   onSelect,
53 |   onRestartRequest,
54 |   availableTerminalHeight,
55 | }: SettingsDialogProps): React.JSX.Element {
56 |   // Get vim mode context to sync vim mode changes
57 |   const { vimEnabled, toggleVimEnabled } = useVimMode();
58 | 
59 |   // Focus state: 'settings' or 'scope'
60 |   const [focusSection, setFocusSection] = useState<'settings' | 'scope'>(
61 |     'settings',
62 |   );
63 |   // Scope selector state (User by default)
64 |   const [selectedScope, setSelectedScope] = useState<SettingScope>(
65 |     SettingScope.User,
66 |   );
67 |   // Active indices
68 |   const [activeSettingIndex, setActiveSettingIndex] = useState(0);
69 |   // Scroll offset for settings
70 |   const [scrollOffset, setScrollOffset] = useState(0);
71 |   const [showRestartPrompt, setShowRestartPrompt] = useState(false);
72 | 
73 |   // Local pending settings state for the selected scope
74 |   const [pendingSettings, setPendingSettings] = useState<Settings>(() =>
75 |     // Deep clone to avoid mutation
76 |     structuredClone(settings.forScope(selectedScope).settings),
77 |   );
78 | 
79 |   // Track which settings have been modified by the user
80 |   const [modifiedSettings, setModifiedSettings] = useState<Set<string>>(
81 |     new Set(),
82 |   );
83 | 
84 |   // Preserve pending changes across scope switches
85 |   type PendingValue = boolean | number | string;
86 |   const [globalPendingChanges, setGlobalPendingChanges] = useState<
87 |     Map<string, PendingValue>
88 |   >(new Map());
89 | 
90 |   // Track restart-required settings across scope changes
91 |   const [_restartRequiredSettings, setRestartRequiredSettings] = useState<
92 |     Set<string>
93 |   >(new Set());
94 | 
95 |   useEffect(() => {
96 |     // Base settings for selected scope
97 |     let updated = structuredClone(settings.forScope(selectedScope).settings);
98 |     // Overlay globally pending (unsaved) changes so user sees their modifications in any scope
99 |     const newModified = new Set<string>();
100 |     const newRestartRequired = new Set<string>();
101 |     for (const [key, value] of globalPendingChanges.entries()) {
102 |       const def = getSettingDefinition(key);
103 |       if (def?.type === 'boolean' && typeof value === 'boolean') {
104 |         updated = setPendingSettingValue(key, value, updated);
105 |       } else if (
106 |         (def?.type === 'number' && typeof value === 'number') ||
107 |         (def?.type === 'string' && typeof value === 'string')
108 |       ) {
109 |         updated = setPendingSettingValueAny(key, value, updated);
110 |       }
111 |       newModified.add(key);
112 |       if (requiresRestart(key)) newRestartRequired.add(key);
113 |     }
114 |     setPendingSettings(updated);
115 |     setModifiedSettings(newModified);
116 |     setRestartRequiredSettings(newRestartRequired);
117 |     setShowRestartPrompt(newRestartRequired.size > 0);
118 |   }, [selectedScope, settings, globalPendingChanges]);
119 | 
120 |   const generateSettingsItems = () => {
121 |     const settingKeys = getDialogSettingKeys();
122 | 
123 |     return settingKeys.map((key: string) => {
124 |       const definition = getSettingDefinition(key);
125 | 
126 |       return {
127 |         label: definition?.label || key,
128 |         value: key,
129 |         type: definition?.type,
130 |         toggle: () => {
131 |           if (!TOGGLE_TYPES.has(definition?.type)) {
132 |             return;
133 |           }
134 |           const currentValue = getEffectiveValue(key, pendingSettings, {});
135 |           let newValue: SettingsValue;
136 |           if (definition?.type === 'boolean') {
137 |             newValue = !(currentValue as boolean);
138 |             setPendingSettings((prev) =>
139 |               setPendingSettingValue(key, newValue as boolean, prev),
140 |             );
141 |           } else if (definition?.type === 'enum' && definition.options) {
142 |             const options = definition.options;
143 |             const currentIndex = options?.findIndex(
144 |               (opt) => opt.value === currentValue,
145 |             );
146 |             if (currentIndex !== -1 && currentIndex < options.length - 1) {
147 |               newValue = options[currentIndex + 1].value;
148 |             } else {
149 |               newValue = options[0].value; // loop back to start.
150 |             }
151 |             setPendingSettings((prev) =>
152 |               setPendingSettingValueAny(key, newValue, prev),
153 |             );
154 |           }
155 | 
156 |           setPendingSettings((prev) =>
157 |             setPendingSettingValue(key, newValue as boolean, prev),
158 |           );
159 | 
160 |           if (!requiresRestart(key)) {
161 |             const immediateSettings = new Set([key]);
162 |             const immediateSettingsObject = setPendingSettingValueAny(
163 |               key,
164 |               newValue,
165 |               {} as Settings,
166 |             );
167 | 
168 |             console.log(
169 |               `[DEBUG SettingsDialog] Saving ${key} immediately with value:`,
170 |               newValue,
171 |             );
172 |             saveModifiedSettings(
173 |               immediateSettings,
174 |               immediateSettingsObject,
175 |               settings,
176 |               selectedScope,
177 |             );
178 | 
179 |             // Special handling for vim mode to sync with VimModeContext
180 |             if (key === 'general.vimMode' && newValue !== vimEnabled) {
181 |               // Call toggleVimEnabled to sync the VimModeContext local state
182 |               toggleVimEnabled().catch((error) => {
183 |                 console.error('Failed to toggle vim mode:', error);
184 |               });
185 |             }
186 | 
187 |             // Remove from modifiedSettings since it's now saved
188 |             setModifiedSettings((prev) => {
189 |               const updated = new Set(prev);
190 |               updated.delete(key);
191 |               return updated;
192 |             });
193 | 
194 |             // Also remove from restart-required settings if it was there
195 |             setRestartRequiredSettings((prev) => {
196 |               const updated = new Set(prev);
197 |               updated.delete(key);
198 |               return updated;
199 |             });
200 | 
201 |             // Remove from global pending changes if present
202 |             setGlobalPendingChanges((prev) => {
203 |               if (!prev.has(key)) return prev;
204 |               const next = new Map(prev);
205 |               next.delete(key);
206 |               return next;
207 |             });
208 | 
209 |             // Refresh pending settings from the saved state
210 |             setPendingSettings(
211 |               structuredClone(settings.forScope(selectedScope).settings),
212 |             );
213 |           } else {
214 |             // For restart-required settings, track as modified
215 |             setModifiedSettings((prev) => {
216 |               const updated = new Set(prev).add(key);
217 |               const needsRestart = hasRestartRequiredSettings(updated);
218 |               console.log(
219 |                 `[DEBUG SettingsDialog] Modified settings:`,
220 |                 Array.from(updated),
221 |                 'Needs restart:',
222 |                 needsRestart,
223 |               );
224 |               if (needsRestart) {
225 |                 setShowRestartPrompt(true);
226 |                 setRestartRequiredSettings((prevRestart) =>
227 |                   new Set(prevRestart).add(key),
228 |                 );
229 |               }
230 |               return updated;
231 |             });
232 | 
233 |             // Add/update pending change globally so it persists across scopes
234 |             setGlobalPendingChanges((prev) => {
235 |               const next = new Map(prev);
236 |               next.set(key, newValue as PendingValue);
237 |               return next;
238 |             });
239 |           }
240 |         },
241 |       };
242 |     });
243 |   };
244 | 
245 |   const items = generateSettingsItems();
246 | 
247 |   // Generic edit state
248 |   const [editingKey, setEditingKey] = useState<string | null>(null);
249 |   const [editBuffer, setEditBuffer] = useState<string>('');
250 |   const [editCursorPos, setEditCursorPos] = useState<number>(0); // Cursor position within edit buffer
251 |   const [cursorVisible, setCursorVisible] = useState<boolean>(true);
252 | 
253 |   useEffect(() => {
254 |     if (!editingKey) {
255 |       setCursorVisible(true);
256 |       return;
257 |     }
258 |     const id = setInterval(() => setCursorVisible((v) => !v), 500);
259 |     return () => clearInterval(id);
260 |   }, [editingKey]);
261 | 
262 |   const startEditing = (key: string, initial?: string) => {
263 |     setEditingKey(key);
264 |     const initialValue = initial ?? '';
265 |     setEditBuffer(initialValue);
266 |     setEditCursorPos(cpLen(initialValue)); // Position cursor at end of initial value
267 |   };
268 | 
269 |   const commitEdit = (key: string) => {
270 |     const definition = getSettingDefinition(key);
271 |     const type = definition?.type;
272 | 
273 |     if (editBuffer.trim() === '' && type === 'number') {
274 |       // Nothing entered for a number; cancel edit
275 |       setEditingKey(null);
276 |       setEditBuffer('');
277 |       setEditCursorPos(0);
278 |       return;
279 |     }
280 | 
281 |     let parsed: string | number;
282 |     if (type === 'number') {
283 |       const numParsed = Number(editBuffer.trim());
284 |       if (Number.isNaN(numParsed)) {
285 |         // Invalid number; cancel edit
286 |         setEditingKey(null);
287 |         setEditBuffer('');
288 |         setEditCursorPos(0);
289 |         return;
290 |       }
291 |       parsed = numParsed;
292 |     } else {
293 |       // For strings, use the buffer as is.
294 |       parsed = editBuffer;
295 |     }
296 | 
297 |     // Update pending
298 |     setPendingSettings((prev) => setPendingSettingValueAny(key, parsed, prev));
299 | 
300 |     if (!requiresRestart(key)) {
301 |       const immediateSettings = new Set([key]);
302 |       const immediateSettingsObject = setPendingSettingValueAny(
303 |         key,
304 |         parsed,
305 |         {} as Settings,
306 |       );
307 |       saveModifiedSettings(
308 |         immediateSettings,
309 |         immediateSettingsObject,
310 |         settings,
311 |         selectedScope,
312 |       );
313 | 
314 |       // Remove from modified sets if present
315 |       setModifiedSettings((prev) => {
316 |         const updated = new Set(prev);
317 |         updated.delete(key);
318 |         return updated;
319 |       });
320 |       setRestartRequiredSettings((prev) => {
321 |         const updated = new Set(prev);
322 |         updated.delete(key);
323 |         return updated;
324 |       });
325 | 
326 |       // Remove from global pending since it's immediately saved
327 |       setGlobalPendingChanges((prev) => {
328 |         if (!prev.has(key)) return prev;
329 |         const next = new Map(prev);
330 |         next.delete(key);
331 |         return next;
332 |       });
333 |     } else {
334 |       // Mark as modified and needing restart
335 |       setModifiedSettings((prev) => {
336 |         const updated = new Set(prev).add(key);
337 |         const needsRestart = hasRestartRequiredSettings(updated);
338 |         if (needsRestart) {
339 |           setShowRestartPrompt(true);
340 |           setRestartRequiredSettings((prevRestart) =>
341 |             new Set(prevRestart).add(key),
342 |           );
343 |         }
344 |         return updated;
345 |       });
346 | 
347 |       // Record pending change globally for persistence across scopes
348 |       setGlobalPendingChanges((prev) => {
349 |         const next = new Map(prev);
350 |         next.set(key, parsed as PendingValue);
351 |         return next;
352 |       });
353 |     }
354 | 
355 |     setEditingKey(null);
356 |     setEditBuffer('');
357 |     setEditCursorPos(0);
358 |   };
359 | 
360 |   // Scope selector items
361 |   const scopeItems = getScopeItems().map((item) => ({
362 |     ...item,
363 |     key: item.value,
364 |   }));
365 | 
366 |   const handleScopeHighlight = (scope: SettingScope) => {
367 |     setSelectedScope(scope);
368 |   };
369 | 
370 |   const handleScopeSelect = (scope: SettingScope) => {
371 |     handleScopeHighlight(scope);
372 |     setFocusSection('settings');
373 |   };
374 | 
375 |   // Height constraint calculations similar to ThemeDialog
376 |   const DIALOG_PADDING = 4;
377 |   const SETTINGS_TITLE_HEIGHT = 2; // "Settings" title + spacing
378 |   const SCROLL_ARROWS_HEIGHT = 2; // Up and down arrows
[TRUNCATED]
```

src/ui/components/ShellConfirmationDialog.test.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { renderWithProviders } from '../../test-utils/render.js';
8 | import { describe, it, expect, vi } from 'vitest';
9 | import { ShellConfirmationDialog } from './ShellConfirmationDialog.js';
10 | 
11 | describe('ShellConfirmationDialog', () => {
12 |   const onConfirm = vi.fn();
13 | 
14 |   const request = {
15 |     commands: ['ls -la', 'echo "hello"'],
16 |     onConfirm,
17 |   };
18 | 
19 |   it('renders correctly', () => {
20 |     const { lastFrame } = renderWithProviders(
21 |       <ShellConfirmationDialog request={request} />,
22 |     );
23 |     expect(lastFrame()).toMatchSnapshot();
24 |   });
25 | 
26 |   it('calls onConfirm with ProceedOnce when "Yes, allow once" is selected', () => {
27 |     const { lastFrame } = renderWithProviders(
28 |       <ShellConfirmationDialog request={request} />,
29 |     );
30 |     const select = lastFrame()!.toString();
31 |     // Simulate selecting the first option
32 |     // This is a simplified way to test the selection
33 |     expect(select).toContain('Yes, allow once');
34 |   });
35 | 
36 |   it('calls onConfirm with ProceedAlways when "Yes, allow always for this session" is selected', () => {
37 |     const { lastFrame } = renderWithProviders(
38 |       <ShellConfirmationDialog request={request} />,
39 |     );
40 |     const select = lastFrame()!.toString();
41 |     // Simulate selecting the second option
42 |     expect(select).toContain('Yes, allow always for this session');
43 |   });
44 | 
45 |   it('calls onConfirm with Cancel when "No (esc)" is selected', () => {
46 |     const { lastFrame } = renderWithProviders(
47 |       <ShellConfirmationDialog request={request} />,
48 |     );
49 |     const select = lastFrame()!.toString();
50 |     // Simulate selecting the third option
51 |     expect(select).toContain('No (esc)');
52 |   });
53 | });
```

src/ui/components/ShellConfirmationDialog.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { ToolConfirmationOutcome } from '@google/gemini-cli-core';
8 | import { Box, Text } from 'ink';
9 | import type React from 'react';
10 | import { theme } from '../semantic-colors.js';
11 | import { RenderInline } from '../utils/InlineMarkdownRenderer.js';
12 | import type { RadioSelectItem } from './shared/RadioButtonSelect.js';
13 | import { RadioButtonSelect } from './shared/RadioButtonSelect.js';
14 | import { useKeypress } from '../hooks/useKeypress.js';
15 | 
16 | export interface ShellConfirmationRequest {
17 |   commands: string[];
18 |   onConfirm: (
19 |     outcome: ToolConfirmationOutcome,
20 |     approvedCommands?: string[],
21 |   ) => void;
22 | }
23 | 
24 | export interface ShellConfirmationDialogProps {
25 |   request: ShellConfirmationRequest;
26 | }
27 | 
28 | export const ShellConfirmationDialog: React.FC<
29 |   ShellConfirmationDialogProps
30 | > = ({ request }) => {
31 |   const { commands, onConfirm } = request;
32 | 
33 |   useKeypress(
34 |     (key) => {
35 |       if (key.name === 'escape') {
36 |         onConfirm(ToolConfirmationOutcome.Cancel);
37 |       }
38 |     },
39 |     { isActive: true },
40 |   );
41 | 
42 |   const handleSelect = (item: ToolConfirmationOutcome) => {
43 |     if (item === ToolConfirmationOutcome.Cancel) {
44 |       onConfirm(item);
45 |     } else {
46 |       // For both ProceedOnce and ProceedAlways, we approve all the
47 |       // commands that were requested.
48 |       onConfirm(item, commands);
49 |     }
50 |   };
51 | 
52 |   const options: Array<RadioSelectItem<ToolConfirmationOutcome>> = [
53 |     {
54 |       label: 'Yes, allow once',
55 |       value: ToolConfirmationOutcome.ProceedOnce,
56 |       key: 'Yes, allow once',
57 |     },
58 |     {
59 |       label: 'Yes, allow always for this session',
60 |       value: ToolConfirmationOutcome.ProceedAlways,
61 |       key: 'Yes, allow always for this session',
62 |     },
63 |     {
64 |       label: 'No (esc)',
65 |       value: ToolConfirmationOutcome.Cancel,
66 |       key: 'No (esc)',
67 |     },
68 |   ];
69 | 
70 |   return (
71 |     <Box
72 |       flexDirection="column"
73 |       borderStyle="round"
74 |       borderColor={theme.status.warning}
75 |       padding={1}
76 |       width="100%"
77 |       marginLeft={1}
78 |     >
79 |       <Box flexDirection="column" marginBottom={1}>
80 |         <Text bold color={theme.text.primary}>
81 |           Shell Command Execution
82 |         </Text>
83 |         <Text color={theme.text.primary}>
84 |           A custom command wants to run the following shell commands:
85 |         </Text>
86 |         <Box
87 |           flexDirection="column"
88 |           borderStyle="round"
89 |           borderColor={theme.border.default}
90 |           paddingX={1}
91 |           marginTop={1}
92 |         >
93 |           {commands.map((cmd) => (
94 |             <Text key={cmd} color={theme.text.link}>
95 |               <RenderInline text={cmd} />
96 |             </Text>
97 |           ))}
98 |         </Box>
99 |       </Box>
100 | 
101 |       <Box marginBottom={1}>
102 |         <Text color={theme.text.primary}>Do you want to proceed?</Text>
103 |       </Box>
104 | 
105 |       <RadioButtonSelect items={options} onSelect={handleSelect} isFocused />
106 |     </Box>
107 |   );
108 | };
```

src/ui/components/ShellInputPrompt.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { useCallback } from 'react';
8 | import type React from 'react';
9 | import { useKeypress } from '../hooks/useKeypress.js';
10 | import { ShellExecutionService } from '@google/gemini-cli-core';
11 | import { keyToAnsi, type Key } from '../hooks/keyToAnsi.js';
12 | 
13 | export interface ShellInputPromptProps {
14 |   activeShellPtyId: number | null;
15 |   focus?: boolean;
16 | }
17 | 
18 | export const ShellInputPrompt: React.FC<ShellInputPromptProps> = ({
19 |   activeShellPtyId,
20 |   focus = true,
21 | }) => {
22 |   const handleShellInputSubmit = useCallback(
23 |     (input: string) => {
24 |       if (activeShellPtyId) {
25 |         ShellExecutionService.writeToPty(activeShellPtyId, input);
26 |       }
27 |     },
28 |     [activeShellPtyId],
29 |   );
30 | 
31 |   const handleInput = useCallback(
32 |     (key: Key) => {
33 |       if (!focus || !activeShellPtyId) {
34 |         return;
35 |       }
36 |       if (key.ctrl && key.shift && key.name === 'up') {
37 |         ShellExecutionService.scrollPty(activeShellPtyId, -1);
38 |         return;
39 |       }
40 | 
41 |       if (key.ctrl && key.shift && key.name === 'down') {
42 |         ShellExecutionService.scrollPty(activeShellPtyId, 1);
43 |         return;
44 |       }
45 | 
46 |       const ansiSequence = keyToAnsi(key);
47 |       if (ansiSequence) {
48 |         handleShellInputSubmit(ansiSequence);
49 |       }
50 |     },
51 |     [focus, handleShellInputSubmit, activeShellPtyId],
52 |   );
53 | 
54 |   useKeypress(handleInput, { isActive: focus });
55 | 
56 |   return null;
57 | };
```

src/ui/components/ShellModeIndicator.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type React from 'react';
8 | import { Box, Text } from 'ink';
9 | import { theme } from '../semantic-colors.js';
10 | 
11 | export const ShellModeIndicator: React.FC = () => (
12 |   <Box>
13 |     <Text color={theme.ui.symbol}>
14 |       shell mode enabled
15 |       <Text color={theme.text.secondary}> (esc to disable)</Text>
16 |     </Text>
17 |   </Box>
18 | );
```

src/ui/components/ShowMoreLines.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { Box, Text } from 'ink';
8 | import { useOverflowState } from '../contexts/OverflowContext.js';
9 | import { useStreamingContext } from '../contexts/StreamingContext.js';
10 | import { StreamingState } from '../types.js';
11 | import { theme } from '../semantic-colors.js';
12 | 
13 | interface ShowMoreLinesProps {
14 |   constrainHeight: boolean;
15 | }
16 | 
17 | export const ShowMoreLines = ({ constrainHeight }: ShowMoreLinesProps) => {
18 |   const overflowState = useOverflowState();
19 |   const streamingState = useStreamingContext();
20 | 
21 |   if (
22 |     overflowState === undefined ||
23 |     overflowState.overflowingIds.size === 0 ||
24 |     !constrainHeight ||
25 |     !(
26 |       streamingState === StreamingState.Idle ||
27 |       streamingState === StreamingState.WaitingForConfirmation
28 |     )
29 |   ) {
30 |     return null;
31 |   }
32 | 
33 |   return (
34 |     <Box>
35 |       <Text color={theme.text.secondary} wrap="truncate">
36 |         Press ctrl-s to show more lines
37 |       </Text>
38 |     </Box>
39 |   );
40 | };
```

src/ui/components/StatsDisplay.test.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { render } from 'ink-testing-library';
8 | import { describe, it, expect, vi } from 'vitest';
9 | import { StatsDisplay } from './StatsDisplay.js';
10 | import * as SessionContext from '../contexts/SessionContext.js';
11 | import type { SessionMetrics } from '../contexts/SessionContext.js';
12 | 
13 | // Mock the context to provide controlled data for testing
14 | vi.mock('../contexts/SessionContext.js', async (importOriginal) => {
15 |   const actual = await importOriginal<typeof SessionContext>();
16 |   return {
17 |     ...actual,
18 |     useSessionStats: vi.fn(),
19 |   };
20 | });
21 | 
22 | const useSessionStatsMock = vi.mocked(SessionContext.useSessionStats);
23 | 
24 | const renderWithMockedStats = (metrics: SessionMetrics) => {
25 |   useSessionStatsMock.mockReturnValue({
26 |     stats: {
27 |       sessionId: 'test-session-id',
28 |       sessionStartTime: new Date(),
29 |       metrics,
30 |       lastPromptTokenCount: 0,
31 |       promptCount: 5,
32 |     },
33 | 
34 |     getPromptCount: () => 5,
35 |     startNewPrompt: vi.fn(),
36 |   });
37 | 
38 |   return render(<StatsDisplay duration="1s" />);
39 | };
40 | 
41 | describe('<StatsDisplay />', () => {
42 |   it('renders only the Performance section in its zero state', () => {
43 |     const zeroMetrics: SessionMetrics = {
44 |       models: {},
45 |       tools: {
46 |         totalCalls: 0,
47 |         totalSuccess: 0,
48 |         totalFail: 0,
49 |         totalDurationMs: 0,
50 |         totalDecisions: { accept: 0, reject: 0, modify: 0 },
51 |         byName: {},
52 |       },
53 |       files: {
54 |         totalLinesAdded: 0,
55 |         totalLinesRemoved: 0,
56 |       },
57 |     };
58 | 
59 |     const { lastFrame } = renderWithMockedStats(zeroMetrics);
60 |     const output = lastFrame();
61 | 
62 |     expect(output).toContain('Performance');
63 |     expect(output).toContain('Interaction Summary');
64 |     expect(output).not.toContain('Efficiency & Optimizations');
65 |     expect(output).not.toContain('Model'); // The table header
66 |     expect(output).toMatchSnapshot();
67 |   });
68 | 
69 |   it('renders a table with two models correctly', () => {
70 |     const metrics: SessionMetrics = {
71 |       models: {
72 |         'gemini-2.5-pro': {
73 |           api: { totalRequests: 3, totalErrors: 0, totalLatencyMs: 15000 },
74 |           tokens: {
75 |             prompt: 1000,
76 |             candidates: 2000,
77 |             total: 43234,
78 |             cached: 500,
79 |             thoughts: 100,
80 |             tool: 50,
81 |           },
82 |         },
83 |         'gemini-2.5-flash': {
84 |           api: { totalRequests: 5, totalErrors: 1, totalLatencyMs: 4500 },
85 |           tokens: {
86 |             prompt: 25000,
87 |             candidates: 15000,
88 |             total: 150000000,
89 |             cached: 10000,
90 |             thoughts: 2000,
91 |             tool: 1000,
92 |           },
93 |         },
94 |       },
95 |       tools: {
96 |         totalCalls: 0,
97 |         totalSuccess: 0,
98 |         totalFail: 0,
99 |         totalDurationMs: 0,
100 |         totalDecisions: { accept: 0, reject: 0, modify: 0 },
101 |         byName: {},
102 |       },
103 |       files: {
104 |         totalLinesAdded: 0,
105 |         totalLinesRemoved: 0,
106 |       },
107 |     };
108 | 
109 |     const { lastFrame } = renderWithMockedStats(metrics);
110 |     const output = lastFrame();
111 | 
112 |     expect(output).toContain('gemini-2.5-pro');
113 |     expect(output).toContain('gemini-2.5-flash');
114 |     expect(output).toContain('1,000');
115 |     expect(output).toContain('25,000');
116 |     expect(output).toMatchSnapshot();
117 |   });
118 | 
119 |   it('renders all sections when all data is present', () => {
120 |     const metrics: SessionMetrics = {
121 |       models: {
122 |         'gemini-2.5-pro': {
123 |           api: { totalRequests: 1, totalErrors: 0, totalLatencyMs: 100 },
124 |           tokens: {
125 |             prompt: 100,
126 |             candidates: 100,
127 |             total: 250,
128 |             cached: 50,
129 |             thoughts: 0,
130 |             tool: 0,
131 |           },
132 |         },
133 |       },
134 |       tools: {
135 |         totalCalls: 2,
136 |         totalSuccess: 1,
137 |         totalFail: 1,
138 |         totalDurationMs: 123,
139 |         totalDecisions: { accept: 1, reject: 0, modify: 0 },
140 |         byName: {
141 |           'test-tool': {
142 |             count: 2,
143 |             success: 1,
144 |             fail: 1,
145 |             durationMs: 123,
146 |             decisions: { accept: 1, reject: 0, modify: 0 },
147 |           },
148 |         },
149 |       },
150 |       files: {
151 |         totalLinesAdded: 0,
152 |         totalLinesRemoved: 0,
153 |       },
154 |     };
155 | 
156 |     const { lastFrame } = renderWithMockedStats(metrics);
157 |     const output = lastFrame();
158 | 
159 |     expect(output).toContain('Performance');
160 |     expect(output).toContain('Interaction Summary');
161 |     expect(output).toContain('User Agreement');
162 |     expect(output).toContain('Savings Highlight');
163 |     expect(output).toContain('gemini-2.5-pro');
164 |     expect(output).toMatchSnapshot();
165 |   });
166 | 
167 |   describe('Conditional Rendering Tests', () => {
168 |     it('hides User Agreement when no decisions are made', () => {
169 |       const metrics: SessionMetrics = {
170 |         models: {},
171 |         tools: {
172 |           totalCalls: 2,
173 |           totalSuccess: 1,
174 |           totalFail: 1,
175 |           totalDurationMs: 123,
176 |           totalDecisions: { accept: 0, reject: 0, modify: 0 }, // No decisions
177 |           byName: {
178 |             'test-tool': {
179 |               count: 2,
180 |               success: 1,
181 |               fail: 1,
182 |               durationMs: 123,
183 |               decisions: { accept: 0, reject: 0, modify: 0 },
184 |             },
185 |           },
186 |         },
187 |         files: {
188 |           totalLinesAdded: 0,
189 |           totalLinesRemoved: 0,
190 |         },
191 |       };
192 | 
193 |       const { lastFrame } = renderWithMockedStats(metrics);
194 |       const output = lastFrame();
195 | 
196 |       expect(output).toContain('Interaction Summary');
197 |       expect(output).toContain('Success Rate');
198 |       expect(output).not.toContain('User Agreement');
199 |       expect(output).toMatchSnapshot();
200 |     });
201 | 
202 |     it('hides Efficiency section when cache is not used', () => {
203 |       const metrics: SessionMetrics = {
204 |         models: {
205 |           'gemini-2.5-pro': {
206 |             api: { totalRequests: 1, totalErrors: 0, totalLatencyMs: 100 },
207 |             tokens: {
208 |               prompt: 100,
209 |               candidates: 100,
210 |               total: 200,
211 |               cached: 0,
212 |               thoughts: 0,
213 |               tool: 0,
214 |             },
215 |           },
216 |         },
217 |         tools: {
218 |           totalCalls: 0,
219 |           totalSuccess: 0,
220 |           totalFail: 0,
221 |           totalDurationMs: 0,
222 |           totalDecisions: { accept: 0, reject: 0, modify: 0 },
223 |           byName: {},
224 |         },
225 |         files: {
226 |           totalLinesAdded: 0,
227 |           totalLinesRemoved: 0,
228 |         },
229 |       };
230 | 
231 |       const { lastFrame } = renderWithMockedStats(metrics);
232 |       const output = lastFrame();
233 | 
234 |       expect(output).not.toContain('Efficiency & Optimizations');
235 |       expect(output).toMatchSnapshot();
236 |     });
237 |   });
238 | 
239 |   describe('Conditional Color Tests', () => {
240 |     it('renders success rate in green for high values', () => {
241 |       const metrics: SessionMetrics = {
242 |         models: {},
243 |         tools: {
244 |           totalCalls: 10,
245 |           totalSuccess: 10,
246 |           totalFail: 0,
247 |           totalDurationMs: 0,
248 |           totalDecisions: { accept: 0, reject: 0, modify: 0 },
249 |           byName: {},
250 |         },
251 |         files: {
252 |           totalLinesAdded: 0,
253 |           totalLinesRemoved: 0,
254 |         },
255 |       };
256 |       const { lastFrame } = renderWithMockedStats(metrics);
257 |       expect(lastFrame()).toMatchSnapshot();
258 |     });
259 | 
260 |     it('renders success rate in yellow for medium values', () => {
261 |       const metrics: SessionMetrics = {
262 |         models: {},
263 |         tools: {
264 |           totalCalls: 10,
265 |           totalSuccess: 9,
266 |           totalFail: 1,
267 |           totalDurationMs: 0,
268 |           totalDecisions: { accept: 0, reject: 0, modify: 0 },
269 |           byName: {},
270 |         },
271 |         files: {
272 |           totalLinesAdded: 0,
273 |           totalLinesRemoved: 0,
274 |         },
275 |       };
276 |       const { lastFrame } = renderWithMockedStats(metrics);
277 |       expect(lastFrame()).toMatchSnapshot();
278 |     });
279 | 
280 |     it('renders success rate in red for low values', () => {
281 |       const metrics: SessionMetrics = {
282 |         models: {},
283 |         tools: {
284 |           totalCalls: 10,
285 |           totalSuccess: 5,
286 |           totalFail: 5,
287 |           totalDurationMs: 0,
288 |           totalDecisions: { accept: 0, reject: 0, modify: 0 },
289 |           byName: {},
290 |         },
291 |         files: {
292 |           totalLinesAdded: 0,
293 |           totalLinesRemoved: 0,
294 |         },
295 |       };
296 |       const { lastFrame } = renderWithMockedStats(metrics);
297 |       expect(lastFrame()).toMatchSnapshot();
298 |     });
299 |   });
300 | 
301 |   describe('Code Changes Display', () => {
302 |     it('displays Code Changes when line counts are present', () => {
303 |       const metrics: SessionMetrics = {
304 |         models: {},
305 |         tools: {
306 |           totalCalls: 1,
307 |           totalSuccess: 1,
308 |           totalFail: 0,
309 |           totalDurationMs: 100,
310 |           totalDecisions: { accept: 0, reject: 0, modify: 0 },
311 |           byName: {},
312 |         },
313 |         files: {
314 |           totalLinesAdded: 42,
315 |           totalLinesRemoved: 18,
316 |         },
317 |       };
318 | 
319 |       const { lastFrame } = renderWithMockedStats(metrics);
320 |       const output = lastFrame();
321 | 
322 |       expect(output).toContain('Code Changes:');
323 |       expect(output).toContain('+42');
324 |       expect(output).toContain('-18');
325 |       expect(output).toMatchSnapshot();
326 |     });
327 | 
328 |     it('hides Code Changes when no lines are added or removed', () => {
329 |       const metrics: SessionMetrics = {
330 |         models: {},
331 |         tools: {
332 |           totalCalls: 1,
333 |           totalSuccess: 1,
334 |           totalFail: 0,
335 |           totalDurationMs: 100,
336 |           totalDecisions: { accept: 0, reject: 0, modify: 0 },
337 |           byName: {},
338 |         },
339 |         files: {
340 |           totalLinesAdded: 0,
341 |           totalLinesRemoved: 0,
342 |         },
343 |       };
344 | 
345 |       const { lastFrame } = renderWithMockedStats(metrics);
346 |       const output = lastFrame();
347 | 
348 |       expect(output).not.toContain('Code Changes:');
349 |       expect(output).toMatchSnapshot();
350 |     });
351 |   });
352 | 
353 |   describe('Title Rendering', () => {
354 |     const zeroMetrics: SessionMetrics = {
355 |       models: {},
356 |       tools: {
357 |         totalCalls: 0,
358 |         totalSuccess: 0,
359 |         totalFail: 0,
360 |         totalDurationMs: 0,
361 |         totalDecisions: { accept: 0, reject: 0, modify: 0 },
362 |         byName: {},
363 |       },
364 |       files: {
365 |         totalLinesAdded: 0,
366 |         totalLinesRemoved: 0,
367 |       },
368 |     };
369 | 
370 |     it('renders the default title when no title prop is provided', () => {
371 |       const { lastFrame } = renderWithMockedStats(zeroMetrics);
372 |       const output = lastFrame();
373 |       expect(output).toContain('Session Stats');
374 |       expect(output).not.toContain('Agent powering down');
375 |       expect(output).toMatchSnapshot();
376 |     });
377 | 
378 |     it('renders the custom title when a title prop is provided', () => {
379 |       useSessionStatsMock.mockReturnValue({
380 |         stats: {
381 |           sessionId: 'test-session-id',
382 |           sessionStartTime: new Date(),
383 |           metrics: zeroMetrics,
384 |           lastPromptTokenCount: 0,
385 |           promptCount: 5,
386 |         },
387 | 
388 |         getPromptCount: () => 5,
389 |         startNewPrompt: vi.fn(),
390 |       });
391 | 
392 |       const { lastFrame } = render(
393 |         <StatsDisplay duration="1s" title="Agent powering down. Goodbye!" />,
394 |       );
395 |       const output = lastFrame();
396 |       expect(output).toContain('Agent powering down. Goodbye!');
397 |       expect(output).not.toContain('Session Stats');
398 |       expect(output).toMatchSnapshot();
399 |     });
400 |   });
401 | });
```

src/ui/components/StatsDisplay.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type React from 'react';
8 | import { Box, Text } from 'ink';
9 | import Gradient from 'ink-gradient';
10 | import { theme } from '../semantic-colors.js';
11 | import { formatDuration } from '../utils/formatters.js';
12 | import type { ModelMetrics } from '../contexts/SessionContext.js';
13 | import { useSessionStats } from '../contexts/SessionContext.js';
14 | import {
15 |   getStatusColor,
16 |   TOOL_SUCCESS_RATE_HIGH,
17 |   TOOL_SUCCESS_RATE_MEDIUM,
18 |   USER_AGREEMENT_RATE_HIGH,
19 |   USER_AGREEMENT_RATE_MEDIUM,
20 | } from '../utils/displayUtils.js';
21 | import { computeSessionStats } from '../utils/computeStats.js';
22 | 
23 | // A more flexible and powerful StatRow component
24 | interface StatRowProps {
25 |   title: string;
26 |   children: React.ReactNode; // Use children to allow for complex, colored values
27 | }
28 | 
29 | const StatRow: React.FC<StatRowProps> = ({ title, children }) => (
30 |   <Box>
31 |     {/* Fixed width for the label creates a clean "gutter" for alignment */}
32 |     <Box width={28}>
33 |       <Text color={theme.text.link}>{title}</Text>
34 |     </Box>
35 |     {/* FIX: Wrap children in a Box that can grow to fill remaining space */}
36 |     <Box flexGrow={1}>{children}</Box>
37 |   </Box>
38 | );
39 | 
40 | // A SubStatRow for indented, secondary information
41 | interface SubStatRowProps {
42 |   title: string;
43 |   children: React.ReactNode;
44 | }
45 | 
46 | const SubStatRow: React.FC<SubStatRowProps> = ({ title, children }) => (
47 |   <Box paddingLeft={2}>
48 |     {/* Adjust width for the "» " prefix */}
49 |     <Box width={26}>
50 |       <Text color={theme.text.secondary}>» {title}</Text>
51 |     </Box>
52 |     {/* FIX: Apply the same flexGrow fix here */}
53 |     <Box flexGrow={1}>{children}</Box>
54 |   </Box>
55 | );
56 | 
57 | // A Section component to group related stats
58 | interface SectionProps {
59 |   title: string;
60 |   children: React.ReactNode;
61 | }
62 | 
63 | const Section: React.FC<SectionProps> = ({ title, children }) => (
64 |   <Box flexDirection="column" width="100%" marginBottom={1}>
65 |     <Text bold color={theme.text.primary}>
66 |       {title}
67 |     </Text>
68 |     {children}
69 |   </Box>
70 | );
71 | 
72 | const ModelUsageTable: React.FC<{
73 |   models: Record<string, ModelMetrics>;
74 |   totalCachedTokens: number;
75 |   cacheEfficiency: number;
76 | }> = ({ models, totalCachedTokens, cacheEfficiency }) => {
77 |   const nameWidth = 25;
78 |   const requestsWidth = 8;
79 |   const inputTokensWidth = 15;
80 |   const outputTokensWidth = 15;
81 | 
82 |   return (
83 |     <Box flexDirection="column" marginTop={1}>
84 |       {/* Header */}
85 |       <Box>
86 |         <Box width={nameWidth}>
87 |           <Text bold color={theme.text.primary}>
88 |             Model Usage
89 |           </Text>
90 |         </Box>
91 |         <Box width={requestsWidth} justifyContent="flex-end">
92 |           <Text bold color={theme.text.primary}>
93 |             Reqs
94 |           </Text>
95 |         </Box>
96 |         <Box width={inputTokensWidth} justifyContent="flex-end">
97 |           <Text bold color={theme.text.primary}>
98 |             Input Tokens
99 |           </Text>
100 |         </Box>
101 |         <Box width={outputTokensWidth} justifyContent="flex-end">
102 |           <Text bold color={theme.text.primary}>
103 |             Output Tokens
104 |           </Text>
105 |         </Box>
106 |       </Box>
107 |       {/* Divider */}
108 |       <Box
109 |         borderStyle="round"
110 |         borderBottom={true}
111 |         borderTop={false}
112 |         borderLeft={false}
113 |         borderRight={false}
114 |         borderColor={theme.border.default}
115 |         width={nameWidth + requestsWidth + inputTokensWidth + outputTokensWidth}
116 |       ></Box>
117 | 
118 |       {/* Rows */}
119 |       {Object.entries(models).map(([name, modelMetrics]) => (
120 |         <Box key={name}>
121 |           <Box width={nameWidth}>
122 |             <Text color={theme.text.primary}>{name.replace('-001', '')}</Text>
123 |           </Box>
124 |           <Box width={requestsWidth} justifyContent="flex-end">
125 |             <Text color={theme.text.primary}>
126 |               {modelMetrics.api.totalRequests}
127 |             </Text>
128 |           </Box>
129 |           <Box width={inputTokensWidth} justifyContent="flex-end">
130 |             <Text color={theme.status.warning}>
131 |               {modelMetrics.tokens.prompt.toLocaleString()}
132 |             </Text>
133 |           </Box>
134 |           <Box width={outputTokensWidth} justifyContent="flex-end">
135 |             <Text color={theme.status.warning}>
136 |               {modelMetrics.tokens.candidates.toLocaleString()}
137 |             </Text>
138 |           </Box>
139 |         </Box>
140 |       ))}
141 |       {cacheEfficiency > 0 && (
142 |         <Box flexDirection="column" marginTop={1}>
143 |           <Text color={theme.text.primary}>
144 |             <Text color={theme.status.success}>Savings Highlight:</Text>{' '}
145 |             {totalCachedTokens.toLocaleString()} ({cacheEfficiency.toFixed(1)}
146 |             %) of input tokens were served from the cache, reducing costs.
147 |           </Text>
148 |           <Box height={1} />
149 |           <Text color={theme.text.secondary}>
150 |             » Tip: For a full token breakdown, run `/stats model`.
151 |           </Text>
152 |         </Box>
153 |       )}
154 |     </Box>
155 |   );
156 | };
157 | 
158 | interface StatsDisplayProps {
159 |   duration: string;
160 |   title?: string;
161 | }
162 | 
163 | export const StatsDisplay: React.FC<StatsDisplayProps> = ({
164 |   duration,
165 |   title,
166 | }) => {
167 |   const { stats } = useSessionStats();
168 |   const { metrics } = stats;
169 |   const { models, tools, files } = metrics;
170 |   const computed = computeSessionStats(metrics);
171 | 
172 |   const successThresholds = {
173 |     green: TOOL_SUCCESS_RATE_HIGH,
174 |     yellow: TOOL_SUCCESS_RATE_MEDIUM,
175 |   };
176 |   const agreementThresholds = {
177 |     green: USER_AGREEMENT_RATE_HIGH,
178 |     yellow: USER_AGREEMENT_RATE_MEDIUM,
179 |   };
180 |   const successColor = getStatusColor(computed.successRate, successThresholds);
181 |   const agreementColor = getStatusColor(
182 |     computed.agreementRate,
183 |     agreementThresholds,
184 |   );
185 | 
186 |   const renderTitle = () => {
187 |     if (title) {
188 |       return theme.ui.gradient && theme.ui.gradient.length > 0 ? (
189 |         <Gradient colors={theme.ui.gradient}>
190 |           <Text bold color={theme.text.primary}>
191 |             {title}
192 |           </Text>
193 |         </Gradient>
194 |       ) : (
195 |         <Text bold color={theme.text.accent}>
196 |           {title}
197 |         </Text>
198 |       );
199 |     }
200 |     return (
201 |       <Text bold color={theme.text.accent}>
202 |         Session Stats
203 |       </Text>
204 |     );
205 |   };
206 | 
207 |   return (
208 |     <Box
209 |       borderStyle="round"
210 |       borderColor={theme.border.default}
211 |       flexDirection="column"
212 |       paddingY={1}
213 |       paddingX={2}
214 |     >
215 |       {renderTitle()}
216 |       <Box height={1} />
217 | 
218 |       <Section title="Interaction Summary">
219 |         <StatRow title="Session ID:">
220 |           <Text color={theme.text.primary}>{stats.sessionId}</Text>
221 |         </StatRow>
222 |         <StatRow title="Tool Calls:">
223 |           <Text color={theme.text.primary}>
224 |             {tools.totalCalls} ({' '}
225 |             <Text color={theme.status.success}>✓ {tools.totalSuccess}</Text>{' '}
226 |             <Text color={theme.status.error}>x {tools.totalFail}</Text> )
227 |           </Text>
228 |         </StatRow>
229 |         <StatRow title="Success Rate:">
230 |           <Text color={successColor}>{computed.successRate.toFixed(1)}%</Text>
231 |         </StatRow>
232 |         {computed.totalDecisions > 0 && (
233 |           <StatRow title="User Agreement:">
234 |             <Text color={agreementColor}>
235 |               {computed.agreementRate.toFixed(1)}%{' '}
236 |               <Text color={theme.text.secondary}>
237 |                 ({computed.totalDecisions} reviewed)
238 |               </Text>
239 |             </Text>
240 |           </StatRow>
241 |         )}
242 |         {files &&
243 |           (files.totalLinesAdded > 0 || files.totalLinesRemoved > 0) && (
244 |             <StatRow title="Code Changes:">
245 |               <Text color={theme.text.primary}>
246 |                 <Text color={theme.status.success}>
247 |                   +{files.totalLinesAdded}
248 |                 </Text>{' '}
249 |                 <Text color={theme.status.error}>
250 |                   -{files.totalLinesRemoved}
251 |                 </Text>
252 |               </Text>
253 |             </StatRow>
254 |           )}
255 |       </Section>
256 | 
257 |       <Section title="Performance">
258 |         <StatRow title="Wall Time:">
259 |           <Text color={theme.text.primary}>{duration}</Text>
260 |         </StatRow>
261 |         <StatRow title="Agent Active:">
262 |           <Text color={theme.text.primary}>
263 |             {formatDuration(computed.agentActiveTime)}
264 |           </Text>
265 |         </StatRow>
266 |         <SubStatRow title="API Time:">
267 |           <Text color={theme.text.primary}>
268 |             {formatDuration(computed.totalApiTime)}{' '}
269 |             <Text color={theme.text.secondary}>
270 |               ({computed.apiTimePercent.toFixed(1)}%)
271 |             </Text>
272 |           </Text>
273 |         </SubStatRow>
274 |         <SubStatRow title="Tool Time:">
275 |           <Text color={theme.text.primary}>
276 |             {formatDuration(computed.totalToolTime)}{' '}
277 |             <Text color={theme.text.secondary}>
278 |               ({computed.toolTimePercent.toFixed(1)}%)
279 |             </Text>
280 |           </Text>
281 |         </SubStatRow>
282 |       </Section>
283 | 
284 |       {Object.keys(models).length > 0 && (
285 |         <ModelUsageTable
286 |           models={models}
287 |           totalCachedTokens={computed.totalCachedTokens}
288 |           cacheEfficiency={computed.cacheEfficiency}
289 |         />
290 |       )}
291 |     </Box>
292 |   );
293 | };
```

src/ui/components/SuggestionsDisplay.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { Box, Text } from 'ink';
8 | import { theme } from '../semantic-colors.js';
9 | import { PrepareLabel, MAX_WIDTH } from './PrepareLabel.js';
10 | import { CommandKind } from '../commands/types.js';
11 | import { Colors } from '../colors.js';
12 | export interface Suggestion {
13 |   label: string;
14 |   value: string;
15 |   description?: string;
16 |   matchedIndex?: number;
17 |   commandKind?: CommandKind;
18 | }
19 | interface SuggestionsDisplayProps {
20 |   suggestions: Suggestion[];
21 |   activeIndex: number;
22 |   isLoading: boolean;
23 |   width: number;
24 |   scrollOffset: number;
25 |   userInput: string;
26 |   mode: 'reverse' | 'slash';
27 |   expandedIndex?: number;
28 | }
29 | 
30 | export const MAX_SUGGESTIONS_TO_SHOW = 8;
31 | export { MAX_WIDTH };
32 | 
33 | export function SuggestionsDisplay({
34 |   suggestions,
35 |   activeIndex,
36 |   isLoading,
37 |   width,
38 |   scrollOffset,
39 |   userInput,
40 |   mode,
41 |   expandedIndex,
42 | }: SuggestionsDisplayProps) {
43 |   if (isLoading) {
44 |     return (
45 |       <Box paddingX={1} width={width}>
46 |         <Text color="gray">Loading suggestions...</Text>
47 |       </Box>
48 |     );
49 |   }
50 | 
51 |   if (suggestions.length === 0) {
52 |     return null; // Don't render anything if there are no suggestions
53 |   }
54 | 
55 |   // Calculate the visible slice based on scrollOffset
56 |   const startIndex = scrollOffset;
57 |   const endIndex = Math.min(
58 |     scrollOffset + MAX_SUGGESTIONS_TO_SHOW,
59 |     suggestions.length,
60 |   );
61 |   const visibleSuggestions = suggestions.slice(startIndex, endIndex);
62 | 
63 |   const getFullLabel = (s: Suggestion) =>
64 |     s.label + (s.commandKind === CommandKind.MCP_PROMPT ? ' [MCP]' : '');
65 | 
66 |   const maxLabelLength = Math.max(
67 |     ...suggestions.map((s) => getFullLabel(s).length),
68 |   );
69 |   const commandColumnWidth =
70 |     mode === 'slash' ? Math.min(maxLabelLength, Math.floor(width * 0.5)) : 0;
71 | 
72 |   return (
73 |     <Box flexDirection="column" paddingX={1} width={width}>
74 |       {scrollOffset > 0 && <Text color={theme.text.primary}>▲</Text>}
75 | 
76 |       {visibleSuggestions.map((suggestion, index) => {
77 |         const originalIndex = startIndex + index;
78 |         const isActive = originalIndex === activeIndex;
79 |         const isExpanded = originalIndex === expandedIndex;
80 |         const textColor = isActive ? theme.text.accent : theme.text.secondary;
81 |         const isLong = suggestion.value.length >= MAX_WIDTH;
82 |         const labelElement = (
83 |           <PrepareLabel
84 |             label={suggestion.value}
85 |             matchedIndex={suggestion.matchedIndex}
86 |             userInput={userInput}
87 |             textColor={textColor}
88 |             isExpanded={isExpanded}
89 |           />
90 |         );
91 | 
92 |         return (
93 |           <Box key={`${suggestion.value}-${originalIndex}`} flexDirection="row">
94 |             <Box
95 |               {...(mode === 'slash'
96 |                 ? { width: commandColumnWidth, flexShrink: 0 as const }
97 |                 : { flexShrink: 1 as const })}
98 |             >
99 |               <Box>
100 |                 {labelElement}
101 |                 {suggestion.commandKind === CommandKind.MCP_PROMPT && (
102 |                   <Text color={textColor}> [MCP]</Text>
103 |                 )}
104 |               </Box>
105 |             </Box>
106 | 
107 |             {suggestion.description && (
108 |               <Box flexGrow={1} paddingLeft={3}>
109 |                 <Text color={textColor} wrap="truncate">
110 |                   {suggestion.description}
111 |                 </Text>
112 |               </Box>
113 |             )}
114 |             {isActive && isLong && (
115 |               <Box>
116 |                 <Text color={Colors.Gray}>{isExpanded ? ' ← ' : ' → '}</Text>
117 |               </Box>
118 |             )}
119 |           </Box>
120 |         );
121 |       })}
122 |       {endIndex < suggestions.length && <Text color="gray">▼</Text>}
123 |       {suggestions.length > MAX_SUGGESTIONS_TO_SHOW && (
124 |         <Text color="gray">
125 |           ({activeIndex + 1}/{suggestions.length})
126 |         </Text>
127 |       )}
128 |     </Box>
129 |   );
130 | }
```

src/ui/components/ThemeDialog.test.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { render } from 'ink-testing-library';
8 | import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
9 | import { ThemeDialog } from './ThemeDialog.js';
10 | import { LoadedSettings } from '../../config/settings.js';
11 | import { KeypressProvider } from '../contexts/KeypressContext.js';
12 | import { SettingsContext } from '../contexts/SettingsContext.js';
13 | import { DEFAULT_THEME, themeManager } from '../themes/theme-manager.js';
14 | import { act } from 'react';
15 | 
16 | const createMockSettings = (
17 |   userSettings = {},
18 |   workspaceSettings = {},
19 |   systemSettings = {},
20 | ): LoadedSettings =>
21 |   new LoadedSettings(
22 |     {
23 |       settings: { ui: { customThemes: {} }, ...systemSettings },
24 |       originalSettings: { ui: { customThemes: {} }, ...systemSettings },
25 |       path: '/system/settings.json',
26 |     },
27 |     {
28 |       settings: {},
29 |       originalSettings: {},
30 |       path: '/system/system-defaults.json',
31 |     },
32 |     {
33 |       settings: {
34 |         ui: { customThemes: {} },
35 |         ...userSettings,
36 |       },
37 |       originalSettings: {
38 |         ui: { customThemes: {} },
39 |         ...userSettings,
40 |       },
41 |       path: '/user/settings.json',
42 |     },
43 |     {
44 |       settings: {
45 |         ui: { customThemes: {} },
46 |         ...workspaceSettings,
47 |       },
48 |       originalSettings: {
49 |         ui: { customThemes: {} },
50 |         ...workspaceSettings,
51 |       },
52 |       path: '/workspace/settings.json',
53 |     },
54 |     true,
55 |     new Set(),
56 |   );
57 | 
58 | describe('ThemeDialog Snapshots', () => {
59 |   const baseProps = {
60 |     onSelect: vi.fn(),
61 |     onHighlight: vi.fn(),
62 |     availableTerminalHeight: 40,
63 |     terminalWidth: 120,
64 |   };
65 | 
66 |   beforeEach(() => {
67 |     // Reset theme manager to a known state
68 |     themeManager.setActiveTheme(DEFAULT_THEME.name);
69 |   });
70 | 
71 |   afterEach(() => {
72 |     vi.restoreAllMocks();
73 |   });
74 | 
75 |   it('should render correctly in theme selection mode', () => {
76 |     const settings = createMockSettings();
77 |     const { lastFrame } = render(
78 |       <SettingsContext.Provider value={settings}>
79 |         <KeypressProvider kittyProtocolEnabled={false}>
80 |           <ThemeDialog {...baseProps} settings={settings} />
81 |         </KeypressProvider>
82 |       </SettingsContext.Provider>,
83 |     );
84 | 
85 |     expect(lastFrame()).toMatchSnapshot();
86 |   });
87 | 
88 |   it('should render correctly in scope selector mode', async () => {
89 |     const settings = createMockSettings();
90 |     const { lastFrame, stdin } = render(
91 |       <SettingsContext.Provider value={settings}>
92 |         <KeypressProvider kittyProtocolEnabled={false}>
93 |           <ThemeDialog {...baseProps} settings={settings} />
94 |         </KeypressProvider>
95 |       </SettingsContext.Provider>,
96 |     );
97 | 
98 |     // Press Tab to switch to scope selector mode
99 |     act(() => {
100 |       stdin.write('\t');
101 |     });
102 | 
103 |     // Need to wait for the state update to propagate
104 |     await new Promise((resolve) => setTimeout(resolve, 100));
105 | 
106 |     expect(lastFrame()).toMatchSnapshot();
107 |   });
108 | });
```

src/ui/components/ThemeDialog.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type React from 'react';
8 | import { useCallback, useState } from 'react';
9 | import { Box, Text } from 'ink';
10 | import { theme } from '../semantic-colors.js';
11 | import { themeManager, DEFAULT_THEME } from '../themes/theme-manager.js';
12 | import { RadioButtonSelect } from './shared/RadioButtonSelect.js';
13 | import { DiffRenderer } from './messages/DiffRenderer.js';
14 | import { colorizeCode } from '../utils/CodeColorizer.js';
15 | import type { LoadedSettings } from '../../config/settings.js';
16 | import { SettingScope } from '../../config/settings.js';
17 | import { getScopeMessageForSetting } from '../../utils/dialogScopeUtils.js';
18 | import { useKeypress } from '../hooks/useKeypress.js';
19 | import { ScopeSelector } from './shared/ScopeSelector.js';
20 | 
21 | interface ThemeDialogProps {
22 |   /** Callback function when a theme is selected */
23 |   onSelect: (themeName: string | undefined, scope: SettingScope) => void;
24 | 
25 |   /** Callback function when a theme is highlighted */
26 |   onHighlight: (themeName: string | undefined) => void;
27 |   /** The settings object */
28 |   settings: LoadedSettings;
29 |   availableTerminalHeight?: number;
30 |   terminalWidth: number;
31 | }
32 | 
33 | export function ThemeDialog({
34 |   onSelect,
35 |   onHighlight,
36 |   settings,
37 |   availableTerminalHeight,
38 |   terminalWidth,
39 | }: ThemeDialogProps): React.JSX.Element {
40 |   const [selectedScope, setSelectedScope] = useState<SettingScope>(
41 |     SettingScope.User,
42 |   );
43 | 
44 |   // Track the currently highlighted theme name
45 |   const [highlightedThemeName, setHighlightedThemeName] = useState<
46 |     string | undefined
47 |   >(settings.merged.ui?.theme || DEFAULT_THEME.name);
48 | 
49 |   // Generate theme items filtered by selected scope
50 |   const customThemes =
51 |     selectedScope === SettingScope.User
52 |       ? settings.user.settings.ui?.customThemes || {}
53 |       : settings.merged.ui?.customThemes || {};
54 |   const builtInThemes = themeManager
55 |     .getAvailableThemes()
56 |     .filter((theme) => theme.type !== 'custom');
57 |   const customThemeNames = Object.keys(customThemes);
58 |   const capitalize = (s: string) => s.charAt(0).toUpperCase() + s.slice(1);
59 |   // Generate theme items
60 |   const themeItems = [
61 |     ...builtInThemes.map((theme) => ({
62 |       label: theme.name,
63 |       value: theme.name,
64 |       themeNameDisplay: theme.name,
65 |       themeTypeDisplay: capitalize(theme.type),
66 |       key: theme.name,
67 |     })),
68 |     ...customThemeNames.map((name) => ({
69 |       label: name,
70 |       value: name,
71 |       themeNameDisplay: name,
72 |       themeTypeDisplay: 'Custom',
73 |       key: name,
74 |     })),
75 |   ];
76 | 
77 |   // Find the index of the selected theme, but only if it exists in the list
78 |   const initialThemeIndex = themeItems.findIndex(
79 |     (item) => item.value === highlightedThemeName,
80 |   );
81 |   // If not found, fall back to the first theme
82 |   const safeInitialThemeIndex = initialThemeIndex >= 0 ? initialThemeIndex : 0;
83 | 
84 |   const handleThemeSelect = useCallback(
85 |     (themeName: string) => {
86 |       onSelect(themeName, selectedScope);
87 |     },
88 |     [onSelect, selectedScope],
89 |   );
90 | 
91 |   const handleThemeHighlight = (themeName: string) => {
92 |     setHighlightedThemeName(themeName);
93 |     onHighlight(themeName);
94 |   };
95 | 
96 |   const handleScopeHighlight = useCallback((scope: SettingScope) => {
97 |     setSelectedScope(scope);
98 |   }, []);
99 | 
100 |   const handleScopeSelect = useCallback(
101 |     (scope: SettingScope) => {
102 |       onSelect(highlightedThemeName, scope);
103 |     },
104 |     [onSelect, highlightedThemeName],
105 |   );
106 | 
107 |   const [mode, setMode] = useState<'theme' | 'scope'>('theme');
108 | 
109 |   useKeypress(
110 |     (key) => {
111 |       if (key.name === 'tab') {
112 |         setMode((prev) => (prev === 'theme' ? 'scope' : 'theme'));
113 |       }
114 |       if (key.name === 'escape') {
115 |         onSelect(undefined, selectedScope);
116 |       }
117 |     },
118 |     { isActive: true },
119 |   );
120 | 
121 |   // Generate scope message for theme setting
122 |   const otherScopeModifiedMessage = getScopeMessageForSetting(
123 |     'ui.theme',
124 |     selectedScope,
125 |     settings,
126 |   );
127 | 
128 |   // Constants for calculating preview pane layout.
129 |   // These values are based on the JSX structure below.
130 |   const PREVIEW_PANE_WIDTH_PERCENTAGE = 0.55;
131 |   // A safety margin to prevent text from touching the border.
132 |   // This is a complete hack unrelated to the 0.9 used in App.tsx
133 |   const PREVIEW_PANE_WIDTH_SAFETY_MARGIN = 0.9;
134 |   // Combined horizontal padding from the dialog and preview pane.
135 |   const TOTAL_HORIZONTAL_PADDING = 4;
136 |   const colorizeCodeWidth = Math.max(
137 |     Math.floor(
138 |       (terminalWidth - TOTAL_HORIZONTAL_PADDING) *
139 |         PREVIEW_PANE_WIDTH_PERCENTAGE *
140 |         PREVIEW_PANE_WIDTH_SAFETY_MARGIN,
141 |     ),
142 |     1,
143 |   );
144 | 
145 |   const DIALOG_PADDING = 2;
146 |   const selectThemeHeight = themeItems.length + 1;
147 |   const TAB_TO_SELECT_HEIGHT = 2;
148 |   availableTerminalHeight = availableTerminalHeight ?? Number.MAX_SAFE_INTEGER;
149 |   availableTerminalHeight -= 2; // Top and bottom borders.
150 |   availableTerminalHeight -= TAB_TO_SELECT_HEIGHT;
151 | 
152 |   let totalLeftHandSideHeight = DIALOG_PADDING + selectThemeHeight;
153 | 
154 |   let includePadding = true;
155 | 
156 |   // Remove content from the LHS that can be omitted if it exceeds the available height.
157 |   if (totalLeftHandSideHeight > availableTerminalHeight) {
158 |     includePadding = false;
159 |     totalLeftHandSideHeight -= DIALOG_PADDING;
160 |   }
161 | 
162 |   // Vertical space taken by elements other than the two code blocks in the preview pane.
163 |   // Includes "Preview" title, borders, and margin between blocks.
164 |   const PREVIEW_PANE_FIXED_VERTICAL_SPACE = 8;
165 | 
166 |   // The right column doesn't need to ever be shorter than the left column.
167 |   availableTerminalHeight = Math.max(
168 |     availableTerminalHeight,
169 |     totalLeftHandSideHeight,
170 |   );
171 |   const availableTerminalHeightCodeBlock =
172 |     availableTerminalHeight -
173 |     PREVIEW_PANE_FIXED_VERTICAL_SPACE -
174 |     (includePadding ? 2 : 0) * 2;
175 | 
176 |   // Subtract margin between code blocks from available height.
177 |   const availableHeightForPanes = Math.max(
178 |     0,
179 |     availableTerminalHeightCodeBlock - 1,
180 |   );
181 | 
182 |   // The code block is slightly longer than the diff, so give it more space.
183 |   const codeBlockHeight = Math.ceil(availableHeightForPanes * 0.6);
184 |   const diffHeight = Math.floor(availableHeightForPanes * 0.4);
185 |   return (
186 |     <Box
187 |       borderStyle="round"
188 |       borderColor={theme.border.default}
189 |       flexDirection="column"
190 |       paddingTop={includePadding ? 1 : 0}
191 |       paddingBottom={includePadding ? 1 : 0}
192 |       paddingLeft={1}
193 |       paddingRight={1}
194 |       width="100%"
195 |     >
196 |       {mode === 'theme' ? (
197 |         <Box flexDirection="row">
198 |           {/* Left Column: Selection */}
199 |           <Box flexDirection="column" width="45%" paddingRight={2}>
200 |             <Text bold={mode === 'theme'} wrap="truncate">
201 |               {mode === 'theme' ? '> ' : '  '}Select Theme{' '}
202 |               <Text color={theme.text.secondary}>
203 |                 {otherScopeModifiedMessage}
204 |               </Text>
205 |             </Text>
206 |             <RadioButtonSelect
207 |               items={themeItems}
208 |               initialIndex={safeInitialThemeIndex}
209 |               onSelect={handleThemeSelect}
210 |               onHighlight={handleThemeHighlight}
211 |               isFocused={mode === 'theme'}
212 |               maxItemsToShow={12}
213 |               showScrollArrows={true}
214 |               showNumbers={mode === 'theme'}
215 |             />
216 |           </Box>
217 | 
218 |           {/* Right Column: Preview */}
219 |           <Box flexDirection="column" width="55%" paddingLeft={2}>
220 |             <Text bold color={theme.text.primary}>
221 |               Preview
222 |             </Text>
223 |             {/* Get the Theme object for the highlighted theme, fall back to default if not found */}
224 |             {(() => {
225 |               const previewTheme =
226 |                 themeManager.getTheme(
227 |                   highlightedThemeName || DEFAULT_THEME.name,
228 |                 ) || DEFAULT_THEME;
229 |               return (
230 |                 <Box
231 |                   borderStyle="single"
232 |                   borderColor={theme.border.default}
233 |                   paddingTop={includePadding ? 1 : 0}
234 |                   paddingBottom={includePadding ? 1 : 0}
235 |                   paddingLeft={1}
236 |                   paddingRight={1}
237 |                   flexDirection="column"
238 |                 >
239 |                   {colorizeCode(
240 |                     `# function
241 | def fibonacci(n):
242 |     a, b = 0, 1
243 |     for _ in range(n):
244 |         a, b = b, a + b
245 |     return a`,
246 |                     'python',
247 |                     codeBlockHeight,
248 |                     colorizeCodeWidth,
249 |                   )}
250 |                   <Box marginTop={1} />
251 |                   <DiffRenderer
252 |                     diffContent={`--- a/util.py
253 | +++ b/util.py
254 | @@ -1,2 +1,2 @@
255 | - print("Hello, " + name)
256 | + print(f"Hello, {name}!")
257 | `}
258 |                     availableTerminalHeight={diffHeight}
259 |                     terminalWidth={colorizeCodeWidth}
260 |                     theme={previewTheme}
261 |                   />
262 |                 </Box>
263 |               );
264 |             })()}
265 |           </Box>
266 |         </Box>
267 |       ) : (
268 |         <ScopeSelector
269 |           onSelect={handleScopeSelect}
270 |           onHighlight={handleScopeHighlight}
271 |           isFocused={mode === 'scope'}
272 |           initialScope={selectedScope}
273 |         />
274 |       )}
275 |       <Box marginTop={1}>
276 |         <Text color={theme.text.secondary} wrap="truncate">
277 |           (Use Enter to {mode === 'theme' ? 'select' : 'apply scope'}, Tab to{' '}
278 |           {mode === 'theme' ? 'configure scope' : 'select theme'})
279 |         </Text>
280 |       </Box>
281 |     </Box>
282 |   );
283 | }
```

src/ui/components/Tips.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type React from 'react';
8 | import { Box, Text } from 'ink';
9 | import { theme } from '../semantic-colors.js';
10 | import { type Config } from '@google/gemini-cli-core';
11 | 
12 | interface TipsProps {
13 |   config: Config;
14 | }
15 | 
16 | export const Tips: React.FC<TipsProps> = ({ config }) => {
17 |   const geminiMdFileCount = config.getGeminiMdFileCount();
18 |   return (
19 |     <Box flexDirection="column">
20 |       <Text color={theme.text.primary}>Tips for getting started:</Text>
21 |       <Text color={theme.text.primary}>
22 |         1. Ask questions, edit files, or run commands.
23 |       </Text>
24 |       <Text color={theme.text.primary}>
25 |         2. Be specific for the best results.
26 |       </Text>
27 |       {geminiMdFileCount === 0 && (
28 |         <Text color={theme.text.primary}>
29 |           3. Create{' '}
30 |           <Text bold color={theme.text.accent}>
31 |             GEMINI.md
32 |           </Text>{' '}
33 |           files to customize your interactions with Gemini.
34 |         </Text>
35 |       )}
36 |       <Text color={theme.text.primary}>
37 |         {geminiMdFileCount === 0 ? '4.' : '3.'}{' '}
38 |         <Text bold color={theme.text.accent}>
39 |           /help
40 |         </Text>{' '}
41 |         for more information.
42 |       </Text>
43 |     </Box>
44 |   );
45 | };
```

src/ui/components/ToolStatsDisplay.test.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { render } from 'ink-testing-library';
8 | import { describe, it, expect, vi } from 'vitest';
9 | import { ToolStatsDisplay } from './ToolStatsDisplay.js';
10 | import * as SessionContext from '../contexts/SessionContext.js';
11 | import type { SessionMetrics } from '../contexts/SessionContext.js';
12 | 
13 | // Mock the context to provide controlled data for testing
14 | vi.mock('../contexts/SessionContext.js', async (importOriginal) => {
15 |   const actual = await importOriginal<typeof SessionContext>();
16 |   return {
17 |     ...actual,
18 |     useSessionStats: vi.fn(),
19 |   };
20 | });
21 | 
22 | const useSessionStatsMock = vi.mocked(SessionContext.useSessionStats);
23 | 
24 | const renderWithMockedStats = (metrics: SessionMetrics) => {
25 |   useSessionStatsMock.mockReturnValue({
26 |     stats: {
27 |       sessionStartTime: new Date(),
28 |       metrics,
29 |       lastPromptTokenCount: 0,
30 |       promptCount: 5,
31 |     },
32 | 
33 |     getPromptCount: () => 5,
34 |     startNewPrompt: vi.fn(),
35 |   });
36 | 
37 |   return render(<ToolStatsDisplay />);
38 | };
39 | 
40 | describe('<ToolStatsDisplay />', () => {
41 |   it('should render "no tool calls" message when there are no active tools', () => {
42 |     const { lastFrame } = renderWithMockedStats({
43 |       models: {},
44 |       tools: {
45 |         totalCalls: 0,
46 |         totalSuccess: 0,
47 |         totalFail: 0,
48 |         totalDurationMs: 0,
49 |         totalDecisions: { accept: 0, reject: 0, modify: 0 },
50 |         byName: {},
51 |       },
52 |     });
53 | 
54 |     expect(lastFrame()).toContain(
55 |       'No tool calls have been made in this session.',
56 |     );
57 |     expect(lastFrame()).toMatchSnapshot();
58 |   });
59 | 
60 |   it('should display stats for a single tool correctly', () => {
61 |     const { lastFrame } = renderWithMockedStats({
62 |       models: {},
63 |       tools: {
64 |         totalCalls: 1,
65 |         totalSuccess: 1,
66 |         totalFail: 0,
67 |         totalDurationMs: 100,
68 |         totalDecisions: { accept: 1, reject: 0, modify: 0 },
69 |         byName: {
70 |           'test-tool': {
71 |             count: 1,
72 |             success: 1,
73 |             fail: 0,
74 |             durationMs: 100,
75 |             decisions: { accept: 1, reject: 0, modify: 0 },
76 |           },
77 |         },
78 |       },
79 |     });
80 | 
81 |     const output = lastFrame();
82 |     expect(output).toContain('test-tool');
83 |     expect(output).toMatchSnapshot();
84 |   });
85 | 
86 |   it('should display stats for multiple tools correctly', () => {
87 |     const { lastFrame } = renderWithMockedStats({
88 |       models: {},
89 |       tools: {
90 |         totalCalls: 3,
91 |         totalSuccess: 2,
92 |         totalFail: 1,
93 |         totalDurationMs: 300,
94 |         totalDecisions: { accept: 1, reject: 1, modify: 1 },
95 |         byName: {
96 |           'tool-a': {
97 |             count: 2,
98 |             success: 1,
99 |             fail: 1,
100 |             durationMs: 200,
101 |             decisions: { accept: 1, reject: 1, modify: 0 },
102 |           },
103 |           'tool-b': {
104 |             count: 1,
105 |             success: 1,
106 |             fail: 0,
107 |             durationMs: 100,
108 |             decisions: { accept: 0, reject: 0, modify: 1 },
109 |           },
110 |         },
111 |       },
112 |     });
113 | 
114 |     const output = lastFrame();
115 |     expect(output).toContain('tool-a');
116 |     expect(output).toContain('tool-b');
117 |     expect(output).toMatchSnapshot();
118 |   });
119 | 
120 |   it('should handle large values without wrapping or overlapping', () => {
121 |     const { lastFrame } = renderWithMockedStats({
122 |       models: {},
123 |       tools: {
124 |         totalCalls: 999999999,
125 |         totalSuccess: 888888888,
126 |         totalFail: 111111111,
127 |         totalDurationMs: 987654321,
128 |         totalDecisions: {
129 |           accept: 123456789,
130 |           reject: 98765432,
131 |           modify: 12345,
132 |         },
133 |         byName: {
134 |           'long-named-tool-for-testing-wrapping-and-such': {
135 |             count: 999999999,
136 |             success: 888888888,
137 |             fail: 111111111,
138 |             durationMs: 987654321,
139 |             decisions: {
140 |               accept: 123456789,
141 |               reject: 98765432,
142 |               modify: 12345,
143 |             },
144 |           },
145 |         },
146 |       },
147 |     });
148 | 
149 |     expect(lastFrame()).toMatchSnapshot();
150 |   });
151 | 
152 |   it('should handle zero decisions gracefully', () => {
153 |     const { lastFrame } = renderWithMockedStats({
154 |       models: {},
155 |       tools: {
156 |         totalCalls: 1,
157 |         totalSuccess: 1,
158 |         totalFail: 0,
159 |         totalDurationMs: 100,
160 |         totalDecisions: { accept: 0, reject: 0, modify: 0 },
161 |         byName: {
162 |           'test-tool': {
163 |             count: 1,
164 |             success: 1,
165 |             fail: 0,
166 |             durationMs: 100,
167 |             decisions: { accept: 0, reject: 0, modify: 0 },
168 |           },
169 |         },
170 |       },
171 |     });
172 | 
173 |     const output = lastFrame();
174 |     expect(output).toContain('Total Reviewed Suggestions:');
175 |     expect(output).toContain('0');
176 |     expect(output).toContain('Overall Agreement Rate:');
177 |     expect(output).toContain('--');
178 |     expect(output).toMatchSnapshot();
179 |   });
180 | });
```

src/ui/components/ToolStatsDisplay.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type React from 'react';
8 | import { Box, Text } from 'ink';
9 | import { theme } from '../semantic-colors.js';
10 | import { formatDuration } from '../utils/formatters.js';
11 | import {
12 |   getStatusColor,
13 |   TOOL_SUCCESS_RATE_HIGH,
14 |   TOOL_SUCCESS_RATE_MEDIUM,
15 |   USER_AGREEMENT_RATE_HIGH,
16 |   USER_AGREEMENT_RATE_MEDIUM,
17 | } from '../utils/displayUtils.js';
18 | import { useSessionStats } from '../contexts/SessionContext.js';
19 | import type { ToolCallStats } from '@google/gemini-cli-core';
20 | 
21 | const TOOL_NAME_COL_WIDTH = 25;
22 | const CALLS_COL_WIDTH = 8;
23 | const SUCCESS_RATE_COL_WIDTH = 15;
24 | const AVG_DURATION_COL_WIDTH = 15;
25 | 
26 | const StatRow: React.FC<{
27 |   name: string;
28 |   stats: ToolCallStats;
29 | }> = ({ name, stats }) => {
30 |   const successRate = stats.count > 0 ? (stats.success / stats.count) * 100 : 0;
31 |   const avgDuration = stats.count > 0 ? stats.durationMs / stats.count : 0;
32 |   const successColor = getStatusColor(successRate, {
33 |     green: TOOL_SUCCESS_RATE_HIGH,
34 |     yellow: TOOL_SUCCESS_RATE_MEDIUM,
35 |   });
36 | 
37 |   return (
38 |     <Box>
39 |       <Box width={TOOL_NAME_COL_WIDTH}>
40 |         <Text color={theme.text.link}>{name}</Text>
41 |       </Box>
42 |       <Box width={CALLS_COL_WIDTH} justifyContent="flex-end">
43 |         <Text color={theme.text.primary}>{stats.count}</Text>
44 |       </Box>
45 |       <Box width={SUCCESS_RATE_COL_WIDTH} justifyContent="flex-end">
46 |         <Text color={successColor}>{successRate.toFixed(1)}%</Text>
47 |       </Box>
48 |       <Box width={AVG_DURATION_COL_WIDTH} justifyContent="flex-end">
49 |         <Text color={theme.text.primary}>{formatDuration(avgDuration)}</Text>
50 |       </Box>
51 |     </Box>
52 |   );
53 | };
54 | 
55 | export const ToolStatsDisplay: React.FC = () => {
56 |   const { stats } = useSessionStats();
57 |   const { tools } = stats.metrics;
58 |   const activeTools = Object.entries(tools.byName).filter(
59 |     ([, metrics]) => metrics.count > 0,
60 |   );
61 | 
62 |   if (activeTools.length === 0) {
63 |     return (
64 |       <Box
65 |         borderStyle="round"
66 |         borderColor={theme.border.default}
67 |         paddingY={1}
68 |         paddingX={2}
69 |       >
70 |         <Text color={theme.text.primary}>
71 |           No tool calls have been made in this session.
72 |         </Text>
73 |       </Box>
74 |     );
75 |   }
76 | 
77 |   const totalDecisions = Object.values(tools.byName).reduce(
78 |     (acc, tool) => {
79 |       acc.accept += tool.decisions.accept;
80 |       acc.reject += tool.decisions.reject;
81 |       acc.modify += tool.decisions.modify;
82 |       return acc;
83 |     },
84 |     { accept: 0, reject: 0, modify: 0 },
85 |   );
86 | 
87 |   const totalReviewed =
88 |     totalDecisions.accept + totalDecisions.reject + totalDecisions.modify;
89 |   const agreementRate =
90 |     totalReviewed > 0 ? (totalDecisions.accept / totalReviewed) * 100 : 0;
91 |   const agreementColor = getStatusColor(agreementRate, {
92 |     green: USER_AGREEMENT_RATE_HIGH,
93 |     yellow: USER_AGREEMENT_RATE_MEDIUM,
94 |   });
95 | 
96 |   return (
97 |     <Box
98 |       borderStyle="round"
99 |       borderColor={theme.border.default}
100 |       flexDirection="column"
101 |       paddingY={1}
102 |       paddingX={2}
103 |       width={70}
104 |     >
105 |       <Text bold color={theme.text.accent}>
106 |         Tool Stats For Nerds
107 |       </Text>
108 |       <Box height={1} />
109 | 
110 |       {/* Header */}
111 |       <Box>
112 |         <Box width={TOOL_NAME_COL_WIDTH}>
113 |           <Text bold color={theme.text.primary}>
114 |             Tool Name
115 |           </Text>
116 |         </Box>
117 |         <Box width={CALLS_COL_WIDTH} justifyContent="flex-end">
118 |           <Text bold color={theme.text.primary}>
119 |             Calls
120 |           </Text>
121 |         </Box>
122 |         <Box width={SUCCESS_RATE_COL_WIDTH} justifyContent="flex-end">
123 |           <Text bold color={theme.text.primary}>
124 |             Success Rate
125 |           </Text>
126 |         </Box>
127 |         <Box width={AVG_DURATION_COL_WIDTH} justifyContent="flex-end">
128 |           <Text bold color={theme.text.primary}>
129 |             Avg Duration
130 |           </Text>
131 |         </Box>
132 |       </Box>
133 | 
134 |       {/* Divider */}
135 |       <Box
136 |         borderStyle="single"
137 |         borderBottom={true}
138 |         borderTop={false}
139 |         borderLeft={false}
140 |         borderRight={false}
141 |         borderColor={theme.border.default}
142 |         width="100%"
143 |       />
144 | 
145 |       {/* Tool Rows */}
146 |       {activeTools.map(([name, stats]) => (
147 |         <StatRow key={name} name={name} stats={stats as ToolCallStats} />
148 |       ))}
149 | 
150 |       <Box height={1} />
151 | 
152 |       {/* User Decision Summary */}
153 |       <Text bold color={theme.text.primary}>
154 |         User Decision Summary
155 |       </Text>
156 |       <Box>
157 |         <Box
158 |           width={TOOL_NAME_COL_WIDTH + CALLS_COL_WIDTH + SUCCESS_RATE_COL_WIDTH}
159 |         >
160 |           <Text color={theme.text.link}>Total Reviewed Suggestions:</Text>
161 |         </Box>
162 |         <Box width={AVG_DURATION_COL_WIDTH} justifyContent="flex-end">
163 |           <Text color={theme.text.primary}>{totalReviewed}</Text>
164 |         </Box>
165 |       </Box>
166 |       <Box>
167 |         <Box
168 |           width={TOOL_NAME_COL_WIDTH + CALLS_COL_WIDTH + SUCCESS_RATE_COL_WIDTH}
169 |         >
170 |           <Text color={theme.text.primary}> » Accepted:</Text>
171 |         </Box>
172 |         <Box width={AVG_DURATION_COL_WIDTH} justifyContent="flex-end">
173 |           <Text color={theme.status.success}>{totalDecisions.accept}</Text>
174 |         </Box>
175 |       </Box>
176 |       <Box>
177 |         <Box
178 |           width={TOOL_NAME_COL_WIDTH + CALLS_COL_WIDTH + SUCCESS_RATE_COL_WIDTH}
179 |         >
180 |           <Text color={theme.text.primary}> » Rejected:</Text>
181 |         </Box>
182 |         <Box width={AVG_DURATION_COL_WIDTH} justifyContent="flex-end">
183 |           <Text color={theme.status.error}>{totalDecisions.reject}</Text>
184 |         </Box>
185 |       </Box>
186 |       <Box>
187 |         <Box
188 |           width={TOOL_NAME_COL_WIDTH + CALLS_COL_WIDTH + SUCCESS_RATE_COL_WIDTH}
189 |         >
190 |           <Text color={theme.text.primary}> » Modified:</Text>
191 |         </Box>
192 |         <Box width={AVG_DURATION_COL_WIDTH} justifyContent="flex-end">
193 |           <Text color={theme.status.warning}>{totalDecisions.modify}</Text>
194 |         </Box>
195 |       </Box>
196 | 
197 |       {/* Divider */}
198 |       <Box
199 |         borderStyle="single"
200 |         borderBottom={true}
201 |         borderTop={false}
202 |         borderLeft={false}
203 |         borderRight={false}
204 |         borderColor={theme.border.default}
205 |         width="100%"
206 |       />
207 | 
208 |       <Box>
209 |         <Box
210 |           width={TOOL_NAME_COL_WIDTH + CALLS_COL_WIDTH + SUCCESS_RATE_COL_WIDTH}
211 |         >
212 |           <Text color={theme.text.primary}> Overall Agreement Rate:</Text>
213 |         </Box>
214 |         <Box width={AVG_DURATION_COL_WIDTH} justifyContent="flex-end">
215 |           <Text bold color={totalReviewed > 0 ? agreementColor : undefined}>
216 |             {totalReviewed > 0 ? `${agreementRate.toFixed(1)}%` : '--'}
217 |           </Text>
218 |         </Box>
219 |       </Box>
220 |     </Box>
221 |   );
222 | };
```

src/ui/components/UpdateNotification.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { Box, Text } from 'ink';
8 | import { theme } from '../semantic-colors.js';
9 | 
10 | interface UpdateNotificationProps {
11 |   message: string;
12 | }
13 | 
14 | export const UpdateNotification = ({ message }: UpdateNotificationProps) => (
15 |   <Box
16 |     borderStyle="round"
17 |     borderColor={theme.status.warning}
18 |     paddingX={1}
19 |     marginY={1}
20 |   >
21 |     <Text color={theme.status.warning}>{message}</Text>
22 |   </Box>
23 | );
```

src/ui/components/WorkspaceMigrationDialog.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { Box, Text, useInput } from 'ink';
8 | import type { GeminiCLIExtension } from '@google/gemini-cli-core';
9 | import { performWorkspaceExtensionMigration } from '../../config/extension.js';
10 | import { RadioButtonSelect } from './shared/RadioButtonSelect.js';
11 | import { theme } from '../semantic-colors.js';
12 | import { useState } from 'react';
13 | 
14 | export function WorkspaceMigrationDialog(props: {
15 |   workspaceExtensions: GeminiCLIExtension[];
16 |   onOpen: () => void;
17 |   onClose: () => void;
18 | }) {
19 |   const { workspaceExtensions, onOpen, onClose } = props;
20 |   const [migrationComplete, setMigrationComplete] = useState(false);
21 |   const [failedExtensions, setFailedExtensions] = useState<string[]>([]);
22 |   onOpen();
23 |   const onMigrate = async () => {
24 |     const failed = await performWorkspaceExtensionMigration(
25 |       workspaceExtensions,
26 |       // We aren't updating extensions, just moving them around, don't need to ask for consent.
27 |       async (_) => true,
28 |     );
29 |     setFailedExtensions(failed);
30 |     setMigrationComplete(true);
31 |   };
32 | 
33 |   useInput((input) => {
34 |     if (migrationComplete && input === 'q') {
35 |       process.exit(0);
36 |     }
37 |   });
38 | 
39 |   if (migrationComplete) {
40 |     return (
41 |       <Box
42 |         flexDirection="column"
43 |         borderStyle="round"
44 |         borderColor={theme.border.default}
45 |         padding={1}
46 |       >
47 |         {failedExtensions.length > 0 ? (
48 |           <>
49 |             <Text color={theme.text.primary}>
50 |               The following extensions failed to migrate. Please try installing
51 |               them manually. To see other changes, Gemini CLI must be restarted.
52 |               Press &apos;q&apos; to quit.
53 |             </Text>
54 |             <Box flexDirection="column" marginTop={1} marginLeft={2}>
55 |               {failedExtensions.map((failed) => (
56 |                 <Text key={failed}>- {failed}</Text>
57 |               ))}
58 |             </Box>
59 |           </>
60 |         ) : (
61 |           <Text color={theme.text.primary}>
62 |             Migration complete. To see changes, Gemini CLI must be restarted.
63 |             Press &apos;q&apos; to quit.
64 |           </Text>
65 |         )}
66 |       </Box>
67 |     );
68 |   }
69 | 
70 |   return (
71 |     <Box
72 |       flexDirection="column"
73 |       borderStyle="round"
74 |       borderColor={theme.border.default}
75 |       padding={1}
76 |     >
77 |       <Text bold color={theme.text.primary}>
78 |         Workspace-level extensions are deprecated{'\n'}
79 |       </Text>
80 |       <Text color={theme.text.primary}>
81 |         Would you like to install them at the user level?
82 |       </Text>
83 |       <Text color={theme.text.primary}>
84 |         The extension definition will remain in your workspace directory.
85 |       </Text>
86 |       <Text color={theme.text.primary}>
87 |         If you opt to skip, you can install them manually using the extensions
88 |         install command.
89 |       </Text>
90 | 
91 |       <Box flexDirection="column" marginTop={1} marginLeft={2}>
92 |         {workspaceExtensions.map((extension) => (
93 |           <Text key={extension.name}>- {extension.name}</Text>
94 |         ))}
95 |       </Box>
96 |       <Box marginTop={1}>
97 |         <RadioButtonSelect
98 |           items={[
99 |             { label: 'Install all', value: 'migrate', key: 'migrate' },
100 |             { label: 'Skip', value: 'skip', key: 'skip' },
101 |           ]}
102 |           onSelect={(value: string) => {
103 |             if (value === 'migrate') {
104 |               onMigrate();
105 |             } else {
106 |               onClose();
107 |             }
108 |           }}
109 |         />
110 |       </Box>
111 |     </Box>
112 |   );
113 | }
```

src/ui/contexts/AppContext.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { createContext, useContext } from 'react';
8 | 
9 | export interface AppState {
10 |   version: string;
11 |   startupWarnings: string[];
12 | }
13 | 
14 | export const AppContext = createContext<AppState | null>(null);
15 | 
16 | export const useAppContext = () => {
17 |   const context = useContext(AppContext);
18 |   if (!context) {
19 |     throw new Error('useAppContext must be used within an AppProvider');
20 |   }
21 |   return context;
22 | };
```

src/ui/contexts/ConfigContext.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import React, { useContext } from 'react';
8 | import { type Config } from '@google/gemini-cli-core';
9 | 
10 | export const ConfigContext = React.createContext<Config | undefined>(undefined);
11 | 
12 | export const useConfig = () => {
13 |   const context = useContext(ConfigContext);
14 |   if (context === undefined) {
15 |     throw new Error('useConfig must be used within a ConfigProvider');
16 |   }
17 |   return context;
18 | };
```

src/ui/contexts/KeypressContext.test.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type React from 'react';
8 | import { renderHook, act, waitFor } from '@testing-library/react';
9 | import type { Mock } from 'vitest';
10 | import { vi } from 'vitest';
11 | import type { Key } from './KeypressContext.js';
12 | import {
13 |   KeypressProvider,
14 |   useKeypressContext,
15 |   DRAG_COMPLETION_TIMEOUT_MS,
16 |   // CSI_END_O,
17 |   // SS3_END,
18 |   SINGLE_QUOTE,
19 |   DOUBLE_QUOTE,
20 | } from './KeypressContext.js';
21 | import { useStdin } from 'ink';
22 | import { EventEmitter } from 'node:events';
23 | 
24 | // Mock the 'ink' module to control stdin
25 | vi.mock('ink', async (importOriginal) => {
26 |   const original = await importOriginal<typeof import('ink')>();
27 |   return {
28 |     ...original,
29 |     useStdin: vi.fn(),
30 |   };
31 | });
32 | 
33 | class MockStdin extends EventEmitter {
34 |   isTTY = true;
35 |   setRawMode = vi.fn();
36 |   override on = this.addListener;
37 |   override removeListener = super.removeListener;
38 |   write = vi.fn();
39 |   resume = vi.fn();
40 |   pause = vi.fn();
41 | 
42 |   // Helper to simulate a keypress event
43 |   pressKey(key: Partial<Key>) {
44 |     this.emit('keypress', null, key);
45 |   }
46 | 
47 |   // Helper to simulate a kitty protocol sequence
48 |   sendKittySequence(sequence: string) {
49 |     this.emit('data', Buffer.from(sequence));
50 |   }
51 | 
52 |   // Helper to simulate a paste event
53 |   sendPaste(text: string) {
54 |     const PASTE_MODE_PREFIX = `\x1b[200~`;
55 |     const PASTE_MODE_SUFFIX = `\x1b[201~`;
56 |     this.emit('data', Buffer.from(PASTE_MODE_PREFIX));
57 |     this.emit('data', Buffer.from(text));
58 |     this.emit('data', Buffer.from(PASTE_MODE_SUFFIX));
59 |   }
60 | }
61 | 
62 | describe('KeypressContext - Kitty Protocol', () => {
63 |   let stdin: MockStdin;
64 |   const mockSetRawMode = vi.fn();
65 | 
66 |   const wrapper = ({
67 |     children,
68 |     kittyProtocolEnabled = true,
69 |   }: {
70 |     children: React.ReactNode;
71 |     kittyProtocolEnabled?: boolean;
72 |   }) => (
73 |     <KeypressProvider kittyProtocolEnabled={kittyProtocolEnabled}>
74 |       {children}
75 |     </KeypressProvider>
76 |   );
77 | 
78 |   beforeEach(() => {
79 |     vi.clearAllMocks();
80 |     stdin = new MockStdin();
81 |     (useStdin as Mock).mockReturnValue({
82 |       stdin,
83 |       setRawMode: mockSetRawMode,
84 |     });
85 |   });
86 | 
87 |   describe('Enter key handling', () => {
88 |     it('should recognize regular enter key (keycode 13) in kitty protocol', async () => {
89 |       const keyHandler = vi.fn();
90 | 
91 |       const { result } = renderHook(() => useKeypressContext(), {
92 |         wrapper: ({ children }) =>
93 |           wrapper({ children, kittyProtocolEnabled: true }),
94 |       });
95 | 
96 |       act(() => {
97 |         result.current.subscribe(keyHandler);
98 |       });
99 | 
100 |       // Send kitty protocol sequence for regular enter: ESC[13u
101 |       act(() => {
102 |         stdin.sendKittySequence(`\x1b[13u`);
103 |       });
104 | 
105 |       expect(keyHandler).toHaveBeenCalledWith(
106 |         expect.objectContaining({
107 |           name: 'return',
108 |           kittyProtocol: true,
109 |           ctrl: false,
110 |           meta: false,
111 |           shift: false,
112 |         }),
113 |       );
114 |     });
115 | 
116 |     it('should recognize numpad enter key (keycode 57414) in kitty protocol', async () => {
117 |       const keyHandler = vi.fn();
118 | 
119 |       const { result } = renderHook(() => useKeypressContext(), {
120 |         wrapper: ({ children }) =>
121 |           wrapper({ children, kittyProtocolEnabled: true }),
122 |       });
123 | 
124 |       act(() => {
125 |         result.current.subscribe(keyHandler);
126 |       });
127 | 
128 |       // Send kitty protocol sequence for numpad enter: ESC[57414u
129 |       act(() => {
130 |         stdin.sendKittySequence(`\x1b[57414u`);
131 |       });
132 | 
133 |       expect(keyHandler).toHaveBeenCalledWith(
134 |         expect.objectContaining({
135 |           name: 'return',
136 |           kittyProtocol: true,
137 |           ctrl: false,
138 |           meta: false,
139 |           shift: false,
140 |         }),
141 |       );
142 |     });
143 | 
144 |     it('should handle numpad enter with modifiers', async () => {
145 |       const keyHandler = vi.fn();
146 | 
147 |       const { result } = renderHook(() => useKeypressContext(), {
148 |         wrapper: ({ children }) =>
149 |           wrapper({ children, kittyProtocolEnabled: true }),
150 |       });
151 | 
152 |       act(() => {
153 |         result.current.subscribe(keyHandler);
154 |       });
155 | 
156 |       // Send kitty protocol sequence for numpad enter with Shift (modifier 2): ESC[57414;2u
157 |       act(() => {
158 |         stdin.sendKittySequence(`\x1b[57414;2u`);
159 |       });
160 | 
161 |       expect(keyHandler).toHaveBeenCalledWith(
162 |         expect.objectContaining({
163 |           name: 'return',
164 |           kittyProtocol: true,
165 |           ctrl: false,
166 |           meta: false,
167 |           shift: true,
168 |         }),
169 |       );
170 |     });
171 | 
172 |     it('should handle numpad enter with Ctrl modifier', async () => {
173 |       const keyHandler = vi.fn();
174 | 
175 |       const { result } = renderHook(() => useKeypressContext(), {
176 |         wrapper: ({ children }) =>
177 |           wrapper({ children, kittyProtocolEnabled: true }),
178 |       });
179 | 
180 |       act(() => {
181 |         result.current.subscribe(keyHandler);
182 |       });
183 | 
184 |       // Send kitty protocol sequence for numpad enter with Ctrl (modifier 5): ESC[57414;5u
185 |       act(() => {
186 |         stdin.sendKittySequence(`\x1b[57414;5u`);
187 |       });
188 | 
189 |       expect(keyHandler).toHaveBeenCalledWith(
190 |         expect.objectContaining({
191 |           name: 'return',
192 |           kittyProtocol: true,
193 |           ctrl: true,
194 |           meta: false,
195 |           shift: false,
196 |         }),
197 |       );
198 |     });
199 | 
200 |     it('should handle numpad enter with Alt modifier', async () => {
201 |       const keyHandler = vi.fn();
202 | 
203 |       const { result } = renderHook(() => useKeypressContext(), {
204 |         wrapper: ({ children }) =>
205 |           wrapper({ children, kittyProtocolEnabled: true }),
206 |       });
207 | 
208 |       act(() => {
209 |         result.current.subscribe(keyHandler);
210 |       });
211 | 
212 |       // Send kitty protocol sequence for numpad enter with Alt (modifier 3): ESC[57414;3u
213 |       act(() => {
214 |         stdin.sendKittySequence(`\x1b[57414;3u`);
215 |       });
216 | 
217 |       expect(keyHandler).toHaveBeenCalledWith(
218 |         expect.objectContaining({
219 |           name: 'return',
220 |           kittyProtocol: true,
221 |           ctrl: false,
222 |           meta: true,
223 |           shift: false,
224 |         }),
225 |       );
226 |     });
227 | 
228 |     it('should not process kitty sequences when kitty protocol is disabled', async () => {
229 |       const keyHandler = vi.fn();
230 | 
231 |       const { result } = renderHook(() => useKeypressContext(), {
232 |         wrapper: ({ children }) =>
233 |           wrapper({ children, kittyProtocolEnabled: false }),
234 |       });
235 | 
236 |       act(() => {
237 |         result.current.subscribe(keyHandler);
238 |       });
239 | 
240 |       // Send kitty protocol sequence for numpad enter
241 |       act(() => {
242 |         stdin.sendKittySequence(`\x1b[57414u`);
243 |       });
244 | 
245 |       // When kitty protocol is disabled, the sequence should be passed through
246 |       // as individual keypresses, not recognized as a single enter key
247 |       expect(keyHandler).not.toHaveBeenCalledWith(
248 |         expect.objectContaining({
249 |           name: 'return',
250 |           kittyProtocol: true,
251 |         }),
252 |       );
253 |     });
254 |   });
255 | 
256 |   describe('Escape key handling', () => {
257 |     it('should recognize escape key (keycode 27) in kitty protocol', async () => {
258 |       const keyHandler = vi.fn();
259 | 
260 |       const { result } = renderHook(() => useKeypressContext(), {
261 |         wrapper: ({ children }) =>
262 |           wrapper({ children, kittyProtocolEnabled: true }),
263 |       });
264 | 
265 |       act(() => {
266 |         result.current.subscribe(keyHandler);
267 |       });
268 | 
269 |       // Send kitty protocol sequence for escape: ESC[27u
270 |       act(() => {
271 |         stdin.sendKittySequence('\x1b[27u');
272 |       });
273 | 
274 |       expect(keyHandler).toHaveBeenCalledWith(
275 |         expect.objectContaining({
276 |           name: 'escape',
277 |           kittyProtocol: true,
278 |         }),
279 |       );
280 |     });
281 |   });
282 | 
283 |   describe('Tab and Backspace handling', () => {
284 |     it('should recognize Tab key in kitty protocol', async () => {
285 |       const keyHandler = vi.fn();
286 |       const { result } = renderHook(() => useKeypressContext(), { wrapper });
287 |       act(() => result.current.subscribe(keyHandler));
288 | 
289 |       act(() => {
290 |         stdin.sendKittySequence(`\x1b[9u`);
291 |       });
292 | 
293 |       expect(keyHandler).toHaveBeenCalledWith(
294 |         expect.objectContaining({
295 |           name: 'tab',
296 |           kittyProtocol: true,
297 |           shift: false,
298 |         }),
299 |       );
300 |     });
301 | 
302 |     it('should recognize Shift+Tab in kitty protocol', async () => {
303 |       const keyHandler = vi.fn();
304 |       const { result } = renderHook(() => useKeypressContext(), { wrapper });
305 |       act(() => result.current.subscribe(keyHandler));
306 | 
307 |       // Modifier 2 is Shift
308 |       act(() => {
309 |         stdin.sendKittySequence(`\x1b[9;2u`);
310 |       });
311 | 
312 |       expect(keyHandler).toHaveBeenCalledWith(
313 |         expect.objectContaining({
314 |           name: 'tab',
315 |           kittyProtocol: true,
316 |           shift: true,
317 |         }),
318 |       );
319 |     });
320 | 
321 |     it('should recognize Backspace key in kitty protocol', async () => {
322 |       const keyHandler = vi.fn();
323 |       const { result } = renderHook(() => useKeypressContext(), { wrapper });
324 |       act(() => result.current.subscribe(keyHandler));
325 | 
326 |       act(() => {
327 |         stdin.sendKittySequence(`\x1b[127u`);
328 |       });
329 | 
330 |       expect(keyHandler).toHaveBeenCalledWith(
331 |         expect.objectContaining({
332 |           name: 'backspace',
333 |           kittyProtocol: true,
334 |           meta: false,
335 |         }),
336 |       );
337 |     });
338 | 
339 |     it('should recognize Option+Backspace in kitty protocol', async () => {
340 |       const keyHandler = vi.fn();
341 |       const { result } = renderHook(() => useKeypressContext(), { wrapper });
342 |       act(() => result.current.subscribe(keyHandler));
343 | 
344 |       // Modifier 3 is Alt/Option
345 |       act(() => {
346 |         stdin.sendKittySequence(`\x1b[127;3u`);
347 |       });
348 | 
349 |       expect(keyHandler).toHaveBeenCalledWith(
350 |         expect.objectContaining({
351 |           name: 'backspace',
352 |           kittyProtocol: true,
353 |           meta: true,
354 |         }),
355 |       );
356 |     });
357 | 
358 |     it('should recognize Ctrl+Backspace in kitty protocol', async () => {
359 |       const keyHandler = vi.fn();
360 |       const { result } = renderHook(() => useKeypressContext(), { wrapper });
361 |       act(() => result.current.subscribe(keyHandler));
362 | 
363 |       // Modifier 5 is Ctrl
364 |       act(() => {
365 |         stdin.sendKittySequence(`\x1b[127;5u`);
366 |       });
367 | 
368 |       expect(keyHandler).toHaveBeenCalledWith(
369 |         expect.objectContaining({
370 |           name: 'backspace',
371 |           kittyProtocol: true,
372 |           ctrl: true,
373 |         }),
374 |       );
375 |     });
376 |   });
377 | 
378 |   describe('paste mode', () => {
379 |     it('should handle multiline paste as a single event', async () => {
380 |       const keyHandler = vi.fn();
381 |       const pastedText = 'This \n is \n a \n multiline \n paste.';
382 | 
383 |       const { result } = renderHook(() => useKeypressContext(), {
384 |         wrapper,
385 |       });
386 | 
387 |       act(() => {
388 |         result.current.subscribe(keyHandler);
389 |       });
390 | 
391 |       // Simulate a bracketed paste event
392 |       act(() => {
393 |         stdin.sendPaste(pastedText);
394 |       });
395 | 
396 |       await waitFor(() => {
397 |         // Expect the handler to be called exactly once for the entire paste
398 |         expect(keyHandler).toHaveBeenCalledTimes(1);
399 |       });
400 | 
401 |       // Verify the single event contains the full pasted text
402 |       expect(keyHandler).toHaveBeenCalledWith(
403 |         expect.objectContaining({
404 |           paste: true,
405 |           sequence: pastedText,
406 |         }),
407 |       );
408 |     });
409 |   });
410 | 
[TRUNCATED]
```

src/ui/contexts/KeypressContext.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type { Config } from '@google/gemini-cli-core';
8 | import {
9 |   KittySequenceOverflowEvent,
10 |   logKittySequenceOverflow,
11 | } from '@google/gemini-cli-core';
12 | import { useStdin } from 'ink';
13 | import type React from 'react';
14 | import {
15 |   createContext,
16 |   useCallback,
17 |   useContext,
18 |   useEffect,
19 |   useRef,
20 | } from 'react';
21 | import readline from 'node:readline';
22 | import { PassThrough } from 'node:stream';
23 | import {
24 |   BACKSLASH_ENTER_DETECTION_WINDOW_MS,
25 |   CHAR_CODE_ESC,
26 |   KITTY_CTRL_C,
27 |   KITTY_KEYCODE_BACKSPACE,
28 |   KITTY_KEYCODE_ENTER,
29 |   KITTY_KEYCODE_NUMPAD_ENTER,
30 |   KITTY_KEYCODE_TAB,
31 |   MAX_KITTY_SEQUENCE_LENGTH,
32 |   KITTY_MODIFIER_BASE,
33 |   KITTY_MODIFIER_EVENT_TYPES_OFFSET,
34 |   MODIFIER_SHIFT_BIT,
35 |   MODIFIER_ALT_BIT,
36 |   MODIFIER_CTRL_BIT,
37 | } from '../utils/platformConstants.js';
38 | 
39 | import { FOCUS_IN, FOCUS_OUT } from '../hooks/useFocus.js';
40 | 
41 | const ESC = '\u001B';
42 | export const PASTE_MODE_PREFIX = `${ESC}[200~`;
43 | export const PASTE_MODE_SUFFIX = `${ESC}[201~`;
44 | export const DRAG_COMPLETION_TIMEOUT_MS = 100; // Broadcast full path after 100ms if no more input
45 | export const SINGLE_QUOTE = "'";
46 | export const DOUBLE_QUOTE = '"';
47 | 
48 | export interface Key {
49 |   name: string;
50 |   ctrl: boolean;
51 |   meta: boolean;
52 |   shift: boolean;
53 |   paste: boolean;
54 |   sequence: string;
55 |   kittyProtocol?: boolean;
56 | }
57 | 
58 | export type KeypressHandler = (key: Key) => void;
59 | 
60 | interface KeypressContextValue {
61 |   subscribe: (handler: KeypressHandler) => void;
62 |   unsubscribe: (handler: KeypressHandler) => void;
63 | }
64 | 
65 | const KeypressContext = createContext<KeypressContextValue | undefined>(
66 |   undefined,
67 | );
68 | 
69 | export function useKeypressContext() {
70 |   const context = useContext(KeypressContext);
71 |   if (!context) {
72 |     throw new Error(
73 |       'useKeypressContext must be used within a KeypressProvider',
74 |     );
75 |   }
76 |   return context;
77 | }
78 | 
79 | export function KeypressProvider({
80 |   children,
81 |   kittyProtocolEnabled,
82 |   config,
83 |   debugKeystrokeLogging,
84 | }: {
85 |   children: React.ReactNode;
86 |   kittyProtocolEnabled: boolean;
87 |   config?: Config;
88 |   debugKeystrokeLogging?: boolean;
89 | }) {
90 |   const { stdin, setRawMode } = useStdin();
91 |   const subscribers = useRef<Set<KeypressHandler>>(new Set()).current;
92 |   const isDraggingRef = useRef(false);
93 |   const dragBufferRef = useRef('');
94 |   const draggingTimerRef = useRef<NodeJS.Timeout | null>(null);
95 | 
96 |   const subscribe = useCallback(
97 |     (handler: KeypressHandler) => {
98 |       subscribers.add(handler);
99 |     },
100 |     [subscribers],
101 |   );
102 | 
103 |   const unsubscribe = useCallback(
104 |     (handler: KeypressHandler) => {
105 |       subscribers.delete(handler);
106 |     },
107 |     [subscribers],
108 |   );
109 | 
110 |   useEffect(() => {
111 |     const clearDraggingTimer = () => {
112 |       if (draggingTimerRef.current) {
113 |         clearTimeout(draggingTimerRef.current);
114 |         draggingTimerRef.current = null;
115 |       }
116 |     };
117 | 
118 |     const wasRaw = stdin.isRaw;
119 |     if (wasRaw === false) {
120 |       setRawMode(true);
121 |     }
122 | 
123 |     const keypressStream = new PassThrough();
124 |     let usePassthrough = false;
125 |     const nodeMajorVersion = parseInt(process.versions.node.split('.')[0], 10);
126 |     if (
127 |       nodeMajorVersion < 20 ||
128 |       process.env['PASTE_WORKAROUND'] === '1' ||
129 |       process.env['PASTE_WORKAROUND'] === 'true'
130 |     ) {
131 |       usePassthrough = true;
132 |     }
133 | 
134 |     let isPaste = false;
135 |     let pasteBuffer = Buffer.alloc(0);
136 |     let kittySequenceBuffer = '';
137 |     let backslashTimeout: NodeJS.Timeout | null = null;
138 |     let waitingForEnterAfterBackslash = false;
139 | 
140 |     // Parse a single complete kitty sequence from the start (prefix) of the
141 |     // buffer and return both the Key and the number of characters consumed.
142 |     // This lets us "peel off" one complete event when multiple sequences arrive
143 |     // in a single chunk, preventing buffer overflow and fragmentation.
144 |     // Parse a single complete kitty/parameterized/legacy sequence from the start
145 |     // of the buffer and return both the parsed Key and the number of characters
146 |     // consumed. This enables peel-and-continue parsing for batched input.
147 |     const parseKittyPrefix = (
148 |       buffer: string,
149 |     ): { key: Key; length: number } | null => {
150 |       // In older terminals ESC [ Z was used as Cursor Backward Tabulation (CBT)
151 |       // In newer terminals the same functionality of key combination for moving
152 |       // backward through focusable elements is Shift+Tab, hence we will
153 |       // map ESC [ Z to Shift+Tab
154 |       // 0) Reverse Tab (legacy): ESC [ Z
155 |       //    Treat as Shift+Tab for UI purposes.
156 |       //    Regex parts:
157 |       //    ^     - start of buffer
158 |       //    ESC [ - CSI introducer
159 |       //    Z     - legacy reverse tab
160 |       const revTabLegacy = new RegExp(`^${ESC}\\[Z`);
161 |       let m = buffer.match(revTabLegacy);
162 |       if (m) {
163 |         return {
164 |           key: {
165 |             name: 'tab',
166 |             ctrl: false,
167 |             meta: false,
168 |             shift: true,
169 |             paste: false,
170 |             sequence: buffer.slice(0, m[0].length),
171 |             kittyProtocol: true,
172 |           },
173 |           length: m[0].length,
174 |         };
175 |       }
176 | 
177 |       // 1) Reverse Tab (parameterized): ESC [ 1 ; <mods> Z
178 |       //    Parameterized reverse Tab: ESC [ 1 ; <mods> Z
179 |       const revTabParam = new RegExp(`^${ESC}\\[1;(\\d+)Z`);
180 |       m = buffer.match(revTabParam);
181 |       if (m) {
182 |         let mods = parseInt(m[1], 10);
183 |         if (mods >= KITTY_MODIFIER_EVENT_TYPES_OFFSET) {
184 |           mods -= KITTY_MODIFIER_EVENT_TYPES_OFFSET;
185 |         }
186 |         const bits = mods - KITTY_MODIFIER_BASE;
187 |         const alt = (bits & MODIFIER_ALT_BIT) === MODIFIER_ALT_BIT;
188 |         const ctrl = (bits & MODIFIER_CTRL_BIT) === MODIFIER_CTRL_BIT;
189 |         return {
190 |           key: {
191 |             name: 'tab',
192 |             ctrl,
193 |             meta: alt,
194 |             // Reverse tab implies Shift behavior; force shift regardless of mods
195 |             shift: true,
196 |             paste: false,
197 |             sequence: buffer.slice(0, m[0].length),
198 |             kittyProtocol: true,
199 |           },
200 |           length: m[0].length,
201 |         };
202 |       }
203 | 
204 |       // 2) Parameterized functional: ESC [ 1 ; <mods> (A|B|C|D|H|F|P|Q|R|S)
205 |       // 2) Parameterized functional: ESC [ 1 ; <mods> (A|B|C|D|H|F|P|Q|R|S)
206 |       //    Arrows, Home/End, F1–F4 with modifiers encoded in <mods>.
207 |       const arrowPrefix = new RegExp(`^${ESC}\\[1;(\\d+)([ABCDHFPQSR])`);
208 |       m = buffer.match(arrowPrefix);
209 |       if (m) {
210 |         let mods = parseInt(m[1], 10);
211 |         if (mods >= KITTY_MODIFIER_EVENT_TYPES_OFFSET) {
212 |           mods -= KITTY_MODIFIER_EVENT_TYPES_OFFSET;
213 |         }
214 |         const bits = mods - KITTY_MODIFIER_BASE;
215 |         const shift = (bits & MODIFIER_SHIFT_BIT) === MODIFIER_SHIFT_BIT;
216 |         const alt = (bits & MODIFIER_ALT_BIT) === MODIFIER_ALT_BIT;
217 |         const ctrl = (bits & MODIFIER_CTRL_BIT) === MODIFIER_CTRL_BIT;
218 |         const sym = m[2];
219 |         const symbolToName: { [k: string]: string } = {
220 |           A: 'up',
221 |           B: 'down',
222 |           C: 'right',
223 |           D: 'left',
224 |           H: 'home',
225 |           F: 'end',
226 |           P: 'f1',
227 |           Q: 'f2',
228 |           R: 'f3',
229 |           S: 'f4',
230 |         };
231 |         const name = symbolToName[sym] || '';
232 |         if (!name) return null;
233 |         return {
234 |           key: {
235 |             name,
236 |             ctrl,
237 |             meta: alt,
238 |             shift,
239 |             paste: false,
240 |             sequence: buffer.slice(0, m[0].length),
241 |             kittyProtocol: true,
242 |           },
243 |           length: m[0].length,
244 |         };
245 |       }
246 | 
247 |       // 3) CSI-u form: ESC [ <code> ; <mods> (u|~)
248 |       // 3) CSI-u and tilde-coded functional keys: ESC [ <code> ; <mods> (u|~)
249 |       //    'u' terminator: Kitty CSI-u; '~' terminator: tilde-coded function keys.
250 |       const csiUPrefix = new RegExp(`^${ESC}\\[(\\d+)(;(\\d+))?([u~])`);
251 |       m = buffer.match(csiUPrefix);
252 |       if (m) {
253 |         const keyCode = parseInt(m[1], 10);
254 |         let modifiers = m[3] ? parseInt(m[3], 10) : KITTY_MODIFIER_BASE;
255 |         if (modifiers >= KITTY_MODIFIER_EVENT_TYPES_OFFSET) {
256 |           modifiers -= KITTY_MODIFIER_EVENT_TYPES_OFFSET;
257 |         }
258 |         const modifierBits = modifiers - KITTY_MODIFIER_BASE;
259 |         const shift =
260 |           (modifierBits & MODIFIER_SHIFT_BIT) === MODIFIER_SHIFT_BIT;
261 |         const alt = (modifierBits & MODIFIER_ALT_BIT) === MODIFIER_ALT_BIT;
262 |         const ctrl = (modifierBits & MODIFIER_CTRL_BIT) === MODIFIER_CTRL_BIT;
263 |         const terminator = m[4];
264 | 
265 |         // Tilde-coded functional keys (Delete, Insert, PageUp/Down, Home/End)
266 |         if (terminator === '~') {
267 |           let name: string | null = null;
268 |           switch (keyCode) {
269 |             case 1:
270 |               name = 'home';
271 |               break;
272 |             case 2:
273 |               name = 'insert';
274 |               break;
275 |             case 3:
276 |               name = 'delete';
277 |               break;
278 |             case 4:
279 |               name = 'end';
280 |               break;
281 |             case 5:
282 |               name = 'pageup';
283 |               break;
284 |             case 6:
285 |               name = 'pagedown';
286 |               break;
287 |             default:
288 |               break;
289 |           }
290 |           if (name) {
291 |             return {
292 |               key: {
293 |                 name,
294 |                 ctrl,
295 |                 meta: alt,
296 |                 shift,
297 |                 paste: false,
298 |                 sequence: buffer.slice(0, m[0].length),
299 |                 kittyProtocol: true,
300 |               },
301 |               length: m[0].length,
302 |             };
303 |           }
304 |         }
305 | 
306 |         const kittyKeyCodeToName: { [key: number]: string } = {
307 |           [CHAR_CODE_ESC]: 'escape',
308 |           [KITTY_KEYCODE_TAB]: 'tab',
309 |           [KITTY_KEYCODE_BACKSPACE]: 'backspace',
310 |           [KITTY_KEYCODE_ENTER]: 'return',
311 |           [KITTY_KEYCODE_NUMPAD_ENTER]: 'return',
312 |         };
313 | 
314 |         const name = kittyKeyCodeToName[keyCode];
315 |         if (name) {
316 |           return {
317 |             key: {
318 |               name,
319 |               ctrl,
320 |               meta: alt,
321 |               shift,
322 |               paste: false,
323 |               sequence: buffer.slice(0, m[0].length),
324 |               kittyProtocol: true,
325 |             },
326 |             length: m[0].length,
327 |           };
328 |         }
329 | 
330 |         // Ctrl+letters
331 |         if (
332 |           ctrl &&
333 |           keyCode >= 'a'.charCodeAt(0) &&
334 |           keyCode <= 'z'.charCodeAt(0)
335 |         ) {
336 |           const letter = String.fromCharCode(keyCode);
337 |           return {
338 |             key: {
339 |               name: letter,
340 |               ctrl: true,
341 |               meta: alt,
342 |               shift,
343 |               paste: false,
344 |               sequence: buffer.slice(0, m[0].length),
345 |               kittyProtocol: true,
346 |             },
347 |             length: m[0].length,
348 |           };
349 |         }
350 |       }
351 | 
352 |       // 4) Legacy function keys (no parameters): ESC [ (A|B|C|D|H|F)
353 |       //    Arrows + Home/End without modifiers.
354 |       const legacyFuncKey = new RegExp(`^${ESC}\\[([ABCDHF])`);
355 |       m = buffer.match(legacyFuncKey);
[TRUNCATED]
```

src/ui/contexts/OverflowContext.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type React from 'react';
8 | import {
9 |   createContext,
10 |   useContext,
11 |   useState,
12 |   useCallback,
13 |   useMemo,
14 | } from 'react';
15 | 
16 | interface OverflowState {
17 |   overflowingIds: ReadonlySet<string>;
18 | }
19 | 
20 | interface OverflowActions {
21 |   addOverflowingId: (id: string) => void;
22 |   removeOverflowingId: (id: string) => void;
23 | }
24 | 
25 | const OverflowStateContext = createContext<OverflowState | undefined>(
26 |   undefined,
27 | );
28 | 
29 | const OverflowActionsContext = createContext<OverflowActions | undefined>(
30 |   undefined,
31 | );
32 | 
33 | export const useOverflowState = (): OverflowState | undefined =>
34 |   useContext(OverflowStateContext);
35 | 
36 | export const useOverflowActions = (): OverflowActions | undefined =>
37 |   useContext(OverflowActionsContext);
38 | 
39 | export const OverflowProvider: React.FC<{ children: React.ReactNode }> = ({
40 |   children,
41 | }) => {
42 |   const [overflowingIds, setOverflowingIds] = useState(new Set<string>());
43 | 
44 |   const addOverflowingId = useCallback((id: string) => {
45 |     setOverflowingIds((prevIds) => {
46 |       if (prevIds.has(id)) {
47 |         return prevIds;
48 |       }
49 |       const newIds = new Set(prevIds);
50 |       newIds.add(id);
51 |       return newIds;
52 |     });
53 |   }, []);
54 | 
55 |   const removeOverflowingId = useCallback((id: string) => {
56 |     setOverflowingIds((prevIds) => {
57 |       if (!prevIds.has(id)) {
58 |         return prevIds;
59 |       }
60 |       const newIds = new Set(prevIds);
61 |       newIds.delete(id);
62 |       return newIds;
63 |     });
64 |   }, []);
65 | 
66 |   const stateValue = useMemo(
67 |     () => ({
68 |       overflowingIds,
69 |     }),
70 |     [overflowingIds],
71 |   );
72 | 
73 |   const actionsValue = useMemo(
74 |     () => ({
75 |       addOverflowingId,
76 |       removeOverflowingId,
77 |     }),
78 |     [addOverflowingId, removeOverflowingId],
79 |   );
80 | 
81 |   return (
82 |     <OverflowStateContext.Provider value={stateValue}>
83 |       <OverflowActionsContext.Provider value={actionsValue}>
84 |         {children}
85 |       </OverflowActionsContext.Provider>
86 |     </OverflowStateContext.Provider>
87 |   );
88 | };
```

src/ui/contexts/SessionContext.test.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { type MutableRefObject } from 'react';
8 | import { render } from 'ink-testing-library';
9 | import { renderHook } from '@testing-library/react';
10 | import { act } from 'react-dom/test-utils';
11 | import type { SessionMetrics } from './SessionContext.js';
12 | import { SessionStatsProvider, useSessionStats } from './SessionContext.js';
13 | import { describe, it, expect, vi } from 'vitest';
14 | import { uiTelemetryService } from '@google/gemini-cli-core';
15 | 
16 | /**
17 |  * A test harness component that uses the hook and exposes the context value
18 |  * via a mutable ref. This allows us to interact with the context's functions
19 |  * and assert against its state directly in our tests.
20 |  */
21 | const TestHarness = ({
22 |   contextRef,
23 | }: {
24 |   contextRef: MutableRefObject<ReturnType<typeof useSessionStats> | undefined>;
25 | }) => {
26 |   contextRef.current = useSessionStats();
27 |   return null;
28 | };
29 | 
30 | describe('SessionStatsContext', () => {
31 |   it('should provide the correct initial state', () => {
32 |     const contextRef: MutableRefObject<
33 |       ReturnType<typeof useSessionStats> | undefined
34 |     > = { current: undefined };
35 | 
36 |     render(
37 |       <SessionStatsProvider>
38 |         <TestHarness contextRef={contextRef} />
39 |       </SessionStatsProvider>,
40 |     );
41 | 
42 |     const stats = contextRef.current?.stats;
43 | 
44 |     expect(stats?.sessionStartTime).toBeInstanceOf(Date);
45 |     expect(stats?.metrics).toBeDefined();
46 |     expect(stats?.metrics.models).toEqual({});
47 |   });
48 | 
49 |   it('should update metrics when the uiTelemetryService emits an update', () => {
50 |     const contextRef: MutableRefObject<
51 |       ReturnType<typeof useSessionStats> | undefined
52 |     > = { current: undefined };
53 | 
54 |     render(
55 |       <SessionStatsProvider>
56 |         <TestHarness contextRef={contextRef} />
57 |       </SessionStatsProvider>,
58 |     );
59 | 
60 |     const newMetrics: SessionMetrics = {
61 |       models: {
62 |         'gemini-pro': {
63 |           api: {
64 |             totalRequests: 1,
65 |             totalErrors: 0,
66 |             totalLatencyMs: 123,
67 |           },
68 |           tokens: {
69 |             prompt: 100,
70 |             candidates: 200,
71 |             total: 300,
72 |             cached: 50,
73 |             thoughts: 20,
74 |             tool: 10,
75 |           },
76 |         },
77 |       },
78 |       tools: {
79 |         totalCalls: 1,
80 |         totalSuccess: 1,
81 |         totalFail: 0,
82 |         totalDurationMs: 456,
83 |         totalDecisions: {
84 |           accept: 1,
85 |           reject: 0,
86 |           modify: 0,
87 |         },
88 |         byName: {
89 |           'test-tool': {
90 |             count: 1,
91 |             success: 1,
92 |             fail: 0,
93 |             durationMs: 456,
94 |             decisions: {
95 |               accept: 1,
96 |               reject: 0,
97 |               modify: 0,
98 |             },
99 |           },
100 |         },
101 |       },
102 |     };
103 | 
104 |     act(() => {
105 |       uiTelemetryService.emit('update', {
106 |         metrics: newMetrics,
107 |         lastPromptTokenCount: 100,
108 |       });
109 |     });
110 | 
111 |     const stats = contextRef.current?.stats;
112 |     expect(stats?.metrics).toEqual(newMetrics);
113 |     expect(stats?.lastPromptTokenCount).toBe(100);
114 |   });
115 | 
116 |   it('should not update metrics if the data is the same', () => {
117 |     const contextRef: MutableRefObject<
118 |       ReturnType<typeof useSessionStats> | undefined
119 |     > = { current: undefined };
120 | 
121 |     let renderCount = 0;
122 |     const CountingTestHarness = () => {
123 |       contextRef.current = useSessionStats();
124 |       renderCount++;
125 |       return null;
126 |     };
127 | 
128 |     render(
129 |       <SessionStatsProvider>
130 |         <CountingTestHarness />
131 |       </SessionStatsProvider>,
132 |     );
133 | 
134 |     expect(renderCount).toBe(1);
135 | 
136 |     const metrics: SessionMetrics = {
137 |       models: {
138 |         'gemini-pro': {
139 |           api: { totalRequests: 1, totalErrors: 0, totalLatencyMs: 100 },
140 |           tokens: {
141 |             prompt: 10,
142 |             candidates: 20,
143 |             total: 30,
144 |             cached: 0,
145 |             thoughts: 0,
146 |             tool: 0,
147 |           },
148 |         },
149 |       },
150 |       tools: {
151 |         totalCalls: 0,
152 |         totalSuccess: 0,
153 |         totalFail: 0,
154 |         totalDurationMs: 0,
155 |         totalDecisions: { accept: 0, reject: 0, modify: 0 },
156 |         byName: {},
157 |       },
158 |     };
159 | 
160 |     act(() => {
161 |       uiTelemetryService.emit('update', { metrics, lastPromptTokenCount: 10 });
162 |     });
163 | 
164 |     expect(renderCount).toBe(2);
165 | 
166 |     act(() => {
167 |       uiTelemetryService.emit('update', { metrics, lastPromptTokenCount: 10 });
168 |     });
169 | 
170 |     expect(renderCount).toBe(2);
171 | 
172 |     const newMetrics = {
173 |       ...metrics,
174 |       models: {
175 |         'gemini-pro': {
176 |           api: { totalRequests: 2, totalErrors: 0, totalLatencyMs: 200 },
177 |           tokens: {
178 |             prompt: 20,
179 |             candidates: 40,
180 |             total: 60,
181 |             cached: 0,
182 |             thoughts: 0,
183 |             tool: 0,
184 |           },
185 |         },
186 |       },
187 |     };
188 |     act(() => {
189 |       uiTelemetryService.emit('update', {
190 |         metrics: newMetrics,
191 |         lastPromptTokenCount: 20,
192 |       });
193 |     });
194 | 
195 |     expect(renderCount).toBe(3);
196 |   });
197 | 
198 |   it('should throw an error when useSessionStats is used outside of a provider', () => {
199 |     // Suppress console.error for this test since we expect an error
200 |     const consoleSpy = vi.spyOn(console, 'error').mockImplementation(() => {});
201 | 
202 |     try {
203 |       // Expect renderHook itself to throw when the hook is used outside a provider
204 |       expect(() => {
205 |         renderHook(() => useSessionStats());
206 |       }).toThrow('useSessionStats must be used within a SessionStatsProvider');
207 |     } finally {
208 |       consoleSpy.mockRestore();
209 |     }
210 |   });
211 | });
```

src/ui/contexts/SessionContext.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type React from 'react';
8 | import {
9 |   createContext,
10 |   useCallback,
11 |   useContext,
12 |   useState,
13 |   useMemo,
14 |   useEffect,
15 | } from 'react';
16 | 
17 | import type {
18 |   SessionMetrics,
19 |   ModelMetrics,
20 |   ToolCallStats,
21 | } from '@google/gemini-cli-core';
22 | import { uiTelemetryService, sessionId } from '@google/gemini-cli-core';
23 | 
24 | export enum ToolCallDecision {
25 |   ACCEPT = 'accept',
26 |   REJECT = 'reject',
27 |   MODIFY = 'modify',
28 |   AUTO_ACCEPT = 'auto_accept',
29 | }
30 | 
31 | function areModelMetricsEqual(a: ModelMetrics, b: ModelMetrics): boolean {
32 |   if (
33 |     a.api.totalRequests !== b.api.totalRequests ||
34 |     a.api.totalErrors !== b.api.totalErrors ||
35 |     a.api.totalLatencyMs !== b.api.totalLatencyMs
36 |   ) {
37 |     return false;
38 |   }
39 |   if (
40 |     a.tokens.prompt !== b.tokens.prompt ||
41 |     a.tokens.candidates !== b.tokens.candidates ||
42 |     a.tokens.total !== b.tokens.total ||
43 |     a.tokens.cached !== b.tokens.cached ||
44 |     a.tokens.thoughts !== b.tokens.thoughts ||
45 |     a.tokens.tool !== b.tokens.tool
46 |   ) {
47 |     return false;
48 |   }
49 |   return true;
50 | }
51 | 
52 | function areToolCallStatsEqual(a: ToolCallStats, b: ToolCallStats): boolean {
53 |   if (
54 |     a.count !== b.count ||
55 |     a.success !== b.success ||
56 |     a.fail !== b.fail ||
57 |     a.durationMs !== b.durationMs
58 |   ) {
59 |     return false;
60 |   }
61 |   if (
62 |     a.decisions[ToolCallDecision.ACCEPT] !==
63 |       b.decisions[ToolCallDecision.ACCEPT] ||
64 |     a.decisions[ToolCallDecision.REJECT] !==
65 |       b.decisions[ToolCallDecision.REJECT] ||
66 |     a.decisions[ToolCallDecision.MODIFY] !==
67 |       b.decisions[ToolCallDecision.MODIFY] ||
68 |     a.decisions[ToolCallDecision.AUTO_ACCEPT] !==
69 |       b.decisions[ToolCallDecision.AUTO_ACCEPT]
70 |   ) {
71 |     return false;
72 |   }
73 |   return true;
74 | }
75 | 
76 | function areMetricsEqual(a: SessionMetrics, b: SessionMetrics): boolean {
77 |   if (a === b) return true;
78 |   if (!a || !b) return false;
79 | 
80 |   // Compare files
81 |   if (
82 |     a.files.totalLinesAdded !== b.files.totalLinesAdded ||
83 |     a.files.totalLinesRemoved !== b.files.totalLinesRemoved
84 |   ) {
85 |     return false;
86 |   }
87 | 
88 |   // Compare tools
89 |   const toolsA = a.tools;
90 |   const toolsB = b.tools;
91 |   if (
92 |     toolsA.totalCalls !== toolsB.totalCalls ||
93 |     toolsA.totalSuccess !== toolsB.totalSuccess ||
94 |     toolsA.totalFail !== toolsB.totalFail ||
95 |     toolsA.totalDurationMs !== toolsB.totalDurationMs
96 |   ) {
97 |     return false;
98 |   }
99 | 
100 |   // Compare tool decisions
101 |   if (
102 |     toolsA.totalDecisions[ToolCallDecision.ACCEPT] !==
103 |       toolsB.totalDecisions[ToolCallDecision.ACCEPT] ||
104 |     toolsA.totalDecisions[ToolCallDecision.REJECT] !==
105 |       toolsB.totalDecisions[ToolCallDecision.REJECT] ||
106 |     toolsA.totalDecisions[ToolCallDecision.MODIFY] !==
107 |       toolsB.totalDecisions[ToolCallDecision.MODIFY] ||
108 |     toolsA.totalDecisions[ToolCallDecision.AUTO_ACCEPT] !==
109 |       toolsB.totalDecisions[ToolCallDecision.AUTO_ACCEPT]
110 |   ) {
111 |     return false;
112 |   }
113 | 
114 |   // Compare tools.byName
115 |   const toolsByNameAKeys = Object.keys(toolsA.byName);
116 |   const toolsByNameBKeys = Object.keys(toolsB.byName);
117 |   if (toolsByNameAKeys.length !== toolsByNameBKeys.length) return false;
118 | 
119 |   for (const key of toolsByNameAKeys) {
120 |     const toolA = toolsA.byName[key];
121 |     const toolB = toolsB.byName[key];
122 |     if (!toolB || !areToolCallStatsEqual(toolA, toolB)) {
123 |       return false;
124 |     }
125 |   }
126 | 
127 |   // Compare models
128 |   const modelsAKeys = Object.keys(a.models);
129 |   const modelsBKeys = Object.keys(b.models);
130 |   if (modelsAKeys.length !== modelsBKeys.length) return false;
131 | 
132 |   for (const key of modelsAKeys) {
133 |     if (!b.models[key] || !areModelMetricsEqual(a.models[key], b.models[key])) {
134 |       return false;
135 |     }
136 |   }
137 | 
138 |   return true;
139 | }
140 | 
141 | export type { SessionMetrics, ModelMetrics };
142 | 
143 | export interface SessionStatsState {
144 |   sessionId: string;
145 |   sessionStartTime: Date;
146 |   metrics: SessionMetrics;
147 |   lastPromptTokenCount: number;
148 |   promptCount: number;
149 | }
150 | 
151 | export interface ComputedSessionStats {
152 |   totalApiTime: number;
153 |   totalToolTime: number;
154 |   agentActiveTime: number;
155 |   apiTimePercent: number;
156 |   toolTimePercent: number;
157 |   cacheEfficiency: number;
158 |   totalDecisions: number;
159 |   successRate: number;
160 |   agreementRate: number;
161 |   totalCachedTokens: number;
162 |   totalPromptTokens: number;
163 |   totalLinesAdded: number;
164 |   totalLinesRemoved: number;
165 | }
166 | 
167 | // Defines the final "value" of our context, including the state
168 | // and the functions to update it.
169 | interface SessionStatsContextValue {
170 |   stats: SessionStatsState;
171 |   startNewPrompt: () => void;
172 |   getPromptCount: () => number;
173 | }
174 | 
175 | // --- Context Definition ---
176 | 
177 | const SessionStatsContext = createContext<SessionStatsContextValue | undefined>(
178 |   undefined,
179 | );
180 | 
181 | // --- Provider Component ---
182 | 
183 | export const SessionStatsProvider: React.FC<{ children: React.ReactNode }> = ({
184 |   children,
185 | }) => {
186 |   const [stats, setStats] = useState<SessionStatsState>({
187 |     sessionId,
188 |     sessionStartTime: new Date(),
189 |     metrics: uiTelemetryService.getMetrics(),
190 |     lastPromptTokenCount: 0,
191 |     promptCount: 0,
192 |   });
193 | 
194 |   useEffect(() => {
195 |     const handleUpdate = ({
196 |       metrics,
197 |       lastPromptTokenCount,
198 |     }: {
199 |       metrics: SessionMetrics;
200 |       lastPromptTokenCount: number;
201 |     }) => {
202 |       setStats((prevState) => {
203 |         if (
204 |           prevState.lastPromptTokenCount === lastPromptTokenCount &&
205 |           areMetricsEqual(prevState.metrics, metrics)
206 |         ) {
207 |           return prevState;
208 |         }
209 |         return {
210 |           ...prevState,
211 |           metrics,
212 |           lastPromptTokenCount,
213 |         };
214 |       });
215 |     };
216 | 
217 |     uiTelemetryService.on('update', handleUpdate);
218 |     // Set initial state
219 |     handleUpdate({
220 |       metrics: uiTelemetryService.getMetrics(),
221 |       lastPromptTokenCount: uiTelemetryService.getLastPromptTokenCount(),
222 |     });
223 | 
224 |     return () => {
225 |       uiTelemetryService.off('update', handleUpdate);
226 |     };
227 |   }, []);
228 | 
229 |   const startNewPrompt = useCallback(() => {
230 |     setStats((prevState) => ({
231 |       ...prevState,
232 |       promptCount: prevState.promptCount + 1,
233 |     }));
234 |   }, []);
235 | 
236 |   const getPromptCount = useCallback(
237 |     () => stats.promptCount,
238 |     [stats.promptCount],
239 |   );
240 | 
241 |   const value = useMemo(
242 |     () => ({
243 |       stats,
244 |       startNewPrompt,
245 |       getPromptCount,
246 |     }),
247 |     [stats, startNewPrompt, getPromptCount],
248 |   );
249 | 
250 |   return (
251 |     <SessionStatsContext.Provider value={value}>
252 |       {children}
253 |     </SessionStatsContext.Provider>
254 |   );
255 | };
256 | 
257 | // --- Consumer Hook ---
258 | 
259 | export const useSessionStats = () => {
260 |   const context = useContext(SessionStatsContext);
261 |   if (context === undefined) {
262 |     throw new Error(
263 |       'useSessionStats must be used within a SessionStatsProvider',
264 |     );
265 |   }
266 |   return context;
267 | };
```

src/ui/contexts/SettingsContext.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import React, { useContext } from 'react';
8 | import type { LoadedSettings } from '../../config/settings.js';
9 | 
10 | export const SettingsContext = React.createContext<LoadedSettings | undefined>(
11 |   undefined,
12 | );
13 | 
14 | export const useSettings = () => {
15 |   const context = useContext(SettingsContext);
16 |   if (context === undefined) {
17 |     throw new Error('useSettings must be used within a SettingsProvider');
18 |   }
19 |   return context;
20 | };
```

src/ui/contexts/ShellFocusContext.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { createContext, useContext } from 'react';
8 | 
9 | export const ShellFocusContext = createContext<boolean>(true);
10 | 
11 | export const useShellFocusState = () => useContext(ShellFocusContext);
```

src/ui/contexts/StreamingContext.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import React, { createContext } from 'react';
8 | import type { StreamingState } from '../types.js';
9 | 
10 | export const StreamingContext = createContext<StreamingState | undefined>(
11 |   undefined,
12 | );
13 | 
14 | export const useStreamingContext = (): StreamingState => {
15 |   const context = React.useContext(StreamingContext);
16 |   if (context === undefined) {
17 |     throw new Error(
18 |       'useStreamingContext must be used within a StreamingContextProvider',
19 |     );
20 |   }
21 |   return context;
22 | };
```

src/ui/contexts/UIActionsContext.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { createContext, useContext } from 'react';
8 | import { type Key } from '../hooks/useKeypress.js';
9 | import { type IdeIntegrationNudgeResult } from '../IdeIntegrationNudge.js';
10 | import { type FolderTrustChoice } from '../components/FolderTrustDialog.js';
11 | import { type AuthType, type EditorType } from '@google/gemini-cli-core';
12 | import { type SettingScope } from '../../config/settings.js';
13 | import type { AuthState } from '../types.js';
14 | 
15 | export interface UIActions {
16 |   handleThemeSelect: (
17 |     themeName: string | undefined,
18 |     scope: SettingScope,
19 |   ) => void;
20 |   handleThemeHighlight: (themeName: string | undefined) => void;
21 |   handleAuthSelect: (
22 |     authType: AuthType | undefined,
23 |     scope: SettingScope,
24 |   ) => void;
25 |   setAuthState: (state: AuthState) => void;
26 |   onAuthError: (error: string) => void;
27 |   handleEditorSelect: (
28 |     editorType: EditorType | undefined,
29 |     scope: SettingScope,
30 |   ) => void;
31 |   exitEditorDialog: () => void;
32 |   exitPrivacyNotice: () => void;
33 |   closeSettingsDialog: () => void;
34 |   closeModelDialog: () => void;
35 |   closePermissionsDialog: () => void;
36 |   setShellModeActive: (value: boolean) => void;
37 |   vimHandleInput: (key: Key) => boolean;
38 |   handleIdePromptComplete: (result: IdeIntegrationNudgeResult) => void;
39 |   handleFolderTrustSelect: (choice: FolderTrustChoice) => void;
40 |   setConstrainHeight: (value: boolean) => void;
41 |   onEscapePromptChange: (show: boolean) => void;
42 |   refreshStatic: () => void;
43 |   handleFinalSubmit: (value: string) => void;
44 |   handleClearScreen: () => void;
45 |   onWorkspaceMigrationDialogOpen: () => void;
46 |   onWorkspaceMigrationDialogClose: () => void;
47 |   handleProQuotaChoice: (choice: 'auth' | 'continue') => void;
48 | }
49 | 
50 | export const UIActionsContext = createContext<UIActions | null>(null);
51 | 
52 | export const useUIActions = () => {
53 |   const context = useContext(UIActionsContext);
54 |   if (!context) {
55 |     throw new Error('useUIActions must be used within a UIActionsProvider');
56 |   }
57 |   return context;
58 | };
```

src/ui/contexts/UIStateContext.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { createContext, useContext } from 'react';
8 | import type {
9 |   HistoryItem,
10 |   ThoughtSummary,
11 |   ConsoleMessageItem,
12 |   ShellConfirmationRequest,
13 |   ConfirmationRequest,
14 |   LoopDetectionConfirmationRequest,
15 |   HistoryItemWithoutId,
16 |   StreamingState,
17 | } from '../types.js';
18 | import type { CommandContext, SlashCommand } from '../commands/types.js';
19 | import type { TextBuffer } from '../components/shared/text-buffer.js';
20 | import type {
21 |   IdeContext,
22 |   ApprovalMode,
23 |   UserTierId,
24 |   IdeInfo,
25 |   FallbackIntent,
26 | } from '@google/gemini-cli-core';
27 | import type { DOMElement } from 'ink';
28 | import type { SessionStatsState } from '../contexts/SessionContext.js';
29 | import type { ExtensionUpdateState } from '../state/extensions.js';
30 | import type { UpdateObject } from '../utils/updateCheck.js';
31 | 
32 | export interface ProQuotaDialogRequest {
33 |   failedModel: string;
34 |   fallbackModel: string;
35 |   resolve: (intent: FallbackIntent) => void;
36 | }
37 | 
38 | import { type UseHistoryManagerReturn } from '../hooks/useHistoryManager.js';
39 | import { type RestartReason } from '../hooks/useIdeTrustListener.js';
40 | 
41 | export interface UIState {
42 |   history: HistoryItem[];
43 |   historyManager: UseHistoryManagerReturn;
44 |   isThemeDialogOpen: boolean;
45 |   themeError: string | null;
46 |   isAuthenticating: boolean;
47 |   isConfigInitialized: boolean;
48 |   authError: string | null;
49 |   isAuthDialogOpen: boolean;
50 |   editorError: string | null;
51 |   isEditorDialogOpen: boolean;
52 |   showPrivacyNotice: boolean;
53 |   corgiMode: boolean;
54 |   debugMessage: string;
55 |   quittingMessages: HistoryItem[] | null;
56 |   isSettingsDialogOpen: boolean;
57 |   isModelDialogOpen: boolean;
58 |   isPermissionsDialogOpen: boolean;
59 |   slashCommands: readonly SlashCommand[];
60 |   pendingSlashCommandHistoryItems: HistoryItemWithoutId[];
61 |   commandContext: CommandContext;
62 |   shellConfirmationRequest: ShellConfirmationRequest | null;
63 |   confirmationRequest: ConfirmationRequest | null;
64 |   confirmUpdateExtensionRequests: ConfirmationRequest[];
65 |   loopDetectionConfirmationRequest: LoopDetectionConfirmationRequest | null;
66 |   geminiMdFileCount: number;
67 |   streamingState: StreamingState;
68 |   initError: string | null;
69 |   pendingGeminiHistoryItems: HistoryItemWithoutId[];
70 |   thought: ThoughtSummary | null;
71 |   shellModeActive: boolean;
72 |   userMessages: string[];
73 |   buffer: TextBuffer;
74 |   inputWidth: number;
75 |   suggestionsWidth: number;
76 |   isInputActive: boolean;
77 |   shouldShowIdePrompt: boolean;
78 |   isFolderTrustDialogOpen: boolean;
79 |   isTrustedFolder: boolean | undefined;
80 |   constrainHeight: boolean;
81 |   showErrorDetails: boolean;
82 |   filteredConsoleMessages: ConsoleMessageItem[];
83 |   ideContextState: IdeContext | undefined;
84 |   showToolDescriptions: boolean;
85 |   ctrlCPressedOnce: boolean;
86 |   ctrlDPressedOnce: boolean;
87 |   showEscapePrompt: boolean;
88 |   elapsedTime: number;
89 |   currentLoadingPhrase: string;
90 |   historyRemountKey: number;
91 |   messageQueue: string[];
92 |   showAutoAcceptIndicator: ApprovalMode;
93 |   showWorkspaceMigrationDialog: boolean;
94 |   // eslint-disable-next-line @typescript-eslint/no-explicit-any
95 |   workspaceExtensions: any[]; // Extension[]
96 |   // Quota-related state
97 |   userTier: UserTierId | undefined;
98 |   proQuotaRequest: ProQuotaDialogRequest | null;
99 |   currentModel: string;
100 |   contextFileNames: string[];
101 |   errorCount: number;
102 |   availableTerminalHeight: number | undefined;
103 |   mainAreaWidth: number;
104 |   staticAreaMaxItemHeight: number;
105 |   staticExtraHeight: number;
106 |   dialogsVisible: boolean;
107 |   pendingHistoryItems: HistoryItemWithoutId[];
108 |   nightly: boolean;
109 |   branchName: string | undefined;
110 |   sessionStats: SessionStatsState;
111 |   terminalWidth: number;
112 |   terminalHeight: number;
113 |   mainControlsRef: React.MutableRefObject<DOMElement | null>;
114 |   // NOTE: This is for performance profiling only.
115 |   rootUiRef: React.MutableRefObject<DOMElement | null>;
116 |   currentIDE: IdeInfo | null;
117 |   updateInfo: UpdateObject | null;
118 |   showIdeRestartPrompt: boolean;
119 |   ideTrustRestartReason: RestartReason;
120 |   isRestarting: boolean;
121 |   extensionsUpdateState: Map<string, ExtensionUpdateState>;
122 |   activePtyId: number | undefined;
123 |   embeddedShellFocused: boolean;
124 |   showDebugProfiler: boolean;
125 | }
126 | 
127 | export const UIStateContext = createContext<UIState | null>(null);
128 | 
129 | export const useUIState = () => {
130 |   const context = useContext(UIStateContext);
131 |   if (!context) {
132 |     throw new Error('useUIState must be used within a UIStateProvider');
133 |   }
134 |   return context;
135 | };
```

src/ui/contexts/VimModeContext.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import {
8 |   createContext,
9 |   useCallback,
10 |   useContext,
11 |   useEffect,
12 |   useState,
13 | } from 'react';
14 | import type { LoadedSettings } from '../../config/settings.js';
15 | import { SettingScope } from '../../config/settings.js';
16 | 
17 | export type VimMode = 'NORMAL' | 'INSERT';
18 | 
19 | interface VimModeContextType {
20 |   vimEnabled: boolean;
21 |   vimMode: VimMode;
22 |   toggleVimEnabled: () => Promise<boolean>;
23 |   setVimMode: (mode: VimMode) => void;
24 | }
25 | 
26 | const VimModeContext = createContext<VimModeContextType | undefined>(undefined);
27 | 
28 | export const VimModeProvider = ({
29 |   children,
30 |   settings,
31 | }: {
32 |   children: React.ReactNode;
33 |   settings: LoadedSettings;
34 | }) => {
35 |   const initialVimEnabled = settings.merged.general?.vimMode ?? false;
36 |   const [vimEnabled, setVimEnabled] = useState(initialVimEnabled);
37 |   const [vimMode, setVimMode] = useState<VimMode>(
38 |     initialVimEnabled ? 'NORMAL' : 'INSERT',
39 |   );
40 | 
41 |   useEffect(() => {
42 |     // Initialize vimEnabled from settings on mount
43 |     const enabled = settings.merged.general?.vimMode ?? false;
44 |     setVimEnabled(enabled);
45 |     // When vim mode is enabled, always start in NORMAL mode
46 |     if (enabled) {
47 |       setVimMode('NORMAL');
48 |     }
49 |   }, [settings.merged.general?.vimMode]);
50 | 
51 |   const toggleVimEnabled = useCallback(async () => {
52 |     const newValue = !vimEnabled;
53 |     setVimEnabled(newValue);
54 |     // When enabling vim mode, start in NORMAL mode
55 |     if (newValue) {
56 |       setVimMode('NORMAL');
57 |     }
58 |     await settings.setValue(SettingScope.User, 'general.vimMode', newValue);
59 |     return newValue;
60 |   }, [vimEnabled, settings]);
61 | 
62 |   const value = {
63 |     vimEnabled,
64 |     vimMode,
65 |     toggleVimEnabled,
66 |     setVimMode,
67 |   };
68 | 
69 |   return (
70 |     <VimModeContext.Provider value={value}>{children}</VimModeContext.Provider>
71 |   );
72 | };
73 | 
74 | export const useVimMode = () => {
75 |   const context = useContext(VimModeContext);
76 |   if (context === undefined) {
77 |     throw new Error('useVimMode must be used within a VimModeProvider');
78 |   }
79 |   return context;
80 | };
```

src/ui/editors/editorSettingsManager.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import {
8 |   allowEditorTypeInSandbox,
9 |   checkHasEditorType,
10 |   type EditorType,
11 | } from '@google/gemini-cli-core';
12 | 
13 | export interface EditorDisplay {
14 |   name: string;
15 |   type: EditorType | 'not_set';
16 |   disabled: boolean;
17 | }
18 | 
19 | export const EDITOR_DISPLAY_NAMES: Record<EditorType, string> = {
20 |   cursor: 'Cursor',
21 |   emacs: 'Emacs',
22 |   neovim: 'Neovim',
23 |   vim: 'Vim',
24 |   vscode: 'VS Code',
25 |   vscodium: 'VSCodium',
26 |   windsurf: 'Windsurf',
27 |   zed: 'Zed',
28 | };
29 | 
30 | class EditorSettingsManager {
31 |   private readonly availableEditors: EditorDisplay[];
32 | 
33 |   constructor() {
34 |     const editorTypes = Object.keys(
35 |       EDITOR_DISPLAY_NAMES,
36 |     ).sort() as EditorType[];
37 |     this.availableEditors = [
38 |       {
39 |         name: 'None',
40 |         type: 'not_set',
41 |         disabled: false,
42 |       },
43 |       ...editorTypes.map((type) => {
44 |         const hasEditor = checkHasEditorType(type);
45 |         const isAllowedInSandbox = allowEditorTypeInSandbox(type);
46 | 
47 |         let labelSuffix = !isAllowedInSandbox
48 |           ? ' (Not available in sandbox)'
49 |           : '';
50 |         labelSuffix = !hasEditor ? ' (Not installed)' : labelSuffix;
51 | 
52 |         return {
53 |           name: EDITOR_DISPLAY_NAMES[type] + labelSuffix,
54 |           type,
55 |           disabled: !hasEditor || !isAllowedInSandbox,
56 |         };
57 |       }),
58 |     ];
59 |   }
60 | 
61 |   getAvailableEditorDisplays(): EditorDisplay[] {
62 |     return this.availableEditors;
63 |   }
64 | }
65 | 
66 | export const editorSettingsManager = new EditorSettingsManager();
```

src/ui/layouts/DefaultAppLayout.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type React from 'react';
8 | import { Box } from 'ink';
9 | import { Notifications } from '../components/Notifications.js';
10 | import { MainContent } from '../components/MainContent.js';
11 | import { DialogManager } from '../components/DialogManager.js';
12 | import { Composer } from '../components/Composer.js';
13 | import { ExitWarning } from '../components/ExitWarning.js';
14 | import { useUIState } from '../contexts/UIStateContext.js';
15 | import { useFlickerDetector } from '../hooks/useFlickerDetector.js';
16 | 
17 | export const DefaultAppLayout: React.FC = () => {
18 |   const uiState = useUIState();
19 |   const { rootUiRef, terminalHeight } = uiState;
20 |   useFlickerDetector(rootUiRef, terminalHeight);
21 | 
22 |   return (
23 |     <Box
24 |       flexDirection="column"
25 |       width={uiState.mainAreaWidth}
26 |       ref={uiState.rootUiRef}
27 |     >
28 |       <MainContent />
29 | 
30 |       <Box flexDirection="column" ref={uiState.mainControlsRef}>
31 |         <Notifications />
32 | 
33 |         {uiState.dialogsVisible ? (
34 |           <DialogManager
35 |             terminalWidth={uiState.mainAreaWidth}
36 |             addItem={uiState.historyManager.addItem}
37 |           />
38 |         ) : (
39 |           <Composer />
40 |         )}
41 | 
42 |         <ExitWarning />
43 |       </Box>
44 |     </Box>
45 |   );
46 | };
```

src/ui/layouts/ScreenReaderAppLayout.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type React from 'react';
8 | import { Box } from 'ink';
9 | import { Notifications } from '../components/Notifications.js';
10 | import { MainContent } from '../components/MainContent.js';
11 | import { DialogManager } from '../components/DialogManager.js';
12 | import { Composer } from '../components/Composer.js';
13 | import { Footer } from '../components/Footer.js';
14 | import { ExitWarning } from '../components/ExitWarning.js';
15 | import { useUIState } from '../contexts/UIStateContext.js';
16 | import { useFlickerDetector } from '../hooks/useFlickerDetector.js';
17 | 
18 | export const ScreenReaderAppLayout: React.FC = () => {
19 |   const uiState = useUIState();
20 |   const { rootUiRef, terminalHeight } = uiState;
21 |   useFlickerDetector(rootUiRef, terminalHeight);
22 | 
23 |   return (
24 |     <Box
25 |       flexDirection="column"
26 |       width="90%"
27 |       height="100%"
28 |       ref={uiState.rootUiRef}
29 |     >
30 |       <Notifications />
31 |       <Footer />
32 |       <Box flexGrow={1} overflow="hidden">
33 |         <MainContent />
34 |       </Box>
35 |       {uiState.dialogsVisible ? (
36 |         <DialogManager
37 |           terminalWidth={uiState.terminalWidth}
38 |           addItem={uiState.historyManager.addItem}
39 |         />
40 |       ) : (
41 |         <Composer />
42 |       )}
43 | 
44 |       <ExitWarning />
45 |     </Box>
46 |   );
47 | };
```

src/ui/hooks/atCommandProcessor.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type { Mock } from 'vitest';
8 | import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
9 | import { handleAtCommand } from './atCommandProcessor.js';
10 | import type { Config } from '@google/gemini-cli-core';
11 | import {
12 |   FileDiscoveryService,
13 |   GlobTool,
14 |   ReadManyFilesTool,
15 |   StandardFileSystemService,
16 |   ToolRegistry,
17 |   COMMON_IGNORE_PATTERNS,
18 |   // DEFAULT_FILE_EXCLUDES,
19 | } from '@google/gemini-cli-core';
20 | import * as os from 'node:os';
21 | import { ToolCallStatus } from '../types.js';
22 | import type { UseHistoryManagerReturn } from './useHistoryManager.js';
23 | import * as fsPromises from 'node:fs/promises';
24 | import * as path from 'node:path';
25 | 
26 | describe('handleAtCommand', () => {
27 |   let testRootDir: string;
28 |   let mockConfig: Config;
29 | 
30 |   const mockAddItem: Mock<UseHistoryManagerReturn['addItem']> = vi.fn();
31 |   const mockOnDebugMessage: Mock<(message: string) => void> = vi.fn();
32 | 
33 |   let abortController: AbortController;
34 | 
35 |   async function createTestFile(fullPath: string, fileContents: string) {
36 |     await fsPromises.mkdir(path.dirname(fullPath), { recursive: true });
37 |     await fsPromises.writeFile(fullPath, fileContents);
38 |     return path.resolve(testRootDir, fullPath);
39 |   }
40 | 
41 |   beforeEach(async () => {
42 |     vi.resetAllMocks();
43 | 
44 |     testRootDir = await fsPromises.mkdtemp(
45 |       path.join(os.tmpdir(), 'folder-structure-test-'),
46 |     );
47 | 
48 |     abortController = new AbortController();
49 | 
50 |     const getToolRegistry = vi.fn();
51 | 
52 |     mockConfig = {
53 |       getToolRegistry,
54 |       getTargetDir: () => testRootDir,
55 |       isSandboxed: () => false,
56 |       getFileService: () => new FileDiscoveryService(testRootDir),
57 |       getFileFilteringRespectGitIgnore: () => true,
58 |       getFileFilteringRespectGeminiIgnore: () => true,
59 |       getFileFilteringOptions: () => ({
60 |         respectGitIgnore: true,
61 |         respectGeminiIgnore: true,
62 |       }),
63 |       getFileSystemService: () => new StandardFileSystemService(),
64 |       getEnableRecursiveFileSearch: vi.fn(() => true),
65 |       getWorkspaceContext: () => ({
66 |         isPathWithinWorkspace: () => true,
67 |         getDirectories: () => [testRootDir],
68 |       }),
69 |       getMcpServers: () => ({}),
70 |       getMcpServerCommand: () => undefined,
71 |       getPromptRegistry: () => ({
72 |         getPromptsByServer: () => [],
73 |       }),
74 |       getDebugMode: () => false,
75 |       getFileExclusions: () => ({
76 |         getCoreIgnorePatterns: () => COMMON_IGNORE_PATTERNS,
77 |         getDefaultExcludePatterns: () => [],
78 |         getGlobExcludes: () => [],
79 |         buildExcludePatterns: () => [],
80 |         getReadManyFilesExcludes: () => [],
81 |       }),
82 |       getUsageStatisticsEnabled: () => false,
83 |     } as unknown as Config;
84 | 
85 |     const registry = new ToolRegistry(mockConfig);
86 |     registry.registerTool(new ReadManyFilesTool(mockConfig));
87 |     registry.registerTool(new GlobTool(mockConfig));
88 |     getToolRegistry.mockReturnValue(registry);
89 |   });
90 | 
91 |   afterEach(async () => {
92 |     abortController.abort();
93 |     await fsPromises.rm(testRootDir, { recursive: true, force: true });
94 |   });
95 | 
96 |   it('should pass through query if no @ command is present', async () => {
97 |     const query = 'regular user query';
98 | 
99 |     const result = await handleAtCommand({
100 |       query,
101 |       config: mockConfig,
102 |       addItem: mockAddItem,
103 |       onDebugMessage: mockOnDebugMessage,
104 |       messageId: 123,
105 |       signal: abortController.signal,
106 |     });
107 | 
108 |     expect(result).toEqual({
109 |       processedQuery: [{ text: query }],
110 |       shouldProceed: true,
111 |     });
112 |   });
113 | 
114 |   it('should pass through original query if only a lone @ symbol is present', async () => {
115 |     const queryWithSpaces = '  @  ';
116 | 
117 |     const result = await handleAtCommand({
118 |       query: queryWithSpaces,
119 |       config: mockConfig,
120 |       addItem: mockAddItem,
121 |       onDebugMessage: mockOnDebugMessage,
122 |       messageId: 124,
123 |       signal: abortController.signal,
124 |     });
125 | 
126 |     expect(result).toEqual({
127 |       processedQuery: [{ text: queryWithSpaces }],
128 |       shouldProceed: true,
129 |     });
130 |     expect(mockOnDebugMessage).toHaveBeenCalledWith(
131 |       'Lone @ detected, will be treated as text in the modified query.',
132 |     );
133 |   });
134 | 
135 |   it('should process a valid text file path', async () => {
136 |     const fileContent = 'This is the file content.';
137 |     const filePath = await createTestFile(
138 |       path.join(testRootDir, 'path', 'to', 'file.txt'),
139 |       fileContent,
140 |     );
141 |     const query = `@${filePath}`;
142 | 
143 |     const result = await handleAtCommand({
144 |       query,
145 |       config: mockConfig,
146 |       addItem: mockAddItem,
147 |       onDebugMessage: mockOnDebugMessage,
148 |       messageId: 125,
149 |       signal: abortController.signal,
150 |     });
151 | 
152 |     expect(result).toEqual({
153 |       processedQuery: [
154 |         { text: `@${filePath}` },
155 |         { text: '\n--- Content from referenced files ---' },
156 |         { text: `\nContent from @${filePath}:\n` },
157 |         { text: fileContent },
158 |         { text: '\n--- End of content ---' },
159 |       ],
160 |       shouldProceed: true,
161 |     });
162 |     expect(mockAddItem).toHaveBeenCalledWith(
163 |       expect.objectContaining({
164 |         type: 'tool_group',
165 |         tools: [expect.objectContaining({ status: ToolCallStatus.Success })],
166 |       }),
167 |       125,
168 |     );
169 |   });
170 | 
171 |   it('should process a valid directory path and convert to glob', async () => {
172 |     const fileContent = 'This is the file content.';
173 |     const filePath = await createTestFile(
174 |       path.join(testRootDir, 'path', 'to', 'file.txt'),
175 |       fileContent,
176 |     );
177 |     const dirPath = path.dirname(filePath);
178 |     const query = `@${dirPath}`;
179 |     const resolvedGlob = `${dirPath}/**`;
180 | 
181 |     const result = await handleAtCommand({
182 |       query,
183 |       config: mockConfig,
184 |       addItem: mockAddItem,
185 |       onDebugMessage: mockOnDebugMessage,
186 |       messageId: 126,
187 |       signal: abortController.signal,
188 |     });
189 | 
190 |     expect(result).toEqual({
191 |       processedQuery: [
192 |         { text: `@${resolvedGlob}` },
193 |         { text: '\n--- Content from referenced files ---' },
194 |         { text: `\nContent from @${filePath}:\n` },
195 |         { text: fileContent },
196 |         { text: '\n--- End of content ---' },
197 |       ],
198 |       shouldProceed: true,
199 |     });
200 |     expect(mockOnDebugMessage).toHaveBeenCalledWith(
201 |       `Path ${dirPath} resolved to directory, using glob: ${resolvedGlob}`,
202 |     );
203 |   });
204 | 
205 |   it('should handle query with text before and after @command', async () => {
206 |     const fileContent = 'Markdown content.';
207 |     const filePath = await createTestFile(
208 |       path.join(testRootDir, 'doc.md'),
209 |       fileContent,
210 |     );
211 |     const textBefore = 'Explain this: ';
212 |     const textAfter = ' in detail.';
213 |     const query = `${textBefore}@${filePath}${textAfter}`;
214 | 
215 |     const result = await handleAtCommand({
216 |       query,
217 |       config: mockConfig,
218 |       addItem: mockAddItem,
219 |       onDebugMessage: mockOnDebugMessage,
220 |       messageId: 128,
221 |       signal: abortController.signal,
222 |     });
223 | 
224 |     expect(result).toEqual({
225 |       processedQuery: [
226 |         { text: `${textBefore}@${filePath}${textAfter}` },
227 |         { text: '\n--- Content from referenced files ---' },
228 |         { text: `\nContent from @${filePath}:\n` },
229 |         { text: fileContent },
230 |         { text: '\n--- End of content ---' },
231 |       ],
232 |       shouldProceed: true,
233 |     });
234 |   });
235 | 
236 |   it('should correctly unescape paths with escaped spaces', async () => {
237 |     const fileContent = 'This is the file content.';
238 |     const filePath = await createTestFile(
239 |       path.join(testRootDir, 'path', 'to', 'my file.txt'),
240 |       fileContent,
241 |     );
242 |     const escapedpath = path.join(testRootDir, 'path', 'to', 'my\\ file.txt');
243 |     const query = `@${escapedpath}`;
244 | 
245 |     const result = await handleAtCommand({
246 |       query,
247 |       config: mockConfig,
248 |       addItem: mockAddItem,
249 |       onDebugMessage: mockOnDebugMessage,
250 |       messageId: 125,
251 |       signal: abortController.signal,
252 |     });
253 | 
254 |     expect(result).toEqual({
255 |       processedQuery: [
256 |         { text: `@${filePath}` },
257 |         { text: '\n--- Content from referenced files ---' },
258 |         { text: `\nContent from @${filePath}:\n` },
259 |         { text: fileContent },
260 |         { text: '\n--- End of content ---' },
261 |       ],
262 |       shouldProceed: true,
263 |     });
264 |     expect(mockAddItem).toHaveBeenCalledWith(
265 |       expect.objectContaining({
266 |         type: 'tool_group',
267 |         tools: [expect.objectContaining({ status: ToolCallStatus.Success })],
268 |       }),
269 |       125,
270 |     );
271 |   });
272 | 
273 |   it('should handle multiple @file references', async () => {
274 |     const content1 = 'Content file1';
275 |     const file1Path = await createTestFile(
276 |       path.join(testRootDir, 'file1.txt'),
277 |       content1,
278 |     );
279 |     const content2 = 'Content file2';
280 |     const file2Path = await createTestFile(
281 |       path.join(testRootDir, 'file2.md'),
282 |       content2,
283 |     );
284 |     const query = `@${file1Path} @${file2Path}`;
285 | 
286 |     const result = await handleAtCommand({
287 |       query,
288 |       config: mockConfig,
289 |       addItem: mockAddItem,
290 |       onDebugMessage: mockOnDebugMessage,
291 |       messageId: 130,
292 |       signal: abortController.signal,
293 |     });
294 | 
295 |     expect(result).toEqual({
296 |       processedQuery: [
297 |         { text: query },
298 |         { text: '\n--- Content from referenced files ---' },
299 |         { text: `\nContent from @${file1Path}:\n` },
300 |         { text: content1 },
301 |         { text: `\nContent from @${file2Path}:\n` },
302 |         { text: content2 },
303 |         { text: '\n--- End of content ---' },
304 |       ],
305 |       shouldProceed: true,
306 |     });
307 |   });
308 | 
309 |   it('should handle multiple @file references with interleaved text', async () => {
310 |     const text1 = 'Check ';
311 |     const content1 = 'C1';
312 |     const file1Path = await createTestFile(
313 |       path.join(testRootDir, 'f1.txt'),
314 |       content1,
315 |     );
316 |     const text2 = ' and ';
317 |     const content2 = 'C2';
318 |     const file2Path = await createTestFile(
319 |       path.join(testRootDir, 'f2.md'),
320 |       content2,
321 |     );
322 |     const text3 = ' please.';
323 |     const query = `${text1}@${file1Path}${text2}@${file2Path}${text3}`;
324 | 
325 |     const result = await handleAtCommand({
326 |       query,
327 |       config: mockConfig,
328 |       addItem: mockAddItem,
329 |       onDebugMessage: mockOnDebugMessage,
330 |       messageId: 131,
331 |       signal: abortController.signal,
332 |     });
333 | 
334 |     expect(result).toEqual({
335 |       processedQuery: [
336 |         { text: query },
337 |         { text: '\n--- Content from referenced files ---' },
338 |         { text: `\nContent from @${file1Path}:\n` },
339 |         { text: content1 },
340 |         { text: `\nContent from @${file2Path}:\n` },
341 |         { text: content2 },
342 |         { text: '\n--- End of content ---' },
343 |       ],
344 |       shouldProceed: true,
345 |     });
346 |   });
347 | 
348 |   it('should handle a mix of valid, invalid, and lone @ references', async () => {
349 |     const content1 = 'Valid content 1';
350 |     const file1Path = await createTestFile(
351 |       path.join(testRootDir, 'valid1.txt'),
352 |       content1,
353 |     );
354 |     const invalidFile = 'nonexistent.txt';
355 |     const content2 = 'Globbed content';
356 |     const file2Path = await createTestFile(
357 |       path.join(testRootDir, 'resolved', 'valid2.actual'),
358 |       content2,
359 |     );
360 |     const query = `Look at @${file1Path} then @${invalidFile} and also just @ symbol, then @${file2Path}`;
361 | 
362 |     const result = await handleAtCommand({
363 |       query,
364 |       config: mockConfig,
365 |       addItem: mockAddItem,
366 |       onDebugMessage: mockOnDebugMessage,
367 |       messageId: 132,
368 |       signal: abortController.signal,
369 |     });
370 | 
371 |     expect(result).toEqual({
372 |       processedQuery: [
373 |         {
374 |           text: `Look at @${file1Path} then @${invalidFile} and also just @ symbol, then @${file2Path}`,
375 |         },
376 |         { text: '\n--- Content from referenced files ---' },
377 |         { text: `\nContent from @${file2Path}:\n` },
378 |         { text: content2 },
379 |         { text: `\nContent from @${file1Path}:\n` },
[TRUNCATED]
```

src/ui/hooks/atCommandProcessor.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import * as fs from 'node:fs/promises';
8 | import * as path from 'node:path';
9 | import type { PartListUnion, PartUnion } from '@google/genai';
10 | import type { AnyToolInvocation, Config } from '@google/gemini-cli-core';
11 | import {
12 |   getErrorMessage,
13 |   isNodeError,
14 |   unescapePath,
15 | } from '@google/gemini-cli-core';
16 | import type { HistoryItem, IndividualToolCallDisplay } from '../types.js';
17 | import { ToolCallStatus } from '../types.js';
18 | import type { UseHistoryManagerReturn } from './useHistoryManager.js';
19 | 
20 | interface HandleAtCommandParams {
21 |   query: string;
22 |   config: Config;
23 |   addItem: UseHistoryManagerReturn['addItem'];
24 |   onDebugMessage: (message: string) => void;
25 |   messageId: number;
26 |   signal: AbortSignal;
27 | }
28 | 
29 | interface HandleAtCommandResult {
30 |   processedQuery: PartListUnion | null;
31 |   shouldProceed: boolean;
32 | }
33 | 
34 | interface AtCommandPart {
35 |   type: 'text' | 'atPath';
36 |   content: string;
37 | }
38 | 
39 | /**
40 |  * Parses a query string to find all '@<path>' commands and text segments.
41 |  * Handles \ escaped spaces within paths.
42 |  */
43 | function parseAllAtCommands(query: string): AtCommandPart[] {
44 |   const parts: AtCommandPart[] = [];
45 |   let currentIndex = 0;
46 | 
47 |   while (currentIndex < query.length) {
48 |     let atIndex = -1;
49 |     let nextSearchIndex = currentIndex;
50 |     // Find next unescaped '@'
51 |     while (nextSearchIndex < query.length) {
52 |       if (
53 |         query[nextSearchIndex] === '@' &&
54 |         (nextSearchIndex === 0 || query[nextSearchIndex - 1] !== '\\')
55 |       ) {
56 |         atIndex = nextSearchIndex;
57 |         break;
58 |       }
59 |       nextSearchIndex++;
60 |     }
61 | 
62 |     if (atIndex === -1) {
63 |       // No more @
64 |       if (currentIndex < query.length) {
65 |         parts.push({ type: 'text', content: query.substring(currentIndex) });
66 |       }
67 |       break;
68 |     }
69 | 
70 |     // Add text before @
71 |     if (atIndex > currentIndex) {
72 |       parts.push({
73 |         type: 'text',
74 |         content: query.substring(currentIndex, atIndex),
75 |       });
76 |     }
77 | 
78 |     // Parse @path
79 |     let pathEndIndex = atIndex + 1;
80 |     let inEscape = false;
81 |     while (pathEndIndex < query.length) {
82 |       const char = query[pathEndIndex];
83 |       if (inEscape) {
84 |         inEscape = false;
85 |       } else if (char === '\\') {
86 |         inEscape = true;
87 |       } else if (/[,\s;!?()[\]{}]/.test(char)) {
88 |         // Path ends at first whitespace or punctuation not escaped
89 |         break;
90 |       } else if (char === '.') {
91 |         // For . we need to be more careful - only terminate if followed by whitespace or end of string
92 |         // This allows file extensions like .txt, .js but terminates at sentence endings like "file.txt. Next sentence"
93 |         const nextChar =
94 |           pathEndIndex + 1 < query.length ? query[pathEndIndex + 1] : '';
95 |         if (nextChar === '' || /\s/.test(nextChar)) {
96 |           break;
97 |         }
98 |       }
99 |       pathEndIndex++;
100 |     }
101 |     const rawAtPath = query.substring(atIndex, pathEndIndex);
102 |     // unescapePath expects the @ symbol to be present, and will handle it.
103 |     const atPath = unescapePath(rawAtPath);
104 |     parts.push({ type: 'atPath', content: atPath });
105 |     currentIndex = pathEndIndex;
106 |   }
107 |   // Filter out empty text parts that might result from consecutive @paths or leading/trailing spaces
108 |   return parts.filter(
109 |     (part) => !(part.type === 'text' && part.content.trim() === ''),
110 |   );
111 | }
112 | 
113 | /**
114 |  * Processes user input potentially containing one or more '@<path>' commands.
115 |  * If found, it attempts to read the specified files/directories using the
116 |  * 'read_many_files' tool. The user query is modified to include resolved paths,
117 |  * and the content of the files is appended in a structured block.
118 |  *
119 |  * @returns An object indicating whether the main hook should proceed with an
120 |  *          LLM call and the processed query parts (including file content).
121 |  */
122 | export async function handleAtCommand({
123 |   query,
124 |   config,
125 |   addItem,
126 |   onDebugMessage,
127 |   messageId: userMessageTimestamp,
128 |   signal,
129 | }: HandleAtCommandParams): Promise<HandleAtCommandResult> {
130 |   const commandParts = parseAllAtCommands(query);
131 |   const atPathCommandParts = commandParts.filter(
132 |     (part) => part.type === 'atPath',
133 |   );
134 | 
135 |   if (atPathCommandParts.length === 0) {
136 |     return { processedQuery: [{ text: query }], shouldProceed: true };
137 |   }
138 | 
139 |   // Get centralized file discovery service
140 |   const fileDiscovery = config.getFileService();
141 | 
142 |   const respectFileIgnore = config.getFileFilteringOptions();
143 | 
144 |   const pathSpecsToRead: string[] = [];
145 |   const atPathToResolvedSpecMap = new Map<string, string>();
146 |   const contentLabelsForDisplay: string[] = [];
147 |   const ignoredByReason: Record<string, string[]> = {
148 |     git: [],
149 |     gemini: [],
150 |     both: [],
151 |   };
152 | 
153 |   const toolRegistry = config.getToolRegistry();
154 |   const readManyFilesTool = toolRegistry.getTool('read_many_files');
155 |   const globTool = toolRegistry.getTool('glob');
156 | 
157 |   if (!readManyFilesTool) {
158 |     addItem(
159 |       { type: 'error', text: 'Error: read_many_files tool not found.' },
160 |       userMessageTimestamp,
161 |     );
162 |     return { processedQuery: null, shouldProceed: false };
163 |   }
164 | 
165 |   for (const atPathPart of atPathCommandParts) {
166 |     const originalAtPath = atPathPart.content; // e.g., "@file.txt" or "@"
167 | 
168 |     if (originalAtPath === '@') {
169 |       onDebugMessage(
170 |         'Lone @ detected, will be treated as text in the modified query.',
171 |       );
172 |       continue;
173 |     }
174 | 
175 |     const pathName = originalAtPath.substring(1);
176 |     if (!pathName) {
177 |       // This case should ideally not be hit if parseAllAtCommands ensures content after @
178 |       // but as a safeguard:
179 |       addItem(
180 |         {
181 |           type: 'error',
182 |           text: `Error: Invalid @ command '${originalAtPath}'. No path specified.`,
183 |         },
184 |         userMessageTimestamp,
185 |       );
186 |       // Decide if this is a fatal error for the whole command or just skip this @ part
187 |       // For now, let's be strict and fail the command if one @path is malformed.
188 |       return { processedQuery: null, shouldProceed: false };
189 |     }
190 | 
191 |     // Check if path should be ignored based on filtering options
192 | 
193 |     const workspaceContext = config.getWorkspaceContext();
194 |     if (!workspaceContext.isPathWithinWorkspace(pathName)) {
195 |       onDebugMessage(
196 |         `Path ${pathName} is not in the workspace and will be skipped.`,
197 |       );
198 |       continue;
199 |     }
200 | 
201 |     const gitIgnored =
202 |       respectFileIgnore.respectGitIgnore &&
203 |       fileDiscovery.shouldIgnoreFile(pathName, {
204 |         respectGitIgnore: true,
205 |         respectGeminiIgnore: false,
206 |       });
207 |     const geminiIgnored =
208 |       respectFileIgnore.respectGeminiIgnore &&
209 |       fileDiscovery.shouldIgnoreFile(pathName, {
210 |         respectGitIgnore: false,
211 |         respectGeminiIgnore: true,
212 |       });
213 | 
214 |     if (gitIgnored || geminiIgnored) {
215 |       const reason =
216 |         gitIgnored && geminiIgnored ? 'both' : gitIgnored ? 'git' : 'gemini';
217 |       ignoredByReason[reason].push(pathName);
218 |       const reasonText =
219 |         reason === 'both'
220 |           ? 'ignored by both git and gemini'
221 |           : reason === 'git'
222 |             ? 'git-ignored'
223 |             : 'gemini-ignored';
224 |       onDebugMessage(`Path ${pathName} is ${reasonText} and will be skipped.`);
225 |       continue;
226 |     }
227 | 
228 |     for (const dir of config.getWorkspaceContext().getDirectories()) {
229 |       let currentPathSpec = pathName;
230 |       let resolvedSuccessfully = false;
231 |       try {
232 |         const absolutePath = path.resolve(dir, pathName);
233 |         const stats = await fs.stat(absolutePath);
234 |         if (stats.isDirectory()) {
235 |           currentPathSpec =
236 |             pathName + (pathName.endsWith(path.sep) ? `**` : `/**`);
237 |           onDebugMessage(
238 |             `Path ${pathName} resolved to directory, using glob: ${currentPathSpec}`,
239 |           );
240 |         } else {
241 |           onDebugMessage(`Path ${pathName} resolved to file: ${absolutePath}`);
242 |         }
243 |         resolvedSuccessfully = true;
244 |       } catch (error) {
245 |         if (isNodeError(error) && error.code === 'ENOENT') {
246 |           if (config.getEnableRecursiveFileSearch() && globTool) {
247 |             onDebugMessage(
248 |               `Path ${pathName} not found directly, attempting glob search.`,
249 |             );
250 |             try {
251 |               const globResult = await globTool.buildAndExecute(
252 |                 {
253 |                   pattern: `**/*${pathName}*`,
254 |                   path: dir,
255 |                 },
256 |                 signal,
257 |               );
258 |               if (
259 |                 globResult.llmContent &&
260 |                 typeof globResult.llmContent === 'string' &&
261 |                 !globResult.llmContent.startsWith('No files found') &&
262 |                 !globResult.llmContent.startsWith('Error:')
263 |               ) {
264 |                 const lines = globResult.llmContent.split('\n');
265 |                 if (lines.length > 1 && lines[1]) {
266 |                   const firstMatchAbsolute = lines[1].trim();
267 |                   currentPathSpec = path.relative(dir, firstMatchAbsolute);
268 |                   onDebugMessage(
269 |                     `Glob search for ${pathName} found ${firstMatchAbsolute}, using relative path: ${currentPathSpec}`,
270 |                   );
271 |                   resolvedSuccessfully = true;
272 |                 } else {
273 |                   onDebugMessage(
274 |                     `Glob search for '**/*${pathName}*' did not return a usable path. Path ${pathName} will be skipped.`,
275 |                   );
276 |                 }
277 |               } else {
278 |                 onDebugMessage(
279 |                   `Glob search for '**/*${pathName}*' found no files or an error. Path ${pathName} will be skipped.`,
280 |                 );
281 |               }
282 |             } catch (globError) {
283 |               console.error(
284 |                 `Error during glob search for ${pathName}: ${getErrorMessage(globError)}`,
285 |               );
286 |               onDebugMessage(
287 |                 `Error during glob search for ${pathName}. Path ${pathName} will be skipped.`,
288 |               );
289 |             }
290 |           } else {
291 |             onDebugMessage(
292 |               `Glob tool not found. Path ${pathName} will be skipped.`,
293 |             );
294 |           }
295 |         } else {
296 |           console.error(
297 |             `Error stating path ${pathName}: ${getErrorMessage(error)}`,
298 |           );
299 |           onDebugMessage(
300 |             `Error stating path ${pathName}. Path ${pathName} will be skipped.`,
301 |           );
302 |         }
303 |       }
304 |       if (resolvedSuccessfully) {
305 |         pathSpecsToRead.push(currentPathSpec);
306 |         atPathToResolvedSpecMap.set(originalAtPath, currentPathSpec);
307 |         contentLabelsForDisplay.push(pathName);
308 |         break;
309 |       }
310 |     }
311 |   }
312 | 
313 |   // Construct the initial part of the query for the LLM
314 |   let initialQueryText = '';
315 |   for (let i = 0; i < commandParts.length; i++) {
316 |     const part = commandParts[i];
317 |     if (part.type === 'text') {
318 |       initialQueryText += part.content;
319 |     } else {
320 |       // type === 'atPath'
321 |       const resolvedSpec = atPathToResolvedSpecMap.get(part.content);
322 |       if (
323 |         i > 0 &&
324 |         initialQueryText.length > 0 &&
325 |         !initialQueryText.endsWith(' ')
326 |       ) {
327 |         // Add space if previous part was text and didn't end with space, or if previous was @path
328 |         const prevPart = commandParts[i - 1];
329 |         if (
330 |           prevPart.type === 'text' ||
331 |           (prevPart.type === 'atPath' &&
332 |             atPathToResolvedSpecMap.has(prevPart.content))
333 |         ) {
334 |           initialQueryText += ' ';
335 |         }
336 |       }
337 |       if (resolvedSpec) {
338 |         initialQueryText += `@${resolvedSpec}`;
339 |       } else {
340 |         // If not resolved for reading (e.g. lone @ or invalid path that was skipped),
341 |         // add the original @-string back, ensuring spacing if it's not the first element.
342 |         if (
343 |           i > 0 &&
344 |           initialQueryText.length > 0 &&
345 |           !initialQueryText.endsWith(' ') &&
346 |           !part.content.startsWith(' ')
347 |         ) {
348 |           initialQueryText += ' ';
349 |         }
[TRUNCATED]
```

src/ui/hooks/keyToAnsi.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type { Key } from '../contexts/KeypressContext.js';
8 | 
9 | export type { Key };
10 | 
11 | /**
12 |  * Translates a Key object into its corresponding ANSI escape sequence.
13 |  * This is useful for sending control characters to a pseudo-terminal.
14 |  *
15 |  * @param key The Key object to translate.
16 |  * @returns The ANSI escape sequence as a string, or null if no mapping exists.
17 |  */
18 | export function keyToAnsi(key: Key): string | null {
19 |   if (key.ctrl) {
20 |     // Ctrl + letter
21 |     if (key.name >= 'a' && key.name <= 'z') {
22 |       return String.fromCharCode(
23 |         key.name.charCodeAt(0) - 'a'.charCodeAt(0) + 1,
24 |       );
25 |     }
26 |     // Other Ctrl combinations might need specific handling
27 |     switch (key.name) {
28 |       case 'c':
29 |         return '\x03'; // ETX (End of Text), commonly used for interrupt
30 |       // Add other special ctrl cases if needed
31 |       default:
32 |         break;
33 |     }
34 |   }
35 | 
36 |   // Arrow keys and other special keys
37 |   switch (key.name) {
38 |     case 'up':
39 |       return '\x1b[A';
40 |     case 'down':
41 |       return '\x1b[B';
42 |     case 'right':
43 |       return '\x1b[C';
44 |     case 'left':
45 |       return '\x1b[D';
46 |     case 'escape':
47 |       return '\x1b';
48 |     case 'tab':
49 |       return '\t';
50 |     case 'backspace':
51 |       return '\x7f';
52 |     case 'delete':
53 |       return '\x1b[3~';
54 |     case 'home':
55 |       return '\x1b[H';
56 |     case 'end':
57 |       return '\x1b[F';
58 |     case 'pageup':
59 |       return '\x1b[5~';
60 |     case 'pagedown':
61 |       return '\x1b[6~';
62 |     default:
63 |       break;
64 |   }
65 | 
66 |   // Enter/Return
67 |   if (key.name === 'return') {
68 |     return '\r';
69 |   }
70 | 
71 |   // If it's a simple character, return it.
72 |   if (!key.ctrl && !key.meta && key.sequence) {
73 |     return key.sequence;
74 |   }
75 | 
76 |   return null;
77 | }
```

src/ui/hooks/shellCommandProcessor.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { act, renderHook } from '@testing-library/react';
8 | import {
9 |   vi,
10 |   describe,
11 |   it,
12 |   expect,
13 |   beforeEach,
14 |   afterEach,
15 |   type Mock,
16 | } from 'vitest';
17 | 
18 | const mockIsBinary = vi.hoisted(() => vi.fn());
19 | const mockShellExecutionService = vi.hoisted(() => vi.fn());
20 | vi.mock('@google/gemini-cli-core', () => ({
21 |   ShellExecutionService: { execute: mockShellExecutionService },
22 |   isBinary: mockIsBinary,
23 | }));
24 | vi.mock('fs');
25 | vi.mock('os');
26 | vi.mock('crypto');
27 | vi.mock('../utils/textUtils.js');
28 | 
29 | import {
30 |   useShellCommandProcessor,
31 |   OUTPUT_UPDATE_INTERVAL_MS,
32 | } from './shellCommandProcessor.js';
33 | import {
34 |   type Config,
35 |   type GeminiClient,
36 |   type ShellExecutionResult,
37 |   type ShellOutputEvent,
38 | } from '@google/gemini-cli-core';
39 | import * as fs from 'node:fs';
40 | import * as os from 'node:os';
41 | import * as path from 'node:path';
42 | import * as crypto from 'node:crypto';
43 | import { ToolCallStatus } from '../types.js';
44 | 
45 | describe('useShellCommandProcessor', () => {
46 |   let addItemToHistoryMock: Mock;
47 |   let setPendingHistoryItemMock: Mock;
48 |   let onExecMock: Mock;
49 |   let onDebugMessageMock: Mock;
50 |   let mockConfig: Config;
51 |   let mockGeminiClient: GeminiClient;
52 | 
53 |   let mockShellOutputCallback: (event: ShellOutputEvent) => void;
54 |   let resolveExecutionPromise: (result: ShellExecutionResult) => void;
55 | 
56 |   let setShellInputFocusedMock: Mock;
57 | 
58 |   beforeEach(() => {
59 |     vi.clearAllMocks();
60 | 
61 |     addItemToHistoryMock = vi.fn();
62 |     setPendingHistoryItemMock = vi.fn();
63 |     onExecMock = vi.fn();
64 |     onDebugMessageMock = vi.fn();
65 |     setShellInputFocusedMock = vi.fn();
66 |     mockConfig = {
67 |       getTargetDir: () => '/test/dir',
68 |       getEnableInteractiveShell: () => false,
69 |       getShellExecutionConfig: () => ({
70 |         terminalHeight: 20,
71 |         terminalWidth: 80,
72 |       }),
73 |     } as Config;
74 |     mockGeminiClient = { addHistory: vi.fn() } as unknown as GeminiClient;
75 | 
76 |     vi.mocked(os.platform).mockReturnValue('linux');
77 |     vi.mocked(os.tmpdir).mockReturnValue('/tmp');
78 |     (vi.mocked(crypto.randomBytes) as Mock).mockReturnValue(
79 |       Buffer.from('abcdef', 'hex'),
80 |     );
81 |     mockIsBinary.mockReturnValue(false);
82 |     vi.mocked(fs.existsSync).mockReturnValue(false);
83 | 
84 |     mockShellExecutionService.mockImplementation((_cmd, _cwd, callback) => {
85 |       mockShellOutputCallback = callback;
86 |       return Promise.resolve({
87 |         pid: 12345,
88 |         result: new Promise((resolve) => {
89 |           resolveExecutionPromise = resolve;
90 |         }),
91 |       });
92 |     });
93 |   });
94 | 
95 |   const renderProcessorHook = () =>
96 |     renderHook(() =>
97 |       useShellCommandProcessor(
98 |         addItemToHistoryMock,
99 |         setPendingHistoryItemMock,
100 |         onExecMock,
101 |         onDebugMessageMock,
102 |         mockConfig,
103 |         mockGeminiClient,
104 |         setShellInputFocusedMock,
105 |       ),
106 |     );
107 | 
108 |   const createMockServiceResult = (
109 |     overrides: Partial<ShellExecutionResult> = {},
110 |   ): ShellExecutionResult => ({
111 |     rawOutput: Buffer.from(overrides.output || ''),
112 |     output: 'Success',
113 |     exitCode: 0,
114 |     signal: null,
115 |     error: null,
116 |     aborted: false,
117 |     pid: 12345,
118 |     executionMethod: 'child_process',
119 |     ...overrides,
120 |   });
121 | 
122 |   it('should initiate command execution and set pending state', async () => {
123 |     const { result } = renderProcessorHook();
124 | 
125 |     act(() => {
126 |       result.current.handleShellCommand('ls -l', new AbortController().signal);
127 |     });
128 | 
129 |     expect(addItemToHistoryMock).toHaveBeenCalledWith(
130 |       { type: 'user_shell', text: 'ls -l' },
131 |       expect.any(Number),
132 |     );
133 |     expect(setPendingHistoryItemMock).toHaveBeenCalledWith({
134 |       type: 'tool_group',
135 |       tools: [
136 |         expect.objectContaining({
137 |           name: 'Shell Command',
138 |           status: ToolCallStatus.Executing,
139 |         }),
140 |       ],
141 |     });
142 |     const tmpFile = path.join(os.tmpdir(), 'shell_pwd_abcdef.tmp');
143 |     const wrappedCommand = `{ ls -l; }; __code=$?; pwd > "${tmpFile}"; exit $__code`;
144 |     expect(mockShellExecutionService).toHaveBeenCalledWith(
145 |       wrappedCommand,
146 |       '/test/dir',
147 |       expect.any(Function),
148 |       expect.any(Object),
149 |       false,
150 |       expect.any(Object),
151 |     );
152 |     expect(onExecMock).toHaveBeenCalledWith(expect.any(Promise));
153 |   });
154 | 
155 |   it('should handle successful execution and update history correctly', async () => {
156 |     const { result } = renderProcessorHook();
157 | 
158 |     act(() => {
159 |       result.current.handleShellCommand(
160 |         'echo "ok"',
161 |         new AbortController().signal,
162 |       );
163 |     });
164 |     const execPromise = onExecMock.mock.calls[0][0];
165 | 
166 |     act(() => {
167 |       resolveExecutionPromise(createMockServiceResult({ output: 'ok' }));
168 |     });
169 |     await act(async () => await execPromise);
170 | 
171 |     expect(setPendingHistoryItemMock).toHaveBeenCalledWith(null);
172 |     expect(addItemToHistoryMock).toHaveBeenCalledTimes(2); // Initial + final
173 |     expect(addItemToHistoryMock.mock.calls[1][0]).toEqual(
174 |       expect.objectContaining({
175 |         tools: [
176 |           expect.objectContaining({
177 |             status: ToolCallStatus.Success,
178 |             resultDisplay: 'ok',
179 |           }),
180 |         ],
181 |       }),
182 |     );
183 |     expect(mockGeminiClient.addHistory).toHaveBeenCalled();
184 |     expect(setShellInputFocusedMock).toHaveBeenCalledWith(false);
185 |   });
186 | 
187 |   it('should handle command failure and display error status', async () => {
188 |     const { result } = renderProcessorHook();
189 | 
190 |     act(() => {
191 |       result.current.handleShellCommand(
192 |         'bad-cmd',
193 |         new AbortController().signal,
194 |       );
195 |     });
196 |     const execPromise = onExecMock.mock.calls[0][0];
197 | 
198 |     act(() => {
199 |       resolveExecutionPromise(
200 |         createMockServiceResult({ exitCode: 127, output: 'not found' }),
201 |       );
202 |     });
203 |     await act(async () => await execPromise);
204 | 
205 |     const finalHistoryItem = addItemToHistoryMock.mock.calls[1][0];
206 |     expect(finalHistoryItem.tools[0].status).toBe(ToolCallStatus.Error);
207 |     expect(finalHistoryItem.tools[0].resultDisplay).toContain(
208 |       'Command exited with code 127',
209 |     );
210 |     expect(finalHistoryItem.tools[0].resultDisplay).toContain('not found');
211 |     expect(setShellInputFocusedMock).toHaveBeenCalledWith(false);
212 |   });
213 | 
214 |   describe('UI Streaming and Throttling', () => {
215 |     beforeEach(() => {
216 |       vi.useFakeTimers({ toFake: ['Date'] });
217 |     });
218 |     afterEach(() => {
219 |       vi.useRealTimers();
220 |     });
221 | 
222 |     it('should update UI for text streams (non-interactive)', async () => {
223 |       const { result } = renderProcessorHook();
224 |       act(() => {
225 |         result.current.handleShellCommand(
226 |           'stream',
227 |           new AbortController().signal,
228 |         );
229 |       });
230 | 
231 |       // Verify it's using the non-pty shell
232 |       const wrappedCommand = `{ stream; }; __code=$?; pwd > "${path.join(
233 |         os.tmpdir(),
234 |         'shell_pwd_abcdef.tmp',
235 |       )}"; exit $__code`;
236 |       expect(mockShellExecutionService).toHaveBeenCalledWith(
237 |         wrappedCommand,
238 |         '/test/dir',
239 |         expect.any(Function),
240 |         expect.any(Object),
241 |         false, // enableInteractiveShell
242 |         expect.any(Object),
243 |       );
244 | 
245 |       // Wait for the async PID update to happen.
246 |       // Call 1: Initial, Call 2: PID update
247 |       await vi.waitFor(() => {
248 |         expect(setPendingHistoryItemMock).toHaveBeenCalledTimes(2);
249 |       });
250 | 
251 |       // Get the state after the PID update to feed into the stream updaters
252 |       const pidUpdateFn = setPendingHistoryItemMock.mock.calls[1][0];
253 |       const initialState = setPendingHistoryItemMock.mock.calls[0][0];
254 |       const stateAfterPid = pidUpdateFn(initialState);
255 | 
256 |       // Simulate first output chunk
257 |       act(() => {
258 |         mockShellOutputCallback({
259 |           type: 'data',
260 |           chunk: 'hello',
261 |         });
262 |       });
263 |       // A UI update should have occurred.
264 |       expect(setPendingHistoryItemMock).toHaveBeenCalledTimes(3);
265 | 
266 |       const streamUpdateFn1 = setPendingHistoryItemMock.mock.calls[2][0];
267 |       const stateAfterStream1 = streamUpdateFn1(stateAfterPid);
268 |       expect(stateAfterStream1.tools[0].resultDisplay).toBe('hello');
269 | 
270 |       // Simulate second output chunk
271 |       act(() => {
272 |         mockShellOutputCallback({
273 |           type: 'data',
274 |           chunk: ' world',
275 |         });
276 |       });
277 |       // Another UI update should have occurred.
278 |       expect(setPendingHistoryItemMock).toHaveBeenCalledTimes(4);
279 | 
280 |       const streamUpdateFn2 = setPendingHistoryItemMock.mock.calls[3][0];
281 |       const stateAfterStream2 = streamUpdateFn2(stateAfterStream1);
282 |       expect(stateAfterStream2.tools[0].resultDisplay).toBe('hello world');
283 |     });
284 | 
285 |     it('should show binary progress messages correctly', async () => {
286 |       const { result } = renderProcessorHook();
287 |       act(() => {
288 |         result.current.handleShellCommand(
289 |           'cat img',
290 |           new AbortController().signal,
291 |         );
292 |       });
293 | 
294 |       // Should immediately show the detection message
295 |       act(() => {
296 |         mockShellOutputCallback({ type: 'binary_detected' });
297 |       });
298 |       await act(async () => {
299 |         await vi.advanceTimersByTimeAsync(OUTPUT_UPDATE_INTERVAL_MS + 1);
300 |       });
301 |       // Send another event to trigger the update
302 |       act(() => {
303 |         mockShellOutputCallback({ type: 'binary_progress', bytesReceived: 0 });
304 |       });
305 | 
306 |       // The state update is functional, so we test it by executing it.
307 |       const updaterFn1 = setPendingHistoryItemMock.mock.lastCall?.[0];
308 |       if (!updaterFn1) {
309 |         throw new Error('setPendingHistoryItem was not called');
310 |       }
311 |       const initialState = setPendingHistoryItemMock.mock.calls[0][0];
312 |       const stateAfterBinaryDetected = updaterFn1(initialState);
313 | 
314 |       expect(stateAfterBinaryDetected).toEqual(
315 |         expect.objectContaining({
316 |           tools: [
317 |             expect.objectContaining({
318 |               resultDisplay: '[Binary output detected. Halting stream...]',
319 |             }),
320 |           ],
321 |         }),
322 |       );
323 | 
324 |       // Now test progress updates
325 |       await act(async () => {
326 |         await vi.advanceTimersByTimeAsync(OUTPUT_UPDATE_INTERVAL_MS + 1);
327 |       });
328 |       act(() => {
329 |         mockShellOutputCallback({
330 |           type: 'binary_progress',
331 |           bytesReceived: 2048,
332 |         });
333 |       });
334 | 
335 |       const updaterFn2 = setPendingHistoryItemMock.mock.lastCall?.[0];
336 |       if (!updaterFn2) {
337 |         throw new Error('setPendingHistoryItem was not called');
338 |       }
339 |       const stateAfterProgress = updaterFn2(stateAfterBinaryDetected);
340 |       expect(stateAfterProgress).toEqual(
341 |         expect.objectContaining({
342 |           tools: [
343 |             expect.objectContaining({
344 |               resultDisplay: '[Receiving binary output... 2.0 KB received]',
345 |             }),
346 |           ],
347 |         }),
348 |       );
349 |     });
350 |   });
351 | 
352 |   it('should not wrap the command on Windows', async () => {
353 |     vi.mocked(os.platform).mockReturnValue('win32');
354 |     const { result } = renderProcessorHook();
355 | 
356 |     act(() => {
357 |       result.current.handleShellCommand('dir', new AbortController().signal);
358 |     });
359 | 
360 |     expect(mockShellExecutionService).toHaveBeenCalledWith(
361 |       'dir',
362 |       '/test/dir',
363 |       expect.any(Function),
364 |       expect.any(Object),
365 |       false,
366 |       expect.any(Object),
367 |     );
368 |   });
369 | 
370 |   it('should handle command abort and display cancelled status', async () => {
371 |     const { result } = renderProcessorHook();
372 |     const abortController = new AbortController();
373 | 
374 |     act(() => {
375 |       result.current.handleShellCommand('sleep 5', abortController.signal);
376 |     });
377 |     const execPromise = onExecMock.mock.calls[0][0];
378 | 
379 |     act(() => {
380 |       abortController.abort();
381 |       resolveExecutionPromise(
382 |         createMockServiceResult({ aborted: true, output: 'Canceled' }),
383 |       );
384 |     });
385 |     await act(async () => await execPromise);
386 | 
387 |     const finalHistoryItem = addItemToHistoryMock.mock.calls[1][0];
388 |     expect(finalHistoryItem.tools[0].status).toBe(ToolCallStatus.Canceled);
389 |     expect(finalHistoryItem.tools[0].resultDisplay).toContain(
390 |       'Command was cancelled.',
391 |     );
392 |     expect(setShellInputFocusedMock).toHaveBeenCalledWith(false);
393 |   });
394 | 
395 |   it('should handle binary output result correctly', async () => {
396 |     const { result } = renderProcessorHook();
[TRUNCATED]
```

src/ui/hooks/shellCommandProcessor.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type {
8 |   HistoryItemWithoutId,
9 |   IndividualToolCallDisplay,
10 | } from '../types.js';
11 | import { ToolCallStatus } from '../types.js';
12 | import { useCallback, useState } from 'react';
13 | import type {
14 |   AnsiOutput,
15 |   Config,
16 |   GeminiClient,
17 |   ShellExecutionResult,
18 | } from '@google/gemini-cli-core';
19 | import { isBinary, ShellExecutionService } from '@google/gemini-cli-core';
20 | import { type PartListUnion } from '@google/genai';
21 | import type { UseHistoryManagerReturn } from './useHistoryManager.js';
22 | import { SHELL_COMMAND_NAME } from '../constants.js';
23 | import { formatMemoryUsage } from '../utils/formatters.js';
24 | import crypto from 'node:crypto';
25 | import path from 'node:path';
26 | import os from 'node:os';
27 | import fs from 'node:fs';
28 | import { themeManager } from '../../ui/themes/theme-manager.js';
29 | 
30 | export const OUTPUT_UPDATE_INTERVAL_MS = 1000;
31 | const MAX_OUTPUT_LENGTH = 10000;
32 | 
33 | function addShellCommandToGeminiHistory(
34 |   geminiClient: GeminiClient,
35 |   rawQuery: string,
36 |   resultText: string,
37 | ) {
38 |   const modelContent =
39 |     resultText.length > MAX_OUTPUT_LENGTH
40 |       ? resultText.substring(0, MAX_OUTPUT_LENGTH) + '\n... (truncated)'
41 |       : resultText;
42 | 
43 |   geminiClient.addHistory({
44 |     role: 'user',
45 |     parts: [
46 |       {
47 |         text: `I ran the following shell command:
48 | \`\`\`sh
49 | ${rawQuery}
50 | \`\`\`
51 | 
52 | This produced the following result:
53 | \`\`\`
54 | ${modelContent}
55 | \`\`\``,
56 |       },
57 |     ],
58 |   });
59 | }
60 | 
61 | /**
62 |  * Hook to process shell commands.
63 |  * Orchestrates command execution and updates history and agent context.
64 |  */
65 | export const useShellCommandProcessor = (
66 |   addItemToHistory: UseHistoryManagerReturn['addItem'],
67 |   setPendingHistoryItem: React.Dispatch<
68 |     React.SetStateAction<HistoryItemWithoutId | null>
69 |   >,
70 |   onExec: (command: Promise<void>) => void,
71 |   onDebugMessage: (message: string) => void,
72 |   config: Config,
73 |   geminiClient: GeminiClient,
74 |   setShellInputFocused: (value: boolean) => void,
75 |   terminalWidth?: number,
76 |   terminalHeight?: number,
77 | ) => {
78 |   const [activeShellPtyId, setActiveShellPtyId] = useState<number | null>(null);
79 |   const handleShellCommand = useCallback(
80 |     (rawQuery: PartListUnion, abortSignal: AbortSignal): boolean => {
81 |       if (typeof rawQuery !== 'string' || rawQuery.trim() === '') {
82 |         return false;
83 |       }
84 | 
85 |       const userMessageTimestamp = Date.now();
86 |       const callId = `shell-${userMessageTimestamp}`;
87 |       addItemToHistory(
88 |         { type: 'user_shell', text: rawQuery },
89 |         userMessageTimestamp,
90 |       );
91 | 
92 |       const isWindows = os.platform() === 'win32';
93 |       const targetDir = config.getTargetDir();
94 |       let commandToExecute = rawQuery;
95 |       let pwdFilePath: string | undefined;
96 | 
97 |       // On non-windows, wrap the command to capture the final working directory.
98 |       if (!isWindows) {
99 |         let command = rawQuery.trim();
100 |         const pwdFileName = `shell_pwd_${crypto.randomBytes(6).toString('hex')}.tmp`;
101 |         pwdFilePath = path.join(os.tmpdir(), pwdFileName);
102 |         // Ensure command ends with a separator before adding our own.
103 |         if (!command.endsWith(';') && !command.endsWith('&')) {
104 |           command += ';';
105 |         }
106 |         commandToExecute = `{ ${command} }; __code=$?; pwd > "${pwdFilePath}"; exit $__code`;
107 |       }
108 | 
109 |       const executeCommand = async (
110 |         resolve: (value: void | PromiseLike<void>) => void,
111 |       ) => {
112 |         let cumulativeStdout: string | AnsiOutput = '';
113 |         let isBinaryStream = false;
114 |         let binaryBytesReceived = 0;
115 | 
116 |         const initialToolDisplay: IndividualToolCallDisplay = {
117 |           callId,
118 |           name: SHELL_COMMAND_NAME,
119 |           description: rawQuery,
120 |           status: ToolCallStatus.Executing,
121 |           resultDisplay: '',
122 |           confirmationDetails: undefined,
123 |         };
124 | 
125 |         setPendingHistoryItem({
126 |           type: 'tool_group',
127 |           tools: [initialToolDisplay],
128 |         });
129 | 
130 |         let executionPid: number | undefined;
131 | 
132 |         const abortHandler = () => {
133 |           onDebugMessage(
134 |             `Aborting shell command (PID: ${executionPid ?? 'unknown'})`,
135 |           );
136 |         };
137 |         abortSignal.addEventListener('abort', abortHandler, { once: true });
138 | 
139 |         onDebugMessage(`Executing in ${targetDir}: ${commandToExecute}`);
140 | 
141 |         try {
142 |           const activeTheme = themeManager.getActiveTheme();
143 |           const shellExecutionConfig = {
144 |             ...config.getShellExecutionConfig(),
145 |             terminalWidth,
146 |             terminalHeight,
147 |             defaultFg: activeTheme.colors.Foreground,
148 |             defaultBg: activeTheme.colors.Background,
149 |           };
150 | 
151 |           const { pid, result } = await ShellExecutionService.execute(
152 |             commandToExecute,
153 |             targetDir,
154 |             (event) => {
155 |               let shouldUpdate = false;
156 |               switch (event.type) {
157 |                 case 'data':
158 |                   // Do not process text data if we've already switched to binary mode.
159 |                   if (isBinaryStream) break;
160 |                   // PTY provides the full screen state, so we just replace.
161 |                   // Child process provides chunks, so we append.
162 |                   if (config.getEnableInteractiveShell()) {
163 |                     cumulativeStdout = event.chunk;
164 |                     shouldUpdate = true;
165 |                   } else if (
166 |                     typeof event.chunk === 'string' &&
167 |                     typeof cumulativeStdout === 'string'
168 |                   ) {
169 |                     cumulativeStdout += event.chunk;
170 |                     shouldUpdate = true;
171 |                   }
172 |                   break;
173 |                 case 'binary_detected':
174 |                   isBinaryStream = true;
175 |                   // Force an immediate UI update to show the binary detection message.
176 |                   shouldUpdate = true;
177 |                   break;
178 |                 case 'binary_progress':
179 |                   isBinaryStream = true;
180 |                   binaryBytesReceived = event.bytesReceived;
181 |                   shouldUpdate = true;
182 |                   break;
183 |                 default: {
184 |                   throw new Error('An unhandled ShellOutputEvent was found.');
185 |                 }
186 |               }
187 | 
188 |               // Compute the display string based on the *current* state.
189 |               let currentDisplayOutput: string | AnsiOutput;
190 |               if (isBinaryStream) {
191 |                 if (binaryBytesReceived > 0) {
192 |                   currentDisplayOutput = `[Receiving binary output... ${formatMemoryUsage(
193 |                     binaryBytesReceived,
194 |                   )} received]`;
195 |                 } else {
196 |                   currentDisplayOutput =
197 |                     '[Binary output detected. Halting stream...]';
198 |                 }
199 |               } else {
200 |                 currentDisplayOutput = cumulativeStdout;
201 |               }
202 | 
203 |               // Throttle pending UI updates, but allow forced updates.
204 |               if (shouldUpdate) {
205 |                 setPendingHistoryItem((prevItem) => {
206 |                   if (prevItem?.type === 'tool_group') {
207 |                     return {
208 |                       ...prevItem,
209 |                       tools: prevItem.tools.map((tool) =>
210 |                         tool.callId === callId
211 |                           ? { ...tool, resultDisplay: currentDisplayOutput }
212 |                           : tool,
213 |                       ),
214 |                     };
215 |                   }
216 |                   return prevItem;
217 |                 });
218 |               }
219 |             },
220 |             abortSignal,
221 |             config.getEnableInteractiveShell(),
222 |             shellExecutionConfig,
223 |           );
224 | 
225 |           console.log(terminalHeight, terminalWidth);
226 | 
227 |           executionPid = pid;
228 |           if (pid) {
229 |             setActiveShellPtyId(pid);
230 |             setPendingHistoryItem((prevItem) => {
231 |               if (prevItem?.type === 'tool_group') {
232 |                 return {
233 |                   ...prevItem,
234 |                   tools: prevItem.tools.map((tool) =>
235 |                     tool.callId === callId ? { ...tool, ptyId: pid } : tool,
236 |                   ),
237 |                 };
238 |               }
239 |               return prevItem;
240 |             });
241 |           }
242 | 
243 |           result
244 |             .then((result: ShellExecutionResult) => {
245 |               setPendingHistoryItem(null);
246 | 
247 |               let mainContent: string;
248 | 
249 |               if (isBinary(result.rawOutput)) {
250 |                 mainContent =
251 |                   '[Command produced binary output, which is not shown.]';
252 |               } else {
253 |                 mainContent =
254 |                   result.output.trim() || '(Command produced no output)';
255 |               }
256 | 
257 |               let finalOutput = mainContent;
258 |               let finalStatus = ToolCallStatus.Success;
259 | 
260 |               if (result.error) {
261 |                 finalStatus = ToolCallStatus.Error;
262 |                 finalOutput = `${result.error.message}\n${finalOutput}`;
263 |               } else if (result.aborted) {
264 |                 finalStatus = ToolCallStatus.Canceled;
265 |                 finalOutput = `Command was cancelled.\n${finalOutput}`;
266 |               } else if (result.signal) {
267 |                 finalStatus = ToolCallStatus.Error;
268 |                 finalOutput = `Command terminated by signal: ${result.signal}.\n${finalOutput}`;
269 |               } else if (result.exitCode !== 0) {
270 |                 finalStatus = ToolCallStatus.Error;
271 |                 finalOutput = `Command exited with code ${result.exitCode}.\n${finalOutput}`;
272 |               }
273 | 
274 |               if (pwdFilePath && fs.existsSync(pwdFilePath)) {
275 |                 const finalPwd = fs.readFileSync(pwdFilePath, 'utf8').trim();
276 |                 if (finalPwd && finalPwd !== targetDir) {
277 |                   const warning = `WARNING: shell mode is stateless; the directory change to '${finalPwd}' will not persist.`;
278 |                   finalOutput = `${warning}\n\n${finalOutput}`;
279 |                 }
280 |               }
281 | 
282 |               const finalToolDisplay: IndividualToolCallDisplay = {
283 |                 ...initialToolDisplay,
284 |                 status: finalStatus,
285 |                 resultDisplay: finalOutput,
286 |               };
287 | 
288 |               // Add the complete, contextual result to the local UI history.
289 |               addItemToHistory(
290 |                 {
291 |                   type: 'tool_group',
292 |                   tools: [finalToolDisplay],
293 |                 } as HistoryItemWithoutId,
294 |                 userMessageTimestamp,
295 |               );
296 | 
297 |               // Add the same complete, contextual result to the LLM's history.
298 |               addShellCommandToGeminiHistory(
299 |                 geminiClient,
300 |                 rawQuery,
301 |                 finalOutput,
302 |               );
303 |             })
304 |             .catch((err) => {
305 |               setPendingHistoryItem(null);
306 |               const errorMessage =
307 |                 err instanceof Error ? err.message : String(err);
308 |               addItemToHistory(
309 |                 {
310 |                   type: 'error',
311 |                   text: `An unexpected error occurred: ${errorMessage}`,
312 |                 },
313 |                 userMessageTimestamp,
314 |               );
315 |             })
316 |             .finally(() => {
317 |               abortSignal.removeEventListener('abort', abortHandler);
318 |               if (pwdFilePath && fs.existsSync(pwdFilePath)) {
319 |                 fs.unlinkSync(pwdFilePath);
320 |               }
321 |               setActiveShellPtyId(null);
322 |               setShellInputFocused(false);
323 |               resolve();
324 |             });
325 |         } catch (err) {
326 |           // This block handles synchronous errors from `execute`
327 |           setPendingHistoryItem(null);
328 |           const errorMessage = err instanceof Error ? err.message : String(err);
329 |           addItemToHistory(
330 |             {
331 |               type: 'error',
332 |               text: `An unexpected error occurred: ${errorMessage}`,
333 |             },
334 |             userMessageTimestamp,
335 |           );
336 | 
337 |           // Perform cleanup here as well
338 |           if (pwdFilePath && fs.existsSync(pwdFilePath)) {
339 |             fs.unlinkSync(pwdFilePath);
340 |           }
341 |           setActiveShellPtyId(null);
342 |           setShellInputFocused(false);
343 |           resolve(); // Resolve the promise to unblock `onExec`
344 |         }
345 |       };
346 | 
347 |       const execPromise = new Promise<void>((resolve) => {
348 |         executeCommand(resolve);
349 |       });
350 | 
351 |       onExec(execPromise);
352 |       return true;
353 |     },
354 |     [
355 |       config,
356 |       onDebugMessage,
357 |       addItemToHistory,
358 |       setPendingHistoryItem,
359 |       onExec,
360 |       geminiClient,
361 |       setShellInputFocused,
362 |       terminalHeight,
363 |       terminalWidth,
364 |     ],
365 |   );
366 | 
367 |   return { handleShellCommand, activeShellPtyId };
368 | };
```

src/ui/hooks/slashCommandProcessor.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { act, renderHook, waitFor } from '@testing-library/react';
8 | import { vi, describe, it, expect, beforeEach } from 'vitest';
9 | import { useSlashCommandProcessor } from './slashCommandProcessor.js';
10 | import type {
11 |   CommandContext,
12 |   ConfirmShellCommandsActionReturn,
13 |   SlashCommand,
14 | } from '../commands/types.js';
15 | import { CommandKind } from '../commands/types.js';
16 | import type { LoadedSettings } from '../../config/settings.js';
17 | import { MessageType } from '../types.js';
18 | import { BuiltinCommandLoader } from '../../services/BuiltinCommandLoader.js';
19 | import { FileCommandLoader } from '../../services/FileCommandLoader.js';
20 | import { McpPromptLoader } from '../../services/McpPromptLoader.js';
21 | import {
22 |   type GeminiClient,
23 |   SlashCommandStatus,
24 |   ToolConfirmationOutcome,
25 |   makeFakeConfig,
26 | } from '@google/gemini-cli-core';
27 | 
28 | const { logSlashCommand } = vi.hoisted(() => ({
29 |   logSlashCommand: vi.fn(),
30 | }));
31 | 
32 | vi.mock('@google/gemini-cli-core', async (importOriginal) => {
33 |   const original =
34 |     await importOriginal<typeof import('@google/gemini-cli-core')>();
35 | 
36 |   return {
37 |     ...original,
38 |     logSlashCommand,
39 |     getIdeInstaller: vi.fn().mockReturnValue(null),
40 |   };
41 | });
42 | 
43 | const { mockProcessExit } = vi.hoisted(() => ({
44 |   mockProcessExit: vi.fn((_code?: number): never => undefined as never),
45 | }));
46 | 
47 | vi.mock('node:process', () => {
48 |   const mockProcess: Partial<NodeJS.Process> = {
49 |     exit: mockProcessExit,
50 |     platform: 'sunos',
51 |     cwd: () => '/fake/dir',
52 |   } as unknown as NodeJS.Process;
53 |   return {
54 |     ...mockProcess,
55 |     default: mockProcess,
56 |   };
57 | });
58 | 
59 | const mockBuiltinLoadCommands = vi.fn();
60 | vi.mock('../../services/BuiltinCommandLoader.js', () => ({
61 |   BuiltinCommandLoader: vi.fn().mockImplementation(() => ({
62 |     loadCommands: mockBuiltinLoadCommands,
63 |   })),
64 | }));
65 | 
66 | const mockFileLoadCommands = vi.fn();
67 | vi.mock('../../services/FileCommandLoader.js', () => ({
68 |   FileCommandLoader: vi.fn().mockImplementation(() => ({
69 |     loadCommands: mockFileLoadCommands,
70 |   })),
71 | }));
72 | 
73 | const mockMcpLoadCommands = vi.fn();
74 | vi.mock('../../services/McpPromptLoader.js', () => ({
75 |   McpPromptLoader: vi.fn().mockImplementation(() => ({
76 |     loadCommands: mockMcpLoadCommands,
77 |   })),
78 | }));
79 | 
80 | vi.mock('../contexts/SessionContext.js', () => ({
81 |   useSessionStats: vi.fn(() => ({ stats: {} })),
82 | }));
83 | 
84 | const { mockRunExitCleanup } = vi.hoisted(() => ({
85 |   mockRunExitCleanup: vi.fn(),
86 | }));
87 | 
88 | vi.mock('../../utils/cleanup.js', () => ({
89 |   runExitCleanup: mockRunExitCleanup,
90 | }));
91 | 
92 | function createTestCommand(
93 |   overrides: Partial<SlashCommand>,
94 |   kind: CommandKind = CommandKind.BUILT_IN,
95 | ): SlashCommand {
96 |   return {
97 |     name: 'test',
98 |     description: 'a test command',
99 |     kind,
100 |     ...overrides,
101 |   };
102 | }
103 | 
104 | describe('useSlashCommandProcessor', () => {
105 |   const mockAddItem = vi.fn();
106 |   const mockClearItems = vi.fn();
107 |   const mockLoadHistory = vi.fn();
108 |   const mockOpenThemeDialog = vi.fn();
109 |   const mockOpenAuthDialog = vi.fn();
110 |   const mockOpenModelDialog = vi.fn();
111 |   const mockSetQuittingMessages = vi.fn();
112 | 
113 |   const mockConfig = makeFakeConfig({});
114 |   const mockSettings = {} as LoadedSettings;
115 | 
116 |   beforeEach(() => {
117 |     vi.clearAllMocks();
118 |     vi.mocked(BuiltinCommandLoader).mockClear();
119 |     mockBuiltinLoadCommands.mockResolvedValue([]);
120 |     mockFileLoadCommands.mockResolvedValue([]);
121 |     mockMcpLoadCommands.mockResolvedValue([]);
122 |   });
123 | 
124 |   const setupProcessorHook = (
125 |     builtinCommands: SlashCommand[] = [],
126 |     fileCommands: SlashCommand[] = [],
127 |     mcpCommands: SlashCommand[] = [],
128 |     setIsProcessing = vi.fn(),
129 |   ) => {
130 |     mockBuiltinLoadCommands.mockResolvedValue(Object.freeze(builtinCommands));
131 |     mockFileLoadCommands.mockResolvedValue(Object.freeze(fileCommands));
132 |     mockMcpLoadCommands.mockResolvedValue(Object.freeze(mcpCommands));
133 | 
134 |     const { result } = renderHook(() =>
135 |       useSlashCommandProcessor(
136 |         mockConfig,
137 |         mockSettings,
138 |         mockAddItem,
139 |         mockClearItems,
140 |         mockLoadHistory,
141 |         vi.fn(), // refreshStatic
142 |         vi.fn(), // toggleVimEnabled
143 |         setIsProcessing,
144 |         vi.fn(), // setGeminiMdFileCount
145 |         {
146 |           openAuthDialog: mockOpenAuthDialog,
147 |           openThemeDialog: mockOpenThemeDialog,
148 |           openEditorDialog: vi.fn(),
149 |           openPrivacyNotice: vi.fn(),
150 |           openSettingsDialog: vi.fn(),
151 |           openModelDialog: mockOpenModelDialog,
152 |           quit: mockSetQuittingMessages,
153 |           setDebugMessage: vi.fn(),
154 |           toggleCorgiMode: vi.fn(),
155 |         },
156 |       ),
157 |     );
158 | 
159 |     return result;
160 |   };
161 | 
162 |   describe('Initialization and Command Loading', () => {
163 |     it('should initialize CommandService with all required loaders', () => {
164 |       setupProcessorHook();
165 |       expect(BuiltinCommandLoader).toHaveBeenCalledWith(mockConfig);
166 |       expect(FileCommandLoader).toHaveBeenCalledWith(mockConfig);
167 |       expect(McpPromptLoader).toHaveBeenCalledWith(mockConfig);
168 |     });
169 | 
170 |     it('should call loadCommands and populate state after mounting', async () => {
171 |       const testCommand = createTestCommand({ name: 'test' });
172 |       const result = setupProcessorHook([testCommand]);
173 | 
174 |       await waitFor(() => {
175 |         expect(result.current.slashCommands).toHaveLength(1);
176 |       });
177 | 
178 |       expect(result.current.slashCommands[0]?.name).toBe('test');
179 |       expect(mockBuiltinLoadCommands).toHaveBeenCalledTimes(1);
180 |       expect(mockFileLoadCommands).toHaveBeenCalledTimes(1);
181 |       expect(mockMcpLoadCommands).toHaveBeenCalledTimes(1);
182 |     });
183 | 
184 |     it('should provide an immutable array of commands to consumers', async () => {
185 |       const testCommand = createTestCommand({ name: 'test' });
186 |       const result = setupProcessorHook([testCommand]);
187 | 
188 |       await waitFor(() => {
189 |         expect(result.current.slashCommands).toHaveLength(1);
190 |       });
191 | 
192 |       const commands = result.current.slashCommands;
193 | 
194 |       expect(() => {
195 |         // @ts-expect-error - We are intentionally testing a violation of the readonly type.
196 |         commands.push(createTestCommand({ name: 'rogue' }));
197 |       }).toThrow(TypeError);
198 |     });
199 | 
200 |     it('should override built-in commands with file-based commands of the same name', async () => {
201 |       const builtinAction = vi.fn();
202 |       const fileAction = vi.fn();
203 | 
204 |       const builtinCommand = createTestCommand({
205 |         name: 'override',
206 |         description: 'builtin',
207 |         action: builtinAction,
208 |       });
209 |       const fileCommand = createTestCommand(
210 |         { name: 'override', description: 'file', action: fileAction },
211 |         CommandKind.FILE,
212 |       );
213 | 
214 |       const result = setupProcessorHook([builtinCommand], [fileCommand]);
215 | 
216 |       await waitFor(() => {
217 |         // The service should only return one command with the name 'override'
218 |         expect(result.current.slashCommands).toHaveLength(1);
219 |       });
220 | 
221 |       await act(async () => {
222 |         await result.current.handleSlashCommand('/override');
223 |       });
224 | 
225 |       // Only the file-based command's action should be called.
226 |       expect(fileAction).toHaveBeenCalledTimes(1);
227 |       expect(builtinAction).not.toHaveBeenCalled();
228 |     });
229 |   });
230 | 
231 |   describe('Command Execution Logic', () => {
232 |     it('should display an error for an unknown command', async () => {
233 |       const result = setupProcessorHook();
234 |       await waitFor(() => expect(result.current.slashCommands).toBeDefined());
235 | 
236 |       await act(async () => {
237 |         await result.current.handleSlashCommand('/nonexistent');
238 |       });
239 | 
240 |       // Expect 2 calls: one for the user's input, one for the error message.
241 |       expect(mockAddItem).toHaveBeenCalledTimes(2);
242 |       expect(mockAddItem).toHaveBeenLastCalledWith(
243 |         {
244 |           type: MessageType.ERROR,
245 |           text: 'Unknown command: /nonexistent',
246 |         },
247 |         expect.any(Number),
248 |       );
249 |     });
250 | 
251 |     it('should display help for a parent command invoked without a subcommand', async () => {
252 |       const parentCommand: SlashCommand = {
253 |         name: 'parent',
254 |         description: 'a parent command',
255 |         kind: CommandKind.BUILT_IN,
256 |         subCommands: [
257 |           {
258 |             name: 'child1',
259 |             description: 'First child.',
260 |             kind: CommandKind.BUILT_IN,
261 |           },
262 |         ],
263 |       };
264 |       const result = setupProcessorHook([parentCommand]);
265 |       await waitFor(() => expect(result.current.slashCommands).toHaveLength(1));
266 | 
267 |       await act(async () => {
268 |         await result.current.handleSlashCommand('/parent');
269 |       });
270 | 
271 |       expect(mockAddItem).toHaveBeenCalledTimes(2);
272 |       expect(mockAddItem).toHaveBeenLastCalledWith(
273 |         {
274 |           type: MessageType.INFO,
275 |           text: expect.stringContaining(
276 |             "Command '/parent' requires a subcommand.",
277 |           ),
278 |         },
279 |         expect.any(Number),
280 |       );
281 |     });
282 | 
283 |     it('should correctly find and execute a nested subcommand', async () => {
284 |       const childAction = vi.fn();
285 |       const parentCommand: SlashCommand = {
286 |         name: 'parent',
287 |         description: 'a parent command',
288 |         kind: CommandKind.BUILT_IN,
289 |         subCommands: [
290 |           {
291 |             name: 'child',
292 |             description: 'a child command',
293 |             kind: CommandKind.BUILT_IN,
294 |             action: childAction,
295 |           },
296 |         ],
297 |       };
298 |       const result = setupProcessorHook([parentCommand]);
299 |       await waitFor(() => expect(result.current.slashCommands).toHaveLength(1));
300 | 
301 |       await act(async () => {
302 |         await result.current.handleSlashCommand('/parent child with args');
303 |       });
304 | 
305 |       expect(childAction).toHaveBeenCalledTimes(1);
306 | 
307 |       expect(childAction).toHaveBeenCalledWith(
308 |         expect.objectContaining({
309 |           services: expect.objectContaining({
310 |             config: mockConfig,
311 |           }),
312 |           ui: expect.objectContaining({
313 |             addItem: mockAddItem,
314 |           }),
315 |         }),
316 |         'with args',
317 |       );
318 |     });
319 | 
320 |     it('sets isProcessing to false if the the input is not a command', async () => {
321 |       const setMockIsProcessing = vi.fn();
322 |       const result = setupProcessorHook([], [], [], setMockIsProcessing);
323 | 
324 |       await act(async () => {
325 |         await result.current.handleSlashCommand('imnotacommand');
326 |       });
327 | 
328 |       expect(setMockIsProcessing).not.toHaveBeenCalled();
329 |     });
330 | 
331 |     it('sets isProcessing to false if the command has an error', async () => {
332 |       const setMockIsProcessing = vi.fn();
333 |       const failCommand = createTestCommand({
334 |         name: 'fail',
335 |         action: vi.fn().mockRejectedValue(new Error('oh no!')),
336 |       });
337 | 
338 |       const result = setupProcessorHook(
339 |         [failCommand],
340 |         [],
341 |         [],
342 |         setMockIsProcessing,
343 |       );
344 | 
345 |       await act(async () => {
346 |         await result.current.handleSlashCommand('/fail');
347 |       });
348 | 
349 |       expect(setMockIsProcessing).toHaveBeenNthCalledWith(1, true);
350 |       expect(setMockIsProcessing).toHaveBeenNthCalledWith(2, false);
351 |     });
352 | 
353 |     it('should set isProcessing to true during execution and false afterwards', async () => {
354 |       const mockSetIsProcessing = vi.fn();
355 |       const command = createTestCommand({
356 |         name: 'long-running',
357 |         action: () => new Promise((resolve) => setTimeout(resolve, 50)),
358 |       });
359 | 
360 |       const result = setupProcessorHook([command], [], [], mockSetIsProcessing);
361 |       await waitFor(() => expect(result.current.slashCommands).toHaveLength(1));
362 | 
363 |       const executionPromise = act(async () => {
364 |         await result.current.handleSlashCommand('/long-running');
365 |       });
366 | 
367 |       // It should be true immediately after starting
368 |       expect(mockSetIsProcessing).toHaveBeenNthCalledWith(1, true);
369 |       // It should not have been called with false yet
370 |       expect(mockSetIsProcessing).not.toHaveBeenCalledWith(false);
371 | 
372 |       await executionPromise;
373 | 
374 |       // After the promise resolves, it should be called with false
375 |       expect(mockSetIsProcessing).toHaveBeenNthCalledWith(2, false);
376 |       expect(mockSetIsProcessing).toHaveBeenCalledTimes(2);
377 |     });
378 |   });
379 | 
380 |   describe('Action Result Handling', () => {
381 |     it('should handle "dialog: theme" action', async () => {
382 |       const command = createTestCommand({
383 |         name: 'themecmd',
384 |         action: vi.fn().mockResolvedValue({ type: 'dialog', dialog: 'theme' }),
385 |       });
386 |       const result = setupProcessorHook([command]);
387 |       await waitFor(() => expect(result.current.slashCommands).toHaveLength(1));
388 | 
389 |       await act(async () => {
[TRUNCATED]
```

src/ui/hooks/slashCommandProcessor.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { useCallback, useMemo, useEffect, useState } from 'react';
8 | import { type PartListUnion } from '@google/genai';
9 | import process from 'node:process';
10 | import type { UseHistoryManagerReturn } from './useHistoryManager.js';
11 | import type { Config } from '@google/gemini-cli-core';
12 | import {
13 |   GitService,
14 |   Logger,
15 |   logSlashCommand,
16 |   makeSlashCommandEvent,
17 |   SlashCommandStatus,
18 |   ToolConfirmationOutcome,
19 |   Storage,
20 |   IdeClient,
21 | } from '@google/gemini-cli-core';
22 | import { useSessionStats } from '../contexts/SessionContext.js';
23 | import type {
24 |   Message,
25 |   HistoryItemWithoutId,
26 |   SlashCommandProcessorResult,
27 |   HistoryItem,
28 |   ConfirmationRequest,
29 | } from '../types.js';
30 | import { MessageType } from '../types.js';
31 | import type { LoadedSettings } from '../../config/settings.js';
32 | import { type CommandContext, type SlashCommand } from '../commands/types.js';
33 | import { CommandService } from '../../services/CommandService.js';
34 | import { BuiltinCommandLoader } from '../../services/BuiltinCommandLoader.js';
35 | import { FileCommandLoader } from '../../services/FileCommandLoader.js';
36 | import { McpPromptLoader } from '../../services/McpPromptLoader.js';
37 | import { parseSlashCommand } from '../../utils/commands.js';
38 | import {
39 |   type ExtensionUpdateAction,
40 |   type ExtensionUpdateStatus,
41 | } from '../state/extensions.js';
42 | 
43 | interface SlashCommandProcessorActions {
44 |   openAuthDialog: () => void;
45 |   openThemeDialog: () => void;
46 |   openEditorDialog: () => void;
47 |   openPrivacyNotice: () => void;
48 |   openSettingsDialog: () => void;
49 |   openModelDialog: () => void;
50 |   openPermissionsDialog: () => void;
51 |   quit: (messages: HistoryItem[]) => void;
52 |   setDebugMessage: (message: string) => void;
53 |   toggleCorgiMode: () => void;
54 |   toggleDebugProfiler: () => void;
55 |   dispatchExtensionStateUpdate: (action: ExtensionUpdateAction) => void;
56 |   addConfirmUpdateExtensionRequest: (request: ConfirmationRequest) => void;
57 | }
58 | 
59 | /**
60 |  * Hook to define and process slash commands (e.g., /help, /clear).
61 |  */
62 | export const useSlashCommandProcessor = (
63 |   config: Config | null,
64 |   settings: LoadedSettings,
65 |   addItem: UseHistoryManagerReturn['addItem'],
66 |   clearItems: UseHistoryManagerReturn['clearItems'],
67 |   loadHistory: UseHistoryManagerReturn['loadHistory'],
68 |   refreshStatic: () => void,
69 |   toggleVimEnabled: () => Promise<boolean>,
70 |   setIsProcessing: (isProcessing: boolean) => void,
71 |   setGeminiMdFileCount: (count: number) => void,
72 |   actions: SlashCommandProcessorActions,
73 |   extensionsUpdateState: Map<string, ExtensionUpdateStatus>,
74 |   isConfigInitialized: boolean,
75 | ) => {
76 |   const session = useSessionStats();
77 |   const [commands, setCommands] = useState<readonly SlashCommand[]>([]);
78 |   const [reloadTrigger, setReloadTrigger] = useState(0);
79 | 
80 |   const reloadCommands = useCallback(() => {
81 |     setReloadTrigger((v) => v + 1);
82 |   }, []);
83 |   const [shellConfirmationRequest, setShellConfirmationRequest] =
84 |     useState<null | {
85 |       commands: string[];
86 |       onConfirm: (
87 |         outcome: ToolConfirmationOutcome,
88 |         approvedCommands?: string[],
89 |       ) => void;
90 |     }>(null);
91 |   const [confirmationRequest, setConfirmationRequest] = useState<null | {
92 |     prompt: React.ReactNode;
93 |     onConfirm: (confirmed: boolean) => void;
94 |   }>(null);
95 | 
96 |   const [sessionShellAllowlist, setSessionShellAllowlist] = useState(
97 |     new Set<string>(),
98 |   );
99 |   const gitService = useMemo(() => {
100 |     if (!config?.getProjectRoot()) {
101 |       return;
102 |     }
103 |     return new GitService(config.getProjectRoot(), config.storage);
104 |   }, [config]);
105 | 
106 |   const logger = useMemo(() => {
107 |     const l = new Logger(
108 |       config?.getSessionId() || '',
109 |       config?.storage ?? new Storage(process.cwd()),
110 |     );
111 |     // The logger's initialize is async, but we can create the instance
112 |     // synchronously. Commands that use it will await its initialization.
113 |     return l;
114 |   }, [config]);
115 | 
116 |   const [pendingItem, setPendingItem] = useState<HistoryItemWithoutId | null>(
117 |     null,
118 |   );
119 | 
120 |   const pendingHistoryItems = useMemo(() => {
121 |     const items: HistoryItemWithoutId[] = [];
122 |     if (pendingItem != null) {
123 |       items.push(pendingItem);
124 |     }
125 |     return items;
126 |   }, [pendingItem]);
127 | 
128 |   const addMessage = useCallback(
129 |     (message: Message) => {
130 |       // Convert Message to HistoryItemWithoutId
131 |       let historyItemContent: HistoryItemWithoutId;
132 |       if (message.type === MessageType.ABOUT) {
133 |         historyItemContent = {
134 |           type: 'about',
135 |           cliVersion: message.cliVersion,
136 |           osVersion: message.osVersion,
137 |           sandboxEnv: message.sandboxEnv,
138 |           modelVersion: message.modelVersion,
139 |           selectedAuthType: message.selectedAuthType,
140 |           gcpProject: message.gcpProject,
141 |           ideClient: message.ideClient,
142 |         };
143 |       } else if (message.type === MessageType.HELP) {
144 |         historyItemContent = {
145 |           type: 'help',
146 |           timestamp: message.timestamp,
147 |         };
148 |       } else if (message.type === MessageType.STATS) {
149 |         historyItemContent = {
150 |           type: 'stats',
151 |           duration: message.duration,
152 |         };
153 |       } else if (message.type === MessageType.MODEL_STATS) {
154 |         historyItemContent = {
155 |           type: 'model_stats',
156 |         };
157 |       } else if (message.type === MessageType.TOOL_STATS) {
158 |         historyItemContent = {
159 |           type: 'tool_stats',
160 |         };
161 |       } else if (message.type === MessageType.QUIT) {
162 |         historyItemContent = {
163 |           type: 'quit',
164 |           duration: message.duration,
165 |         };
166 |       } else if (message.type === MessageType.COMPRESSION) {
167 |         historyItemContent = {
168 |           type: 'compression',
169 |           compression: message.compression,
170 |         };
171 |       } else {
172 |         historyItemContent = {
173 |           type: message.type,
174 |           text: message.content,
175 |         };
176 |       }
177 |       addItem(historyItemContent, message.timestamp.getTime());
178 |     },
179 |     [addItem],
180 |   );
181 |   const commandContext = useMemo(
182 |     (): CommandContext => ({
183 |       services: {
184 |         config,
185 |         settings,
186 |         git: gitService,
187 |         logger,
188 |       },
189 |       ui: {
190 |         addItem,
191 |         clear: () => {
192 |           clearItems();
193 |           console.clear();
194 |           refreshStatic();
195 |         },
196 |         loadHistory,
197 |         setDebugMessage: actions.setDebugMessage,
198 |         pendingItem,
199 |         setPendingItem,
200 |         toggleCorgiMode: actions.toggleCorgiMode,
201 |         toggleDebugProfiler: actions.toggleDebugProfiler,
202 |         toggleVimEnabled,
203 |         setGeminiMdFileCount,
204 |         reloadCommands,
205 |         extensionsUpdateState,
206 |         dispatchExtensionStateUpdate: actions.dispatchExtensionStateUpdate,
207 |         addConfirmUpdateExtensionRequest:
208 |           actions.addConfirmUpdateExtensionRequest,
209 |       },
210 |       session: {
211 |         stats: session.stats,
212 |         sessionShellAllowlist,
213 |       },
214 |     }),
215 |     [
216 |       config,
217 |       settings,
218 |       gitService,
219 |       logger,
220 |       loadHistory,
221 |       addItem,
222 |       clearItems,
223 |       refreshStatic,
224 |       session.stats,
225 |       actions,
226 |       pendingItem,
227 |       setPendingItem,
228 |       toggleVimEnabled,
229 |       sessionShellAllowlist,
230 |       setGeminiMdFileCount,
231 |       reloadCommands,
232 |       extensionsUpdateState,
233 |     ],
234 |   );
235 | 
236 |   useEffect(() => {
237 |     if (!config) {
238 |       return;
239 |     }
240 | 
241 |     const listener = () => {
242 |       reloadCommands();
243 |     };
244 | 
245 |     (async () => {
246 |       const ideClient = await IdeClient.getInstance();
247 |       ideClient.addStatusChangeListener(listener);
248 |     })();
249 | 
250 |     return () => {
251 |       (async () => {
252 |         const ideClient = await IdeClient.getInstance();
253 |         ideClient.removeStatusChangeListener(listener);
254 |       })();
255 |     };
256 |   }, [config, reloadCommands]);
257 | 
258 |   useEffect(() => {
259 |     const controller = new AbortController();
260 |     const load = async () => {
261 |       const loaders = [
262 |         new McpPromptLoader(config),
263 |         new BuiltinCommandLoader(config),
264 |         new FileCommandLoader(config),
265 |       ];
266 |       const commandService = await CommandService.create(
267 |         loaders,
268 |         controller.signal,
269 |       );
270 |       setCommands(commandService.getCommands());
271 |     };
272 | 
273 |     load();
274 | 
275 |     return () => {
276 |       controller.abort();
277 |     };
278 |   }, [config, reloadTrigger, isConfigInitialized]);
279 | 
280 |   const handleSlashCommand = useCallback(
281 |     async (
282 |       rawQuery: PartListUnion,
283 |       oneTimeShellAllowlist?: Set<string>,
284 |       overwriteConfirmed?: boolean,
285 |     ): Promise<SlashCommandProcessorResult | false> => {
286 |       if (typeof rawQuery !== 'string') {
287 |         return false;
288 |       }
289 | 
290 |       const trimmed = rawQuery.trim();
291 |       if (!trimmed.startsWith('/') && !trimmed.startsWith('?')) {
292 |         return false;
293 |       }
294 | 
295 |       setIsProcessing(true);
296 | 
297 |       const userMessageTimestamp = Date.now();
298 |       addItem({ type: MessageType.USER, text: trimmed }, userMessageTimestamp);
299 | 
300 |       let hasError = false;
301 |       const {
302 |         commandToExecute,
303 |         args,
304 |         canonicalPath: resolvedCommandPath,
305 |       } = parseSlashCommand(trimmed, commands);
306 | 
307 |       const subcommand =
308 |         resolvedCommandPath.length > 1
309 |           ? resolvedCommandPath.slice(1).join(' ')
310 |           : undefined;
311 | 
312 |       try {
313 |         if (commandToExecute) {
314 |           if (commandToExecute.action) {
315 |             const fullCommandContext: CommandContext = {
316 |               ...commandContext,
317 |               invocation: {
318 |                 raw: trimmed,
319 |                 name: commandToExecute.name,
320 |                 args,
321 |               },
322 |               overwriteConfirmed,
323 |             };
324 | 
325 |             // If a one-time list is provided for a "Proceed" action, temporarily
326 |             // augment the session allowlist for this single execution.
327 |             if (oneTimeShellAllowlist && oneTimeShellAllowlist.size > 0) {
328 |               fullCommandContext.session = {
329 |                 ...fullCommandContext.session,
330 |                 sessionShellAllowlist: new Set([
331 |                   ...fullCommandContext.session.sessionShellAllowlist,
332 |                   ...oneTimeShellAllowlist,
333 |                 ]),
334 |               };
335 |             }
336 |             const result = await commandToExecute.action(
337 |               fullCommandContext,
338 |               args,
339 |             );
340 | 
341 |             if (result) {
342 |               switch (result.type) {
343 |                 case 'tool':
344 |                   return {
345 |                     type: 'schedule_tool',
346 |                     toolName: result.toolName,
347 |                     toolArgs: result.toolArgs,
348 |                   };
349 |                 case 'message':
350 |                   addItem(
351 |                     {
352 |                       type:
353 |                         result.messageType === 'error'
354 |                           ? MessageType.ERROR
355 |                           : MessageType.INFO,
356 |                       text: result.content,
357 |                     },
358 |                     Date.now(),
359 |                   );
360 |                   return { type: 'handled' };
361 |                 case 'dialog':
362 |                   switch (result.dialog) {
363 |                     case 'auth':
364 |                       actions.openAuthDialog();
365 |                       return { type: 'handled' };
366 |                     case 'theme':
367 |                       actions.openThemeDialog();
368 |                       return { type: 'handled' };
369 |                     case 'editor':
370 |                       actions.openEditorDialog();
371 |                       return { type: 'handled' };
372 |                     case 'privacy':
373 |                       actions.openPrivacyNotice();
374 |                       return { type: 'handled' };
375 |                     case 'settings':
376 |                       actions.openSettingsDialog();
377 |                       return { type: 'handled' };
378 |                     case 'model':
379 |                       actions.openModelDialog();
380 |                       return { type: 'handled' };
381 |                     case 'permissions':
382 |                       actions.openPermissionsDialog();
383 |                       return { type: 'handled' };
384 |                     case 'help':
385 |                       return { type: 'handled' };
386 |                     default: {
387 |                       const unhandled: never = result.dialog;
388 |                       throw new Error(
389 |                         `Unhandled slash command result: ${unhandled}`,
390 |                       );
391 |                     }
392 |                   }
393 |                 case 'load_history': {
394 |                   config?.getGeminiClient()?.setHistory(result.clientHistory);
395 |                   config?.getGeminiClient()?.stripThoughtsFromHistory();
396 |                   fullCommandContext.ui.clear();
397 |                   result.history.forEach((item, index) => {
398 |                     fullCommandContext.ui.addItem(item, index);
399 |                   });
400 |                   return { type: 'handled' };
401 |                 }
402 |                 case 'quit':
403 |                   actions.quit(result.messages);
404 |                   return { type: 'handled' };
405 | 
406 |                 case 'submit_prompt':
407 |                   return {
408 |                     type: 'submit_prompt',
409 |                     content: result.content,
410 |                   };
411 |                 case 'confirm_shell_commands': {
412 |                   const { outcome, approvedCommands } = await new Promise<{
413 |                     outcome: ToolConfirmationOutcome;
414 |                     approvedCommands?: string[];
415 |                   }>((resolve) => {
416 |                     setShellConfirmationRequest({
417 |                       commands: result.commandsToConfirm,
418 |                       onConfirm: (
419 |                         resolvedOutcome,
420 |                         resolvedApprovedCommands,
421 |                       ) => {
422 |                         setShellConfirmationRequest(null); // Close the dialog
423 |                         resolve({
424 |                           outcome: resolvedOutcome,
425 |                           approvedCommands: resolvedApprovedCommands,
426 |                         });
427 |                       },
428 |                     });
429 |                   });
430 | 
431 |                   if (
432 |                     outcome === ToolConfirmationOutcome.Cancel ||
433 |                     !approvedCommands ||
434 |                     approvedCommands.length === 0
435 |                   ) {
436 |                     return { type: 'handled' };
437 |                   }
438 | 
439 |                   if (outcome === ToolConfirmationOutcome.ProceedAlways) {
440 |                     setSessionShellAllowlist(
[TRUNCATED]
```

src/ui/hooks/useAtCompletion.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | /** @vitest-environment jsdom */
8 | 
9 | import { describe, it, expect, beforeEach, vi, afterEach } from 'vitest';
10 | import { renderHook, waitFor, act } from '@testing-library/react';
11 | import { useAtCompletion } from './useAtCompletion.js';
12 | import type { Config, FileSearch } from '@google/gemini-cli-core';
13 | import { FileSearchFactory } from '@google/gemini-cli-core';
14 | import type { FileSystemStructure } from '@google/gemini-cli-test-utils';
15 | import { createTmpDir, cleanupTmpDir } from '@google/gemini-cli-test-utils';
16 | import { useState } from 'react';
17 | import type { Suggestion } from '../components/SuggestionsDisplay.js';
18 | 
19 | // Test harness to capture the state from the hook's callbacks.
20 | function useTestHarnessForAtCompletion(
21 |   enabled: boolean,
22 |   pattern: string,
23 |   config: Config | undefined,
24 |   cwd: string,
25 | ) {
26 |   const [suggestions, setSuggestions] = useState<Suggestion[]>([]);
27 |   const [isLoadingSuggestions, setIsLoadingSuggestions] = useState(false);
28 | 
29 |   useAtCompletion({
30 |     enabled,
31 |     pattern,
32 |     config,
33 |     cwd,
34 |     setSuggestions,
35 |     setIsLoadingSuggestions,
36 |   });
37 | 
38 |   return { suggestions, isLoadingSuggestions };
39 | }
40 | 
41 | describe('useAtCompletion', () => {
42 |   let testRootDir: string;
43 |   let mockConfig: Config;
44 | 
45 |   beforeEach(() => {
46 |     mockConfig = {
47 |       getFileFilteringOptions: vi.fn(() => ({
48 |         respectGitIgnore: true,
49 |         respectGeminiIgnore: true,
50 |       })),
51 |       getEnableRecursiveFileSearch: () => true,
52 |       getFileFilteringDisableFuzzySearch: () => false,
53 |     } as unknown as Config;
54 |     vi.clearAllMocks();
55 |   });
56 | 
57 |   afterEach(async () => {
58 |     if (testRootDir) {
59 |       await cleanupTmpDir(testRootDir);
60 |     }
61 |     vi.restoreAllMocks();
62 |   });
63 | 
64 |   describe('File Search Logic', () => {
65 |     it('should perform a recursive search for an empty pattern', async () => {
66 |       const structure: FileSystemStructure = {
67 |         'file.txt': '',
68 |         src: {
69 |           'index.js': '',
70 |           components: ['Button.tsx', 'Button with spaces.tsx'],
71 |         },
72 |       };
73 |       testRootDir = await createTmpDir(structure);
74 | 
75 |       const { result } = renderHook(() =>
76 |         useTestHarnessForAtCompletion(true, '', mockConfig, testRootDir),
77 |       );
78 | 
79 |       await waitFor(() => {
80 |         expect(result.current.suggestions.length).toBeGreaterThan(0);
81 |       });
82 | 
83 |       expect(result.current.suggestions.map((s) => s.value)).toEqual([
84 |         'src/',
85 |         'src/components/',
86 |         'file.txt',
87 |         'src/components/Button\\ with\\ spaces.tsx',
88 |         'src/components/Button.tsx',
89 |         'src/index.js',
90 |       ]);
91 |     });
92 | 
93 |     it('should correctly filter the recursive list based on a pattern', async () => {
94 |       const structure: FileSystemStructure = {
95 |         'file.txt': '',
96 |         src: {
97 |           'index.js': '',
98 |           components: {
99 |             'Button.tsx': '',
100 |           },
101 |         },
102 |       };
103 |       testRootDir = await createTmpDir(structure);
104 | 
105 |       const { result } = renderHook(() =>
106 |         useTestHarnessForAtCompletion(true, 'src/', mockConfig, testRootDir),
107 |       );
108 | 
109 |       await waitFor(() => {
110 |         expect(result.current.suggestions.length).toBeGreaterThan(0);
111 |       });
112 | 
113 |       expect(result.current.suggestions.map((s) => s.value)).toEqual([
114 |         'src/',
115 |         'src/components/',
116 |         'src/index.js',
117 |         'src/components/Button.tsx',
118 |       ]);
119 |     });
120 | 
121 |     it('should append a trailing slash to directory paths in suggestions', async () => {
122 |       const structure: FileSystemStructure = {
123 |         'file.txt': '',
124 |         dir: {},
125 |       };
126 |       testRootDir = await createTmpDir(structure);
127 | 
128 |       const { result } = renderHook(() =>
129 |         useTestHarnessForAtCompletion(true, '', mockConfig, testRootDir),
130 |       );
131 | 
132 |       await waitFor(() => {
133 |         expect(result.current.suggestions.length).toBeGreaterThan(0);
134 |       });
135 | 
136 |       expect(result.current.suggestions.map((s) => s.value)).toEqual([
137 |         'dir/',
138 |         'file.txt',
139 |       ]);
140 |     });
141 |   });
142 | 
143 |   describe('UI State and Loading Behavior', () => {
144 |     it('should be in a loading state during initial file system crawl', async () => {
145 |       testRootDir = await createTmpDir({});
146 |       const { result } = renderHook(() =>
147 |         useTestHarnessForAtCompletion(true, '', mockConfig, testRootDir),
148 |       );
149 | 
150 |       // It's initially true because the effect runs synchronously.
151 |       expect(result.current.isLoadingSuggestions).toBe(true);
152 | 
153 |       // Wait for the loading to complete.
154 |       await waitFor(() => {
155 |         expect(result.current.isLoadingSuggestions).toBe(false);
156 |       });
157 |     });
158 | 
159 |     it('should NOT show a loading indicator for subsequent searches that complete under 200ms', async () => {
160 |       const structure: FileSystemStructure = { 'a.txt': '', 'b.txt': '' };
161 |       testRootDir = await createTmpDir(structure);
162 | 
163 |       const { result, rerender } = renderHook(
164 |         ({ pattern }) =>
165 |           useTestHarnessForAtCompletion(true, pattern, mockConfig, testRootDir),
166 |         { initialProps: { pattern: 'a' } },
167 |       );
168 | 
169 |       await waitFor(() => {
170 |         expect(result.current.suggestions.map((s) => s.value)).toEqual([
171 |           'a.txt',
172 |         ]);
173 |       });
174 |       expect(result.current.isLoadingSuggestions).toBe(false);
175 | 
176 |       rerender({ pattern: 'b' });
177 | 
178 |       // Wait for the final result
179 |       await waitFor(() => {
180 |         expect(result.current.suggestions.map((s) => s.value)).toEqual([
181 |           'b.txt',
182 |         ]);
183 |       });
184 | 
185 |       expect(result.current.isLoadingSuggestions).toBe(false);
186 |     });
187 | 
188 |     it('should show a loading indicator and clear old suggestions for subsequent searches that take longer than 200ms', async () => {
189 |       const structure: FileSystemStructure = { 'a.txt': '', 'b.txt': '' };
190 |       testRootDir = await createTmpDir(structure);
191 | 
192 |       const realFileSearch = FileSearchFactory.create({
193 |         projectRoot: testRootDir,
194 |         ignoreDirs: [],
195 |         useGitignore: true,
196 |         useGeminiignore: true,
197 |         cache: false,
198 |         cacheTtl: 0,
199 |         enableRecursiveFileSearch: true,
200 |         disableFuzzySearch: false,
201 |       });
202 |       await realFileSearch.initialize();
203 | 
204 |       // Mock that returns results immediately but we'll control timing with fake timers
205 |       const mockFileSearch: FileSearch = {
206 |         initialize: vi.fn().mockResolvedValue(undefined),
207 |         search: vi
208 |           .fn()
209 |           .mockImplementation(async (...args) =>
210 |             realFileSearch.search(...args),
211 |           ),
212 |       };
213 |       vi.spyOn(FileSearchFactory, 'create').mockReturnValue(mockFileSearch);
214 | 
215 |       const { result, rerender } = renderHook(
216 |         ({ pattern }) =>
217 |           useTestHarnessForAtCompletion(true, pattern, mockConfig, testRootDir),
218 |         { initialProps: { pattern: 'a' } },
219 |       );
220 | 
221 |       // Wait for the initial search to complete (using real timers)
222 |       await waitFor(() => {
223 |         expect(result.current.suggestions.map((s) => s.value)).toEqual([
224 |           'a.txt',
225 |         ]);
226 |       });
227 | 
228 |       // Now switch to fake timers for precise control of the loading behavior
229 |       vi.useFakeTimers();
230 | 
231 |       // Trigger the second search
232 |       act(() => {
233 |         rerender({ pattern: 'b' });
234 |       });
235 | 
236 |       // Initially, loading should be false (before 200ms timer)
237 |       expect(result.current.isLoadingSuggestions).toBe(false);
238 | 
239 |       // Advance time by exactly 200ms to trigger the loading state
240 |       act(() => {
241 |         vi.advanceTimersByTime(200);
242 |       });
243 | 
244 |       // Now loading should be true and suggestions should be cleared
245 |       expect(result.current.isLoadingSuggestions).toBe(true);
246 |       expect(result.current.suggestions).toEqual([]);
247 | 
248 |       // Switch back to real timers for the final waitFor
249 |       vi.useRealTimers();
250 | 
251 |       // Wait for the search results to be processed
252 |       await waitFor(() => {
253 |         expect(result.current.suggestions.map((s) => s.value)).toEqual([
254 |           'b.txt',
255 |         ]);
256 |       });
257 | 
258 |       expect(result.current.isLoadingSuggestions).toBe(false);
259 |     });
260 | 
261 |     it('should abort the previous search when a new one starts', async () => {
262 |       const structure: FileSystemStructure = { 'a.txt': '', 'b.txt': '' };
263 |       testRootDir = await createTmpDir(structure);
264 | 
265 |       const abortSpy = vi.spyOn(AbortController.prototype, 'abort');
266 |       const mockFileSearch: FileSearch = {
267 |         initialize: vi.fn().mockResolvedValue(undefined),
268 |         search: vi.fn().mockImplementation(async (pattern: string) => {
269 |           const delay = pattern === 'a' ? 500 : 50;
270 |           await new Promise((resolve) => setTimeout(resolve, delay));
271 |           return [pattern];
272 |         }),
273 |       };
274 |       vi.spyOn(FileSearchFactory, 'create').mockReturnValue(mockFileSearch);
275 | 
276 |       const { result, rerender } = renderHook(
277 |         ({ pattern }) =>
278 |           useTestHarnessForAtCompletion(true, pattern, mockConfig, testRootDir),
279 |         { initialProps: { pattern: 'a' } },
280 |       );
281 | 
282 |       // Wait for the hook to be ready (initialization is complete)
283 |       await waitFor(() => {
284 |         expect(mockFileSearch.search).toHaveBeenCalledWith(
285 |           'a',
286 |           expect.any(Object),
287 |         );
288 |       });
289 | 
290 |       // Now that the first search is in-flight, trigger the second one.
291 |       act(() => {
292 |         rerender({ pattern: 'b' });
293 |       });
294 | 
295 |       // The abort should have been called for the first search.
296 |       expect(abortSpy).toHaveBeenCalledTimes(1);
297 | 
298 |       // Wait for the final result, which should be from the second, faster search.
299 |       await waitFor(
300 |         () => {
301 |           expect(result.current.suggestions.map((s) => s.value)).toEqual(['b']);
302 |         },
303 |         { timeout: 1000 },
304 |       );
305 | 
306 |       // The search spy should have been called for both patterns.
307 |       expect(mockFileSearch.search).toHaveBeenCalledWith(
308 |         'b',
309 |         expect.any(Object),
310 |       );
311 |     });
312 |   });
313 | 
314 |   describe('State Management', () => {
315 |     it('should reset the state when disabled after being in a READY state', async () => {
316 |       const structure: FileSystemStructure = { 'a.txt': '' };
317 |       testRootDir = await createTmpDir(structure);
318 | 
319 |       const { result, rerender } = renderHook(
320 |         ({ enabled }) =>
321 |           useTestHarnessForAtCompletion(enabled, 'a', mockConfig, testRootDir),
322 |         { initialProps: { enabled: true } },
323 |       );
324 | 
325 |       // Wait for the hook to be ready and have suggestions
326 |       await waitFor(() => {
327 |         expect(result.current.suggestions.map((s) => s.value)).toEqual([
328 |           'a.txt',
329 |         ]);
330 |       });
331 | 
332 |       // Now, disable the hook
333 |       rerender({ enabled: false });
334 | 
335 |       // The suggestions should be cleared immediately because of the RESET action
336 |       expect(result.current.suggestions).toEqual([]);
337 |     });
338 | 
339 |     it('should reset the state when disabled after being in an ERROR state', async () => {
340 |       testRootDir = await createTmpDir({});
341 | 
342 |       // Force an error during initialization
343 |       const mockFileSearch: FileSearch = {
344 |         initialize: vi
345 |           .fn()
346 |           .mockRejectedValue(new Error('Initialization failed')),
347 |         search: vi.fn(),
348 |       };
349 |       vi.spyOn(FileSearchFactory, 'create').mockReturnValue(mockFileSearch);
350 | 
351 |       const { result, rerender } = renderHook(
352 |         ({ enabled }) =>
353 |           useTestHarnessForAtCompletion(enabled, '', mockConfig, testRootDir),
354 |         { initialProps: { enabled: true } },
355 |       );
356 | 
357 |       // Wait for the hook to enter the error state
358 |       await waitFor(() => {
359 |         expect(result.current.isLoadingSuggestions).toBe(false);
360 |       });
361 |       expect(result.current.suggestions).toEqual([]); // No suggestions on error
362 | 
363 |       // Now, disable the hook
364 |       rerender({ enabled: false });
365 | 
366 |       // The state should still be reset (though visually it's the same)
[TRUNCATED]
```

src/ui/hooks/useAtCompletion.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { useEffect, useReducer, useRef } from 'react';
8 | import type { Config, FileSearch } from '@google/gemini-cli-core';
9 | import { FileSearchFactory, escapePath } from '@google/gemini-cli-core';
10 | import type { Suggestion } from '../components/SuggestionsDisplay.js';
11 | import { MAX_SUGGESTIONS_TO_SHOW } from '../components/SuggestionsDisplay.js';
12 | 
13 | export enum AtCompletionStatus {
14 |   IDLE = 'idle',
15 |   INITIALIZING = 'initializing',
16 |   READY = 'ready',
17 |   SEARCHING = 'searching',
18 |   ERROR = 'error',
19 | }
20 | 
21 | interface AtCompletionState {
22 |   status: AtCompletionStatus;
23 |   suggestions: Suggestion[];
24 |   isLoading: boolean;
25 |   pattern: string | null;
26 | }
27 | 
28 | type AtCompletionAction =
29 |   | { type: 'INITIALIZE' }
30 |   | { type: 'INITIALIZE_SUCCESS' }
31 |   | { type: 'SEARCH'; payload: string }
32 |   | { type: 'SEARCH_SUCCESS'; payload: Suggestion[] }
33 |   | { type: 'SET_LOADING'; payload: boolean }
34 |   | { type: 'ERROR' }
35 |   | { type: 'RESET' };
36 | 
37 | const initialState: AtCompletionState = {
38 |   status: AtCompletionStatus.IDLE,
39 |   suggestions: [],
40 |   isLoading: false,
41 |   pattern: null,
42 | };
43 | 
44 | function atCompletionReducer(
45 |   state: AtCompletionState,
46 |   action: AtCompletionAction,
47 | ): AtCompletionState {
48 |   switch (action.type) {
49 |     case 'INITIALIZE':
50 |       return {
51 |         ...state,
52 |         status: AtCompletionStatus.INITIALIZING,
53 |         isLoading: true,
54 |       };
55 |     case 'INITIALIZE_SUCCESS':
56 |       return { ...state, status: AtCompletionStatus.READY, isLoading: false };
57 |     case 'SEARCH':
58 |       // Keep old suggestions, don't set loading immediately
59 |       return {
60 |         ...state,
61 |         status: AtCompletionStatus.SEARCHING,
62 |         pattern: action.payload,
63 |       };
64 |     case 'SEARCH_SUCCESS':
65 |       return {
66 |         ...state,
67 |         status: AtCompletionStatus.READY,
68 |         suggestions: action.payload,
69 |         isLoading: false,
70 |       };
71 |     case 'SET_LOADING':
72 |       // Only show loading if we are still in a searching state
73 |       if (state.status === AtCompletionStatus.SEARCHING) {
74 |         return { ...state, isLoading: action.payload, suggestions: [] };
75 |       }
76 |       return state;
77 |     case 'ERROR':
78 |       return {
79 |         ...state,
80 |         status: AtCompletionStatus.ERROR,
81 |         isLoading: false,
82 |         suggestions: [],
83 |       };
84 |     case 'RESET':
85 |       return initialState;
86 |     default:
87 |       return state;
88 |   }
89 | }
90 | 
91 | export interface UseAtCompletionProps {
92 |   enabled: boolean;
93 |   pattern: string;
94 |   config: Config | undefined;
95 |   cwd: string;
96 |   setSuggestions: (suggestions: Suggestion[]) => void;
97 |   setIsLoadingSuggestions: (isLoading: boolean) => void;
98 | }
99 | 
100 | export function useAtCompletion(props: UseAtCompletionProps): void {
101 |   const {
102 |     enabled,
103 |     pattern,
104 |     config,
105 |     cwd,
106 |     setSuggestions,
107 |     setIsLoadingSuggestions,
108 |   } = props;
109 |   const [state, dispatch] = useReducer(atCompletionReducer, initialState);
110 |   const fileSearch = useRef<FileSearch | null>(null);
111 |   const searchAbortController = useRef<AbortController | null>(null);
112 |   const slowSearchTimer = useRef<NodeJS.Timeout | null>(null);
113 | 
114 |   useEffect(() => {
115 |     setSuggestions(state.suggestions);
116 |   }, [state.suggestions, setSuggestions]);
117 | 
118 |   useEffect(() => {
119 |     setIsLoadingSuggestions(state.isLoading);
120 |   }, [state.isLoading, setIsLoadingSuggestions]);
121 | 
122 |   useEffect(() => {
123 |     dispatch({ type: 'RESET' });
124 |   }, [cwd, config]);
125 | 
126 |   // Reacts to user input (`pattern`) ONLY.
127 |   useEffect(() => {
128 |     if (!enabled) {
129 |       // reset when first getting out of completion suggestions
130 |       if (
131 |         state.status === AtCompletionStatus.READY ||
132 |         state.status === AtCompletionStatus.ERROR
133 |       ) {
134 |         dispatch({ type: 'RESET' });
135 |       }
136 |       return;
137 |     }
138 |     if (pattern === null) {
139 |       dispatch({ type: 'RESET' });
140 |       return;
141 |     }
142 | 
143 |     if (state.status === AtCompletionStatus.IDLE) {
144 |       dispatch({ type: 'INITIALIZE' });
145 |     } else if (
146 |       (state.status === AtCompletionStatus.READY ||
147 |         state.status === AtCompletionStatus.SEARCHING) &&
148 |       pattern !== state.pattern // Only search if the pattern has changed
149 |     ) {
150 |       dispatch({ type: 'SEARCH', payload: pattern });
151 |     }
152 |   }, [enabled, pattern, state.status, state.pattern]);
153 | 
154 |   // The "Worker" that performs async operations based on status.
155 |   useEffect(() => {
156 |     const initialize = async () => {
157 |       try {
158 |         const searcher = FileSearchFactory.create({
159 |           projectRoot: cwd,
160 |           ignoreDirs: [],
161 |           useGitignore:
162 |             config?.getFileFilteringOptions()?.respectGitIgnore ?? true,
163 |           useGeminiignore:
164 |             config?.getFileFilteringOptions()?.respectGeminiIgnore ?? true,
165 |           cache: true,
166 |           cacheTtl: 30, // 30 seconds
167 |           enableRecursiveFileSearch:
168 |             config?.getEnableRecursiveFileSearch() ?? true,
169 |           disableFuzzySearch:
170 |             config?.getFileFilteringDisableFuzzySearch() ?? false,
171 |         });
172 |         await searcher.initialize();
173 |         fileSearch.current = searcher;
174 |         dispatch({ type: 'INITIALIZE_SUCCESS' });
175 |         if (state.pattern !== null) {
176 |           dispatch({ type: 'SEARCH', payload: state.pattern });
177 |         }
178 |       } catch (_) {
179 |         dispatch({ type: 'ERROR' });
180 |       }
181 |     };
182 | 
183 |     const search = async () => {
184 |       if (!fileSearch.current || state.pattern === null) {
185 |         return;
186 |       }
187 | 
188 |       if (slowSearchTimer.current) {
189 |         clearTimeout(slowSearchTimer.current);
190 |       }
191 | 
192 |       const controller = new AbortController();
193 |       searchAbortController.current = controller;
194 | 
195 |       slowSearchTimer.current = setTimeout(() => {
196 |         dispatch({ type: 'SET_LOADING', payload: true });
197 |       }, 200);
198 | 
199 |       try {
200 |         const results = await fileSearch.current.search(state.pattern, {
201 |           signal: controller.signal,
202 |           maxResults: MAX_SUGGESTIONS_TO_SHOW * 3,
203 |         });
204 | 
205 |         if (slowSearchTimer.current) {
206 |           clearTimeout(slowSearchTimer.current);
207 |         }
208 | 
209 |         if (controller.signal.aborted) {
210 |           return;
211 |         }
212 | 
213 |         const suggestions = results.map((p) => ({
214 |           label: p,
215 |           value: escapePath(p),
216 |         }));
217 |         dispatch({ type: 'SEARCH_SUCCESS', payload: suggestions });
218 |       } catch (error) {
219 |         if (!(error instanceof Error && error.name === 'AbortError')) {
220 |           dispatch({ type: 'ERROR' });
221 |         }
222 |       }
223 |     };
224 | 
225 |     if (state.status === AtCompletionStatus.INITIALIZING) {
226 |       initialize();
227 |     } else if (state.status === AtCompletionStatus.SEARCHING) {
228 |       search();
229 |     }
230 | 
231 |     return () => {
232 |       searchAbortController.current?.abort();
233 |       if (slowSearchTimer.current) {
234 |         clearTimeout(slowSearchTimer.current);
235 |       }
236 |     };
237 |   }, [state.status, state.pattern, config, cwd]);
238 | }
```

src/ui/hooks/useAutoAcceptIndicator.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import {
8 |   describe,
9 |   it,
10 |   expect,
11 |   vi,
12 |   beforeEach,
13 |   type MockedFunction,
14 |   type Mock,
15 | } from 'vitest';
16 | import { renderHook, act } from '@testing-library/react';
17 | import { useAutoAcceptIndicator } from './useAutoAcceptIndicator.js';
18 | 
19 | import { Config, ApprovalMode } from '@google/gemini-cli-core';
20 | import type { Config as ActualConfigType } from '@google/gemini-cli-core';
21 | import type { Key } from './useKeypress.js';
22 | import { useKeypress } from './useKeypress.js';
23 | import { MessageType } from '../types.js';
24 | 
25 | vi.mock('./useKeypress.js');
26 | 
27 | vi.mock('@google/gemini-cli-core', async () => {
28 |   const actualServerModule = (await vi.importActual(
29 |     '@google/gemini-cli-core',
30 |   )) as Record<string, unknown>;
31 |   return {
32 |     ...actualServerModule,
33 |     Config: vi.fn(),
34 |   };
35 | });
36 | 
37 | interface MockConfigInstanceShape {
38 |   getApprovalMode: Mock<() => ApprovalMode>;
39 |   setApprovalMode: Mock<(value: ApprovalMode) => void>;
40 |   isTrustedFolder: Mock<() => boolean>;
41 |   getCoreTools: Mock<() => string[]>;
42 |   getToolDiscoveryCommand: Mock<() => string | undefined>;
43 |   getTargetDir: Mock<() => string>;
44 |   getApiKey: Mock<() => string>;
45 |   getModel: Mock<() => string>;
46 |   getSandbox: Mock<() => boolean | string>;
47 |   getDebugMode: Mock<() => boolean>;
48 |   getQuestion: Mock<() => string | undefined>;
49 |   getFullContext: Mock<() => boolean>;
50 |   getUserAgent: Mock<() => string>;
51 |   getUserMemory: Mock<() => string>;
52 |   getGeminiMdFileCount: Mock<() => number>;
53 |   getToolRegistry: Mock<() => { discoverTools: Mock<() => void> }>;
54 | }
55 | 
56 | type UseKeypressHandler = (key: Key) => void;
57 | 
58 | describe('useAutoAcceptIndicator', () => {
59 |   let mockConfigInstance: MockConfigInstanceShape;
60 |   let capturedUseKeypressHandler: UseKeypressHandler;
61 |   let mockedUseKeypress: MockedFunction<typeof useKeypress>;
62 | 
63 |   beforeEach(() => {
64 |     vi.resetAllMocks();
65 | 
66 |     (
67 |       Config as unknown as MockedFunction<() => MockConfigInstanceShape>
68 |     ).mockImplementation(() => {
69 |       const instanceGetApprovalModeMock = vi.fn();
70 |       const instanceSetApprovalModeMock = vi.fn();
71 | 
72 |       const instance: MockConfigInstanceShape = {
73 |         getApprovalMode: instanceGetApprovalModeMock as Mock<
74 |           () => ApprovalMode
75 |         >,
76 |         setApprovalMode: instanceSetApprovalModeMock as Mock<
77 |           (value: ApprovalMode) => void
78 |         >,
79 |         isTrustedFolder: vi.fn().mockReturnValue(true) as Mock<() => boolean>,
80 |         getCoreTools: vi.fn().mockReturnValue([]) as Mock<() => string[]>,
81 |         getToolDiscoveryCommand: vi.fn().mockReturnValue(undefined) as Mock<
82 |           () => string | undefined
83 |         >,
84 |         getTargetDir: vi.fn().mockReturnValue('.') as Mock<() => string>,
85 |         getApiKey: vi.fn().mockReturnValue('test-api-key') as Mock<
86 |           () => string
87 |         >,
88 |         getModel: vi.fn().mockReturnValue('test-model') as Mock<() => string>,
89 |         getSandbox: vi.fn().mockReturnValue(false) as Mock<
90 |           () => boolean | string
91 |         >,
92 |         getDebugMode: vi.fn().mockReturnValue(false) as Mock<() => boolean>,
93 |         getQuestion: vi.fn().mockReturnValue(undefined) as Mock<
94 |           () => string | undefined
95 |         >,
96 |         getFullContext: vi.fn().mockReturnValue(false) as Mock<() => boolean>,
97 |         getUserAgent: vi.fn().mockReturnValue('test-user-agent') as Mock<
98 |           () => string
99 |         >,
100 |         getUserMemory: vi.fn().mockReturnValue('') as Mock<() => string>,
101 |         getGeminiMdFileCount: vi.fn().mockReturnValue(0) as Mock<() => number>,
102 |         getToolRegistry: vi
103 |           .fn()
104 |           .mockReturnValue({ discoverTools: vi.fn() }) as Mock<
105 |           () => { discoverTools: Mock<() => void> }
106 |         >,
107 |       };
108 |       instanceSetApprovalModeMock.mockImplementation((value: ApprovalMode) => {
109 |         instanceGetApprovalModeMock.mockReturnValue(value);
110 |       });
111 |       return instance;
112 |     });
113 | 
114 |     mockedUseKeypress = useKeypress as MockedFunction<typeof useKeypress>;
115 |     mockedUseKeypress.mockImplementation(
116 |       (handler: UseKeypressHandler, _options) => {
117 |         capturedUseKeypressHandler = handler;
118 |       },
119 |     );
120 | 
121 |     // eslint-disable-next-line @typescript-eslint/no-explicit-any
122 |     mockConfigInstance = new (Config as any)() as MockConfigInstanceShape;
123 |   });
124 | 
125 |   it('should initialize with ApprovalMode.AUTO_EDIT if config.getApprovalMode returns ApprovalMode.AUTO_EDIT', () => {
126 |     mockConfigInstance.getApprovalMode.mockReturnValue(ApprovalMode.AUTO_EDIT);
127 |     const { result } = renderHook(() =>
128 |       useAutoAcceptIndicator({
129 |         config: mockConfigInstance as unknown as ActualConfigType,
130 |         addItem: vi.fn(),
131 |       }),
132 |     );
133 |     expect(result.current).toBe(ApprovalMode.AUTO_EDIT);
134 |     expect(mockConfigInstance.getApprovalMode).toHaveBeenCalledTimes(1);
135 |   });
136 | 
137 |   it('should initialize with ApprovalMode.DEFAULT if config.getApprovalMode returns ApprovalMode.DEFAULT', () => {
138 |     mockConfigInstance.getApprovalMode.mockReturnValue(ApprovalMode.DEFAULT);
139 |     const { result } = renderHook(() =>
140 |       useAutoAcceptIndicator({
141 |         config: mockConfigInstance as unknown as ActualConfigType,
142 |         addItem: vi.fn(),
143 |       }),
144 |     );
145 |     expect(result.current).toBe(ApprovalMode.DEFAULT);
146 |     expect(mockConfigInstance.getApprovalMode).toHaveBeenCalledTimes(1);
147 |   });
148 | 
149 |   it('should initialize with ApprovalMode.YOLO if config.getApprovalMode returns ApprovalMode.YOLO', () => {
150 |     mockConfigInstance.getApprovalMode.mockReturnValue(ApprovalMode.YOLO);
151 |     const { result } = renderHook(() =>
152 |       useAutoAcceptIndicator({
153 |         config: mockConfigInstance as unknown as ActualConfigType,
154 |         addItem: vi.fn(),
155 |       }),
156 |     );
157 |     expect(result.current).toBe(ApprovalMode.YOLO);
158 |     expect(mockConfigInstance.getApprovalMode).toHaveBeenCalledTimes(1);
159 |   });
160 | 
161 |   it('should toggle the indicator and update config when Shift+Tab or Ctrl+Y is pressed', () => {
162 |     mockConfigInstance.getApprovalMode.mockReturnValue(ApprovalMode.DEFAULT);
163 |     const { result } = renderHook(() =>
164 |       useAutoAcceptIndicator({
165 |         config: mockConfigInstance as unknown as ActualConfigType,
166 |         addItem: vi.fn(),
167 |       }),
168 |     );
169 |     expect(result.current).toBe(ApprovalMode.DEFAULT);
170 | 
171 |     act(() => {
172 |       capturedUseKeypressHandler({
173 |         name: 'tab',
174 |         shift: true,
175 |       } as Key);
176 |     });
177 |     expect(mockConfigInstance.setApprovalMode).toHaveBeenCalledWith(
178 |       ApprovalMode.AUTO_EDIT,
179 |     );
180 |     expect(result.current).toBe(ApprovalMode.AUTO_EDIT);
181 | 
182 |     act(() => {
183 |       capturedUseKeypressHandler({ name: 'y', ctrl: true } as Key);
184 |     });
185 |     expect(mockConfigInstance.setApprovalMode).toHaveBeenCalledWith(
186 |       ApprovalMode.YOLO,
187 |     );
188 |     expect(result.current).toBe(ApprovalMode.YOLO);
189 | 
190 |     act(() => {
191 |       capturedUseKeypressHandler({ name: 'y', ctrl: true } as Key);
192 |     });
193 |     expect(mockConfigInstance.setApprovalMode).toHaveBeenCalledWith(
194 |       ApprovalMode.DEFAULT,
195 |     );
196 |     expect(result.current).toBe(ApprovalMode.DEFAULT);
197 | 
198 |     act(() => {
199 |       capturedUseKeypressHandler({ name: 'y', ctrl: true } as Key);
200 |     });
201 |     expect(mockConfigInstance.setApprovalMode).toHaveBeenCalledWith(
202 |       ApprovalMode.YOLO,
203 |     );
204 |     expect(result.current).toBe(ApprovalMode.YOLO);
205 | 
206 |     act(() => {
207 |       capturedUseKeypressHandler({
208 |         name: 'tab',
209 |         shift: true,
210 |       } as Key);
211 |     });
212 |     expect(mockConfigInstance.setApprovalMode).toHaveBeenCalledWith(
213 |       ApprovalMode.AUTO_EDIT,
214 |     );
215 |     expect(result.current).toBe(ApprovalMode.AUTO_EDIT);
216 | 
217 |     act(() => {
218 |       capturedUseKeypressHandler({
219 |         name: 'tab',
220 |         shift: true,
221 |       } as Key);
222 |     });
223 |     expect(mockConfigInstance.setApprovalMode).toHaveBeenCalledWith(
224 |       ApprovalMode.DEFAULT,
225 |     );
226 |     expect(result.current).toBe(ApprovalMode.DEFAULT);
227 |   });
228 | 
229 |   it('should not toggle if only one key or other keys combinations are pressed', () => {
230 |     mockConfigInstance.getApprovalMode.mockReturnValue(ApprovalMode.DEFAULT);
231 |     renderHook(() =>
232 |       useAutoAcceptIndicator({
233 |         config: mockConfigInstance as unknown as ActualConfigType,
234 |         addItem: vi.fn(),
235 |       }),
236 |     );
237 | 
238 |     act(() => {
239 |       capturedUseKeypressHandler({
240 |         name: 'tab',
241 |         shift: false,
242 |       } as Key);
243 |     });
244 |     expect(mockConfigInstance.setApprovalMode).not.toHaveBeenCalled();
245 | 
246 |     act(() => {
247 |       capturedUseKeypressHandler({
248 |         name: 'unknown',
249 |         shift: true,
250 |       } as Key);
251 |     });
252 |     expect(mockConfigInstance.setApprovalMode).not.toHaveBeenCalled();
253 | 
254 |     act(() => {
255 |       capturedUseKeypressHandler({
256 |         name: 'a',
257 |         shift: false,
258 |         ctrl: false,
259 |       } as Key);
260 |     });
261 |     expect(mockConfigInstance.setApprovalMode).not.toHaveBeenCalled();
262 | 
263 |     act(() => {
264 |       capturedUseKeypressHandler({ name: 'y', ctrl: false } as Key);
265 |     });
266 |     expect(mockConfigInstance.setApprovalMode).not.toHaveBeenCalled();
267 | 
268 |     act(() => {
269 |       capturedUseKeypressHandler({ name: 'a', ctrl: true } as Key);
270 |     });
271 |     expect(mockConfigInstance.setApprovalMode).not.toHaveBeenCalled();
272 | 
273 |     act(() => {
274 |       capturedUseKeypressHandler({ name: 'y', shift: true } as Key);
275 |     });
276 |     expect(mockConfigInstance.setApprovalMode).not.toHaveBeenCalled();
277 | 
278 |     act(() => {
279 |       capturedUseKeypressHandler({
280 |         name: 'a',
281 |         ctrl: true,
282 |         shift: true,
283 |       } as Key);
284 |     });
285 |     expect(mockConfigInstance.setApprovalMode).not.toHaveBeenCalled();
286 |   });
287 | 
288 |   it('should update indicator when config value changes externally (useEffect dependency)', () => {
289 |     mockConfigInstance.getApprovalMode.mockReturnValue(ApprovalMode.DEFAULT);
290 |     const { result, rerender } = renderHook(
291 |       (props: { config: ActualConfigType; addItem: () => void }) =>
292 |         useAutoAcceptIndicator(props),
293 |       {
294 |         initialProps: {
295 |           config: mockConfigInstance as unknown as ActualConfigType,
296 |           addItem: vi.fn(),
297 |         },
298 |       },
299 |     );
300 |     expect(result.current).toBe(ApprovalMode.DEFAULT);
301 | 
302 |     mockConfigInstance.getApprovalMode.mockReturnValue(ApprovalMode.AUTO_EDIT);
303 | 
304 |     rerender({
305 |       config: mockConfigInstance as unknown as ActualConfigType,
306 |       addItem: vi.fn(),
307 |     });
308 |     expect(result.current).toBe(ApprovalMode.AUTO_EDIT);
309 |     expect(mockConfigInstance.getApprovalMode).toHaveBeenCalledTimes(3);
310 |   });
311 | 
312 |   describe('in untrusted folders', () => {
313 |     beforeEach(() => {
314 |       mockConfigInstance.isTrustedFolder.mockReturnValue(false);
315 |     });
316 | 
317 |     it('should not enable YOLO mode when Ctrl+Y is pressed', () => {
318 |       mockConfigInstance.getApprovalMode.mockReturnValue(ApprovalMode.DEFAULT);
319 |       mockConfigInstance.setApprovalMode.mockImplementation(() => {
320 |         throw new Error(
321 |           'Cannot enable privileged approval modes in an untrusted folder.',
322 |         );
323 |       });
324 |       const mockAddItem = vi.fn();
325 |       const { result } = renderHook(() =>
326 |         useAutoAcceptIndicator({
327 |           config: mockConfigInstance as unknown as ActualConfigType,
328 |           addItem: mockAddItem,
329 |         }),
330 |       );
331 | 
332 |       expect(result.current).toBe(ApprovalMode.DEFAULT);
333 | 
334 |       act(() => {
335 |         capturedUseKeypressHandler({ name: 'y', ctrl: true } as Key);
336 |       });
337 | 
338 |       // We expect setApprovalMode to be called, and the error to be caught.
339 |       expect(mockConfigInstance.setApprovalMode).toHaveBeenCalledWith(
340 |         ApprovalMode.YOLO,
341 |       );
342 |       expect(mockAddItem).toHaveBeenCalled();
343 |       // Verify the underlying config value was not changed
344 |       expect(mockConfigInstance.getApprovalMode()).toBe(ApprovalMode.DEFAULT);
345 |     });
346 | 
347 |     it('should not enable AUTO_EDIT mode when Shift+Tab is pressed', () => {
348 |       mockConfigInstance.getApprovalMode.mockReturnValue(ApprovalMode.DEFAULT);
349 |       mockConfigInstance.setApprovalMode.mockImplementation(() => {
350 |         throw new Error(
351 |           'Cannot enable privileged approval modes in an untrusted folder.',
352 |         );
353 |       });
354 |       const mockAddItem = vi.fn();
355 |       const { result } = renderHook(() =>
356 |         useAutoAcceptIndicator({
357 |           config: mockConfigInstance as unknown as ActualConfigType,
358 |           addItem: mockAddItem,
359 |         }),
360 |       );
361 | 
362 |       expect(result.current).toBe(ApprovalMode.DEFAULT);
363 | 
364 |       act(() => {
365 |         capturedUseKeypressHandler({
366 |           name: 'tab',
367 |           shift: true,
368 |         } as Key);
369 |       });
370 | 
371 |       // We expect setApprovalMode to be called, and the error to be caught.
372 |       expect(mockConfigInstance.setApprovalMode).toHaveBeenCalledWith(
373 |         ApprovalMode.AUTO_EDIT,
374 |       );
375 |       expect(mockAddItem).toHaveBeenCalled();
376 |       // Verify the underlying config value was not changed
377 |       expect(mockConfigInstance.getApprovalMode()).toBe(ApprovalMode.DEFAULT);
378 |     });
[TRUNCATED]
```

src/ui/hooks/useAutoAcceptIndicator.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { useState, useEffect } from 'react';
8 | import { ApprovalMode, type Config } from '@google/gemini-cli-core';
9 | import { useKeypress } from './useKeypress.js';
10 | import type { HistoryItemWithoutId } from '../types.js';
11 | import { MessageType } from '../types.js';
12 | 
13 | export interface UseAutoAcceptIndicatorArgs {
14 |   config: Config;
15 |   addItem?: (item: HistoryItemWithoutId, timestamp: number) => void;
16 |   onApprovalModeChange?: (mode: ApprovalMode) => void;
17 | }
18 | 
19 | export function useAutoAcceptIndicator({
20 |   config,
21 |   addItem,
22 |   onApprovalModeChange,
23 | }: UseAutoAcceptIndicatorArgs): ApprovalMode {
24 |   const currentConfigValue = config.getApprovalMode();
25 |   const [showAutoAcceptIndicator, setShowAutoAcceptIndicator] =
26 |     useState(currentConfigValue);
27 | 
28 |   useEffect(() => {
29 |     setShowAutoAcceptIndicator(currentConfigValue);
30 |   }, [currentConfigValue]);
31 | 
32 |   useKeypress(
33 |     (key) => {
34 |       let nextApprovalMode: ApprovalMode | undefined;
35 | 
36 |       if (key.ctrl && key.name === 'y') {
37 |         nextApprovalMode =
38 |           config.getApprovalMode() === ApprovalMode.YOLO
39 |             ? ApprovalMode.DEFAULT
40 |             : ApprovalMode.YOLO;
41 |       } else if (key.shift && key.name === 'tab') {
42 |         nextApprovalMode =
43 |           config.getApprovalMode() === ApprovalMode.AUTO_EDIT
44 |             ? ApprovalMode.DEFAULT
45 |             : ApprovalMode.AUTO_EDIT;
46 |       }
47 | 
48 |       if (nextApprovalMode) {
49 |         try {
50 |           config.setApprovalMode(nextApprovalMode);
51 |           // Update local state immediately for responsiveness
52 |           setShowAutoAcceptIndicator(nextApprovalMode);
53 | 
54 |           // Notify the central handler about the approval mode change
55 |           onApprovalModeChange?.(nextApprovalMode);
56 |         } catch (e) {
57 |           if (addItem) {
58 |             addItem(
59 |               {
60 |                 type: MessageType.INFO,
61 |                 text: (e as Error).message,
62 |               },
63 |               Date.now(),
64 |             );
65 |           }
66 |         }
67 |       }
68 |     },
69 |     { isActive: true },
70 |   );
71 | 
72 |   return showAutoAcceptIndicator;
73 | }
```

src/ui/hooks/useBracketedPaste.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { useEffect } from 'react';
8 | 
9 | const ENABLE_BRACKETED_PASTE = '\x1b[?2004h';
10 | const DISABLE_BRACKETED_PASTE = '\x1b[?2004l';
11 | 
12 | /**
13 |  * Enables and disables bracketed paste mode in the terminal.
14 |  *
15 |  * This hook ensures that bracketed paste mode is enabled when the component
16 |  * mounts and disabled when it unmounts or when the process exits.
17 |  */
18 | export const useBracketedPaste = () => {
19 |   const cleanup = () => {
20 |     process.stdout.write(DISABLE_BRACKETED_PASTE);
21 |   };
22 | 
23 |   useEffect(() => {
24 |     process.stdout.write(ENABLE_BRACKETED_PASTE);
25 | 
26 |     process.on('exit', cleanup);
27 |     process.on('SIGINT', cleanup);
28 |     process.on('SIGTERM', cleanup);
29 | 
30 |     return () => {
31 |       cleanup();
32 |       process.removeListener('exit', cleanup);
33 |       process.removeListener('SIGINT', cleanup);
34 |       process.removeListener('SIGTERM', cleanup);
35 |     };
36 |   }, []);
37 | };
```

src/ui/hooks/useCommandCompletion.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | /** @vitest-environment jsdom */
8 | 
9 | import { describe, it, expect, beforeEach, vi, afterEach } from 'vitest';
10 | import { renderHook, act, waitFor } from '@testing-library/react';
11 | import { useCommandCompletion } from './useCommandCompletion.js';
12 | import type { CommandContext } from '../commands/types.js';
13 | import type { Config } from '@google/gemini-cli-core';
14 | import { useTextBuffer } from '../components/shared/text-buffer.js';
15 | import { useEffect } from 'react';
16 | import type { Suggestion } from '../components/SuggestionsDisplay.js';
17 | import type { UseAtCompletionProps } from './useAtCompletion.js';
18 | import { useAtCompletion } from './useAtCompletion.js';
19 | import type { UseSlashCompletionProps } from './useSlashCompletion.js';
20 | import { useSlashCompletion } from './useSlashCompletion.js';
21 | 
22 | vi.mock('./useAtCompletion', () => ({
23 |   useAtCompletion: vi.fn(),
24 | }));
25 | 
26 | vi.mock('./useSlashCompletion', () => ({
27 |   useSlashCompletion: vi.fn(() => ({
28 |     completionStart: 0,
29 |     completionEnd: 0,
30 |   })),
31 | }));
32 | 
33 | // Helper to set up mocks in a consistent way for both child hooks
34 | const setupMocks = ({
35 |   atSuggestions = [],
36 |   slashSuggestions = [],
37 |   isLoading = false,
38 |   isPerfectMatch = false,
39 |   slashCompletionRange = { completionStart: 0, completionEnd: 0 },
40 | }: {
41 |   atSuggestions?: Suggestion[];
42 |   slashSuggestions?: Suggestion[];
43 |   isLoading?: boolean;
44 |   isPerfectMatch?: boolean;
45 |   slashCompletionRange?: { completionStart: number; completionEnd: number };
46 | }) => {
47 |   // Mock for @-completions
48 |   (useAtCompletion as vi.Mock).mockImplementation(
49 |     ({
50 |       enabled,
51 |       setSuggestions,
52 |       setIsLoadingSuggestions,
53 |     }: UseAtCompletionProps) => {
54 |       useEffect(() => {
55 |         if (enabled) {
56 |           setIsLoadingSuggestions(isLoading);
57 |           setSuggestions(atSuggestions);
58 |         }
59 |       }, [enabled, setSuggestions, setIsLoadingSuggestions]);
60 |     },
61 |   );
62 | 
63 |   // Mock for /-completions
64 |   (useSlashCompletion as vi.Mock).mockImplementation(
65 |     ({
66 |       enabled,
67 |       setSuggestions,
68 |       setIsLoadingSuggestions,
69 |       setIsPerfectMatch,
70 |     }: UseSlashCompletionProps) => {
71 |       useEffect(() => {
72 |         if (enabled) {
73 |           setIsLoadingSuggestions(isLoading);
74 |           setSuggestions(slashSuggestions);
75 |           setIsPerfectMatch(isPerfectMatch);
76 |         }
77 |       }, [enabled, setSuggestions, setIsLoadingSuggestions, setIsPerfectMatch]);
78 |       // The hook returns a range, which we can mock simply
79 |       return slashCompletionRange;
80 |     },
81 |   );
82 | };
83 | 
84 | describe('useCommandCompletion', () => {
85 |   const mockCommandContext = {} as CommandContext;
86 |   const mockConfig = {
87 |     getEnablePromptCompletion: () => false,
88 |   } as Config;
89 |   const testDirs: string[] = [];
90 |   const testRootDir = '/';
91 | 
92 |   // Helper to create real TextBuffer objects within renderHook
93 |   function useTextBufferForTest(text: string, cursorOffset?: number) {
94 |     return useTextBuffer({
95 |       initialText: text,
96 |       initialCursorOffset: cursorOffset ?? text.length,
97 |       viewport: { width: 80, height: 20 },
98 |       isValidPath: () => false,
99 |       onChange: () => {},
100 |     });
101 |   }
102 | 
103 |   beforeEach(() => {
104 |     vi.clearAllMocks();
105 |     // Reset to default mocks before each test
106 |     setupMocks({});
107 |   });
108 | 
109 |   afterEach(() => {
110 |     vi.restoreAllMocks();
111 |   });
112 | 
113 |   describe('Core Hook Behavior', () => {
114 |     describe('State Management', () => {
115 |       it('should initialize with default state', () => {
116 |         const { result } = renderHook(() =>
117 |           useCommandCompletion(
118 |             useTextBufferForTest(''),
119 |             testDirs,
120 |             testRootDir,
121 |             [],
122 |             mockCommandContext,
123 |             false,
124 |             mockConfig,
125 |           ),
126 |         );
127 | 
128 |         expect(result.current.suggestions).toEqual([]);
129 |         expect(result.current.activeSuggestionIndex).toBe(-1);
130 |         expect(result.current.visibleStartIndex).toBe(0);
131 |         expect(result.current.showSuggestions).toBe(false);
132 |         expect(result.current.isLoadingSuggestions).toBe(false);
133 |       });
134 | 
135 |       it('should reset state when completion mode becomes IDLE', async () => {
136 |         setupMocks({
137 |           atSuggestions: [{ label: 'src/file.txt', value: 'src/file.txt' }],
138 |         });
139 | 
140 |         const { result } = renderHook(() => {
141 |           const textBuffer = useTextBufferForTest('@file');
142 |           const completion = useCommandCompletion(
143 |             textBuffer,
144 |             testDirs,
145 |             testRootDir,
146 |             [],
147 |             mockCommandContext,
148 |             false,
149 |             mockConfig,
150 |           );
151 |           return { completion, textBuffer };
152 |         });
153 | 
154 |         await waitFor(() => {
155 |           expect(result.current.completion.suggestions).toHaveLength(1);
156 |         });
157 | 
158 |         expect(result.current.completion.showSuggestions).toBe(true);
159 | 
160 |         act(() => {
161 |           result.current.textBuffer.replaceRangeByOffset(
162 |             0,
163 |             5,
164 |             'just some text',
165 |           );
166 |         });
167 | 
168 |         await waitFor(() => {
169 |           expect(result.current.completion.showSuggestions).toBe(false);
170 |         });
171 |       });
172 | 
173 |       it('should reset all state to default values', () => {
174 |         const { result } = renderHook(() =>
175 |           useCommandCompletion(
176 |             useTextBufferForTest('@files'),
177 |             testDirs,
178 |             testRootDir,
179 |             [],
180 |             mockCommandContext,
181 |             false,
182 |             mockConfig,
183 |           ),
184 |         );
185 | 
186 |         act(() => {
187 |           result.current.setActiveSuggestionIndex(5);
188 |           result.current.setShowSuggestions(true);
189 |         });
190 | 
191 |         act(() => {
192 |           result.current.resetCompletionState();
193 |         });
194 | 
195 |         expect(result.current.activeSuggestionIndex).toBe(-1);
196 |         expect(result.current.visibleStartIndex).toBe(0);
197 |         expect(result.current.showSuggestions).toBe(false);
198 |       });
199 | 
200 |       it('should call useAtCompletion with the correct query for an escaped space', async () => {
201 |         const text = '@src/a\\ file.txt';
202 |         renderHook(() =>
203 |           useCommandCompletion(
204 |             useTextBufferForTest(text),
205 |             testDirs,
206 |             testRootDir,
207 |             [],
208 |             mockCommandContext,
209 |             false,
210 |             mockConfig,
211 |           ),
212 |         );
213 | 
214 |         await waitFor(() => {
215 |           expect(useAtCompletion).toHaveBeenLastCalledWith(
216 |             expect.objectContaining({
217 |               enabled: true,
218 |               pattern: 'src/a\\ file.txt',
219 |             }),
220 |           );
221 |         });
222 |       });
223 | 
224 |       it('should correctly identify the completion context with multiple @ symbols', async () => {
225 |         const text = '@file1 @file2';
226 |         const cursorOffset = 3; // @fi|le1 @file2
227 | 
228 |         renderHook(() =>
229 |           useCommandCompletion(
230 |             useTextBufferForTest(text, cursorOffset),
231 |             testDirs,
232 |             testRootDir,
233 |             [],
234 |             mockCommandContext,
235 |             false,
236 |             mockConfig,
237 |           ),
238 |         );
239 | 
240 |         await waitFor(() => {
241 |           expect(useAtCompletion).toHaveBeenLastCalledWith(
242 |             expect.objectContaining({
243 |               enabled: true,
244 |               pattern: 'file1',
245 |             }),
246 |           );
247 |         });
248 |       });
249 |     });
250 | 
251 |     describe('Navigation', () => {
252 |       const mockSuggestions = [
253 |         { label: 'cmd1', value: 'cmd1' },
254 |         { label: 'cmd2', value: 'cmd2' },
255 |         { label: 'cmd3', value: 'cmd3' },
256 |         { label: 'cmd4', value: 'cmd4' },
257 |         { label: 'cmd5', value: 'cmd5' },
258 |       ];
259 | 
260 |       beforeEach(() => {
261 |         setupMocks({ slashSuggestions: mockSuggestions });
262 |       });
263 | 
264 |       it('should handle navigateUp with no suggestions', () => {
265 |         setupMocks({ slashSuggestions: [] });
266 | 
267 |         const { result } = renderHook(() =>
268 |           useCommandCompletion(
269 |             useTextBufferForTest('/'),
270 |             testDirs,
271 |             testRootDir,
272 |             [],
273 |             mockCommandContext,
274 |             false,
275 |             mockConfig,
276 |           ),
277 |         );
278 | 
279 |         act(() => {
280 |           result.current.navigateUp();
281 |         });
282 | 
283 |         expect(result.current.activeSuggestionIndex).toBe(-1);
284 |       });
285 | 
286 |       it('should handle navigateDown with no suggestions', () => {
287 |         setupMocks({ slashSuggestions: [] });
288 |         const { result } = renderHook(() =>
289 |           useCommandCompletion(
290 |             useTextBufferForTest('/'),
291 |             testDirs,
292 |             testRootDir,
293 |             [],
294 |             mockCommandContext,
295 |             false,
296 |             mockConfig,
297 |           ),
298 |         );
299 | 
300 |         act(() => {
301 |           result.current.navigateDown();
302 |         });
303 | 
304 |         expect(result.current.activeSuggestionIndex).toBe(-1);
305 |       });
306 | 
307 |       it('should navigate up through suggestions with wrap-around', async () => {
308 |         const { result } = renderHook(() =>
309 |           useCommandCompletion(
310 |             useTextBufferForTest('/'),
311 |             testDirs,
312 |             testRootDir,
313 |             [],
314 |             mockCommandContext,
315 |             false,
316 |             mockConfig,
317 |           ),
318 |         );
319 | 
320 |         await waitFor(() => {
321 |           expect(result.current.suggestions.length).toBe(5);
322 |         });
323 | 
324 |         expect(result.current.activeSuggestionIndex).toBe(0);
325 | 
326 |         act(() => {
327 |           result.current.navigateUp();
328 |         });
329 | 
330 |         expect(result.current.activeSuggestionIndex).toBe(4);
331 |       });
332 | 
333 |       it('should navigate down through suggestions with wrap-around', async () => {
334 |         const { result } = renderHook(() =>
335 |           useCommandCompletion(
336 |             useTextBufferForTest('/'),
337 |             testDirs,
338 |             testRootDir,
339 |             [],
340 |             mockCommandContext,
341 |             false,
342 |             mockConfig,
343 |           ),
344 |         );
345 | 
346 |         await waitFor(() => {
347 |           expect(result.current.suggestions.length).toBe(5);
348 |         });
349 | 
350 |         act(() => {
351 |           result.current.setActiveSuggestionIndex(4);
352 |         });
353 |         expect(result.current.activeSuggestionIndex).toBe(4);
354 | 
355 |         act(() => {
356 |           result.current.navigateDown();
357 |         });
358 | 
359 |         expect(result.current.activeSuggestionIndex).toBe(0);
360 |       });
361 | 
362 |       it('should handle navigation with multiple suggestions', async () => {
363 |         const { result } = renderHook(() =>
364 |           useCommandCompletion(
365 |             useTextBufferForTest('/'),
366 |             testDirs,
367 |             testRootDir,
368 |             [],
369 |             mockCommandContext,
370 |             false,
371 |             mockConfig,
372 |           ),
373 |         );
374 | 
375 |         await waitFor(() => {
376 |           expect(result.current.suggestions.length).toBe(5);
377 |         });
378 | 
379 |         expect(result.current.activeSuggestionIndex).toBe(0);
380 | 
381 |         act(() => result.current.navigateDown());
382 |         expect(result.current.activeSuggestionIndex).toBe(1);
383 | 
384 |         act(() => result.current.navigateDown());
385 |         expect(result.current.activeSuggestionIndex).toBe(2);
386 | 
387 |         act(() => result.current.navigateUp());
388 |         expect(result.current.activeSuggestionIndex).toBe(1);
389 | 
390 |         act(() => result.current.navigateUp());
391 |         expect(result.current.activeSuggestionIndex).toBe(0);
392 | 
393 |         act(() => result.current.navigateUp());
394 |         expect(result.current.activeSuggestionIndex).toBe(4);
395 |       });
396 | 
397 |       it('should automatically select the first item when suggestions are available', async () => {
398 |         setupMocks({ slashSuggestions: mockSuggestions });
399 | 
400 |         const { result } = renderHook(() =>
401 |           useCommandCompletion(
402 |             useTextBufferForTest('/'),
403 |             testDirs,
404 |             testRootDir,
405 |             [],
406 |             mockCommandContext,
407 |             false,
408 |             mockConfig,
409 |           ),
410 |         );
411 | 
412 |         await waitFor(() => {
413 |           expect(result.current.suggestions.length).toBe(
414 |             mockSuggestions.length,
415 |           );
416 |           expect(result.current.activeSuggestionIndex).toBe(0);
417 |         });
418 |       });
419 |     });
420 |   });
421 | 
422 |   describe('handleAutocomplete', () => {
423 |     it('should complete a partial command', async () => {
424 |       setupMocks({
425 |         slashSuggestions: [{ label: 'memory', value: 'memory' }],
426 |         slashCompletionRange: { completionStart: 1, completionEnd: 4 },
427 |       });
428 | 
429 |       const { result } = renderHook(() => {
430 |         const textBuffer = useTextBufferForTest('/mem');
431 |         const completion = useCommandCompletion(
432 |           textBuffer,
433 |           testDirs,
434 |           testRootDir,
435 |           [],
436 |           mockCommandContext,
437 |           false,
438 |           mockConfig,
439 |         );
440 |         return { ...completion, textBuffer };
441 |       });
442 | 
443 |       await waitFor(() => {
444 |         expect(result.current.suggestions.length).toBe(1);
445 |       });
446 | 
447 |       act(() => {
448 |         result.current.handleAutocomplete(0);
449 |       });
450 | 
451 |       expect(result.current.textBuffer.text).toBe('/memory ');
452 |     });
453 | 
454 |     it('should complete a file path', async () => {
455 |       setupMocks({
456 |         atSuggestions: [{ label: 'src/file1.txt', value: 'src/file1.txt' }],
[TRUNCATED]
```

src/ui/hooks/useCommandCompletion.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { useCallback, useMemo, useEffect } from 'react';
8 | import type { Suggestion } from '../components/SuggestionsDisplay.js';
9 | import type { CommandContext, SlashCommand } from '../commands/types.js';
10 | import type { TextBuffer } from '../components/shared/text-buffer.js';
11 | import { logicalPosToOffset } from '../components/shared/text-buffer.js';
12 | import { isSlashCommand } from '../utils/commandUtils.js';
13 | import { toCodePoints } from '../utils/textUtils.js';
14 | import { useAtCompletion } from './useAtCompletion.js';
15 | import { useSlashCompletion } from './useSlashCompletion.js';
16 | import type { PromptCompletion } from './usePromptCompletion.js';
17 | import {
18 |   usePromptCompletion,
19 |   PROMPT_COMPLETION_MIN_LENGTH,
20 | } from './usePromptCompletion.js';
21 | import type { Config } from '@google/gemini-cli-core';
22 | import { useCompletion } from './useCompletion.js';
23 | 
24 | export enum CompletionMode {
25 |   IDLE = 'IDLE',
26 |   AT = 'AT',
27 |   SLASH = 'SLASH',
28 |   PROMPT = 'PROMPT',
29 | }
30 | 
31 | export interface UseCommandCompletionReturn {
32 |   suggestions: Suggestion[];
33 |   activeSuggestionIndex: number;
34 |   visibleStartIndex: number;
35 |   showSuggestions: boolean;
36 |   isLoadingSuggestions: boolean;
37 |   isPerfectMatch: boolean;
38 |   setActiveSuggestionIndex: React.Dispatch<React.SetStateAction<number>>;
39 |   setShowSuggestions: React.Dispatch<React.SetStateAction<boolean>>;
40 |   resetCompletionState: () => void;
41 |   navigateUp: () => void;
42 |   navigateDown: () => void;
43 |   handleAutocomplete: (indexToUse: number) => void;
44 |   promptCompletion: PromptCompletion;
45 | }
46 | 
47 | export function useCommandCompletion(
48 |   buffer: TextBuffer,
49 |   dirs: readonly string[],
50 |   cwd: string,
51 |   slashCommands: readonly SlashCommand[],
52 |   commandContext: CommandContext,
53 |   reverseSearchActive: boolean = false,
54 |   config?: Config,
55 | ): UseCommandCompletionReturn {
56 |   const {
57 |     suggestions,
58 |     activeSuggestionIndex,
59 |     visibleStartIndex,
60 |     showSuggestions,
61 |     isLoadingSuggestions,
62 |     isPerfectMatch,
63 | 
64 |     setSuggestions,
65 |     setShowSuggestions,
66 |     setActiveSuggestionIndex,
67 |     setIsLoadingSuggestions,
68 |     setIsPerfectMatch,
69 |     setVisibleStartIndex,
70 | 
71 |     resetCompletionState,
72 |     navigateUp,
73 |     navigateDown,
74 |   } = useCompletion();
75 | 
76 |   const cursorRow = buffer.cursor[0];
77 |   const cursorCol = buffer.cursor[1];
78 | 
79 |   const { completionMode, query, completionStart, completionEnd } =
80 |     useMemo(() => {
81 |       const currentLine = buffer.lines[cursorRow] || '';
82 |       if (cursorRow === 0 && isSlashCommand(currentLine.trim())) {
83 |         return {
84 |           completionMode: CompletionMode.SLASH,
85 |           query: currentLine,
86 |           completionStart: 0,
87 |           completionEnd: currentLine.length,
88 |         };
89 |       }
90 | 
91 |       const codePoints = toCodePoints(currentLine);
92 |       for (let i = cursorCol - 1; i >= 0; i--) {
93 |         const char = codePoints[i];
94 | 
95 |         if (char === ' ') {
96 |           let backslashCount = 0;
97 |           for (let j = i - 1; j >= 0 && codePoints[j] === '\\'; j--) {
98 |             backslashCount++;
99 |           }
100 |           if (backslashCount % 2 === 0) {
101 |             break;
102 |           }
103 |         } else if (char === '@') {
104 |           let end = codePoints.length;
105 |           for (let i = cursorCol; i < codePoints.length; i++) {
106 |             if (codePoints[i] === ' ') {
107 |               let backslashCount = 0;
108 |               for (let j = i - 1; j >= 0 && codePoints[j] === '\\'; j--) {
109 |                 backslashCount++;
110 |               }
111 | 
112 |               if (backslashCount % 2 === 0) {
113 |                 end = i;
114 |                 break;
115 |               }
116 |             }
117 |           }
118 |           const pathStart = i + 1;
119 |           const partialPath = currentLine.substring(pathStart, end);
120 |           return {
121 |             completionMode: CompletionMode.AT,
122 |             query: partialPath,
123 |             completionStart: pathStart,
124 |             completionEnd: end,
125 |           };
126 |         }
127 |       }
128 | 
129 |       // Check for prompt completion - only if enabled
130 |       const trimmedText = buffer.text.trim();
131 |       const isPromptCompletionEnabled =
132 |         config?.getEnablePromptCompletion() ?? false;
133 | 
134 |       if (
135 |         isPromptCompletionEnabled &&
136 |         trimmedText.length >= PROMPT_COMPLETION_MIN_LENGTH &&
137 |         !isSlashCommand(trimmedText) &&
138 |         !trimmedText.includes('@')
139 |       ) {
140 |         return {
141 |           completionMode: CompletionMode.PROMPT,
142 |           query: trimmedText,
143 |           completionStart: 0,
144 |           completionEnd: trimmedText.length,
145 |         };
146 |       }
147 | 
148 |       return {
149 |         completionMode: CompletionMode.IDLE,
150 |         query: null,
151 |         completionStart: -1,
152 |         completionEnd: -1,
153 |       };
154 |     }, [cursorRow, cursorCol, buffer.lines, buffer.text, config]);
155 | 
156 |   useAtCompletion({
157 |     enabled: completionMode === CompletionMode.AT,
158 |     pattern: query || '',
159 |     config,
160 |     cwd,
161 |     setSuggestions,
162 |     setIsLoadingSuggestions,
163 |   });
164 | 
165 |   const slashCompletionRange = useSlashCompletion({
166 |     enabled: completionMode === CompletionMode.SLASH,
167 |     query,
168 |     slashCommands,
169 |     commandContext,
170 |     setSuggestions,
171 |     setIsLoadingSuggestions,
172 |     setIsPerfectMatch,
173 |   });
174 | 
175 |   const promptCompletion = usePromptCompletion({
176 |     buffer,
177 |     config,
178 |     enabled: completionMode === CompletionMode.PROMPT,
179 |   });
180 | 
181 |   useEffect(() => {
182 |     setActiveSuggestionIndex(suggestions.length > 0 ? 0 : -1);
183 |     setVisibleStartIndex(0);
184 |   }, [suggestions, setActiveSuggestionIndex, setVisibleStartIndex]);
185 | 
186 |   useEffect(() => {
187 |     if (completionMode === CompletionMode.IDLE || reverseSearchActive) {
188 |       resetCompletionState();
189 |       return;
190 |     }
191 |     // Show suggestions if we are loading OR if there are results to display.
192 |     setShowSuggestions(isLoadingSuggestions || suggestions.length > 0);
193 |   }, [
194 |     completionMode,
195 |     suggestions.length,
196 |     isLoadingSuggestions,
197 |     reverseSearchActive,
198 |     resetCompletionState,
199 |     setShowSuggestions,
200 |   ]);
201 | 
202 |   const handleAutocomplete = useCallback(
203 |     (indexToUse: number) => {
204 |       if (indexToUse < 0 || indexToUse >= suggestions.length) {
205 |         return;
206 |       }
207 |       const suggestion = suggestions[indexToUse].value;
208 | 
209 |       let start = completionStart;
210 |       let end = completionEnd;
211 |       if (completionMode === CompletionMode.SLASH) {
212 |         start = slashCompletionRange.completionStart;
213 |         end = slashCompletionRange.completionEnd;
214 |       }
215 | 
216 |       if (start === -1 || end === -1) {
217 |         return;
218 |       }
219 | 
220 |       let suggestionText = suggestion;
221 |       if (completionMode === CompletionMode.SLASH) {
222 |         if (
223 |           start === end &&
224 |           start > 1 &&
225 |           (buffer.lines[cursorRow] || '')[start - 1] !== ' '
226 |         ) {
227 |           suggestionText = ' ' + suggestionText;
228 |         }
229 |       }
230 | 
231 |       const lineCodePoints = toCodePoints(buffer.lines[cursorRow] || '');
232 |       const charAfterCompletion = lineCodePoints[end];
233 |       if (charAfterCompletion !== ' ') {
234 |         suggestionText += ' ';
235 |       }
236 | 
237 |       buffer.replaceRangeByOffset(
238 |         logicalPosToOffset(buffer.lines, cursorRow, start),
239 |         logicalPosToOffset(buffer.lines, cursorRow, end),
240 |         suggestionText,
241 |       );
242 |     },
243 |     [
244 |       cursorRow,
245 |       buffer,
246 |       suggestions,
247 |       completionMode,
248 |       completionStart,
249 |       completionEnd,
250 |       slashCompletionRange,
251 |     ],
252 |   );
253 | 
254 |   return {
255 |     suggestions,
256 |     activeSuggestionIndex,
257 |     visibleStartIndex,
258 |     showSuggestions,
259 |     isLoadingSuggestions,
260 |     isPerfectMatch,
261 |     setActiveSuggestionIndex,
262 |     setShowSuggestions,
263 |     resetCompletionState,
264 |     navigateUp,
265 |     navigateDown,
266 |     handleAutocomplete,
267 |     promptCompletion,
268 |   };
269 | }
```

src/ui/hooks/useCompletion.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { useState, useCallback } from 'react';
8 | 
9 | import type { Suggestion } from '../components/SuggestionsDisplay.js';
10 | import { MAX_SUGGESTIONS_TO_SHOW } from '../components/SuggestionsDisplay.js';
11 | 
12 | export interface UseCompletionReturn {
13 |   suggestions: Suggestion[];
14 |   activeSuggestionIndex: number;
15 |   visibleStartIndex: number;
16 |   showSuggestions: boolean;
17 |   isLoadingSuggestions: boolean;
18 |   isPerfectMatch: boolean;
19 |   setSuggestions: React.Dispatch<React.SetStateAction<Suggestion[]>>;
20 |   setActiveSuggestionIndex: React.Dispatch<React.SetStateAction<number>>;
21 |   setVisibleStartIndex: React.Dispatch<React.SetStateAction<number>>;
22 |   setIsLoadingSuggestions: React.Dispatch<React.SetStateAction<boolean>>;
23 |   setIsPerfectMatch: React.Dispatch<React.SetStateAction<boolean>>;
24 |   setShowSuggestions: React.Dispatch<React.SetStateAction<boolean>>;
25 |   resetCompletionState: () => void;
26 |   navigateUp: () => void;
27 |   navigateDown: () => void;
28 | }
29 | 
30 | export function useCompletion(): UseCompletionReturn {
31 |   const [suggestions, setSuggestions] = useState<Suggestion[]>([]);
32 |   const [activeSuggestionIndex, setActiveSuggestionIndex] =
33 |     useState<number>(-1);
34 |   const [visibleStartIndex, setVisibleStartIndex] = useState<number>(0);
35 |   const [showSuggestions, setShowSuggestions] = useState<boolean>(false);
36 |   const [isLoadingSuggestions, setIsLoadingSuggestions] =
37 |     useState<boolean>(false);
38 |   const [isPerfectMatch, setIsPerfectMatch] = useState<boolean>(false);
39 | 
40 |   const resetCompletionState = useCallback(() => {
41 |     setSuggestions([]);
42 |     setActiveSuggestionIndex(-1);
43 |     setVisibleStartIndex(0);
44 |     setShowSuggestions(false);
45 |     setIsLoadingSuggestions(false);
46 |     setIsPerfectMatch(false);
47 |   }, []);
48 | 
49 |   const navigateUp = useCallback(() => {
50 |     if (suggestions.length === 0) return;
51 | 
52 |     setActiveSuggestionIndex((prevActiveIndex) => {
53 |       // Calculate new active index, handling wrap-around
54 |       const newActiveIndex =
55 |         prevActiveIndex <= 0 ? suggestions.length - 1 : prevActiveIndex - 1;
56 | 
57 |       // Adjust scroll position based on the new active index
58 |       setVisibleStartIndex((prevVisibleStart) => {
59 |         // Case 1: Wrapped around to the last item
60 |         if (
61 |           newActiveIndex === suggestions.length - 1 &&
62 |           suggestions.length > MAX_SUGGESTIONS_TO_SHOW
63 |         ) {
64 |           return Math.max(0, suggestions.length - MAX_SUGGESTIONS_TO_SHOW);
65 |         }
66 |         // Case 2: Scrolled above the current visible window
67 |         if (newActiveIndex < prevVisibleStart) {
68 |           return newActiveIndex;
69 |         }
70 |         // Otherwise, keep the current scroll position
71 |         return prevVisibleStart;
72 |       });
73 | 
74 |       return newActiveIndex;
75 |     });
76 |   }, [suggestions.length]);
77 | 
78 |   const navigateDown = useCallback(() => {
79 |     if (suggestions.length === 0) return;
80 | 
81 |     setActiveSuggestionIndex((prevActiveIndex) => {
82 |       // Calculate new active index, handling wrap-around
83 |       const newActiveIndex =
84 |         prevActiveIndex >= suggestions.length - 1 ? 0 : prevActiveIndex + 1;
85 | 
86 |       // Adjust scroll position based on the new active index
87 |       setVisibleStartIndex((prevVisibleStart) => {
88 |         // Case 1: Wrapped around to the first item
89 |         if (
90 |           newActiveIndex === 0 &&
91 |           suggestions.length > MAX_SUGGESTIONS_TO_SHOW
92 |         ) {
93 |           return 0;
94 |         }
95 |         // Case 2: Scrolled below the current visible window
96 |         const visibleEndIndex = prevVisibleStart + MAX_SUGGESTIONS_TO_SHOW;
97 |         if (newActiveIndex >= visibleEndIndex) {
98 |           return newActiveIndex - MAX_SUGGESTIONS_TO_SHOW + 1;
99 |         }
100 |         // Otherwise, keep the current scroll position
101 |         return prevVisibleStart;
102 |       });
103 | 
104 |       return newActiveIndex;
105 |     });
106 |   }, [suggestions.length]);
107 |   return {
108 |     suggestions,
109 |     activeSuggestionIndex,
110 |     visibleStartIndex,
111 |     showSuggestions,
112 |     isLoadingSuggestions,
113 |     isPerfectMatch,
114 | 
115 |     setSuggestions,
116 |     setShowSuggestions,
117 |     setActiveSuggestionIndex,
118 |     setVisibleStartIndex,
119 |     setIsLoadingSuggestions,
120 |     setIsPerfectMatch,
121 | 
122 |     resetCompletionState,
123 |     navigateUp,
124 |     navigateDown,
125 |   };
126 | }
```

src/ui/hooks/useConsoleMessages.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { act, renderHook } from '@testing-library/react';
8 | import { vi } from 'vitest';
9 | import { useConsoleMessages } from './useConsoleMessages';
10 | import { useCallback } from 'react';
11 | 
12 | describe('useConsoleMessages', () => {
13 |   beforeEach(() => {
14 |     vi.useFakeTimers();
15 |   });
16 | 
17 |   afterEach(() => {
18 |     vi.runOnlyPendingTimers();
19 |     vi.useRealTimers();
20 |   });
21 | 
22 |   const useTestableConsoleMessages = () => {
23 |     const { handleNewMessage, ...rest } = useConsoleMessages();
24 |     const log = useCallback(
25 |       (content: string) => handleNewMessage({ type: 'log', content, count: 1 }),
26 |       [handleNewMessage],
27 |     );
28 |     const error = useCallback(
29 |       (content: string) =>
30 |         handleNewMessage({ type: 'error', content, count: 1 }),
31 |       [handleNewMessage],
32 |     );
33 |     return {
34 |       ...rest,
35 |       log,
36 |       error,
37 |       clearConsoleMessages: rest.clearConsoleMessages,
38 |     };
39 |   };
40 | 
41 |   it('should initialize with an empty array of console messages', () => {
42 |     const { result } = renderHook(() => useTestableConsoleMessages());
43 |     expect(result.current.consoleMessages).toEqual([]);
44 |   });
45 | 
46 |   it('should add a new message when log is called', async () => {
47 |     const { result } = renderHook(() => useTestableConsoleMessages());
48 | 
49 |     act(() => {
50 |       result.current.log('Test message');
51 |     });
52 | 
53 |     await act(async () => {
54 |       await vi.advanceTimersByTimeAsync(20);
55 |     });
56 | 
57 |     expect(result.current.consoleMessages).toEqual([
58 |       { type: 'log', content: 'Test message', count: 1 },
59 |     ]);
60 |   });
61 | 
62 |   it('should batch and count identical consecutive messages', async () => {
63 |     const { result } = renderHook(() => useTestableConsoleMessages());
64 | 
65 |     act(() => {
66 |       result.current.log('Test message');
67 |       result.current.log('Test message');
68 |       result.current.log('Test message');
69 |     });
70 | 
71 |     await act(async () => {
72 |       await vi.advanceTimersByTimeAsync(20);
73 |     });
74 | 
75 |     expect(result.current.consoleMessages).toEqual([
76 |       { type: 'log', content: 'Test message', count: 3 },
77 |     ]);
78 |   });
79 | 
80 |   it('should not batch different messages', async () => {
81 |     const { result } = renderHook(() => useTestableConsoleMessages());
82 | 
83 |     act(() => {
84 |       result.current.log('First message');
85 |       result.current.error('Second message');
86 |     });
87 | 
88 |     await act(async () => {
89 |       await vi.advanceTimersByTimeAsync(20);
90 |     });
91 | 
92 |     expect(result.current.consoleMessages).toEqual([
93 |       { type: 'log', content: 'First message', count: 1 },
94 |       { type: 'error', content: 'Second message', count: 1 },
95 |     ]);
96 |   });
97 | 
98 |   it('should clear all messages when clearConsoleMessages is called', async () => {
99 |     const { result } = renderHook(() => useTestableConsoleMessages());
100 | 
101 |     act(() => {
102 |       result.current.log('A message');
103 |     });
104 | 
105 |     await act(async () => {
106 |       await vi.advanceTimersByTimeAsync(20);
107 |     });
108 | 
109 |     expect(result.current.consoleMessages).toHaveLength(1);
110 | 
111 |     act(() => {
112 |       result.current.clearConsoleMessages();
113 |     });
114 | 
115 |     expect(result.current.consoleMessages).toHaveLength(0);
116 |   });
117 | 
118 |   it('should clear the pending timeout when clearConsoleMessages is called', () => {
119 |     const { result } = renderHook(() => useTestableConsoleMessages());
120 |     const clearTimeoutSpy = vi.spyOn(global, 'clearTimeout');
121 | 
122 |     act(() => {
123 |       result.current.log('A message');
124 |     });
125 | 
126 |     act(() => {
127 |       result.current.clearConsoleMessages();
128 |     });
129 | 
130 |     expect(clearTimeoutSpy).toHaveBeenCalled();
131 |     clearTimeoutSpy.mockRestore();
132 |   });
133 | 
134 |   it('should clean up the timeout on unmount', () => {
135 |     const { result, unmount } = renderHook(() => useTestableConsoleMessages());
136 |     const clearTimeoutSpy = vi.spyOn(global, 'clearTimeout');
137 | 
138 |     act(() => {
139 |       result.current.log('A message');
140 |     });
141 | 
142 |     unmount();
143 | 
144 |     expect(clearTimeoutSpy).toHaveBeenCalled();
145 |     clearTimeoutSpy.mockRestore();
146 |   });
147 | });
```

src/ui/hooks/useConsoleMessages.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import {
8 |   useCallback,
9 |   useEffect,
10 |   useReducer,
11 |   useRef,
12 |   useTransition,
13 | } from 'react';
14 | import type { ConsoleMessageItem } from '../types.js';
15 | 
16 | export interface UseConsoleMessagesReturn {
17 |   consoleMessages: ConsoleMessageItem[];
18 |   handleNewMessage: (message: ConsoleMessageItem) => void;
19 |   clearConsoleMessages: () => void;
20 | }
21 | 
22 | type Action =
23 |   | { type: 'ADD_MESSAGES'; payload: ConsoleMessageItem[] }
24 |   | { type: 'CLEAR' };
25 | 
26 | function consoleMessagesReducer(
27 |   state: ConsoleMessageItem[],
28 |   action: Action,
29 | ): ConsoleMessageItem[] {
30 |   switch (action.type) {
31 |     case 'ADD_MESSAGES': {
32 |       const newMessages = [...state];
33 |       for (const queuedMessage of action.payload) {
34 |         const lastMessage = newMessages[newMessages.length - 1];
35 |         if (
36 |           lastMessage &&
37 |           lastMessage.type === queuedMessage.type &&
38 |           lastMessage.content === queuedMessage.content
39 |         ) {
40 |           // Create a new object for the last message to ensure React detects
41 |           // the change, preventing mutation of the existing state object.
42 |           newMessages[newMessages.length - 1] = {
43 |             ...lastMessage,
44 |             count: lastMessage.count + 1,
45 |           };
46 |         } else {
47 |           newMessages.push({ ...queuedMessage, count: 1 });
48 |         }
49 |       }
50 |       return newMessages;
51 |     }
52 |     case 'CLEAR':
53 |       return [];
54 |     default:
55 |       return state;
56 |   }
57 | }
58 | 
59 | export function useConsoleMessages(): UseConsoleMessagesReturn {
60 |   const [consoleMessages, dispatch] = useReducer(consoleMessagesReducer, []);
61 |   const messageQueueRef = useRef<ConsoleMessageItem[]>([]);
62 |   const timeoutRef = useRef<NodeJS.Timeout | null>(null);
63 |   const [, startTransition] = useTransition();
64 | 
65 |   const processQueue = useCallback(() => {
66 |     if (messageQueueRef.current.length > 0) {
67 |       const messagesToProcess = messageQueueRef.current;
68 |       messageQueueRef.current = [];
69 |       startTransition(() => {
70 |         dispatch({ type: 'ADD_MESSAGES', payload: messagesToProcess });
71 |       });
72 |     }
73 |     timeoutRef.current = null;
74 |   }, []);
75 | 
76 |   const handleNewMessage = useCallback(
77 |     (message: ConsoleMessageItem) => {
78 |       messageQueueRef.current.push(message);
79 |       if (!timeoutRef.current) {
80 |         // Batch updates using a timeout. 16ms is a reasonable delay to batch
81 |         // rapid-fire messages without noticeable lag.
82 |         timeoutRef.current = setTimeout(processQueue, 16);
83 |       }
84 |     },
85 |     [processQueue],
86 |   );
87 | 
88 |   const clearConsoleMessages = useCallback(() => {
89 |     if (timeoutRef.current) {
90 |       clearTimeout(timeoutRef.current);
91 |       timeoutRef.current = null;
92 |     }
93 |     messageQueueRef.current = [];
94 |     startTransition(() => {
95 |       dispatch({ type: 'CLEAR' });
96 |     });
97 |   }, []);
98 | 
99 |   // Cleanup on unmount
100 |   useEffect(
101 |     () => () => {
102 |       if (timeoutRef.current) {
103 |         clearTimeout(timeoutRef.current);
104 |       }
105 |     },
106 |     [],
107 |   );
108 | 
109 |   return { consoleMessages, handleNewMessage, clearConsoleMessages };
110 | }
```

src/ui/hooks/useEditorSettings.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import {
8 |   afterEach,
9 |   beforeEach,
10 |   describe,
11 |   expect,
12 |   it,
13 |   vi,
14 |   type MockedFunction,
15 | } from 'vitest';
16 | import { act } from 'react';
17 | import { renderHook } from '@testing-library/react';
18 | import { useEditorSettings } from './useEditorSettings.js';
19 | import type { LoadedSettings } from '../../config/settings.js';
20 | import { SettingScope } from '../../config/settings.js';
21 | import { MessageType, type HistoryItem } from '../types.js';
22 | import {
23 |   type EditorType,
24 |   checkHasEditorType,
25 |   allowEditorTypeInSandbox,
26 | } from '@google/gemini-cli-core';
27 | 
28 | vi.mock('@google/gemini-cli-core', async () => {
29 |   const actual = await vi.importActual('@google/gemini-cli-core');
30 |   return {
31 |     ...actual,
32 |     checkHasEditorType: vi.fn(() => true),
33 |     allowEditorTypeInSandbox: vi.fn(() => true),
34 |   };
35 | });
36 | 
37 | const mockCheckHasEditorType = vi.mocked(checkHasEditorType);
38 | const mockAllowEditorTypeInSandbox = vi.mocked(allowEditorTypeInSandbox);
39 | 
40 | describe('useEditorSettings', () => {
41 |   let mockLoadedSettings: LoadedSettings;
42 |   let mockSetEditorError: MockedFunction<(error: string | null) => void>;
43 |   let mockAddItem: MockedFunction<
44 |     (item: Omit<HistoryItem, 'id'>, timestamp: number) => void
45 |   >;
46 | 
47 |   beforeEach(() => {
48 |     vi.resetAllMocks();
49 | 
50 |     mockLoadedSettings = {
51 |       setValue: vi.fn(),
52 |     } as unknown as LoadedSettings;
53 | 
54 |     mockSetEditorError = vi.fn();
55 |     mockAddItem = vi.fn();
56 | 
57 |     // Reset mock implementations to default
58 |     mockCheckHasEditorType.mockReturnValue(true);
59 |     mockAllowEditorTypeInSandbox.mockReturnValue(true);
60 |   });
61 | 
62 |   afterEach(() => {
63 |     vi.restoreAllMocks();
64 |   });
65 | 
66 |   it('should initialize with dialog closed', () => {
67 |     const { result } = renderHook(() =>
68 |       useEditorSettings(mockLoadedSettings, mockSetEditorError, mockAddItem),
69 |     );
70 | 
71 |     expect(result.current.isEditorDialogOpen).toBe(false);
72 |   });
73 | 
74 |   it('should open editor dialog when openEditorDialog is called', () => {
75 |     const { result } = renderHook(() =>
76 |       useEditorSettings(mockLoadedSettings, mockSetEditorError, mockAddItem),
77 |     );
78 | 
79 |     act(() => {
80 |       result.current.openEditorDialog();
81 |     });
82 | 
83 |     expect(result.current.isEditorDialogOpen).toBe(true);
84 |   });
85 | 
86 |   it('should close editor dialog when exitEditorDialog is called', () => {
87 |     const { result } = renderHook(() =>
88 |       useEditorSettings(mockLoadedSettings, mockSetEditorError, mockAddItem),
89 |     );
90 |     act(() => {
91 |       result.current.openEditorDialog();
92 |       result.current.exitEditorDialog();
93 |     });
94 |     expect(result.current.isEditorDialogOpen).toBe(false);
95 |   });
96 | 
97 |   it('should handle editor selection successfully', () => {
98 |     const { result } = renderHook(() =>
99 |       useEditorSettings(mockLoadedSettings, mockSetEditorError, mockAddItem),
100 |     );
101 | 
102 |     const editorType: EditorType = 'vscode';
103 |     const scope = SettingScope.User;
104 | 
105 |     act(() => {
106 |       result.current.openEditorDialog();
107 |       result.current.handleEditorSelect(editorType, scope);
108 |     });
109 | 
110 |     expect(mockLoadedSettings.setValue).toHaveBeenCalledWith(
111 |       scope,
112 |       'preferredEditor',
113 |       editorType,
114 |     );
115 | 
116 |     expect(mockAddItem).toHaveBeenCalledWith(
117 |       {
118 |         type: MessageType.INFO,
119 |         text: 'Editor preference set to "vscode" in User settings.',
120 |       },
121 |       expect.any(Number),
122 |     );
123 | 
124 |     expect(mockSetEditorError).toHaveBeenCalledWith(null);
125 |     expect(result.current.isEditorDialogOpen).toBe(false);
126 |   });
127 | 
128 |   it('should handle clearing editor preference (undefined editor)', () => {
129 |     const { result } = renderHook(() =>
130 |       useEditorSettings(mockLoadedSettings, mockSetEditorError, mockAddItem),
131 |     );
132 | 
133 |     const scope = SettingScope.Workspace;
134 | 
135 |     act(() => {
136 |       result.current.openEditorDialog();
137 |       result.current.handleEditorSelect(undefined, scope);
138 |     });
139 | 
140 |     expect(mockLoadedSettings.setValue).toHaveBeenCalledWith(
141 |       scope,
142 |       'preferredEditor',
143 |       undefined,
144 |     );
145 | 
146 |     expect(mockAddItem).toHaveBeenCalledWith(
147 |       {
148 |         type: MessageType.INFO,
149 |         text: 'Editor preference cleared in Workspace settings.',
150 |       },
151 |       expect.any(Number),
152 |     );
153 | 
154 |     expect(mockSetEditorError).toHaveBeenCalledWith(null);
155 |     expect(result.current.isEditorDialogOpen).toBe(false);
156 |   });
157 | 
158 |   it('should handle different editor types', () => {
159 |     const { result } = renderHook(() =>
160 |       useEditorSettings(mockLoadedSettings, mockSetEditorError, mockAddItem),
161 |     );
162 | 
163 |     const editorTypes: EditorType[] = ['cursor', 'windsurf', 'vim'];
164 |     const scope = SettingScope.User;
165 | 
166 |     editorTypes.forEach((editorType) => {
167 |       act(() => {
168 |         result.current.handleEditorSelect(editorType, scope);
169 |       });
170 | 
171 |       expect(mockLoadedSettings.setValue).toHaveBeenCalledWith(
172 |         scope,
173 |         'preferredEditor',
174 |         editorType,
175 |       );
176 | 
177 |       expect(mockAddItem).toHaveBeenCalledWith(
178 |         {
179 |           type: MessageType.INFO,
180 |           text: `Editor preference set to "${editorType}" in User settings.`,
181 |         },
182 |         expect.any(Number),
183 |       );
184 |     });
185 |   });
186 | 
187 |   it('should handle different setting scopes', () => {
188 |     const { result } = renderHook(() =>
189 |       useEditorSettings(mockLoadedSettings, mockSetEditorError, mockAddItem),
190 |     );
191 | 
192 |     const editorType: EditorType = 'vscode';
193 |     const scopes = [SettingScope.User, SettingScope.Workspace];
194 | 
195 |     scopes.forEach((scope) => {
196 |       act(() => {
197 |         result.current.handleEditorSelect(editorType, scope);
198 |       });
199 | 
200 |       expect(mockLoadedSettings.setValue).toHaveBeenCalledWith(
201 |         scope,
202 |         'preferredEditor',
203 |         editorType,
204 |       );
205 | 
206 |       expect(mockAddItem).toHaveBeenCalledWith(
207 |         {
208 |           type: MessageType.INFO,
209 |           text: `Editor preference set to "vscode" in ${scope} settings.`,
210 |         },
211 |         expect.any(Number),
212 |       );
213 |     });
214 |   });
215 | 
216 |   it('should not set preference for unavailable editors', () => {
217 |     const { result } = renderHook(() =>
218 |       useEditorSettings(mockLoadedSettings, mockSetEditorError, mockAddItem),
219 |     );
220 | 
221 |     mockCheckHasEditorType.mockReturnValue(false);
222 | 
223 |     const editorType: EditorType = 'vscode';
224 |     const scope = SettingScope.User;
225 | 
226 |     act(() => {
227 |       result.current.openEditorDialog();
228 |       result.current.handleEditorSelect(editorType, scope);
229 |     });
230 | 
231 |     expect(mockLoadedSettings.setValue).not.toHaveBeenCalled();
232 |     expect(mockAddItem).not.toHaveBeenCalled();
233 |     expect(result.current.isEditorDialogOpen).toBe(true);
234 |   });
235 | 
236 |   it('should not set preference for editors not allowed in sandbox', () => {
237 |     const { result } = renderHook(() =>
238 |       useEditorSettings(mockLoadedSettings, mockSetEditorError, mockAddItem),
239 |     );
240 | 
241 |     mockAllowEditorTypeInSandbox.mockReturnValue(false);
242 | 
243 |     const editorType: EditorType = 'vscode';
244 |     const scope = SettingScope.User;
245 | 
246 |     act(() => {
247 |       result.current.openEditorDialog();
248 |       result.current.handleEditorSelect(editorType, scope);
249 |     });
250 | 
251 |     expect(mockLoadedSettings.setValue).not.toHaveBeenCalled();
252 |     expect(mockAddItem).not.toHaveBeenCalled();
253 |     expect(result.current.isEditorDialogOpen).toBe(true);
254 |   });
255 | 
256 |   it('should handle errors during editor selection', () => {
257 |     const { result } = renderHook(() =>
258 |       useEditorSettings(mockLoadedSettings, mockSetEditorError, mockAddItem),
259 |     );
260 | 
261 |     const errorMessage = 'Failed to save settings';
262 |     (
263 |       mockLoadedSettings.setValue as MockedFunction<
264 |         typeof mockLoadedSettings.setValue
265 |       >
266 |     ).mockImplementation(() => {
267 |       throw new Error(errorMessage);
268 |     });
269 | 
270 |     const editorType: EditorType = 'vscode';
271 |     const scope = SettingScope.User;
272 | 
273 |     act(() => {
274 |       result.current.openEditorDialog();
275 |       result.current.handleEditorSelect(editorType, scope);
276 |     });
277 | 
278 |     expect(mockSetEditorError).toHaveBeenCalledWith(
279 |       `Failed to set editor preference: Error: ${errorMessage}`,
280 |     );
281 |     expect(mockAddItem).not.toHaveBeenCalled();
282 |     expect(result.current.isEditorDialogOpen).toBe(true);
283 |   });
284 | });
```

src/ui/hooks/useEditorSettings.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { useState, useCallback } from 'react';
8 | import type { LoadedSettings, SettingScope } from '../../config/settings.js';
9 | import { type HistoryItem, MessageType } from '../types.js';
10 | import type { EditorType } from '@google/gemini-cli-core';
11 | import {
12 |   allowEditorTypeInSandbox,
13 |   checkHasEditorType,
14 | } from '@google/gemini-cli-core';
15 | 
16 | interface UseEditorSettingsReturn {
17 |   isEditorDialogOpen: boolean;
18 |   openEditorDialog: () => void;
19 |   handleEditorSelect: (
20 |     editorType: EditorType | undefined,
21 |     scope: SettingScope,
22 |   ) => void;
23 |   exitEditorDialog: () => void;
24 | }
25 | 
26 | export const useEditorSettings = (
27 |   loadedSettings: LoadedSettings,
28 |   setEditorError: (error: string | null) => void,
29 |   addItem: (item: Omit<HistoryItem, 'id'>, timestamp: number) => void,
30 | ): UseEditorSettingsReturn => {
31 |   const [isEditorDialogOpen, setIsEditorDialogOpen] = useState(false);
32 | 
33 |   const openEditorDialog = useCallback(() => {
34 |     setIsEditorDialogOpen(true);
35 |   }, []);
36 | 
37 |   const handleEditorSelect = useCallback(
38 |     (editorType: EditorType | undefined, scope: SettingScope) => {
39 |       if (
40 |         editorType &&
41 |         (!checkHasEditorType(editorType) ||
42 |           !allowEditorTypeInSandbox(editorType))
43 |       ) {
44 |         return;
45 |       }
46 | 
47 |       try {
48 |         loadedSettings.setValue(scope, 'preferredEditor', editorType);
49 |         addItem(
50 |           {
51 |             type: MessageType.INFO,
52 |             text: `Editor preference ${editorType ? `set to "${editorType}"` : 'cleared'} in ${scope} settings.`,
53 |           },
54 |           Date.now(),
55 |         );
56 |         setEditorError(null);
57 |         setIsEditorDialogOpen(false);
58 |       } catch (error) {
59 |         setEditorError(`Failed to set editor preference: ${error}`);
60 |       }
61 |     },
62 |     [loadedSettings, setEditorError, addItem],
63 |   );
64 | 
65 |   const exitEditorDialog = useCallback(() => {
66 |     setIsEditorDialogOpen(false);
67 |   }, []);
68 | 
69 |   return {
70 |     isEditorDialogOpen,
71 |     openEditorDialog,
72 |     handleEditorSelect,
73 |     exitEditorDialog,
74 |   };
75 | };
```

src/ui/hooks/useExtensionUpdates.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { vi } from 'vitest';
8 | import * as fs from 'node:fs';
9 | import * as os from 'node:os';
10 | import * as path from 'node:path';
11 | import {
12 |   ExtensionStorage,
13 |   annotateActiveExtensions,
14 |   loadExtension,
15 | } from '../../config/extension.js';
16 | import { createExtension } from '../../test-utils/createExtension.js';
17 | import { useExtensionUpdates } from './useExtensionUpdates.js';
18 | import { GEMINI_DIR, type GeminiCLIExtension } from '@google/gemini-cli-core';
19 | import { renderHook, waitFor } from '@testing-library/react';
20 | import { MessageType } from '../types.js';
21 | import { ExtensionEnablementManager } from '../../config/extensions/extensionEnablement.js';
22 | import {
23 |   checkForAllExtensionUpdates,
24 |   updateExtension,
25 | } from '../../config/extensions/update.js';
26 | import { ExtensionUpdateState } from '../state/extensions.js';
27 | 
28 | vi.mock('os', async (importOriginal) => {
29 |   const mockedOs = await importOriginal<typeof os>();
30 |   return {
31 |     ...mockedOs,
32 |     homedir: vi.fn(),
33 |   };
34 | });
35 | 
36 | vi.mock('../../config/extensions/update.js', () => ({
37 |   checkForAllExtensionUpdates: vi.fn(),
38 |   updateExtension: vi.fn(),
39 | }));
40 | 
41 | describe('useExtensionUpdates', () => {
42 |   let tempHomeDir: string;
43 |   let userExtensionsDir: string;
44 | 
45 |   beforeEach(() => {
46 |     tempHomeDir = fs.mkdtempSync(
47 |       path.join(os.tmpdir(), 'gemini-cli-test-home-'),
48 |     );
49 |     vi.mocked(os.homedir).mockReturnValue(tempHomeDir);
50 |     userExtensionsDir = path.join(tempHomeDir, GEMINI_DIR, 'extensions');
51 |     fs.mkdirSync(userExtensionsDir, { recursive: true });
52 |     vi.mocked(checkForAllExtensionUpdates).mockReset();
53 |     vi.mocked(updateExtension).mockReset();
54 |   });
55 | 
56 |   afterEach(() => {
57 |     fs.rmSync(tempHomeDir, { recursive: true, force: true });
58 |   });
59 | 
60 |   it('should check for updates and log a message if an update is available', async () => {
61 |     const extensions = [
62 |       {
63 |         name: 'test-extension',
64 |         type: 'git',
65 |         version: '1.0.0',
66 |         path: '/some/path',
67 |         isActive: true,
68 |         installMetadata: {
69 |           type: 'git',
70 |           source: 'https://some/repo',
71 |           autoUpdate: false,
72 |         },
73 |         contextFiles: [],
74 |       },
75 |     ];
76 |     const addItem = vi.fn();
77 |     const cwd = '/test/cwd';
78 | 
79 |     vi.mocked(checkForAllExtensionUpdates).mockImplementation(
80 |       async (_extensions, dispatch, _cwd) => {
81 |         dispatch({
82 |           type: 'SET_STATE',
83 |           payload: {
84 |             name: 'test-extension',
85 |             state: ExtensionUpdateState.UPDATE_AVAILABLE,
86 |           },
87 |         });
88 |       },
89 |     );
90 | 
91 |     renderHook(() =>
92 |       useExtensionUpdates(extensions as GeminiCLIExtension[], addItem, cwd),
93 |     );
94 | 
95 |     await waitFor(() => {
96 |       expect(addItem).toHaveBeenCalledWith(
97 |         {
98 |           type: MessageType.INFO,
99 |           text: 'You have 1 extension with an update available, run "/extensions list" for more information.',
100 |         },
101 |         expect.any(Number),
102 |       );
103 |     });
104 |   });
105 | 
106 |   it('should check for updates and automatically update if autoUpdate is true', async () => {
107 |     const extensionDir = createExtension({
108 |       extensionsDir: userExtensionsDir,
109 |       name: 'test-extension',
110 |       version: '1.0.0',
111 |       installMetadata: {
112 |         source: 'https://some.git/repo',
113 |         type: 'git',
114 |         autoUpdate: true,
115 |       },
116 |     });
117 |     const extension = annotateActiveExtensions(
118 |       [loadExtension({ extensionDir, workspaceDir: tempHomeDir })!],
119 |       tempHomeDir,
120 |       new ExtensionEnablementManager(ExtensionStorage.getUserExtensionsDir()),
121 |     )[0];
122 | 
123 |     const addItem = vi.fn();
124 | 
125 |     vi.mocked(checkForAllExtensionUpdates).mockImplementation(
126 |       async (_extensions, dispatch, _cwd) => {
127 |         dispatch({
128 |           type: 'SET_STATE',
129 |           payload: {
130 |             name: 'test-extension',
131 |             state: ExtensionUpdateState.UPDATE_AVAILABLE,
132 |           },
133 |         });
134 |       },
135 |     );
136 | 
137 |     vi.mocked(updateExtension).mockResolvedValue({
138 |       originalVersion: '1.0.0',
139 |       updatedVersion: '1.1.0',
140 |       name: '',
141 |     });
142 | 
143 |     renderHook(() => useExtensionUpdates([extension], addItem, tempHomeDir));
144 | 
145 |     await waitFor(
146 |       () => {
147 |         expect(addItem).toHaveBeenCalledWith(
148 |           {
149 |             type: MessageType.INFO,
150 |             text: 'Extension "test-extension" successfully updated: 1.0.0 → 1.1.0.',
151 |           },
152 |           expect.any(Number),
153 |         );
154 |       },
155 |       { timeout: 4000 },
156 |     );
157 |   });
158 | 
159 |   it('should batch update notifications for multiple extensions', async () => {
160 |     const extensionDir1 = createExtension({
161 |       extensionsDir: userExtensionsDir,
162 |       name: 'test-extension-1',
163 |       version: '1.0.0',
164 |       installMetadata: {
165 |         source: 'https://some.git/repo1',
166 |         type: 'git',
167 |         autoUpdate: true,
168 |       },
169 |     });
170 |     const extensionDir2 = createExtension({
171 |       extensionsDir: userExtensionsDir,
172 |       name: 'test-extension-2',
173 |       version: '2.0.0',
174 |       installMetadata: {
175 |         source: 'https://some.git/repo2',
176 |         type: 'git',
177 |         autoUpdate: true,
178 |       },
179 |     });
180 | 
181 |     const extensions = annotateActiveExtensions(
182 |       [
183 |         loadExtension({
184 |           extensionDir: extensionDir1,
185 |           workspaceDir: tempHomeDir,
186 |         })!,
187 |         loadExtension({
188 |           extensionDir: extensionDir2,
189 |           workspaceDir: tempHomeDir,
190 |         })!,
191 |       ],
192 |       tempHomeDir,
193 |       new ExtensionEnablementManager(ExtensionStorage.getUserExtensionsDir()),
194 |     );
195 | 
196 |     const addItem = vi.fn();
197 | 
198 |     vi.mocked(checkForAllExtensionUpdates).mockImplementation(
199 |       async (_extensions, dispatch, _cwd) => {
200 |         dispatch({
201 |           type: 'SET_STATE',
202 |           payload: {
203 |             name: 'test-extension-1',
204 |             state: ExtensionUpdateState.UPDATE_AVAILABLE,
205 |           },
206 |         });
207 |         dispatch({
208 |           type: 'SET_STATE',
209 |           payload: {
210 |             name: 'test-extension-2',
211 |             state: ExtensionUpdateState.UPDATE_AVAILABLE,
212 |           },
213 |         });
214 |       },
215 |     );
216 | 
217 |     vi.mocked(updateExtension)
218 |       .mockResolvedValueOnce({
219 |         originalVersion: '1.0.0',
220 |         updatedVersion: '1.1.0',
221 |         name: '',
222 |       })
223 |       .mockResolvedValueOnce({
224 |         originalVersion: '2.0.0',
225 |         updatedVersion: '2.1.0',
226 |         name: '',
227 |       });
228 | 
229 |     renderHook(() => useExtensionUpdates(extensions, addItem, tempHomeDir));
230 | 
231 |     await waitFor(
232 |       () => {
233 |         expect(addItem).toHaveBeenCalledTimes(2);
234 |         expect(addItem).toHaveBeenCalledWith(
235 |           {
236 |             type: MessageType.INFO,
237 |             text: 'Extension "test-extension-1" successfully updated: 1.0.0 → 1.1.0.',
238 |           },
239 |           expect.any(Number),
240 |         );
241 |         expect(addItem).toHaveBeenCalledWith(
242 |           {
243 |             type: MessageType.INFO,
244 |             text: 'Extension "test-extension-2" successfully updated: 2.0.0 → 2.1.0.',
245 |           },
246 |           expect.any(Number),
247 |         );
248 |       },
249 |       { timeout: 4000 },
250 |     );
251 |   });
252 | 
253 |   it('should batch update notifications for multiple extensions with autoUpdate: false', async () => {
254 |     const extensions = [
255 |       {
256 |         name: 'test-extension-1',
257 |         type: 'git',
258 |         version: '1.0.0',
259 |         path: '/some/path1',
260 |         isActive: true,
261 |         installMetadata: {
262 |           type: 'git',
263 |           source: 'https://some/repo1',
264 |           autoUpdate: false,
265 |         },
266 |         contextFiles: [],
267 |       },
268 |       {
269 |         name: 'test-extension-2',
270 |         type: 'git',
271 |         version: '2.0.0',
272 |         path: '/some/path2',
273 |         isActive: true,
274 |         installMetadata: {
275 |           type: 'git',
276 |           source: 'https://some/repo2',
277 |           autoUpdate: false,
278 |         },
279 |         contextFiles: [],
280 |       },
281 |     ];
282 |     const addItem = vi.fn();
283 |     const cwd = '/test/cwd';
284 | 
285 |     vi.mocked(checkForAllExtensionUpdates).mockImplementation(
286 |       async (_extensions, dispatch, _cwd) => {
287 |         dispatch({ type: 'BATCH_CHECK_START' });
288 |         dispatch({
289 |           type: 'SET_STATE',
290 |           payload: {
291 |             name: 'test-extension-1',
292 |             state: ExtensionUpdateState.UPDATE_AVAILABLE,
293 |           },
294 |         });
295 |         await new Promise((r) => setTimeout(r, 50));
296 |         dispatch({
297 |           type: 'SET_STATE',
298 |           payload: {
299 |             name: 'test-extension-2',
300 |             state: ExtensionUpdateState.UPDATE_AVAILABLE,
301 |           },
302 |         });
303 |         dispatch({ type: 'BATCH_CHECK_END' });
304 |       },
305 |     );
306 | 
307 |     renderHook(() =>
308 |       useExtensionUpdates(extensions as GeminiCLIExtension[], addItem, cwd),
309 |     );
310 | 
311 |     await waitFor(() => {
312 |       expect(addItem).toHaveBeenCalledTimes(1);
313 |       expect(addItem).toHaveBeenCalledWith(
314 |         {
315 |           type: MessageType.INFO,
316 |           text: 'You have 2 extensions with an update available, run "/extensions list" for more information.',
317 |         },
318 |         expect.any(Number),
319 |       );
320 |     });
321 |   });
322 | });
```

src/ui/hooks/useExtensionUpdates.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type { GeminiCLIExtension } from '@google/gemini-cli-core';
8 | import { getErrorMessage } from '../../utils/errors.js';
9 | import {
10 |   ExtensionUpdateState,
11 |   extensionUpdatesReducer,
12 |   initialExtensionUpdatesState,
13 | } from '../state/extensions.js';
14 | import { useCallback, useEffect, useMemo, useReducer } from 'react';
15 | import type { UseHistoryManagerReturn } from './useHistoryManager.js';
16 | import { MessageType, type ConfirmationRequest } from '../types.js';
17 | import {
18 |   checkForAllExtensionUpdates,
19 |   updateExtension,
20 | } from '../../config/extensions/update.js';
21 | import {
22 |   requestConsentInteractive,
23 |   type ExtensionUpdateInfo,
24 | } from '../../config/extension.js';
25 | import { checkExhaustive } from '../../utils/checks.js';
26 | 
27 | type ConfirmationRequestWrapper = {
28 |   prompt: React.ReactNode;
29 |   onConfirm: (confirmed: boolean) => void;
30 | };
31 | 
32 | type ConfirmationRequestAction =
33 |   | { type: 'add'; request: ConfirmationRequestWrapper }
34 |   | { type: 'remove'; request: ConfirmationRequestWrapper };
35 | 
36 | function confirmationRequestsReducer(
37 |   state: ConfirmationRequestWrapper[],
38 |   action: ConfirmationRequestAction,
39 | ): ConfirmationRequestWrapper[] {
40 |   switch (action.type) {
41 |     case 'add':
42 |       return [...state, action.request];
43 |     case 'remove':
44 |       return state.filter((r) => r !== action.request);
45 |     default:
46 |       checkExhaustive(action);
47 |   }
48 | }
49 | 
50 | export const useExtensionUpdates = (
51 |   extensions: GeminiCLIExtension[],
52 |   addItem: UseHistoryManagerReturn['addItem'],
53 |   cwd: string,
54 | ) => {
55 |   const [extensionsUpdateState, dispatchExtensionStateUpdate] = useReducer(
56 |     extensionUpdatesReducer,
57 |     initialExtensionUpdatesState,
58 |   );
59 |   const [
60 |     confirmUpdateExtensionRequests,
61 |     dispatchConfirmUpdateExtensionRequests,
62 |   ] = useReducer(confirmationRequestsReducer, []);
63 |   const addConfirmUpdateExtensionRequest = useCallback(
64 |     (original: ConfirmationRequest) => {
65 |       const wrappedRequest = {
66 |         prompt: original.prompt,
67 |         onConfirm: (confirmed: boolean) => {
68 |           // Remove it from the outstanding list of requests by identity.
69 |           dispatchConfirmUpdateExtensionRequests({
70 |             type: 'remove',
71 |             request: wrappedRequest,
72 |           });
73 |           original.onConfirm(confirmed);
74 |         },
75 |       };
76 |       dispatchConfirmUpdateExtensionRequests({
77 |         type: 'add',
78 |         request: wrappedRequest,
79 |       });
80 |     },
81 |     [dispatchConfirmUpdateExtensionRequests],
82 |   );
83 | 
84 |   useEffect(() => {
85 |     const extensionsToCheck = extensions.filter((extension) => {
86 |       const currentStatus = extensionsUpdateState.extensionStatuses.get(
87 |         extension.name,
88 |       );
89 |       if (!currentStatus) return true;
90 |       const currentState = currentStatus.status;
91 |       return !currentState || currentState === ExtensionUpdateState.UNKNOWN;
92 |     });
93 |     if (extensionsToCheck.length === 0) return;
94 |     checkForAllExtensionUpdates(
95 |       extensionsToCheck,
96 |       dispatchExtensionStateUpdate,
97 |       cwd,
98 |     );
99 |   }, [
100 |     extensions,
101 |     extensionsUpdateState.extensionStatuses,
102 |     cwd,
103 |     dispatchExtensionStateUpdate,
104 |   ]);
105 | 
106 |   useEffect(() => {
107 |     if (extensionsUpdateState.batchChecksInProgress > 0) {
108 |       return;
109 |     }
110 |     const scheduledUpdate = extensionsUpdateState.scheduledUpdate;
111 |     if (scheduledUpdate) {
112 |       dispatchExtensionStateUpdate({
113 |         type: 'CLEAR_SCHEDULED_UPDATE',
114 |       });
115 |     }
116 | 
117 |     function shouldDoUpdate(extension: GeminiCLIExtension): boolean {
118 |       if (scheduledUpdate) {
119 |         if (scheduledUpdate.all) {
120 |           return true;
121 |         }
122 |         return scheduledUpdate.names?.includes(extension.name) === true;
123 |       } else {
124 |         return extension.installMetadata?.autoUpdate === true;
125 |       }
126 |     }
127 | 
128 |     let extensionsWithUpdatesCount = 0;
129 |     // We only notify if we have unprocessed extensions in the UPDATE_AVAILABLE
130 |     // state.
131 |     let shouldNotifyOfUpdates = false;
132 |     const updatePromises: Array<Promise<ExtensionUpdateInfo | undefined>> = [];
133 |     for (const extension of extensions) {
134 |       const currentState = extensionsUpdateState.extensionStatuses.get(
135 |         extension.name,
136 |       );
137 |       if (
138 |         !currentState ||
139 |         currentState.status !== ExtensionUpdateState.UPDATE_AVAILABLE
140 |       ) {
141 |         continue;
142 |       }
143 |       const shouldUpdate = shouldDoUpdate(extension);
144 |       if (!shouldUpdate) {
145 |         extensionsWithUpdatesCount++;
146 |         if (!currentState.notified) {
147 |           // Mark as processed immediately to avoid re-triggering.
148 |           dispatchExtensionStateUpdate({
149 |             type: 'SET_NOTIFIED',
150 |             payload: { name: extension.name, notified: true },
151 |           });
152 |           shouldNotifyOfUpdates = true;
153 |         }
154 |       } else {
155 |         const updatePromise = updateExtension(
156 |           extension,
157 |           cwd,
158 |           (description) =>
159 |             requestConsentInteractive(
160 |               description,
161 |               addConfirmUpdateExtensionRequest,
162 |             ),
163 |           currentState.status,
164 |           dispatchExtensionStateUpdate,
165 |         );
166 |         updatePromises.push(updatePromise);
167 |         updatePromise
168 |           .then((result) => {
169 |             if (!result) return;
170 |             addItem(
171 |               {
172 |                 type: MessageType.INFO,
173 |                 text: `Extension "${extension.name}" successfully updated: ${result.originalVersion} → ${result.updatedVersion}.`,
174 |               },
175 |               Date.now(),
176 |             );
177 |           })
178 |           .catch((error) => {
179 |             addItem(
180 |               {
181 |                 type: MessageType.ERROR,
182 |                 text: getErrorMessage(error),
183 |               },
184 |               Date.now(),
185 |             );
186 |           });
187 |       }
188 |     }
189 |     if (shouldNotifyOfUpdates) {
190 |       const s = extensionsWithUpdatesCount > 1 ? 's' : '';
191 |       addItem(
192 |         {
193 |           type: MessageType.INFO,
194 |           text: `You have ${extensionsWithUpdatesCount} extension${s} with an update available, run "/extensions list" for more information.`,
195 |         },
196 |         Date.now(),
197 |       );
198 |     }
199 |     if (scheduledUpdate) {
200 |       Promise.all(updatePromises).then((results) => {
201 |         const nonNullResults = results.filter((result) => result != null);
202 |         scheduledUpdate.onCompleteCallbacks.forEach((callback) => {
203 |           try {
204 |             callback(nonNullResults);
205 |           } catch (e) {
206 |             console.error(getErrorMessage(e));
207 |           }
208 |         });
209 |       });
210 |     }
211 |   }, [
212 |     extensions,
213 |     extensionsUpdateState,
214 |     addConfirmUpdateExtensionRequest,
215 |     addItem,
216 |     cwd,
217 |   ]);
218 | 
219 |   const extensionsUpdateStateComputed = useMemo(() => {
220 |     const result = new Map<string, ExtensionUpdateState>();
221 |     for (const [
222 |       key,
223 |       value,
224 |     ] of extensionsUpdateState.extensionStatuses.entries()) {
225 |       result.set(key, value.status);
226 |     }
227 |     return result;
228 |   }, [extensionsUpdateState]);
229 | 
230 |   return {
231 |     extensionsUpdateState: extensionsUpdateStateComputed,
232 |     extensionsUpdateStateInternal: extensionsUpdateState.extensionStatuses,
233 |     dispatchExtensionStateUpdate,
234 |     confirmUpdateExtensionRequests,
235 |     addConfirmUpdateExtensionRequest,
236 |   };
237 | };
```

src/ui/hooks/useFlickerDetector.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { renderHook } from '@testing-library/react';
8 | import { vi, type Mock } from 'vitest';
9 | import { useFlickerDetector } from './useFlickerDetector.js';
10 | import { useConfig } from '../contexts/ConfigContext.js';
11 | import { recordFlickerFrame } from '@google/gemini-cli-core';
12 | import { type Config } from '@google/gemini-cli-core';
13 | import { type DOMElement, measureElement } from 'ink';
14 | import { useUIState } from '../contexts/UIStateContext.js';
15 | import { appEvents, AppEvent } from '../../utils/events.js';
16 | 
17 | // Mock dependencies
18 | vi.mock('../contexts/ConfigContext.js');
19 | vi.mock('../contexts/UIStateContext.js');
20 | vi.mock('@google/gemini-cli-core', () => ({
21 |   recordFlickerFrame: vi.fn(),
22 | }));
23 | vi.mock('ink', async (importOriginal) => {
24 |   const original = await importOriginal<typeof import('ink')>();
25 |   return {
26 |     ...original,
27 |     measureElement: vi.fn(),
28 |   };
29 | });
30 | vi.mock('../../utils/events.js', () => ({
31 |   appEvents: {
32 |     emit: vi.fn(),
33 |   },
34 |   AppEvent: {
35 |     Flicker: 'flicker',
36 |   },
37 | }));
38 | 
39 | const mockUseConfig = useConfig as Mock;
40 | const mockUseUIState = useUIState as Mock;
41 | const mockRecordFlickerFrame = recordFlickerFrame as Mock;
42 | const mockMeasureElement = measureElement as Mock;
43 | const mockAppEventsEmit = appEvents.emit as Mock;
44 | 
45 | describe('useFlickerDetector', () => {
46 |   const mockConfig = {} as Config;
47 |   let mockRef: React.RefObject<DOMElement | null>;
48 | 
49 |   beforeEach(() => {
50 |     mockUseConfig.mockReturnValue(mockConfig);
51 |     mockRef = { current: { yogaNode: {} } as DOMElement };
52 |     // Default UI state
53 |     mockUseUIState.mockReturnValue({ constrainHeight: true });
54 |   });
55 | 
56 |   afterEach(() => {
57 |     vi.clearAllMocks();
58 |   });
59 | 
60 |   it('should not record a flicker when height is less than terminal height', () => {
61 |     mockMeasureElement.mockReturnValue({ width: 80, height: 20 });
62 |     renderHook(() => useFlickerDetector(mockRef, 25));
63 |     expect(mockRecordFlickerFrame).not.toHaveBeenCalled();
64 |     expect(mockAppEventsEmit).not.toHaveBeenCalled();
65 |   });
66 | 
67 |   it('should not record a flicker when height is equal to terminal height', () => {
68 |     mockMeasureElement.mockReturnValue({ width: 80, height: 25 });
69 |     renderHook(() => useFlickerDetector(mockRef, 25));
70 |     expect(mockRecordFlickerFrame).not.toHaveBeenCalled();
71 |     expect(mockAppEventsEmit).not.toHaveBeenCalled();
72 |   });
73 | 
74 |   it('should record a flicker when height is greater than terminal height and height is constrained', () => {
75 |     mockMeasureElement.mockReturnValue({ width: 80, height: 30 });
76 |     renderHook(() => useFlickerDetector(mockRef, 25));
77 |     expect(mockRecordFlickerFrame).toHaveBeenCalledTimes(1);
78 |     expect(mockRecordFlickerFrame).toHaveBeenCalledWith(mockConfig);
79 |     expect(mockAppEventsEmit).toHaveBeenCalledTimes(1);
80 |     expect(mockAppEventsEmit).toHaveBeenCalledWith(AppEvent.Flicker);
81 |   });
82 | 
83 |   it('should NOT record a flicker when height is greater than terminal height but height is NOT constrained', () => {
84 |     // Override default UI state for this test
85 |     mockUseUIState.mockReturnValue({ constrainHeight: false });
86 |     mockMeasureElement.mockReturnValue({ width: 80, height: 30 });
87 |     renderHook(() => useFlickerDetector(mockRef, 25));
88 |     expect(mockRecordFlickerFrame).not.toHaveBeenCalled();
89 |     expect(mockAppEventsEmit).not.toHaveBeenCalled();
90 |   });
91 | 
92 |   it('should not check for flicker if the ref is not set', () => {
93 |     mockRef.current = null;
94 |     mockMeasureElement.mockReturnValue({ width: 80, height: 30 });
95 |     renderHook(() => useFlickerDetector(mockRef, 25));
96 |     expect(mockMeasureElement).not.toHaveBeenCalled();
97 |     expect(mockRecordFlickerFrame).not.toHaveBeenCalled();
98 |     expect(mockAppEventsEmit).not.toHaveBeenCalled();
99 |   });
100 | 
101 |   it('should re-evaluate on re-render', () => {
102 |     // Start with a valid height
103 |     mockMeasureElement.mockReturnValue({ width: 80, height: 20 });
104 |     const { rerender } = renderHook(() => useFlickerDetector(mockRef, 25));
105 |     expect(mockRecordFlickerFrame).not.toHaveBeenCalled();
106 | 
107 |     // Now, simulate a re-render where the height is too great
108 |     mockMeasureElement.mockReturnValue({ width: 80, height: 30 });
109 |     rerender();
110 | 
111 |     expect(mockRecordFlickerFrame).toHaveBeenCalledTimes(1);
112 |     expect(mockAppEventsEmit).toHaveBeenCalledTimes(1);
113 |   });
114 | });
```

src/ui/hooks/useFlickerDetector.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { type DOMElement, measureElement } from 'ink';
8 | import { useEffect } from 'react';
9 | import { useConfig } from '../contexts/ConfigContext.js';
10 | import { recordFlickerFrame } from '@google/gemini-cli-core';
11 | import { appEvents, AppEvent } from '../../utils/events.js';
12 | import { useUIState } from '../contexts/UIStateContext.js';
13 | 
14 | /**
15 |  * A hook that detects when the UI flickers (renders taller than the terminal).
16 |  * This is a sign of a rendering bug that should be fixed.
17 |  *
18 |  * @param rootUiRef A ref to the root UI element.
19 |  * @param terminalHeight The height of the terminal.
20 |  */
21 | export function useFlickerDetector(
22 |   rootUiRef: React.RefObject<DOMElement | null>,
23 |   terminalHeight: number,
24 | ) {
25 |   const config = useConfig();
26 |   const { constrainHeight } = useUIState();
27 | 
28 |   useEffect(() => {
29 |     if (rootUiRef.current) {
30 |       const measurement = measureElement(rootUiRef.current);
31 |       if (measurement.height > terminalHeight) {
32 |         // If we are not constraining the height, we are intentionally
33 |         // overflowing the screen.
34 |         if (!constrainHeight) {
35 |           return;
36 |         }
37 | 
38 |         recordFlickerFrame(config);
39 |         appEvents.emit(AppEvent.Flicker);
40 |       }
41 |     }
42 |   });
43 | }
```

src/ui/hooks/useFocus.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { renderHook, act } from '@testing-library/react';
8 | import { EventEmitter } from 'node:events';
9 | import { useFocus } from './useFocus.js';
10 | import { vi } from 'vitest';
11 | import { useStdin, useStdout } from 'ink';
12 | import { KeypressProvider } from '../contexts/KeypressContext.js';
13 | import React from 'react';
14 | 
15 | // Mock the ink hooks
16 | vi.mock('ink', async (importOriginal) => {
17 |   const original = await importOriginal<typeof import('ink')>();
18 |   return {
19 |     ...original,
20 |     useStdin: vi.fn(),
21 |     useStdout: vi.fn(),
22 |   };
23 | });
24 | 
25 | const mockedUseStdin = vi.mocked(useStdin);
26 | const mockedUseStdout = vi.mocked(useStdout);
27 | 
28 | const wrapper = ({ children }: { children: React.ReactNode }) =>
29 |   React.createElement(KeypressProvider, null, children);
30 | 
31 | describe('useFocus', () => {
32 |   let stdin: EventEmitter;
33 |   let stdout: { write: vi.Func };
34 | 
35 |   beforeEach(() => {
36 |     stdin = new EventEmitter();
37 |     stdin.resume = vi.fn();
38 |     stdin.pause = vi.fn();
39 |     stdout = { write: vi.fn() };
40 |     mockedUseStdin.mockReturnValue({ stdin } as ReturnType<typeof useStdin>);
41 |     mockedUseStdout.mockReturnValue({ stdout } as unknown as ReturnType<
42 |       typeof useStdout
43 |     >);
44 |   });
45 | 
46 |   afterEach(() => {
47 |     vi.clearAllMocks();
48 |     stdin.removeAllListeners();
49 |   });
50 | 
51 |   it('should initialize with focus and enable focus reporting', () => {
52 |     const { result } = renderHook(() => useFocus(), { wrapper });
53 | 
54 |     expect(result.current).toBe(true);
55 |     expect(stdout.write).toHaveBeenCalledWith('\x1b[?1004h');
56 |   });
57 | 
58 |   it('should set isFocused to false when a focus-out event is received', () => {
59 |     const { result } = renderHook(() => useFocus(), { wrapper });
60 | 
61 |     // Initial state is focused
62 |     expect(result.current).toBe(true);
63 | 
64 |     // Simulate focus-out event
65 |     act(() => {
66 |       stdin.emit('data', Buffer.from('\x1b[O'));
67 |     });
68 | 
69 |     // State should now be unfocused
70 |     expect(result.current).toBe(false);
71 |   });
72 | 
73 |   it('should set isFocused to true when a focus-in event is received', () => {
74 |     const { result } = renderHook(() => useFocus(), { wrapper });
75 | 
76 |     // Simulate focus-out to set initial state to false
77 |     act(() => {
78 |       stdin.emit('data', Buffer.from('\x1b[O'));
79 |     });
80 |     expect(result.current).toBe(false);
81 | 
82 |     // Simulate focus-in event
83 |     act(() => {
84 |       stdin.emit('data', Buffer.from('\x1b[I'));
85 |     });
86 | 
87 |     // State should now be focused
88 |     expect(result.current).toBe(true);
89 |   });
90 | 
91 |   it('should clean up and disable focus reporting on unmount', () => {
92 |     const { unmount } = renderHook(() => useFocus(), { wrapper });
93 | 
94 |     // At this point we should have listeners from both KeypressProvider and useFocus
95 |     const listenerCountAfterMount = stdin.listenerCount('data');
96 |     expect(listenerCountAfterMount).toBeGreaterThanOrEqual(1);
97 | 
98 |     unmount();
99 | 
100 |     // Assert that the cleanup function was called
101 |     expect(stdout.write).toHaveBeenCalledWith('\x1b[?1004l');
102 |     // Ensure useFocus listener was removed (but KeypressProvider listeners may remain)
103 |     expect(stdin.listenerCount('data')).toBeLessThan(listenerCountAfterMount);
104 |   });
105 | 
106 |   it('should handle multiple focus events correctly', () => {
107 |     const { result } = renderHook(() => useFocus(), { wrapper });
108 | 
109 |     act(() => {
110 |       stdin.emit('data', Buffer.from('\x1b[O'));
111 |     });
112 |     expect(result.current).toBe(false);
113 | 
114 |     act(() => {
115 |       stdin.emit('data', Buffer.from('\x1b[O'));
116 |     });
117 |     expect(result.current).toBe(false);
118 | 
119 |     act(() => {
120 |       stdin.emit('data', Buffer.from('\x1b[I'));
121 |     });
122 |     expect(result.current).toBe(true);
123 | 
124 |     act(() => {
125 |       stdin.emit('data', Buffer.from('\x1b[I'));
126 |     });
127 |     expect(result.current).toBe(true);
128 |   });
129 | 
130 |   it('restores focus on keypress after focus is lost', () => {
131 |     const { result } = renderHook(() => useFocus(), { wrapper });
132 | 
133 |     // Simulate focus-out event
134 |     act(() => {
135 |       stdin.emit('data', Buffer.from('\x1b[O'));
136 |     });
137 |     expect(result.current).toBe(false);
138 | 
139 |     // Simulate a keypress
140 |     act(() => {
141 |       stdin.emit('data', Buffer.from('a'));
142 |     });
143 |     expect(result.current).toBe(true);
144 |   });
145 | });
```

src/ui/hooks/useFocus.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { useStdin, useStdout } from 'ink';
8 | import { useEffect, useState } from 'react';
9 | import { useKeypress } from './useKeypress.js';
10 | 
11 | // ANSI escape codes to enable/disable terminal focus reporting
12 | export const ENABLE_FOCUS_REPORTING = '\x1b[?1004h';
13 | export const DISABLE_FOCUS_REPORTING = '\x1b[?1004l';
14 | 
15 | // ANSI escape codes for focus events
16 | export const FOCUS_IN = '\x1b[I';
17 | export const FOCUS_OUT = '\x1b[O';
18 | 
19 | export const useFocus = () => {
20 |   const { stdin } = useStdin();
21 |   const { stdout } = useStdout();
22 |   const [isFocused, setIsFocused] = useState(true);
23 | 
24 |   useEffect(() => {
25 |     const handleData = (data: Buffer) => {
26 |       const sequence = data.toString();
27 |       const lastFocusIn = sequence.lastIndexOf(FOCUS_IN);
28 |       const lastFocusOut = sequence.lastIndexOf(FOCUS_OUT);
29 | 
30 |       if (lastFocusIn > lastFocusOut) {
31 |         setIsFocused(true);
32 |       } else if (lastFocusOut > lastFocusIn) {
33 |         setIsFocused(false);
34 |       }
35 |     };
36 | 
37 |     // Enable focus reporting
38 |     stdout?.write(ENABLE_FOCUS_REPORTING);
39 |     stdin?.on('data', handleData);
40 | 
41 |     return () => {
42 |       // Disable focus reporting on cleanup
43 |       stdout?.write(DISABLE_FOCUS_REPORTING);
44 |       stdin?.removeListener('data', handleData);
45 |     };
46 |   }, [stdin, stdout]);
47 | 
48 |   useKeypress(
49 |     (_) => {
50 |       if (!isFocused) {
51 |         // If the user has typed a key, and we cannot possibly be focused out.
52 |         // This is a workaround for some tmux use cases. It is still useful to
53 |         // listen for the true FOCUS_IN event as well as that will update the
54 |         // focus state earlier than waiting for a keypress.
55 |         setIsFocused(true);
56 |       }
57 |     },
58 |     { isActive: true },
59 |   );
60 | 
61 |   return isFocused;
62 | };
```

src/ui/hooks/useFolderTrust.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { vi } from 'vitest';
8 | import { renderHook, act } from '@testing-library/react';
9 | import { useFolderTrust } from './useFolderTrust.js';
10 | import type { LoadedSettings } from '../../config/settings.js';
11 | import { FolderTrustChoice } from '../components/FolderTrustDialog.js';
12 | import type { LoadedTrustedFolders } from '../../config/trustedFolders.js';
13 | import { TrustLevel } from '../../config/trustedFolders.js';
14 | import * as trustedFolders from '../../config/trustedFolders.js';
15 | 
16 | const mockedCwd = vi.hoisted(() => vi.fn());
17 | 
18 | vi.mock('node:process', async () => {
19 |   const actual =
20 |     await vi.importActual<typeof import('node:process')>('node:process');
21 |   return {
22 |     ...actual,
23 |     cwd: mockedCwd,
24 |     platform: 'linux',
25 |   };
26 | });
27 | 
28 | describe('useFolderTrust', () => {
29 |   let mockSettings: LoadedSettings;
30 |   let mockTrustedFolders: LoadedTrustedFolders;
31 |   let loadTrustedFoldersSpy: vi.SpyInstance;
32 |   let isWorkspaceTrustedSpy: vi.SpyInstance;
33 |   let onTrustChange: (isTrusted: boolean | undefined) => void;
34 |   let addItem: vi.Mock;
35 | 
36 |   beforeEach(() => {
37 |     mockSettings = {
38 |       merged: {
39 |         security: {
40 |           folderTrust: {
41 |             enabled: true,
42 |           },
43 |         },
44 |       },
45 |       setValue: vi.fn(),
46 |     } as unknown as LoadedSettings;
47 | 
48 |     mockTrustedFolders = {
49 |       setValue: vi.fn(),
50 |     } as unknown as LoadedTrustedFolders;
51 | 
52 |     loadTrustedFoldersSpy = vi
53 |       .spyOn(trustedFolders, 'loadTrustedFolders')
54 |       .mockReturnValue(mockTrustedFolders);
55 |     isWorkspaceTrustedSpy = vi.spyOn(trustedFolders, 'isWorkspaceTrusted');
56 |     mockedCwd.mockReturnValue('/test/path');
57 |     onTrustChange = vi.fn();
58 |     addItem = vi.fn();
59 |   });
60 | 
61 |   afterEach(() => {
62 |     vi.clearAllMocks();
63 |   });
64 | 
65 |   it('should not open dialog when folder is already trusted', () => {
66 |     isWorkspaceTrustedSpy.mockReturnValue({ isTrusted: true, source: 'file' });
67 |     const { result } = renderHook(() =>
68 |       useFolderTrust(mockSettings, onTrustChange, addItem),
69 |     );
70 |     expect(result.current.isFolderTrustDialogOpen).toBe(false);
71 |     expect(onTrustChange).toHaveBeenCalledWith(true);
72 |   });
73 | 
74 |   it('should not open dialog when folder is already untrusted', () => {
75 |     isWorkspaceTrustedSpy.mockReturnValue({ isTrusted: false, source: 'file' });
76 |     const { result } = renderHook(() =>
77 |       useFolderTrust(mockSettings, onTrustChange, addItem),
78 |     );
79 |     expect(result.current.isFolderTrustDialogOpen).toBe(false);
80 |     expect(onTrustChange).toHaveBeenCalledWith(false);
81 |   });
82 | 
83 |   it('should open dialog when folder trust is undefined', () => {
84 |     isWorkspaceTrustedSpy.mockReturnValue({
85 |       isTrusted: undefined,
86 |       source: undefined,
87 |     });
88 |     const { result } = renderHook(() =>
89 |       useFolderTrust(mockSettings, onTrustChange, addItem),
90 |     );
91 |     expect(result.current.isFolderTrustDialogOpen).toBe(true);
92 |     expect(onTrustChange).toHaveBeenCalledWith(undefined);
93 |   });
94 | 
95 |   it('should send a message if the folder is untrusted', () => {
96 |     isWorkspaceTrustedSpy.mockReturnValue({ isTrusted: false, source: 'file' });
97 |     renderHook(() => useFolderTrust(mockSettings, onTrustChange, addItem));
98 |     expect(addItem).toHaveBeenCalledWith(
99 |       {
100 |         text: 'This folder is not trusted. Some features may be disabled. Use the `/permissions` command to change the trust level.',
101 |         type: 'info',
102 |       },
103 |       expect.any(Number),
104 |     );
105 |   });
106 | 
107 |   it('should not send a message if the folder is trusted', () => {
108 |     isWorkspaceTrustedSpy.mockReturnValue({ isTrusted: true, source: 'file' });
109 |     renderHook(() => useFolderTrust(mockSettings, onTrustChange, addItem));
110 |     expect(addItem).not.toHaveBeenCalled();
111 |   });
112 | 
113 |   it('should handle TRUST_FOLDER choice', () => {
114 |     isWorkspaceTrustedSpy.mockReturnValue({
115 |       isTrusted: undefined,
116 |       source: undefined,
117 |     });
118 |     const { result } = renderHook(() =>
119 |       useFolderTrust(mockSettings, onTrustChange, addItem),
120 |     );
121 | 
122 |     act(() => {
123 |       result.current.handleFolderTrustSelect(FolderTrustChoice.TRUST_FOLDER);
124 |     });
125 | 
126 |     expect(loadTrustedFoldersSpy).toHaveBeenCalled();
127 |     expect(mockTrustedFolders.setValue).toHaveBeenCalledWith(
128 |       '/test/path',
129 |       TrustLevel.TRUST_FOLDER,
130 |     );
131 |     expect(result.current.isFolderTrustDialogOpen).toBe(false);
132 |     expect(onTrustChange).toHaveBeenLastCalledWith(true);
133 |   });
134 | 
135 |   it('should handle TRUST_PARENT choice', () => {
136 |     isWorkspaceTrustedSpy.mockReturnValue({
137 |       isTrusted: undefined,
138 |       source: undefined,
139 |     });
140 |     const { result } = renderHook(() =>
141 |       useFolderTrust(mockSettings, onTrustChange, addItem),
142 |     );
143 | 
144 |     act(() => {
145 |       result.current.handleFolderTrustSelect(FolderTrustChoice.TRUST_PARENT);
146 |     });
147 | 
148 |     expect(mockTrustedFolders.setValue).toHaveBeenCalledWith(
149 |       '/test/path',
150 |       TrustLevel.TRUST_PARENT,
151 |     );
152 |     expect(result.current.isFolderTrustDialogOpen).toBe(false);
153 |     expect(onTrustChange).toHaveBeenLastCalledWith(true);
154 |   });
155 | 
156 |   it('should handle DO_NOT_TRUST choice and trigger restart', () => {
157 |     isWorkspaceTrustedSpy.mockReturnValue({
158 |       isTrusted: undefined,
159 |       source: undefined,
160 |     });
161 |     const { result } = renderHook(() =>
162 |       useFolderTrust(mockSettings, onTrustChange, addItem),
163 |     );
164 | 
165 |     act(() => {
166 |       result.current.handleFolderTrustSelect(FolderTrustChoice.DO_NOT_TRUST);
167 |     });
168 | 
169 |     expect(mockTrustedFolders.setValue).toHaveBeenCalledWith(
170 |       '/test/path',
171 |       TrustLevel.DO_NOT_TRUST,
172 |     );
173 |     expect(onTrustChange).toHaveBeenLastCalledWith(false);
174 |     expect(result.current.isRestarting).toBe(true);
175 |     expect(result.current.isFolderTrustDialogOpen).toBe(true);
176 |   });
177 | 
178 |   it('should do nothing for default choice', () => {
179 |     isWorkspaceTrustedSpy.mockReturnValue({
180 |       isTrusted: undefined,
181 |       source: undefined,
182 |     });
183 |     const { result } = renderHook(() =>
184 |       useFolderTrust(mockSettings, onTrustChange, addItem),
185 |     );
186 | 
187 |     act(() => {
188 |       result.current.handleFolderTrustSelect(
189 |         'invalid_choice' as FolderTrustChoice,
190 |       );
191 |     });
192 | 
193 |     expect(mockTrustedFolders.setValue).not.toHaveBeenCalled();
194 |     expect(mockSettings.setValue).not.toHaveBeenCalled();
195 |     expect(result.current.isFolderTrustDialogOpen).toBe(true);
196 |     expect(onTrustChange).toHaveBeenCalledWith(undefined);
197 |   });
198 | 
199 |   it('should set isRestarting to true when trust status changes from false to true', () => {
200 |     isWorkspaceTrustedSpy.mockReturnValue({ isTrusted: false, source: 'file' }); // Initially untrusted
201 |     const { result } = renderHook(() =>
202 |       useFolderTrust(mockSettings, onTrustChange, addItem),
203 |     );
204 | 
205 |     act(() => {
206 |       result.current.handleFolderTrustSelect(FolderTrustChoice.TRUST_FOLDER);
207 |     });
208 | 
209 |     expect(result.current.isRestarting).toBe(true);
210 |     expect(result.current.isFolderTrustDialogOpen).toBe(true); // Dialog should stay open
211 |   });
212 | 
213 |   it('should not set isRestarting to true when trust status does not change', () => {
214 |     isWorkspaceTrustedSpy.mockReturnValue({
215 |       isTrusted: undefined,
216 |       source: undefined,
217 |     });
218 |     const { result } = renderHook(() =>
219 |       useFolderTrust(mockSettings, onTrustChange, addItem),
220 |     );
221 | 
222 |     act(() => {
223 |       result.current.handleFolderTrustSelect(FolderTrustChoice.TRUST_FOLDER);
224 |     });
225 | 
226 |     expect(result.current.isRestarting).toBe(false);
227 |     expect(result.current.isFolderTrustDialogOpen).toBe(false); // Dialog should close
228 |   });
229 | });
```

src/ui/hooks/useFolderTrust.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { useState, useCallback, useEffect, useRef } from 'react';
8 | import type { LoadedSettings } from '../../config/settings.js';
9 | import { FolderTrustChoice } from '../components/FolderTrustDialog.js';
10 | import {
11 |   loadTrustedFolders,
12 |   TrustLevel,
13 |   isWorkspaceTrusted,
14 | } from '../../config/trustedFolders.js';
15 | import * as process from 'node:process';
16 | import { type HistoryItemWithoutId, MessageType } from '../types.js';
17 | 
18 | export const useFolderTrust = (
19 |   settings: LoadedSettings,
20 |   onTrustChange: (isTrusted: boolean | undefined) => void,
21 |   addItem: (item: HistoryItemWithoutId, timestamp: number) => number,
22 | ) => {
23 |   const [isTrusted, setIsTrusted] = useState<boolean | undefined>(undefined);
24 |   const [isFolderTrustDialogOpen, setIsFolderTrustDialogOpen] = useState(false);
25 |   const [isRestarting, setIsRestarting] = useState(false);
26 |   const startupMessageSent = useRef(false);
27 | 
28 |   const folderTrust = settings.merged.security?.folderTrust?.enabled;
29 | 
30 |   useEffect(() => {
31 |     const { isTrusted: trusted } = isWorkspaceTrusted(settings.merged);
32 |     setIsTrusted(trusted);
33 |     setIsFolderTrustDialogOpen(trusted === undefined);
34 |     onTrustChange(trusted);
35 | 
36 |     if (trusted === false && !startupMessageSent.current) {
37 |       addItem(
38 |         {
39 |           type: MessageType.INFO,
40 |           text: 'This folder is not trusted. Some features may be disabled. Use the `/permissions` command to change the trust level.',
41 |         },
42 |         Date.now(),
43 |       );
44 |       startupMessageSent.current = true;
45 |     }
46 |   }, [folderTrust, onTrustChange, settings.merged, addItem]);
47 | 
48 |   const handleFolderTrustSelect = useCallback(
49 |     (choice: FolderTrustChoice) => {
50 |       const trustedFolders = loadTrustedFolders();
51 |       const cwd = process.cwd();
52 |       let trustLevel: TrustLevel;
53 | 
54 |       const wasTrusted = isTrusted ?? true;
55 | 
56 |       switch (choice) {
57 |         case FolderTrustChoice.TRUST_FOLDER:
58 |           trustLevel = TrustLevel.TRUST_FOLDER;
59 |           break;
60 |         case FolderTrustChoice.TRUST_PARENT:
61 |           trustLevel = TrustLevel.TRUST_PARENT;
62 |           break;
63 |         case FolderTrustChoice.DO_NOT_TRUST:
64 |           trustLevel = TrustLevel.DO_NOT_TRUST;
65 |           break;
66 |         default:
67 |           return;
68 |       }
69 | 
70 |       trustedFolders.setValue(cwd, trustLevel);
71 |       const currentIsTrusted =
72 |         trustLevel === TrustLevel.TRUST_FOLDER ||
73 |         trustLevel === TrustLevel.TRUST_PARENT;
74 |       setIsTrusted(currentIsTrusted);
75 |       onTrustChange(currentIsTrusted);
76 | 
77 |       const needsRestart = wasTrusted !== currentIsTrusted;
78 |       if (needsRestart) {
79 |         setIsRestarting(true);
80 |         setIsFolderTrustDialogOpen(true);
81 |       } else {
82 |         setIsFolderTrustDialogOpen(false);
83 |       }
84 |     },
85 |     [onTrustChange, isTrusted],
86 |   );
87 | 
88 |   return {
89 |     isTrusted,
90 |     isFolderTrustDialogOpen,
91 |     handleFolderTrustSelect,
92 |     isRestarting,
93 |   };
94 | };
```

src/ui/hooks/useGeminiStream.test.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | /* eslint-disable @typescript-eslint/no-explicit-any */
8 | import type { Mock, MockInstance } from 'vitest';
9 | import { describe, it, expect, vi, beforeEach } from 'vitest';
10 | import { renderHook, act, waitFor } from '@testing-library/react';
11 | import { useGeminiStream } from './useGeminiStream.js';
12 | import { useKeypress } from './useKeypress.js';
13 | import * as atCommandProcessor from './atCommandProcessor.js';
14 | import type {
15 |   TrackedToolCall,
16 |   TrackedCompletedToolCall,
17 |   TrackedExecutingToolCall,
18 |   TrackedCancelledToolCall,
19 |   TrackedWaitingToolCall,
20 | } from './useReactToolScheduler.js';
21 | import { useReactToolScheduler } from './useReactToolScheduler.js';
22 | import type {
23 |   Config,
24 |   EditorType,
25 |   GeminiClient,
26 |   AnyToolInvocation,
27 | } from '@google/gemini-cli-core';
28 | import {
29 |   ApprovalMode,
30 |   AuthType,
31 |   GeminiEventType as ServerGeminiEventType,
32 |   ToolErrorType,
33 |   ToolConfirmationOutcome,
34 |   tokenLimit,
35 | } from '@google/gemini-cli-core';
36 | import type { Part, PartListUnion } from '@google/genai';
37 | import type { UseHistoryManagerReturn } from './useHistoryManager.js';
38 | import type { HistoryItem, SlashCommandProcessorResult } from '../types.js';
39 | import { MessageType, StreamingState } from '../types.js';
40 | import type { LoadedSettings } from '../../config/settings.js';
41 | 
42 | // --- MOCKS ---
43 | const mockSendMessageStream = vi
44 |   .fn()
45 |   .mockReturnValue((async function* () {})());
46 | const mockStartChat = vi.fn();
47 | 
48 | const MockedGeminiClientClass = vi.hoisted(() =>
49 |   vi.fn().mockImplementation(function (this: any, _config: any) {
50 |     // _config
51 |     this.startChat = mockStartChat;
52 |     this.sendMessageStream = mockSendMessageStream;
53 |     this.addHistory = vi.fn();
54 |     this.getChat = vi.fn().mockReturnValue({
55 |       recordCompletedToolCalls: vi.fn(),
56 |     });
57 |     this.getChatRecordingService = vi.fn().mockReturnValue({
58 |       recordThought: vi.fn(),
59 |       initialize: vi.fn(),
60 |       recordMessage: vi.fn(),
61 |       recordMessageTokens: vi.fn(),
62 |       recordToolCalls: vi.fn(),
63 |       getConversationFile: vi.fn(),
64 |     });
65 |   }),
66 | );
67 | 
68 | const MockedUserPromptEvent = vi.hoisted(() =>
69 |   vi.fn().mockImplementation(() => {}),
70 | );
71 | const mockParseAndFormatApiError = vi.hoisted(() => vi.fn());
72 | 
73 | vi.mock('@google/gemini-cli-core', async (importOriginal) => {
74 |   const actualCoreModule = (await importOriginal()) as any;
75 |   return {
76 |     ...actualCoreModule,
77 |     GitService: vi.fn(),
78 |     GeminiClient: MockedGeminiClientClass,
79 |     UserPromptEvent: MockedUserPromptEvent,
80 |     parseAndFormatApiError: mockParseAndFormatApiError,
81 |     tokenLimit: vi.fn().mockReturnValue(100), // Mock tokenLimit
82 |   };
83 | });
84 | 
85 | const mockUseReactToolScheduler = useReactToolScheduler as Mock;
86 | vi.mock('./useReactToolScheduler.js', async (importOriginal) => {
87 |   const actualSchedulerModule = (await importOriginal()) as any;
88 |   return {
89 |     ...(actualSchedulerModule || {}),
90 |     useReactToolScheduler: vi.fn(),
91 |   };
92 | });
93 | 
94 | vi.mock('./useKeypress.js', () => ({
95 |   useKeypress: vi.fn(),
96 | }));
97 | 
98 | vi.mock('./shellCommandProcessor.js', () => ({
99 |   useShellCommandProcessor: vi.fn().mockReturnValue({
100 |     handleShellCommand: vi.fn(),
101 |   }),
102 | }));
103 | 
104 | vi.mock('./atCommandProcessor.js');
105 | 
106 | vi.mock('../utils/markdownUtilities.js', () => ({
107 |   findLastSafeSplitPoint: vi.fn((s: string) => s.length),
108 | }));
109 | 
110 | vi.mock('./useStateAndRef.js', () => ({
111 |   useStateAndRef: vi.fn((initial) => {
112 |     let val = initial;
113 |     const ref = { current: val };
114 |     const setVal = vi.fn((updater) => {
115 |       if (typeof updater === 'function') {
116 |         val = updater(val);
117 |       } else {
118 |         val = updater;
119 |       }
120 |       ref.current = val;
121 |     });
122 |     return [val, ref, setVal];
123 |   }),
124 | }));
125 | 
126 | vi.mock('./useLogger.js', () => ({
127 |   useLogger: vi.fn().mockReturnValue({
128 |     logMessage: vi.fn().mockResolvedValue(undefined),
129 |   }),
130 | }));
131 | 
132 | const mockStartNewPrompt = vi.fn();
133 | const mockAddUsage = vi.fn();
134 | vi.mock('../contexts/SessionContext.js', () => ({
135 |   useSessionStats: vi.fn(() => ({
136 |     startNewPrompt: mockStartNewPrompt,
137 |     addUsage: mockAddUsage,
138 |     getPromptCount: vi.fn(() => 5),
139 |   })),
140 | }));
141 | 
142 | vi.mock('./slashCommandProcessor.js', () => ({
143 |   handleSlashCommand: vi.fn().mockReturnValue(false),
144 | }));
145 | 
146 | // --- END MOCKS ---
147 | 
148 | // --- Tests for useGeminiStream Hook ---
149 | describe('useGeminiStream', () => {
150 |   let mockAddItem: Mock;
151 |   let mockConfig: Config;
152 |   let mockOnDebugMessage: Mock;
153 |   let mockHandleSlashCommand: Mock;
154 |   let mockScheduleToolCalls: Mock;
155 |   let mockCancelAllToolCalls: Mock;
156 |   let mockMarkToolsAsSubmitted: Mock;
157 |   let handleAtCommandSpy: MockInstance;
158 | 
159 |   beforeEach(() => {
160 |     vi.clearAllMocks(); // Clear mocks before each test
161 | 
162 |     mockAddItem = vi.fn();
163 |     // Define the mock for getGeminiClient
164 |     const mockGetGeminiClient = vi.fn().mockImplementation(() => {
165 |       // MockedGeminiClientClass is defined in the module scope by the previous change.
166 |       // It will use the mockStartChat and mockSendMessageStream that are managed within beforeEach.
167 |       const clientInstance = new MockedGeminiClientClass(mockConfig);
168 |       return clientInstance;
169 |     });
170 | 
171 |     const contentGeneratorConfig = {
172 |       model: 'test-model',
173 |       apiKey: 'test-key',
174 |       vertexai: false,
175 |       authType: AuthType.USE_GEMINI,
176 |     };
177 | 
178 |     mockConfig = {
179 |       apiKey: 'test-api-key',
180 |       model: 'gemini-pro',
181 |       sandbox: false,
182 |       targetDir: '/test/dir',
183 |       debugMode: false,
184 |       question: undefined,
185 |       fullContext: false,
186 |       coreTools: [],
187 |       toolDiscoveryCommand: undefined,
188 |       toolCallCommand: undefined,
189 |       mcpServerCommand: undefined,
190 |       mcpServers: undefined,
191 |       userAgent: 'test-agent',
192 |       userMemory: '',
193 |       geminiMdFileCount: 0,
194 |       alwaysSkipModificationConfirmation: false,
195 |       vertexai: false,
196 |       showMemoryUsage: false,
197 |       contextFileName: undefined,
198 |       getToolRegistry: vi.fn(
199 |         () => ({ getToolSchemaList: vi.fn(() => []) }) as any,
200 |       ),
201 |       getProjectRoot: vi.fn(() => '/test/dir'),
202 |       getCheckpointingEnabled: vi.fn(() => false),
203 |       getGeminiClient: mockGetGeminiClient,
204 |       getApprovalMode: () => ApprovalMode.DEFAULT,
205 |       getUsageStatisticsEnabled: () => true,
206 |       getDebugMode: () => false,
207 |       addHistory: vi.fn(),
208 |       getSessionId() {
209 |         return 'test-session-id';
210 |       },
211 |       setQuotaErrorOccurred: vi.fn(),
212 |       getQuotaErrorOccurred: vi.fn(() => false),
213 |       getModel: vi.fn(() => 'gemini-2.5-pro'),
214 |       getContentGeneratorConfig: vi
215 |         .fn()
216 |         .mockReturnValue(contentGeneratorConfig),
217 |       getUseSmartEdit: () => false,
218 |       getUseModelRouter: () => false,
219 |     } as unknown as Config;
220 |     mockOnDebugMessage = vi.fn();
221 |     mockHandleSlashCommand = vi.fn().mockResolvedValue(false);
222 | 
223 |     // Mock return value for useReactToolScheduler
224 |     mockScheduleToolCalls = vi.fn();
225 |     mockCancelAllToolCalls = vi.fn();
226 |     mockMarkToolsAsSubmitted = vi.fn();
227 | 
228 |     // Default mock for useReactToolScheduler to prevent toolCalls being undefined initially
229 |     mockUseReactToolScheduler.mockReturnValue([
230 |       [], // Default to empty array for toolCalls
231 |       mockScheduleToolCalls,
232 |       mockCancelAllToolCalls,
233 |       mockMarkToolsAsSubmitted,
234 |     ]);
235 | 
236 |     // Reset mocks for GeminiClient instance methods (startChat and sendMessageStream)
237 |     // The GeminiClient constructor itself is mocked at the module level.
238 |     mockStartChat.mockClear().mockResolvedValue({
239 |       sendMessageStream: mockSendMessageStream,
240 |     } as unknown as any); // GeminiChat -> any
241 |     mockSendMessageStream
242 |       .mockClear()
243 |       .mockReturnValue((async function* () {})());
244 |     handleAtCommandSpy = vi.spyOn(atCommandProcessor, 'handleAtCommand');
245 |   });
246 | 
247 |   const mockLoadedSettings: LoadedSettings = {
248 |     merged: { preferredEditor: 'vscode' },
249 |     user: { path: '/user/settings.json', settings: {} },
250 |     workspace: { path: '/workspace/.gemini/settings.json', settings: {} },
251 |     errors: [],
252 |     forScope: vi.fn(),
253 |     setValue: vi.fn(),
254 |   } as unknown as LoadedSettings;
255 | 
256 |   const renderTestHook = (
257 |     initialToolCalls: TrackedToolCall[] = [],
258 |     geminiClient?: any,
259 |   ) => {
260 |     let currentToolCalls = initialToolCalls;
261 |     const setToolCalls = (newToolCalls: TrackedToolCall[]) => {
262 |       currentToolCalls = newToolCalls;
263 |     };
264 | 
265 |     mockUseReactToolScheduler.mockImplementation(() => [
266 |       currentToolCalls,
267 |       mockScheduleToolCalls,
268 |       mockCancelAllToolCalls,
269 |       mockMarkToolsAsSubmitted,
270 |     ]);
271 | 
272 |     const client = geminiClient || mockConfig.getGeminiClient();
273 | 
274 |     const { result, rerender } = renderHook(
275 |       (props: {
276 |         client: any;
277 |         history: HistoryItem[];
278 |         addItem: UseHistoryManagerReturn['addItem'];
279 |         config: Config;
280 |         onDebugMessage: (message: string) => void;
281 |         handleSlashCommand: (
282 |           cmd: PartListUnion,
283 |         ) => Promise<SlashCommandProcessorResult | false>;
284 |         shellModeActive: boolean;
285 |         loadedSettings: LoadedSettings;
286 |         toolCalls?: TrackedToolCall[]; // Allow passing updated toolCalls
287 |       }) => {
288 |         // Update the mock's return value if new toolCalls are passed in props
289 |         if (props.toolCalls) {
290 |           setToolCalls(props.toolCalls);
291 |         }
292 |         return useGeminiStream(
293 |           props.client,
294 |           props.history,
295 |           props.addItem,
296 |           props.config,
297 |           props.loadedSettings,
298 |           props.onDebugMessage,
299 |           props.handleSlashCommand,
300 |           props.shellModeActive,
301 |           () => 'vscode' as EditorType,
302 |           () => {},
303 |           () => Promise.resolve(),
304 |           false,
305 |           () => {},
306 |           () => {},
307 |           () => {},
308 |           () => {},
309 |           80,
310 |           24,
311 |         );
312 |       },
313 |       {
314 |         initialProps: {
315 |           client,
316 |           history: [],
317 |           addItem: mockAddItem as unknown as UseHistoryManagerReturn['addItem'],
318 |           config: mockConfig,
319 |           onDebugMessage: mockOnDebugMessage,
320 |           handleSlashCommand: mockHandleSlashCommand as unknown as (
321 |             cmd: PartListUnion,
322 |           ) => Promise<SlashCommandProcessorResult | false>,
323 |           shellModeActive: false,
324 |           loadedSettings: mockLoadedSettings,
325 |           toolCalls: initialToolCalls,
326 |         },
327 |       },
328 |     );
329 |     return {
330 |       result,
331 |       rerender,
332 |       mockMarkToolsAsSubmitted,
333 |       mockSendMessageStream,
334 |       client,
335 |     };
336 |   };
337 | 
338 |   it('should not submit tool responses if not all tool calls are completed', () => {
339 |     const toolCalls: TrackedToolCall[] = [
340 |       {
341 |         request: {
342 |           callId: 'call1',
343 |           name: 'tool1',
344 |           args: {},
345 |           isClientInitiated: false,
346 |           prompt_id: 'prompt-id-1',
347 |         },
348 |         status: 'success',
349 |         responseSubmittedToGemini: false,
350 |         response: {
351 |           callId: 'call1',
352 |           responseParts: [{ text: 'tool 1 response' }],
353 |           error: undefined,
354 |           errorType: undefined, // FIX: Added missing property
355 |           resultDisplay: 'Tool 1 success display',
356 |         },
357 |         tool: {
358 |           name: 'tool1',
359 |           displayName: 'tool1',
360 |           description: 'desc1',
361 |           build: vi.fn(),
362 |         } as any,
363 |         invocation: {
364 |           getDescription: () => `Mock description`,
365 |         } as unknown as AnyToolInvocation,
366 |         startTime: Date.now(),
367 |         endTime: Date.now(),
368 |       } as TrackedCompletedToolCall,
369 |       {
370 |         request: {
371 |           callId: 'call2',
372 |           name: 'tool2',
373 |           args: {},
374 |           prompt_id: 'prompt-id-1',
375 |         },
376 |         status: 'executing',
377 |         responseSubmittedToGemini: false,
378 |         tool: {
379 |           name: 'tool2',
380 |           displayName: 'tool2',
381 |           description: 'desc2',
382 |           build: vi.fn(),
383 |         } as any,
384 |         invocation: {
385 |           getDescription: () => `Mock description`,
386 |         } as unknown as AnyToolInvocation,
387 |         startTime: Date.now(),
388 |         liveOutput: '...',
389 |       } as TrackedExecutingToolCall,
390 |     ];
391 | 
392 |     const { mockMarkToolsAsSubmitted, mockSendMessageStream } =
393 |       renderTestHook(toolCalls);
394 | 
395 |     // Effect for submitting tool responses depends on toolCalls and isResponding
396 |     // isResponding is initially false, so the effect should run.
397 | 
398 |     expect(mockMarkToolsAsSubmitted).not.toHaveBeenCalled();
399 |     expect(mockSendMessageStream).not.toHaveBeenCalled(); // submitQuery uses this
400 |   });
401 | 
402 |   it('should submit tool responses when all tool calls are completed and ready', async () => {
403 |     const toolCall1ResponseParts: Part[] = [{ text: 'tool 1 final response' }];
[TRUNCATED]
```

src/ui/hooks/useGeminiStream.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { useState, useRef, useCallback, useEffect, useMemo } from 'react';
8 | import type {
9 |   Config,
10 |   EditorType,
11 |   GeminiClient,
12 |   ServerGeminiChatCompressedEvent,
13 |   ServerGeminiContentEvent as ContentEvent,
14 |   ServerGeminiFinishedEvent,
15 |   ServerGeminiStreamEvent as GeminiEvent,
16 |   ThoughtSummary,
17 |   ToolCallRequestInfo,
18 |   GeminiErrorEventValue,
19 | } from '@google/gemini-cli-core';
20 | import {
21 |   GeminiEventType as ServerGeminiEventType,
22 |   getErrorMessage,
23 |   isNodeError,
24 |   MessageSenderType,
25 |   logUserPrompt,
26 |   GitService,
27 |   UnauthorizedError,
28 |   UserPromptEvent,
29 |   DEFAULT_GEMINI_FLASH_MODEL,
30 |   logConversationFinishedEvent,
31 |   ConversationFinishedEvent,
32 |   ApprovalMode,
33 |   parseAndFormatApiError,
34 |   ToolConfirmationOutcome,
35 |   promptIdContext,
36 |   WRITE_FILE_TOOL_NAME,
37 |   tokenLimit,
38 | } from '@google/gemini-cli-core';
39 | import { type Part, type PartListUnion, FinishReason } from '@google/genai';
40 | import type {
41 |   HistoryItem,
42 |   HistoryItemWithoutId,
43 |   HistoryItemToolGroup,
44 |   SlashCommandProcessorResult,
45 | } from '../types.js';
46 | import { StreamingState, MessageType, ToolCallStatus } from '../types.js';
47 | import { isAtCommand, isSlashCommand } from '../utils/commandUtils.js';
48 | import { useShellCommandProcessor } from './shellCommandProcessor.js';
49 | import { handleAtCommand } from './atCommandProcessor.js';
50 | import { findLastSafeSplitPoint } from '../utils/markdownUtilities.js';
51 | import { useStateAndRef } from './useStateAndRef.js';
52 | import type { UseHistoryManagerReturn } from './useHistoryManager.js';
53 | import { useLogger } from './useLogger.js';
54 | import {
55 |   useReactToolScheduler,
56 |   mapToDisplay as mapTrackedToolCallsToDisplay,
57 |   type TrackedToolCall,
58 |   type TrackedCompletedToolCall,
59 |   type TrackedCancelledToolCall,
60 |   type TrackedWaitingToolCall,
61 | } from './useReactToolScheduler.js';
62 | import { promises as fs } from 'node:fs';
63 | import path from 'node:path';
64 | import { useSessionStats } from '../contexts/SessionContext.js';
65 | import { useKeypress } from './useKeypress.js';
66 | import type { LoadedSettings } from '../../config/settings.js';
67 | 
68 | enum StreamProcessingStatus {
69 |   Completed,
70 |   UserCancelled,
71 |   Error,
72 | }
73 | 
74 | const EDIT_TOOL_NAMES = new Set(['replace', WRITE_FILE_TOOL_NAME]);
75 | 
76 | function showCitations(settings: LoadedSettings): boolean {
77 |   const enabled = settings?.merged?.ui?.showCitations;
78 |   if (enabled !== undefined) {
79 |     return enabled;
80 |   }
81 |   return true;
82 | }
83 | 
84 | /**
85 |  * Manages the Gemini stream, including user input, command processing,
86 |  * API interaction, and tool call lifecycle.
87 |  */
88 | export const useGeminiStream = (
89 |   geminiClient: GeminiClient,
90 |   history: HistoryItem[],
91 |   addItem: UseHistoryManagerReturn['addItem'],
92 |   config: Config,
93 |   settings: LoadedSettings,
94 |   onDebugMessage: (message: string) => void,
95 |   handleSlashCommand: (
96 |     cmd: PartListUnion,
97 |   ) => Promise<SlashCommandProcessorResult | false>,
98 |   shellModeActive: boolean,
99 |   getPreferredEditor: () => EditorType | undefined,
100 |   onAuthError: (error: string) => void,
101 |   performMemoryRefresh: () => Promise<void>,
102 |   modelSwitchedFromQuotaError: boolean,
103 |   setModelSwitchedFromQuotaError: React.Dispatch<React.SetStateAction<boolean>>,
104 |   onEditorClose: () => void,
105 |   onCancelSubmit: () => void,
106 |   setShellInputFocused: (value: boolean) => void,
107 |   terminalWidth: number,
108 |   terminalHeight: number,
109 |   isShellFocused?: boolean,
110 | ) => {
111 |   const [initError, setInitError] = useState<string | null>(null);
112 |   const abortControllerRef = useRef<AbortController | null>(null);
113 |   const turnCancelledRef = useRef(false);
114 |   const [isResponding, setIsResponding] = useState<boolean>(false);
115 |   const [thought, setThought] = useState<ThoughtSummary | null>(null);
116 |   const [pendingHistoryItem, pendingHistoryItemRef, setPendingHistoryItem] =
117 |     useStateAndRef<HistoryItemWithoutId | null>(null);
118 |   const processedMemoryToolsRef = useRef<Set<string>>(new Set());
119 |   const { startNewPrompt, getPromptCount } = useSessionStats();
120 |   const storage = config.storage;
121 |   const logger = useLogger(storage);
122 |   const gitService = useMemo(() => {
123 |     if (!config.getProjectRoot()) {
124 |       return;
125 |     }
126 |     return new GitService(config.getProjectRoot(), storage);
127 |   }, [config, storage]);
128 | 
129 |   const [toolCalls, scheduleToolCalls, markToolsAsSubmitted] =
130 |     useReactToolScheduler(
131 |       async (completedToolCallsFromScheduler) => {
132 |         // This onComplete is called when ALL scheduled tools for a given batch are done.
133 |         if (completedToolCallsFromScheduler.length > 0) {
134 |           // Add the final state of these tools to the history for display.
135 |           addItem(
136 |             mapTrackedToolCallsToDisplay(
137 |               completedToolCallsFromScheduler as TrackedToolCall[],
138 |             ),
139 |             Date.now(),
140 |           );
141 | 
142 |           // Record tool calls with full metadata before sending responses.
143 |           try {
144 |             const currentModel =
145 |               config.getGeminiClient().getCurrentSequenceModel() ??
146 |               config.getModel();
147 |             config
148 |               .getGeminiClient()
149 |               .getChat()
150 |               .recordCompletedToolCalls(
151 |                 currentModel,
152 |                 completedToolCallsFromScheduler,
153 |               );
154 |           } catch (error) {
155 |             console.error(
156 |               `Error recording completed tool call information: ${error}`,
157 |             );
158 |           }
159 | 
160 |           // Handle tool response submission immediately when tools complete
161 |           await handleCompletedTools(
162 |             completedToolCallsFromScheduler as TrackedToolCall[],
163 |           );
164 |         }
165 |       },
166 |       config,
167 |       getPreferredEditor,
168 |       onEditorClose,
169 |     );
170 | 
171 |   const pendingToolCallGroupDisplay = useMemo(
172 |     () =>
173 |       toolCalls.length ? mapTrackedToolCallsToDisplay(toolCalls) : undefined,
174 |     [toolCalls],
175 |   );
176 | 
177 |   const activeToolPtyId = useMemo(() => {
178 |     const executingShellTool = toolCalls?.find(
179 |       (tc) =>
180 |         tc.status === 'executing' && tc.request.name === 'run_shell_command',
181 |     );
182 |     if (executingShellTool) {
183 |       return (executingShellTool as { pid?: number }).pid;
184 |     }
185 |     return undefined;
186 |   }, [toolCalls]);
187 | 
188 |   const loopDetectedRef = useRef(false);
189 |   const [
190 |     loopDetectionConfirmationRequest,
191 |     setLoopDetectionConfirmationRequest,
192 |   ] = useState<{
193 |     onComplete: (result: { userSelection: 'disable' | 'keep' }) => void;
194 |   } | null>(null);
195 | 
196 |   const onExec = useCallback(async (done: Promise<void>) => {
197 |     setIsResponding(true);
198 |     await done;
199 |     setIsResponding(false);
200 |   }, []);
201 |   const { handleShellCommand, activeShellPtyId } = useShellCommandProcessor(
202 |     addItem,
203 |     setPendingHistoryItem,
204 |     onExec,
205 |     onDebugMessage,
206 |     config,
207 |     geminiClient,
208 |     setShellInputFocused,
209 |     terminalWidth,
210 |     terminalHeight,
211 |   );
212 | 
213 |   const activePtyId = activeShellPtyId || activeToolPtyId;
214 | 
215 |   useEffect(() => {
216 |     if (!activePtyId) {
217 |       setShellInputFocused(false);
218 |     }
219 |   }, [activePtyId, setShellInputFocused]);
220 | 
221 |   const streamingState = useMemo(() => {
222 |     if (toolCalls.some((tc) => tc.status === 'awaiting_approval')) {
223 |       return StreamingState.WaitingForConfirmation;
224 |     }
225 |     if (
226 |       isResponding ||
227 |       toolCalls.some(
228 |         (tc) =>
229 |           tc.status === 'executing' ||
230 |           tc.status === 'scheduled' ||
231 |           tc.status === 'validating' ||
232 |           ((tc.status === 'success' ||
233 |             tc.status === 'error' ||
234 |             tc.status === 'cancelled') &&
235 |             !(tc as TrackedCompletedToolCall | TrackedCancelledToolCall)
236 |               .responseSubmittedToGemini),
237 |       )
238 |     ) {
239 |       return StreamingState.Responding;
240 |     }
241 |     return StreamingState.Idle;
242 |   }, [isResponding, toolCalls]);
243 | 
244 |   useEffect(() => {
245 |     if (
246 |       config.getApprovalMode() === ApprovalMode.YOLO &&
247 |       streamingState === StreamingState.Idle
248 |     ) {
249 |       const lastUserMessageIndex = history.findLastIndex(
250 |         (item: HistoryItem) => item.type === MessageType.USER,
251 |       );
252 | 
253 |       const turnCount =
254 |         lastUserMessageIndex === -1 ? 0 : history.length - lastUserMessageIndex;
255 | 
256 |       if (turnCount > 0) {
257 |         logConversationFinishedEvent(
258 |           config,
259 |           new ConversationFinishedEvent(config.getApprovalMode(), turnCount),
260 |         );
261 |       }
262 |     }
263 |   }, [streamingState, config, history]);
264 | 
265 |   const cancelOngoingRequest = useCallback(() => {
266 |     if (streamingState !== StreamingState.Responding) {
267 |       return;
268 |     }
269 |     if (turnCancelledRef.current) {
270 |       return;
271 |     }
272 |     turnCancelledRef.current = true;
273 |     abortControllerRef.current?.abort();
274 |     if (pendingHistoryItemRef.current) {
275 |       addItem(pendingHistoryItemRef.current, Date.now());
276 |     }
277 |     addItem(
278 |       {
279 |         type: MessageType.INFO,
280 |         text: 'Request cancelled.',
281 |       },
282 |       Date.now(),
283 |     );
284 |     setPendingHistoryItem(null);
285 |     onCancelSubmit();
286 |     setIsResponding(false);
287 |     setShellInputFocused(false);
288 |   }, [
289 |     streamingState,
290 |     addItem,
291 |     setPendingHistoryItem,
292 |     onCancelSubmit,
293 |     pendingHistoryItemRef,
294 |     setShellInputFocused,
295 |   ]);
296 | 
297 |   useKeypress(
298 |     (key) => {
299 |       if (key.name === 'escape' && !isShellFocused) {
300 |         cancelOngoingRequest();
301 |       }
302 |     },
303 |     { isActive: streamingState === StreamingState.Responding },
304 |   );
305 | 
306 |   const prepareQueryForGemini = useCallback(
307 |     async (
308 |       query: PartListUnion,
309 |       userMessageTimestamp: number,
310 |       abortSignal: AbortSignal,
311 |       prompt_id: string,
312 |     ): Promise<{
313 |       queryToSend: PartListUnion | null;
314 |       shouldProceed: boolean;
315 |     }> => {
316 |       if (turnCancelledRef.current) {
317 |         return { queryToSend: null, shouldProceed: false };
318 |       }
319 |       if (typeof query === 'string' && query.trim().length === 0) {
320 |         return { queryToSend: null, shouldProceed: false };
321 |       }
322 | 
323 |       let localQueryToSendToGemini: PartListUnion | null = null;
324 | 
325 |       if (typeof query === 'string') {
326 |         const trimmedQuery = query.trim();
327 |         onDebugMessage(`User query: '${trimmedQuery}'`);
328 |         await logger?.logMessage(MessageSenderType.USER, trimmedQuery);
329 | 
330 |         // Handle UI-only commands first
331 |         const slashCommandResult = isSlashCommand(trimmedQuery)
332 |           ? await handleSlashCommand(trimmedQuery)
333 |           : false;
334 | 
335 |         if (slashCommandResult) {
336 |           switch (slashCommandResult.type) {
337 |             case 'schedule_tool': {
338 |               const { toolName, toolArgs } = slashCommandResult;
339 |               const toolCallRequest: ToolCallRequestInfo = {
340 |                 callId: `${toolName}-${Date.now()}-${Math.random().toString(16).slice(2)}`,
341 |                 name: toolName,
342 |                 args: toolArgs,
343 |                 isClientInitiated: true,
344 |                 prompt_id,
345 |               };
346 |               scheduleToolCalls([toolCallRequest], abortSignal);
347 |               return { queryToSend: null, shouldProceed: false };
348 |             }
349 |             case 'submit_prompt': {
350 |               localQueryToSendToGemini = slashCommandResult.content;
351 | 
352 |               return {
353 |                 queryToSend: localQueryToSendToGemini,
354 |                 shouldProceed: true,
355 |               };
356 |             }
357 |             case 'handled': {
358 |               return { queryToSend: null, shouldProceed: false };
359 |             }
360 |             default: {
361 |               const unreachable: never = slashCommandResult;
362 |               throw new Error(
363 |                 `Unhandled slash command result type: ${unreachable}`,
364 |               );
365 |             }
366 |           }
367 |         }
368 | 
369 |         if (shellModeActive && handleShellCommand(trimmedQuery, abortSignal)) {
370 |           return { queryToSend: null, shouldProceed: false };
371 |         }
372 | 
373 |         // Handle @-commands (which might involve tool calls)
374 |         if (isAtCommand(trimmedQuery)) {
375 |           const atCommandResult = await handleAtCommand({
376 |             query: trimmedQuery,
377 |             config,
378 |             addItem,
379 |             onDebugMessage,
380 |             messageId: userMessageTimestamp,
381 |             signal: abortSignal,
382 |           });
383 | 
384 |           // Add user's turn after @ command processing is done.
385 |           addItem(
386 |             { type: MessageType.USER, text: trimmedQuery },
387 |             userMessageTimestamp,
388 |           );
389 | 
390 |           if (!atCommandResult.shouldProceed) {
391 |             return { queryToSend: null, shouldProceed: false };
392 |           }
393 |           localQueryToSendToGemini = atCommandResult.processedQuery;
394 |         } else {
395 |           // Normal query for Gemini
396 |           addItem(
397 |             { type: MessageType.USER, text: trimmedQuery },
398 |             userMessageTimestamp,
399 |           );
400 |           localQueryToSendToGemini = trimmedQuery;
401 |         }
402 |       } else {
403 |         // It's a function response (PartListUnion that isn't a string)
404 |         localQueryToSendToGemini = query;
405 |       }
406 | 
407 |       if (localQueryToSendToGemini === null) {
408 |         onDebugMessage(
409 |           'Query processing resulted in null, not sending to Gemini.',
410 |         );
411 |         return { queryToSend: null, shouldProceed: false };
412 |       }
413 |       return { queryToSend: localQueryToSendToGemini, shouldProceed: true };
414 |     },
415 |     [
416 |       config,
417 |       addItem,
418 |       onDebugMessage,
419 |       handleShellCommand,
420 |       handleSlashCommand,
421 |       logger,
422 |       shellModeActive,
423 |       scheduleToolCalls,
424 |     ],
[TRUNCATED]
```

src/ui/hooks/useGitBranchName.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type { MockedFunction } from 'vitest';
8 | import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';
9 | import { act } from 'react';
10 | import { renderHook, waitFor } from '@testing-library/react';
11 | import { useGitBranchName } from './useGitBranchName.js';
12 | import { fs, vol } from 'memfs'; // For mocking fs
13 | import { spawnAsync as mockSpawnAsync } from '@google/gemini-cli-core';
14 | 
15 | // Mock @google/gemini-cli-core
16 | vi.mock('@google/gemini-cli-core', async () => {
17 |   const original = await vi.importActual<
18 |     typeof import('@google/gemini-cli-core')
19 |   >('@google/gemini-cli-core');
20 |   return {
21 |     ...original,
22 |     spawnAsync: vi.fn(),
23 |   };
24 | });
25 | 
26 | // Mock fs and fs/promises
27 | vi.mock('node:fs', async () => {
28 |   const memfs = await vi.importActual<typeof import('memfs')>('memfs');
29 |   return {
30 |     ...memfs.fs,
31 |     default: memfs.fs,
32 |   };
33 | });
34 | 
35 | vi.mock('node:fs/promises', async () => {
36 |   const memfs = await vi.importActual<typeof import('memfs')>('memfs');
37 |   return memfs.fs.promises;
38 | });
39 | 
40 | const CWD = '/test/project';
41 | const GIT_LOGS_HEAD_PATH = `${CWD}/.git/logs/HEAD`;
42 | 
43 | describe('useGitBranchName', () => {
44 |   beforeEach(() => {
45 |     vol.reset(); // Reset in-memory filesystem
46 |     vol.fromJSON({
47 |       [GIT_LOGS_HEAD_PATH]: 'ref: refs/heads/main',
48 |     });
49 |     vi.useFakeTimers(); // Use fake timers for async operations
50 |   });
51 | 
52 |   afterEach(() => {
53 |     vi.restoreAllMocks();
54 |     vi.clearAllTimers();
55 |   });
56 | 
57 |   it('should return branch name', async () => {
58 |     (mockSpawnAsync as MockedFunction<typeof mockSpawnAsync>).mockResolvedValue(
59 |       {
60 |         stdout: 'main\n',
61 |       } as { stdout: string; stderr: string },
62 |     );
63 |     const { result, rerender } = renderHook(() => useGitBranchName(CWD));
64 | 
65 |     await act(async () => {
66 |       vi.runAllTimers(); // Advance timers to trigger useEffect and exec callback
67 |       rerender(); // Rerender to get the updated state
68 |     });
69 | 
70 |     expect(result.current).toBe('main');
71 |   });
72 | 
73 |   it('should return undefined if git command fails', async () => {
74 |     (mockSpawnAsync as MockedFunction<typeof mockSpawnAsync>).mockRejectedValue(
75 |       new Error('Git error'),
76 |     );
77 | 
78 |     const { result, rerender } = renderHook(() => useGitBranchName(CWD));
79 |     expect(result.current).toBeUndefined();
80 | 
81 |     await act(async () => {
82 |       vi.runAllTimers();
83 |       rerender();
84 |     });
85 |     expect(result.current).toBeUndefined();
86 |   });
87 | 
88 |   it('should return short commit hash if branch is HEAD (detached state)', async () => {
89 |     (
90 |       mockSpawnAsync as MockedFunction<typeof mockSpawnAsync>
91 |     ).mockImplementation(async (command: string, args: string[]) => {
92 |       if (args.includes('--abbrev-ref')) {
93 |         return { stdout: 'HEAD\n' } as { stdout: string; stderr: string };
94 |       } else if (args.includes('--short')) {
95 |         return { stdout: 'a1b2c3d\n' } as { stdout: string; stderr: string };
96 |       }
97 |       return { stdout: '' } as { stdout: string; stderr: string };
98 |     });
99 | 
100 |     const { result, rerender } = renderHook(() => useGitBranchName(CWD));
101 |     await act(async () => {
102 |       vi.runAllTimers();
103 |       rerender();
104 |     });
105 |     expect(result.current).toBe('a1b2c3d');
106 |   });
107 | 
108 |   it('should return undefined if branch is HEAD and getting commit hash fails', async () => {
109 |     (
110 |       mockSpawnAsync as MockedFunction<typeof mockSpawnAsync>
111 |     ).mockImplementation(async (command: string, args: string[]) => {
112 |       if (args.includes('--abbrev-ref')) {
113 |         return { stdout: 'HEAD\n' } as { stdout: string; stderr: string };
114 |       } else if (args.includes('--short')) {
115 |         throw new Error('Git error');
116 |       }
117 |       return { stdout: '' } as { stdout: string; stderr: string };
118 |     });
119 | 
120 |     const { result, rerender } = renderHook(() => useGitBranchName(CWD));
121 |     await act(async () => {
122 |       vi.runAllTimers();
123 |       rerender();
124 |     });
125 |     expect(result.current).toBeUndefined();
126 |   });
127 | 
128 |   it('should update branch name when .git/HEAD changes', async ({ skip }) => {
129 |     skip(); // TODO: fix
130 |     (mockSpawnAsync as MockedFunction<typeof mockSpawnAsync>)
131 |       .mockResolvedValueOnce({ stdout: 'main\n' } as {
132 |         stdout: string;
133 |         stderr: string;
134 |       })
135 |       .mockResolvedValueOnce({ stdout: 'develop\n' } as {
136 |         stdout: string;
137 |         stderr: string;
138 |       });
139 | 
140 |     const { result, rerender } = renderHook(() => useGitBranchName(CWD));
141 | 
142 |     await act(async () => {
143 |       vi.runAllTimers();
144 |       rerender();
145 |     });
146 |     expect(result.current).toBe('main');
147 | 
148 |     // Simulate file change event
149 |     // Ensure the watcher is set up before triggering the change
150 |     await act(async () => {
151 |       fs.writeFileSync(GIT_LOGS_HEAD_PATH, 'ref: refs/heads/develop'); // Trigger watcher
152 |       vi.runAllTimers(); // Process timers for watcher and exec
153 |       rerender();
154 |     });
155 | 
156 |     await waitFor(() => {
157 |       expect(result.current).toBe('develop');
158 |     });
159 |   });
160 | 
161 |   it('should handle watcher setup error silently', async () => {
162 |     // Remove .git/logs/HEAD to cause an error in fs.watch setup
163 |     vol.unlinkSync(GIT_LOGS_HEAD_PATH);
164 | 
165 |     (mockSpawnAsync as MockedFunction<typeof mockSpawnAsync>).mockResolvedValue(
166 |       {
167 |         stdout: 'main\n',
168 |       } as { stdout: string; stderr: string },
169 |     );
170 | 
171 |     const { result, rerender } = renderHook(() => useGitBranchName(CWD));
172 | 
173 |     await act(async () => {
174 |       vi.runAllTimers();
175 |       rerender();
176 |     });
177 | 
178 |     expect(result.current).toBe('main'); // Branch name should still be fetched initially
179 | 
180 |     (
181 |       mockSpawnAsync as MockedFunction<typeof mockSpawnAsync>
182 |     ).mockResolvedValueOnce({
183 |       stdout: 'develop\n',
184 |     } as { stdout: string; stderr: string });
185 | 
186 |     // This write would trigger the watcher if it was set up
187 |     // but since it failed, the branch name should not update
188 |     // We need to create the file again for writeFileSync to not throw
189 |     vol.fromJSON({
190 |       [GIT_LOGS_HEAD_PATH]: 'ref: refs/heads/develop',
191 |     });
192 | 
193 |     await act(async () => {
194 |       fs.writeFileSync(GIT_LOGS_HEAD_PATH, 'ref: refs/heads/develop');
195 |       vi.runAllTimers();
196 |       rerender();
197 |     });
198 | 
199 |     // Branch name should not change because watcher setup failed
200 |     expect(result.current).toBe('main');
201 |   });
202 | 
203 |   it('should cleanup watcher on unmount', async ({ skip }) => {
204 |     skip(); // TODO: fix
205 |     const closeMock = vi.fn();
206 |     const watchMock = vi.spyOn(fs, 'watch').mockReturnValue({
207 |       close: closeMock,
208 |     } as unknown as ReturnType<typeof fs.watch>);
209 | 
210 |     (mockSpawnAsync as MockedFunction<typeof mockSpawnAsync>).mockResolvedValue(
211 |       {
212 |         stdout: 'main\n',
213 |       } as { stdout: string; stderr: string },
214 |     );
215 | 
216 |     const { unmount, rerender } = renderHook(() => useGitBranchName(CWD));
217 | 
218 |     await act(async () => {
219 |       vi.runAllTimers();
220 |       rerender();
221 |     });
222 | 
223 |     unmount();
224 |     expect(watchMock).toHaveBeenCalledWith(
225 |       GIT_LOGS_HEAD_PATH,
226 |       expect.any(Function),
227 |     );
228 |     expect(closeMock).toHaveBeenCalled();
229 |   });
230 | });
```

src/ui/hooks/useGitBranchName.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { useState, useEffect, useCallback } from 'react';
8 | import { spawnAsync } from '@google/gemini-cli-core';
9 | import fs from 'node:fs';
10 | import fsPromises from 'node:fs/promises';
11 | import path from 'node:path';
12 | 
13 | export function useGitBranchName(cwd: string): string | undefined {
14 |   const [branchName, setBranchName] = useState<string | undefined>(undefined);
15 | 
16 |   const fetchBranchName = useCallback(async () => {
17 |     try {
18 |       const { stdout } = await spawnAsync(
19 |         'git',
20 |         ['rev-parse', '--abbrev-ref', 'HEAD'],
21 |         { cwd },
22 |       );
23 |       const branch = stdout.toString().trim();
24 |       if (branch && branch !== 'HEAD') {
25 |         setBranchName(branch);
26 |       } else {
27 |         const { stdout: hashStdout } = await spawnAsync(
28 |           'git',
29 |           ['rev-parse', '--short', 'HEAD'],
30 |           { cwd },
31 |         );
32 |         setBranchName(hashStdout.toString().trim());
33 |       }
34 |     } catch (_error) {
35 |       setBranchName(undefined);
36 |     }
37 |   }, [cwd, setBranchName]);
38 | 
39 |   useEffect(() => {
40 |     fetchBranchName(); // Initial fetch
41 | 
42 |     const gitLogsHeadPath = path.join(cwd, '.git', 'logs', 'HEAD');
43 |     let watcher: fs.FSWatcher | undefined;
44 | 
45 |     const setupWatcher = async () => {
46 |       try {
47 |         // Check if .git/logs/HEAD exists, as it might not in a new repo or orphaned head
48 |         await fsPromises.access(gitLogsHeadPath, fs.constants.F_OK);
49 |         watcher = fs.watch(gitLogsHeadPath, (eventType: string) => {
50 |           // Changes to .git/logs/HEAD (appends) indicate HEAD has likely changed
51 |           if (eventType === 'change' || eventType === 'rename') {
52 |             // Handle rename just in case
53 |             fetchBranchName();
54 |           }
55 |         });
56 |       } catch (_watchError) {
57 |         // Silently ignore watcher errors (e.g. permissions or file not existing),
58 |         // similar to how exec errors are handled.
59 |         // The branch name will simply not update automatically.
60 |       }
61 |     };
62 | 
63 |     setupWatcher();
64 | 
65 |     return () => {
66 |       watcher?.close();
67 |     };
68 |   }, [cwd, fetchBranchName]);
69 | 
70 |   return branchName;
71 | }
```

src/ui/hooks/useHistoryManager.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect } from 'vitest';
8 | import { renderHook, act } from '@testing-library/react';
9 | import { useHistory } from './useHistoryManager.js';
10 | import type { HistoryItem } from '../types.js';
11 | 
12 | describe('useHistoryManager', () => {
13 |   it('should initialize with an empty history', () => {
14 |     const { result } = renderHook(() => useHistory());
15 |     expect(result.current.history).toEqual([]);
16 |   });
17 | 
18 |   it('should add an item to history with a unique ID', () => {
19 |     const { result } = renderHook(() => useHistory());
20 |     const timestamp = Date.now();
21 |     const itemData: Omit<HistoryItem, 'id'> = {
22 |       type: 'user', // Replaced HistoryItemType.User
23 |       text: 'Hello',
24 |     };
25 | 
26 |     act(() => {
27 |       result.current.addItem(itemData, timestamp);
28 |     });
29 | 
30 |     expect(result.current.history).toHaveLength(1);
31 |     expect(result.current.history[0]).toEqual(
32 |       expect.objectContaining({
33 |         ...itemData,
34 |         id: expect.any(Number),
35 |       }),
36 |     );
37 |     // Basic check that ID incorporates timestamp
38 |     expect(result.current.history[0].id).toBeGreaterThanOrEqual(timestamp);
39 |   });
40 | 
41 |   it('should generate unique IDs for items added with the same base timestamp', () => {
42 |     const { result } = renderHook(() => useHistory());
43 |     const timestamp = Date.now();
44 |     const itemData1: Omit<HistoryItem, 'id'> = {
45 |       type: 'user', // Replaced HistoryItemType.User
46 |       text: 'First',
47 |     };
48 |     const itemData2: Omit<HistoryItem, 'id'> = {
49 |       type: 'gemini', // Replaced HistoryItemType.Gemini
50 |       text: 'Second',
51 |     };
52 | 
53 |     let id1!: number;
54 |     let id2!: number;
55 | 
56 |     act(() => {
57 |       id1 = result.current.addItem(itemData1, timestamp);
58 |       id2 = result.current.addItem(itemData2, timestamp);
59 |     });
60 | 
61 |     expect(result.current.history).toHaveLength(2);
62 |     expect(id1).not.toEqual(id2);
63 |     expect(result.current.history[0].id).toEqual(id1);
64 |     expect(result.current.history[1].id).toEqual(id2);
65 |     // IDs should be sequential based on the counter
66 |     expect(id2).toBeGreaterThan(id1);
67 |   });
68 | 
69 |   it('should update an existing history item', () => {
70 |     const { result } = renderHook(() => useHistory());
71 |     const timestamp = Date.now();
72 |     const initialItem: Omit<HistoryItem, 'id'> = {
73 |       type: 'gemini', // Replaced HistoryItemType.Gemini
74 |       text: 'Initial content',
75 |     };
76 |     let itemId!: number;
77 | 
78 |     act(() => {
79 |       itemId = result.current.addItem(initialItem, timestamp);
80 |     });
81 | 
82 |     const updatedText = 'Updated content';
83 |     act(() => {
84 |       result.current.updateItem(itemId, { text: updatedText });
85 |     });
86 | 
87 |     expect(result.current.history).toHaveLength(1);
88 |     expect(result.current.history[0]).toEqual({
89 |       ...initialItem,
90 |       id: itemId,
91 |       text: updatedText,
92 |     });
93 |   });
94 | 
95 |   it('should not change history if updateHistoryItem is called with a nonexistent ID', () => {
96 |     const { result } = renderHook(() => useHistory());
97 |     const timestamp = Date.now();
98 |     const itemData: Omit<HistoryItem, 'id'> = {
99 |       type: 'user', // Replaced HistoryItemType.User
100 |       text: 'Hello',
101 |     };
102 | 
103 |     act(() => {
104 |       result.current.addItem(itemData, timestamp);
105 |     });
106 | 
107 |     const originalHistory = [...result.current.history]; // Clone before update attempt
108 | 
109 |     act(() => {
110 |       result.current.updateItem(99999, { text: 'Should not apply' }); // Nonexistent ID
111 |     });
112 | 
113 |     expect(result.current.history).toEqual(originalHistory);
114 |   });
115 | 
116 |   it('should clear the history', () => {
117 |     const { result } = renderHook(() => useHistory());
118 |     const timestamp = Date.now();
119 |     const itemData1: Omit<HistoryItem, 'id'> = {
120 |       type: 'user', // Replaced HistoryItemType.User
121 |       text: 'First',
122 |     };
123 |     const itemData2: Omit<HistoryItem, 'id'> = {
124 |       type: 'gemini', // Replaced HistoryItemType.Gemini
125 |       text: 'Second',
126 |     };
127 | 
128 |     act(() => {
129 |       result.current.addItem(itemData1, timestamp);
130 |       result.current.addItem(itemData2, timestamp);
131 |     });
132 | 
133 |     expect(result.current.history).toHaveLength(2);
134 | 
135 |     act(() => {
136 |       result.current.clearItems();
137 |     });
138 | 
139 |     expect(result.current.history).toEqual([]);
140 |   });
141 | 
142 |   it('should not add consecutive duplicate user messages', () => {
143 |     const { result } = renderHook(() => useHistory());
144 |     const timestamp = Date.now();
145 |     const itemData1: Omit<HistoryItem, 'id'> = {
146 |       type: 'user', // Replaced HistoryItemType.User
147 |       text: 'Duplicate message',
148 |     };
149 |     const itemData2: Omit<HistoryItem, 'id'> = {
150 |       type: 'user', // Replaced HistoryItemType.User
151 |       text: 'Duplicate message',
152 |     };
153 |     const itemData3: Omit<HistoryItem, 'id'> = {
154 |       type: 'gemini', // Replaced HistoryItemType.Gemini
155 |       text: 'Gemini response',
156 |     };
157 |     const itemData4: Omit<HistoryItem, 'id'> = {
158 |       type: 'user', // Replaced HistoryItemType.User
159 |       text: 'Another user message',
160 |     };
161 | 
162 |     act(() => {
163 |       result.current.addItem(itemData1, timestamp);
164 |       result.current.addItem(itemData2, timestamp + 1); // Same text, different timestamp
165 |       result.current.addItem(itemData3, timestamp + 2);
166 |       result.current.addItem(itemData4, timestamp + 3);
167 |     });
168 | 
169 |     expect(result.current.history).toHaveLength(3);
170 |     expect(result.current.history[0].text).toBe('Duplicate message');
171 |     expect(result.current.history[1].text).toBe('Gemini response');
172 |     expect(result.current.history[2].text).toBe('Another user message');
173 |   });
174 | 
175 |   it('should add duplicate user messages if they are not consecutive', () => {
176 |     const { result } = renderHook(() => useHistory());
177 |     const timestamp = Date.now();
178 |     const itemData1: Omit<HistoryItem, 'id'> = {
179 |       type: 'user', // Replaced HistoryItemType.User
180 |       text: 'Message 1',
181 |     };
182 |     const itemData2: Omit<HistoryItem, 'id'> = {
183 |       type: 'gemini', // Replaced HistoryItemType.Gemini
184 |       text: 'Gemini response',
185 |     };
186 |     const itemData3: Omit<HistoryItem, 'id'> = {
187 |       type: 'user', // Replaced HistoryItemType.User
188 |       text: 'Message 1', // Duplicate text, but not consecutive
189 |     };
190 | 
191 |     act(() => {
192 |       result.current.addItem(itemData1, timestamp);
193 |       result.current.addItem(itemData2, timestamp + 1);
194 |       result.current.addItem(itemData3, timestamp + 2);
195 |     });
196 | 
197 |     expect(result.current.history).toHaveLength(3);
198 |     expect(result.current.history[0].text).toBe('Message 1');
199 |     expect(result.current.history[1].text).toBe('Gemini response');
200 |     expect(result.current.history[2].text).toBe('Message 1');
201 |   });
202 | });
```

src/ui/hooks/useHistoryManager.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { useState, useRef, useCallback, useMemo } from 'react';
8 | import type { HistoryItem } from '../types.js';
9 | 
10 | // Type for the updater function passed to updateHistoryItem
11 | type HistoryItemUpdater = (
12 |   prevItem: HistoryItem,
13 | ) => Partial<Omit<HistoryItem, 'id'>>;
14 | 
15 | export interface UseHistoryManagerReturn {
16 |   history: HistoryItem[];
17 |   addItem: (itemData: Omit<HistoryItem, 'id'>, baseTimestamp: number) => number; // Returns the generated ID
18 |   updateItem: (
19 |     id: number,
20 |     updates: Partial<Omit<HistoryItem, 'id'>> | HistoryItemUpdater,
21 |   ) => void;
22 |   clearItems: () => void;
23 |   loadHistory: (newHistory: HistoryItem[]) => void;
24 | }
25 | 
26 | /**
27 |  * Custom hook to manage the chat history state.
28 |  *
29 |  * Encapsulates the history array, message ID generation, adding items,
30 |  * updating items, and clearing the history.
31 |  */
32 | export function useHistory(): UseHistoryManagerReturn {
33 |   const [history, setHistory] = useState<HistoryItem[]>([]);
34 |   const messageIdCounterRef = useRef(0);
35 | 
36 |   // Generates a unique message ID based on a timestamp and a counter.
37 |   const getNextMessageId = useCallback((baseTimestamp: number): number => {
38 |     messageIdCounterRef.current += 1;
39 |     return baseTimestamp + messageIdCounterRef.current;
40 |   }, []);
41 | 
42 |   const loadHistory = useCallback((newHistory: HistoryItem[]) => {
43 |     setHistory(newHistory);
44 |   }, []);
45 | 
46 |   // Adds a new item to the history state with a unique ID.
47 |   const addItem = useCallback(
48 |     (itemData: Omit<HistoryItem, 'id'>, baseTimestamp: number): number => {
49 |       const id = getNextMessageId(baseTimestamp);
50 |       const newItem: HistoryItem = { ...itemData, id } as HistoryItem;
51 | 
52 |       setHistory((prevHistory) => {
53 |         if (prevHistory.length > 0) {
54 |           const lastItem = prevHistory[prevHistory.length - 1];
55 |           // Prevent adding duplicate consecutive user messages
56 |           if (
57 |             lastItem.type === 'user' &&
58 |             newItem.type === 'user' &&
59 |             lastItem.text === newItem.text
60 |           ) {
61 |             return prevHistory; // Don't add the duplicate
62 |           }
63 |         }
64 |         return [...prevHistory, newItem];
65 |       });
66 |       return id; // Return the generated ID (even if not added, to keep signature)
67 |     },
68 |     [getNextMessageId],
69 |   );
70 | 
71 |   /**
72 |    * Updates an existing history item identified by its ID.
73 |    * @deprecated Prefer not to update history item directly as we are currently
74 |    * rendering all history items in <Static /> for performance reasons. Only use
75 |    * if ABSOLUTELY NECESSARY
76 |    */
77 |   //
78 |   const updateItem = useCallback(
79 |     (
80 |       id: number,
81 |       updates: Partial<Omit<HistoryItem, 'id'>> | HistoryItemUpdater,
82 |     ) => {
83 |       setHistory((prevHistory) =>
84 |         prevHistory.map((item) => {
85 |           if (item.id === id) {
86 |             // Apply updates based on whether it's an object or a function
87 |             const newUpdates =
88 |               typeof updates === 'function' ? updates(item) : updates;
89 |             return { ...item, ...newUpdates } as HistoryItem;
90 |           }
91 |           return item;
92 |         }),
93 |       );
94 |     },
95 |     [],
96 |   );
97 | 
98 |   // Clears the entire history state and resets the ID counter.
99 |   const clearItems = useCallback(() => {
100 |     setHistory([]);
101 |     messageIdCounterRef.current = 0;
102 |   }, []);
103 | 
104 |   return useMemo(
105 |     () => ({
106 |       history,
107 |       addItem,
108 |       updateItem,
109 |       clearItems,
110 |       loadHistory,
111 |     }),
112 |     [history, addItem, updateItem, clearItems, loadHistory],
113 |   );
114 | }
```

src/ui/hooks/useIdeTrustListener.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | /** @vitest-environment jsdom */
8 | 
9 | import { renderHook, act } from '@testing-library/react';
10 | import { vi, describe, it, expect, beforeEach } from 'vitest';
11 | import {
12 |   IdeClient,
13 |   IDEConnectionStatus,
14 |   ideContextStore,
15 |   type IDEConnectionState,
16 | } from '@google/gemini-cli-core';
17 | import { useIdeTrustListener } from './useIdeTrustListener.js';
18 | import * as trustedFolders from '../../config/trustedFolders.js';
19 | import { useSettings } from '../contexts/SettingsContext.js';
20 | import type { LoadedSettings } from '../../config/settings.js';
21 | 
22 | // Mock dependencies
23 | vi.mock('@google/gemini-cli-core', async (importOriginal) => {
24 |   const original =
25 |     await importOriginal<typeof import('@google/gemini-cli-core')>();
26 |   const ideClientInstance = {
27 |     addTrustChangeListener: vi.fn(),
28 |     removeTrustChangeListener: vi.fn(),
29 |     addStatusChangeListener: vi.fn(),
30 |     removeStatusChangeListener: vi.fn(),
31 |     getConnectionStatus: vi.fn(() => ({
32 |       status: IDEConnectionStatus.Disconnected,
33 |     })),
34 |   };
35 |   return {
36 |     ...original,
37 |     IdeClient: {
38 |       getInstance: vi.fn().mockResolvedValue(ideClientInstance),
39 |     },
40 |     ideContextStore: {
41 |       get: vi.fn(),
42 |       subscribe: vi.fn(),
43 |     },
44 |   };
45 | });
46 | 
47 | vi.mock('../../config/trustedFolders.js');
48 | vi.mock('../contexts/SettingsContext.js');
49 | 
50 | describe('useIdeTrustListener', () => {
51 |   let mockSettings: LoadedSettings;
52 |   let mockIdeClient: Awaited<ReturnType<typeof IdeClient.getInstance>>;
53 |   let trustChangeCallback: (isTrusted: boolean) => void;
54 |   let statusChangeCallback: (state: IDEConnectionState) => void;
55 | 
56 |   beforeEach(async () => {
57 |     vi.clearAllMocks();
58 |     mockIdeClient = await IdeClient.getInstance();
59 | 
60 |     mockSettings = {
61 |       merged: {
62 |         security: {
63 |           folderTrust: {
64 |             enabled: true,
65 |           },
66 |         },
67 |       },
68 |     } as LoadedSettings;
69 | 
70 |     vi.mocked(useSettings).mockReturnValue(mockSettings);
71 | 
72 |     vi.mocked(mockIdeClient.addTrustChangeListener).mockImplementation((cb) => {
73 |       trustChangeCallback = cb;
74 |     });
75 |     vi.mocked(mockIdeClient.addStatusChangeListener).mockImplementation(
76 |       (cb) => {
77 |         statusChangeCallback = cb;
78 |       },
79 |     );
80 |   });
81 | 
82 |   it('should initialize correctly with no trust information', () => {
83 |     vi.mocked(trustedFolders.isWorkspaceTrusted).mockReturnValue({
84 |       isTrusted: undefined,
85 |       source: undefined,
86 |     });
87 | 
88 |     const { result } = renderHook(() => useIdeTrustListener());
89 | 
90 |     expect(result.current.isIdeTrusted).toBe(undefined);
91 |     expect(result.current.needsRestart).toBe(false);
92 |     expect(result.current.restartReason).toBe('NONE');
93 |   });
94 | 
95 |   it('should NOT set needsRestart when connecting for the first time', async () => {
96 |     vi.mocked(mockIdeClient.getConnectionStatus).mockReturnValue({
97 |       status: IDEConnectionStatus.Disconnected,
98 |     });
99 |     vi.mocked(trustedFolders.isWorkspaceTrusted).mockReturnValue({
100 |       isTrusted: true,
101 |       source: 'ide',
102 |     });
103 |     const { result } = renderHook(() => useIdeTrustListener());
104 | 
105 |     // Manually trigger the initial connection state for the test setup
106 |     await act(async () => {
107 |       statusChangeCallback({ status: IDEConnectionStatus.Disconnected });
108 |     });
109 | 
110 |     expect(result.current.isIdeTrusted).toBe(undefined);
111 |     expect(result.current.needsRestart).toBe(false);
112 | 
113 |     await act(async () => {
114 |       vi.mocked(ideContextStore.get).mockReturnValue({
115 |         workspaceState: { isTrusted: true },
116 |       });
117 |       statusChangeCallback({ status: IDEConnectionStatus.Connected });
118 |     });
119 | 
120 |     expect(result.current.isIdeTrusted).toBe(true);
121 |     expect(result.current.needsRestart).toBe(false);
122 |     expect(result.current.restartReason).toBe('CONNECTION_CHANGE');
123 |   });
124 | 
125 |   it('should set needsRestart when IDE trust changes', async () => {
126 |     vi.mocked(mockIdeClient.getConnectionStatus).mockReturnValue({
127 |       status: IDEConnectionStatus.Connected,
128 |     });
129 |     vi.mocked(ideContextStore.get).mockReturnValue({
130 |       workspaceState: { isTrusted: true },
131 |     });
132 |     vi.mocked(trustedFolders.isWorkspaceTrusted).mockReturnValue({
133 |       isTrusted: true,
134 |       source: 'ide',
135 |     });
136 | 
137 |     const { result } = renderHook(() => useIdeTrustListener());
138 | 
139 |     // Manually trigger the initial connection state for the test setup
140 |     await act(async () => {
141 |       statusChangeCallback({ status: IDEConnectionStatus.Connected });
142 |     });
143 | 
144 |     expect(result.current.isIdeTrusted).toBe(true);
145 |     expect(result.current.needsRestart).toBe(false);
146 | 
147 |     await act(async () => {
148 |       vi.mocked(trustedFolders.isWorkspaceTrusted).mockReturnValue({
149 |         isTrusted: false,
150 |         source: 'ide',
151 |       });
152 |       vi.mocked(ideContextStore.get).mockReturnValue({
153 |         workspaceState: { isTrusted: false },
154 |       });
155 |       trustChangeCallback(false);
156 |     });
157 | 
158 |     expect(result.current.isIdeTrusted).toBe(false);
159 |     expect(result.current.needsRestart).toBe(true);
160 |     expect(result.current.restartReason).toBe('TRUST_CHANGE');
161 |   });
162 | 
163 |   it('should set needsRestart when IDE disconnects', async () => {
164 |     vi.mocked(mockIdeClient.getConnectionStatus).mockReturnValue({
165 |       status: IDEConnectionStatus.Connected,
166 |     });
167 |     vi.mocked(ideContextStore.get).mockReturnValue({
168 |       workspaceState: { isTrusted: true },
169 |     });
170 |     vi.mocked(trustedFolders.isWorkspaceTrusted).mockReturnValue({
171 |       isTrusted: true,
172 |       source: 'ide',
173 |     });
174 | 
175 |     const { result } = renderHook(() => useIdeTrustListener());
176 | 
177 |     // Manually trigger the initial connection state for the test setup
178 |     await act(async () => {
179 |       statusChangeCallback({ status: IDEConnectionStatus.Connected });
180 |     });
181 | 
182 |     expect(result.current.isIdeTrusted).toBe(true);
183 |     expect(result.current.needsRestart).toBe(false);
184 | 
185 |     await act(async () => {
186 |       vi.mocked(trustedFolders.isWorkspaceTrusted).mockReturnValue({
187 |         isTrusted: undefined,
188 |         source: undefined,
189 |       });
190 |       vi.mocked(ideContextStore.get).mockReturnValue(undefined);
191 |       statusChangeCallback({ status: IDEConnectionStatus.Disconnected });
192 |     });
193 | 
194 |     expect(result.current.isIdeTrusted).toBe(undefined);
195 |     expect(result.current.needsRestart).toBe(true);
196 |     expect(result.current.restartReason).toBe('CONNECTION_CHANGE');
197 |   });
198 | 
199 |   it('should NOT set needsRestart if trust value does not change', async () => {
200 |     vi.mocked(mockIdeClient.getConnectionStatus).mockReturnValue({
201 |       status: IDEConnectionStatus.Connected,
202 |     });
203 |     vi.mocked(ideContextStore.get).mockReturnValue({
204 |       workspaceState: { isTrusted: true },
205 |     });
206 |     vi.mocked(trustedFolders.isWorkspaceTrusted).mockReturnValue({
207 |       isTrusted: true,
208 |       source: 'ide',
209 |     });
210 | 
211 |     const { result, rerender } = renderHook(() => useIdeTrustListener());
212 | 
213 |     // Manually trigger the initial connection state for the test setup
214 |     await act(async () => {
215 |       statusChangeCallback({ status: IDEConnectionStatus.Connected });
216 |     });
217 | 
218 |     expect(result.current.isIdeTrusted).toBe(true);
219 |     expect(result.current.needsRestart).toBe(false);
220 | 
221 |     rerender();
222 | 
223 |     expect(result.current.isIdeTrusted).toBe(true);
224 |     expect(result.current.needsRestart).toBe(false);
225 |   });
226 | });
```

src/ui/hooks/useIdeTrustListener.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import {
8 |   useCallback,
9 |   useEffect,
10 |   useState,
11 |   useSyncExternalStore,
12 |   useRef,
13 | } from 'react';
14 | import {
15 |   IdeClient,
16 |   IDEConnectionStatus,
17 |   ideContextStore,
18 |   type IDEConnectionState,
19 | } from '@google/gemini-cli-core';
20 | import { useSettings } from '../contexts/SettingsContext.js';
21 | import { isWorkspaceTrusted } from '../../config/trustedFolders.js';
22 | 
23 | export type RestartReason = 'NONE' | 'CONNECTION_CHANGE' | 'TRUST_CHANGE';
24 | 
25 | /**
26 |  * This hook listens for trust status updates from the IDE companion extension.
27 |  * It provides the current trust status from the IDE and a reason if a restart
28 |  * is needed because the trust state has changed.
29 |  */
30 | export function useIdeTrustListener() {
31 |   const settings = useSettings();
32 |   const [connectionStatus, setConnectionStatus] = useState<IDEConnectionStatus>(
33 |     IDEConnectionStatus.Disconnected,
34 |   );
35 |   const previousTrust = useRef<boolean | undefined>(undefined);
36 |   const [restartReason, setRestartReason] = useState<RestartReason>('NONE');
37 |   const [needsRestart, setNeedsRestart] = useState(false);
38 | 
39 |   const subscribe = useCallback((onStoreChange: () => void) => {
40 |     const handleStatusChange = (state: IDEConnectionState) => {
41 |       setConnectionStatus(state.status);
42 |       setRestartReason('CONNECTION_CHANGE');
43 |       // Also notify useSyncExternalStore that the data has changed
44 |       onStoreChange();
45 |     };
46 | 
47 |     const handleTrustChange = () => {
48 |       setRestartReason('TRUST_CHANGE');
49 |       onStoreChange();
50 |     };
51 | 
52 |     (async () => {
53 |       const ideClient = await IdeClient.getInstance();
54 |       ideClient.addTrustChangeListener(handleTrustChange);
55 |       ideClient.addStatusChangeListener(handleStatusChange);
56 |       setConnectionStatus(ideClient.getConnectionStatus().status);
57 |     })();
58 |     return () => {
59 |       (async () => {
60 |         const ideClient = await IdeClient.getInstance();
61 |         ideClient.removeTrustChangeListener(handleTrustChange);
62 |         ideClient.removeStatusChangeListener(handleStatusChange);
63 |       })();
64 |     };
65 |   }, []);
66 | 
67 |   const getSnapshot = () => {
68 |     if (connectionStatus !== IDEConnectionStatus.Connected) {
69 |       return undefined;
70 |     }
71 |     return ideContextStore.get()?.workspaceState?.isTrusted;
72 |   };
73 | 
74 |   const isIdeTrusted = useSyncExternalStore(subscribe, getSnapshot);
75 | 
76 |   useEffect(() => {
77 |     const currentTrust = isWorkspaceTrusted(settings.merged).isTrusted;
78 |     // Trigger a restart if the overall trust status for the CLI has changed,
79 |     // but not on the initial trust value.
80 |     if (
81 |       previousTrust.current !== undefined &&
82 |       previousTrust.current !== currentTrust
83 |     ) {
84 |       setNeedsRestart(true);
85 |     }
86 |     previousTrust.current = currentTrust;
87 |   }, [isIdeTrusted, settings.merged]);
88 | 
89 |   return { isIdeTrusted, needsRestart, restartReason };
90 | }
```

src/ui/hooks/useInputHistory.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { act, renderHook } from '@testing-library/react';
8 | import { useInputHistory } from './useInputHistory.js';
9 | 
10 | describe('useInputHistory', () => {
11 |   const mockOnSubmit = vi.fn();
12 |   const mockOnChange = vi.fn();
13 | 
14 |   beforeEach(() => {
15 |     vi.clearAllMocks();
16 |   });
17 | 
18 |   const userMessages = ['message 1', 'message 2', 'message 3'];
19 | 
20 |   it('should initialize with historyIndex -1 and empty originalQueryBeforeNav', () => {
21 |     const { result } = renderHook(() =>
22 |       useInputHistory({
23 |         userMessages: [],
24 |         onSubmit: mockOnSubmit,
25 |         isActive: true,
26 |         currentQuery: '',
27 |         onChange: mockOnChange,
28 |       }),
29 |     );
30 | 
31 |     // Internal state is not directly testable, but we can infer from behavior.
32 |     // Attempting to navigate down should do nothing if historyIndex is -1.
33 |     act(() => {
34 |       result.current.navigateDown();
35 |     });
36 |     expect(mockOnChange).not.toHaveBeenCalled();
37 |   });
38 | 
39 |   describe('handleSubmit', () => {
40 |     it('should call onSubmit with trimmed value and reset history', () => {
41 |       const { result } = renderHook(() =>
42 |         useInputHistory({
43 |           userMessages,
44 |           onSubmit: mockOnSubmit,
45 |           isActive: true,
46 |           currentQuery: '  test query  ',
47 |           onChange: mockOnChange,
48 |         }),
49 |       );
50 | 
51 |       act(() => {
52 |         result.current.handleSubmit('  submit value  ');
53 |       });
54 | 
55 |       expect(mockOnSubmit).toHaveBeenCalledWith('submit value');
56 |       // Check if history is reset (e.g., by trying to navigate down)
57 |       act(() => {
58 |         result.current.navigateDown();
59 |       });
60 |       expect(mockOnChange).not.toHaveBeenCalled();
61 |     });
62 | 
63 |     it('should not call onSubmit if value is empty after trimming', () => {
64 |       const { result } = renderHook(() =>
65 |         useInputHistory({
66 |           userMessages,
67 |           onSubmit: mockOnSubmit,
68 |           isActive: true,
69 |           currentQuery: '',
70 |           onChange: mockOnChange,
71 |         }),
72 |       );
73 | 
74 |       act(() => {
75 |         result.current.handleSubmit('   ');
76 |       });
77 | 
78 |       expect(mockOnSubmit).not.toHaveBeenCalled();
79 |     });
80 |   });
81 | 
82 |   describe('navigateUp', () => {
83 |     it('should not navigate if isActive is false', () => {
84 |       const { result } = renderHook(() =>
85 |         useInputHistory({
86 |           userMessages,
87 |           onSubmit: mockOnSubmit,
88 |           isActive: false,
89 |           currentQuery: 'current',
90 |           onChange: mockOnChange,
91 |         }),
92 |       );
93 |       act(() => {
94 |         const navigated = result.current.navigateUp();
95 |         expect(navigated).toBe(false);
96 |       });
97 |       expect(mockOnChange).not.toHaveBeenCalled();
98 |     });
99 | 
100 |     it('should not navigate if userMessages is empty', () => {
101 |       const { result } = renderHook(() =>
102 |         useInputHistory({
103 |           userMessages: [],
104 |           onSubmit: mockOnSubmit,
105 |           isActive: true,
106 |           currentQuery: 'current',
107 |           onChange: mockOnChange,
108 |         }),
109 |       );
110 |       act(() => {
111 |         const navigated = result.current.navigateUp();
112 |         expect(navigated).toBe(false);
113 |       });
114 |       expect(mockOnChange).not.toHaveBeenCalled();
115 |     });
116 | 
117 |     it('should call onChange with the last message when navigating up from initial state', () => {
118 |       const currentQuery = 'current query';
119 |       const { result } = renderHook(() =>
120 |         useInputHistory({
121 |           userMessages,
122 |           onSubmit: mockOnSubmit,
123 |           isActive: true,
124 |           currentQuery,
125 |           onChange: mockOnChange,
126 |         }),
127 |       );
128 | 
129 |       act(() => {
130 |         result.current.navigateUp();
131 |       });
132 | 
133 |       expect(mockOnChange).toHaveBeenCalledWith(userMessages[2]); // Last message
134 |     });
135 | 
136 |     it('should store currentQuery as originalQueryBeforeNav on first navigateUp', () => {
137 |       const currentQuery = 'original user input';
138 |       const { result } = renderHook(() =>
139 |         useInputHistory({
140 |           userMessages,
141 |           onSubmit: mockOnSubmit,
142 |           isActive: true,
143 |           currentQuery,
144 |           onChange: mockOnChange,
145 |         }),
146 |       );
147 | 
148 |       act(() => {
149 |         result.current.navigateUp(); // historyIndex becomes 0
150 |       });
151 |       expect(mockOnChange).toHaveBeenCalledWith(userMessages[2]);
152 | 
153 |       // Navigate down to restore original query
154 |       act(() => {
155 |         result.current.navigateDown(); // historyIndex becomes -1
156 |       });
157 |       expect(mockOnChange).toHaveBeenCalledWith(currentQuery);
158 |     });
159 | 
160 |     it('should navigate through history messages on subsequent navigateUp calls', () => {
161 |       const { result } = renderHook(() =>
162 |         useInputHistory({
163 |           userMessages,
164 |           onSubmit: mockOnSubmit,
165 |           isActive: true,
166 |           currentQuery: '',
167 |           onChange: mockOnChange,
168 |         }),
169 |       );
170 | 
171 |       act(() => {
172 |         result.current.navigateUp(); // Navigates to 'message 3'
173 |       });
174 |       expect(mockOnChange).toHaveBeenCalledWith(userMessages[2]);
175 | 
176 |       act(() => {
177 |         result.current.navigateUp(); // Navigates to 'message 2'
178 |       });
179 |       expect(mockOnChange).toHaveBeenCalledWith(userMessages[1]);
180 | 
181 |       act(() => {
182 |         result.current.navigateUp(); // Navigates to 'message 1'
183 |       });
184 |       expect(mockOnChange).toHaveBeenCalledWith(userMessages[0]);
185 |     });
186 |   });
187 | 
188 |   describe('navigateDown', () => {
189 |     it('should not navigate if isActive is false', () => {
190 |       const initialProps = {
191 |         userMessages,
192 |         onSubmit: mockOnSubmit,
193 |         isActive: true, // Start active to allow setup navigation
194 |         currentQuery: 'current',
195 |         onChange: mockOnChange,
196 |       };
197 |       const { result, rerender } = renderHook(
198 |         (props) => useInputHistory(props),
199 |         {
200 |           initialProps,
201 |         },
202 |       );
203 | 
204 |       // First navigate up to have something in history
205 |       act(() => {
206 |         result.current.navigateUp();
207 |       });
208 |       mockOnChange.mockClear(); // Clear calls from setup
209 | 
210 |       // Set isActive to false for the actual test
211 |       rerender({ ...initialProps, isActive: false });
212 | 
213 |       act(() => {
214 |         const navigated = result.current.navigateDown();
215 |         expect(navigated).toBe(false);
216 |       });
217 |       expect(mockOnChange).not.toHaveBeenCalled();
218 |     });
219 | 
220 |     it('should not navigate if historyIndex is -1 (not in history navigation)', () => {
221 |       const { result } = renderHook(() =>
222 |         useInputHistory({
223 |           userMessages,
224 |           onSubmit: mockOnSubmit,
225 |           isActive: true,
226 |           currentQuery: 'current',
227 |           onChange: mockOnChange,
228 |         }),
229 |       );
230 |       act(() => {
231 |         const navigated = result.current.navigateDown();
232 |         expect(navigated).toBe(false);
233 |       });
234 |       expect(mockOnChange).not.toHaveBeenCalled();
235 |     });
236 | 
237 |     it('should restore originalQueryBeforeNav when navigating down to initial state', () => {
238 |       const originalQuery = 'my original input';
239 |       const { result } = renderHook(() =>
240 |         useInputHistory({
241 |           userMessages,
242 |           onSubmit: mockOnSubmit,
243 |           isActive: true,
244 |           currentQuery: originalQuery,
245 |           onChange: mockOnChange,
246 |         }),
247 |       );
248 | 
249 |       act(() => {
250 |         result.current.navigateUp(); // Navigates to 'message 3', stores 'originalQuery'
251 |       });
252 |       expect(mockOnChange).toHaveBeenCalledWith(userMessages[2]);
253 |       mockOnChange.mockClear();
254 | 
255 |       act(() => {
256 |         result.current.navigateDown(); // Navigates back to original query
257 |       });
258 |       expect(mockOnChange).toHaveBeenCalledWith(originalQuery);
259 |     });
260 |   });
261 | });
```

src/ui/hooks/useInputHistory.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { useState, useCallback } from 'react';
8 | 
9 | interface UseInputHistoryProps {
10 |   userMessages: readonly string[];
11 |   onSubmit: (value: string) => void;
12 |   isActive: boolean;
13 |   currentQuery: string; // Renamed from query to avoid confusion
14 |   onChange: (value: string) => void;
15 | }
16 | 
17 | export interface UseInputHistoryReturn {
18 |   handleSubmit: (value: string) => void;
19 |   navigateUp: () => boolean;
20 |   navigateDown: () => boolean;
21 | }
22 | 
23 | export function useInputHistory({
24 |   userMessages,
25 |   onSubmit,
26 |   isActive,
27 |   currentQuery,
28 |   onChange,
29 | }: UseInputHistoryProps): UseInputHistoryReturn {
30 |   const [historyIndex, setHistoryIndex] = useState<number>(-1);
31 |   const [originalQueryBeforeNav, setOriginalQueryBeforeNav] =
32 |     useState<string>('');
33 | 
34 |   const resetHistoryNav = useCallback(() => {
35 |     setHistoryIndex(-1);
36 |     setOriginalQueryBeforeNav('');
37 |   }, []);
38 | 
39 |   const handleSubmit = useCallback(
40 |     (value: string) => {
41 |       const trimmedValue = value.trim();
42 |       if (trimmedValue) {
43 |         onSubmit(trimmedValue); // Parent handles clearing the query
44 |       }
45 |       resetHistoryNav();
46 |     },
47 |     [onSubmit, resetHistoryNav],
48 |   );
49 | 
50 |   const navigateUp = useCallback(() => {
51 |     if (!isActive) return false;
52 |     if (userMessages.length === 0) return false;
53 | 
54 |     let nextIndex = historyIndex;
55 |     if (historyIndex === -1) {
56 |       // Store the current query from the parent before navigating
57 |       setOriginalQueryBeforeNav(currentQuery);
58 |       nextIndex = 0;
59 |     } else if (historyIndex < userMessages.length - 1) {
60 |       nextIndex = historyIndex + 1;
61 |     } else {
62 |       return false; // Already at the oldest message
63 |     }
64 | 
65 |     if (nextIndex !== historyIndex) {
66 |       setHistoryIndex(nextIndex);
67 |       const newValue = userMessages[userMessages.length - 1 - nextIndex];
68 |       onChange(newValue);
69 |       return true;
70 |     }
71 |     return false;
72 |   }, [
73 |     historyIndex,
74 |     setHistoryIndex,
75 |     onChange,
76 |     userMessages,
77 |     isActive,
78 |     currentQuery, // Use currentQuery from props
79 |     setOriginalQueryBeforeNav,
80 |   ]);
81 | 
82 |   const navigateDown = useCallback(() => {
83 |     if (!isActive) return false;
84 |     if (historyIndex === -1) return false; // Not currently navigating history
85 | 
86 |     const nextIndex = historyIndex - 1;
87 |     setHistoryIndex(nextIndex);
88 | 
89 |     if (nextIndex === -1) {
90 |       // Reached the end of history navigation, restore original query
91 |       onChange(originalQueryBeforeNav);
92 |     } else {
93 |       const newValue = userMessages[userMessages.length - 1 - nextIndex];
94 |       onChange(newValue);
95 |     }
96 |     return true;
97 |   }, [
98 |     historyIndex,
99 |     setHistoryIndex,
100 |     originalQueryBeforeNav,
101 |     onChange,
102 |     userMessages,
103 |     isActive,
104 |   ]);
105 | 
106 |   return {
107 |     handleSubmit,
108 |     navigateUp,
109 |     navigateDown,
110 |   };
111 | }
```

src/ui/hooks/useInputHistoryStore.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { act, renderHook } from '@testing-library/react';
8 | import { vi, describe, it, expect, beforeEach } from 'vitest';
9 | import { useInputHistoryStore } from './useInputHistoryStore.js';
10 | 
11 | describe('useInputHistoryStore', () => {
12 |   beforeEach(() => {
13 |     vi.clearAllMocks();
14 |   });
15 | 
16 |   it('should initialize with empty input history', () => {
17 |     const { result } = renderHook(() => useInputHistoryStore());
18 | 
19 |     expect(result.current.inputHistory).toEqual([]);
20 |   });
21 | 
22 |   it('should add input to history', () => {
23 |     const { result } = renderHook(() => useInputHistoryStore());
24 | 
25 |     act(() => {
26 |       result.current.addInput('test message 1');
27 |     });
28 | 
29 |     expect(result.current.inputHistory).toEqual(['test message 1']);
30 | 
31 |     act(() => {
32 |       result.current.addInput('test message 2');
33 |     });
34 | 
35 |     expect(result.current.inputHistory).toEqual([
36 |       'test message 1',
37 |       'test message 2',
38 |     ]);
39 |   });
40 | 
41 |   it('should not add empty or whitespace-only inputs', () => {
42 |     const { result } = renderHook(() => useInputHistoryStore());
43 | 
44 |     act(() => {
45 |       result.current.addInput('');
46 |     });
47 | 
48 |     expect(result.current.inputHistory).toEqual([]);
49 | 
50 |     act(() => {
51 |       result.current.addInput('   ');
52 |     });
53 | 
54 |     expect(result.current.inputHistory).toEqual([]);
55 |   });
56 | 
57 |   it('should deduplicate consecutive identical messages', () => {
58 |     const { result } = renderHook(() => useInputHistoryStore());
59 | 
60 |     act(() => {
61 |       result.current.addInput('test message');
62 |     });
63 | 
64 |     act(() => {
65 |       result.current.addInput('test message'); // Same as previous
66 |     });
67 | 
68 |     expect(result.current.inputHistory).toEqual(['test message']);
69 | 
70 |     act(() => {
71 |       result.current.addInput('different message');
72 |     });
73 | 
74 |     act(() => {
75 |       result.current.addInput('test message'); // Same as first, but not consecutive
76 |     });
77 | 
78 |     expect(result.current.inputHistory).toEqual([
79 |       'test message',
80 |       'different message',
81 |       'test message',
82 |     ]);
83 |   });
84 | 
85 |   it('should initialize from logger successfully', async () => {
86 |     const mockLogger = {
87 |       getPreviousUserMessages: vi
88 |         .fn()
89 |         .mockResolvedValue(['newest', 'middle', 'oldest']),
90 |     };
91 | 
92 |     const { result } = renderHook(() => useInputHistoryStore());
93 | 
94 |     await act(async () => {
95 |       await result.current.initializeFromLogger(mockLogger);
96 |     });
97 | 
98 |     // Should reverse the order to oldest first
99 |     expect(result.current.inputHistory).toEqual(['oldest', 'middle', 'newest']);
100 |     expect(mockLogger.getPreviousUserMessages).toHaveBeenCalledTimes(1);
101 |   });
102 | 
103 |   it('should handle logger initialization failure gracefully', async () => {
104 |     const mockLogger = {
105 |       getPreviousUserMessages: vi
106 |         .fn()
107 |         .mockRejectedValue(new Error('Logger error')),
108 |     };
109 | 
110 |     const consoleSpy = vi.spyOn(console, 'warn').mockImplementation(() => {});
111 | 
112 |     const { result } = renderHook(() => useInputHistoryStore());
113 | 
114 |     await act(async () => {
115 |       await result.current.initializeFromLogger(mockLogger);
116 |     });
117 | 
118 |     expect(result.current.inputHistory).toEqual([]);
119 |     expect(consoleSpy).toHaveBeenCalledWith(
120 |       'Failed to initialize input history from logger:',
121 |       expect.any(Error),
122 |     );
123 | 
124 |     consoleSpy.mockRestore();
125 |   });
126 | 
127 |   it('should initialize only once', async () => {
128 |     const mockLogger = {
129 |       getPreviousUserMessages: vi
130 |         .fn()
131 |         .mockResolvedValue(['message1', 'message2']),
132 |     };
133 | 
134 |     const { result } = renderHook(() => useInputHistoryStore());
135 | 
136 |     // Call initializeFromLogger twice
137 |     await act(async () => {
138 |       await result.current.initializeFromLogger(mockLogger);
139 |     });
140 | 
141 |     await act(async () => {
142 |       await result.current.initializeFromLogger(mockLogger);
143 |     });
144 | 
145 |     // Should be called only once
146 |     expect(mockLogger.getPreviousUserMessages).toHaveBeenCalledTimes(1);
147 |     expect(result.current.inputHistory).toEqual(['message2', 'message1']);
148 |   });
149 | 
150 |   it('should handle null logger gracefully', async () => {
151 |     const { result } = renderHook(() => useInputHistoryStore());
152 | 
153 |     await act(async () => {
154 |       await result.current.initializeFromLogger(null);
155 |     });
156 | 
157 |     expect(result.current.inputHistory).toEqual([]);
158 |   });
159 | 
160 |   it('should trim input before adding to history', () => {
161 |     const { result } = renderHook(() => useInputHistoryStore());
162 | 
163 |     act(() => {
164 |       result.current.addInput('  test message  ');
165 |     });
166 | 
167 |     expect(result.current.inputHistory).toEqual(['test message']);
168 |   });
169 | 
170 |   describe('deduplication logic from previous implementation', () => {
171 |     it('should deduplicate consecutive messages from past sessions during initialization', async () => {
172 |       const mockLogger = {
173 |         getPreviousUserMessages: vi
174 |           .fn()
175 |           .mockResolvedValue([
176 |             'message1',
177 |             'message1',
178 |             'message2',
179 |             'message2',
180 |             'message3',
181 |           ]), // newest first with duplicates
182 |       };
183 | 
184 |       const { result } = renderHook(() => useInputHistoryStore());
185 | 
186 |       await act(async () => {
187 |         await result.current.initializeFromLogger(mockLogger);
188 |       });
189 | 
190 |       // Should deduplicate consecutive messages and reverse to oldest first
191 |       expect(result.current.inputHistory).toEqual([
192 |         'message3',
193 |         'message2',
194 |         'message1',
195 |       ]);
196 |     });
197 | 
198 |     it('should deduplicate across session boundaries', async () => {
199 |       const mockLogger = {
200 |         getPreviousUserMessages: vi.fn().mockResolvedValue(['old2', 'old1']), // newest first
201 |       };
202 | 
203 |       const { result } = renderHook(() => useInputHistoryStore());
204 | 
205 |       // Initialize with past session
206 |       await act(async () => {
207 |         await result.current.initializeFromLogger(mockLogger);
208 |       });
209 | 
210 |       // Add current session inputs
211 |       act(() => {
212 |         result.current.addInput('old2'); // Same as last past session message
213 |       });
214 | 
215 |       // Should deduplicate across session boundary
216 |       expect(result.current.inputHistory).toEqual(['old1', 'old2']);
217 | 
218 |       act(() => {
219 |         result.current.addInput('new1');
220 |       });
221 | 
222 |       expect(result.current.inputHistory).toEqual(['old1', 'old2', 'new1']);
223 |     });
224 | 
225 |     it('should preserve non-consecutive duplicates', async () => {
226 |       const mockLogger = {
227 |         getPreviousUserMessages: vi
228 |           .fn()
229 |           .mockResolvedValue(['message2', 'message1', 'message2']), // newest first with non-consecutive duplicate
230 |       };
231 | 
232 |       const { result } = renderHook(() => useInputHistoryStore());
233 | 
234 |       await act(async () => {
235 |         await result.current.initializeFromLogger(mockLogger);
236 |       });
237 | 
238 |       // Non-consecutive duplicates should be preserved
239 |       expect(result.current.inputHistory).toEqual([
240 |         'message2',
241 |         'message1',
242 |         'message2',
243 |       ]);
244 |     });
245 | 
246 |     it('should handle complex deduplication with current session', () => {
247 |       const { result } = renderHook(() => useInputHistoryStore());
248 | 
249 |       // Add multiple messages with duplicates
250 |       act(() => {
251 |         result.current.addInput('hello');
252 |       });
253 |       act(() => {
254 |         result.current.addInput('hello'); // consecutive duplicate
255 |       });
256 |       act(() => {
257 |         result.current.addInput('world');
258 |       });
259 |       act(() => {
260 |         result.current.addInput('world'); // consecutive duplicate
261 |       });
262 |       act(() => {
263 |         result.current.addInput('hello'); // non-consecutive duplicate
264 |       });
265 | 
266 |       // Should have deduplicated consecutive ones
267 |       expect(result.current.inputHistory).toEqual(['hello', 'world', 'hello']);
268 |     });
269 | 
270 |     it('should maintain oldest-first order in final output', async () => {
271 |       const mockLogger = {
272 |         getPreviousUserMessages: vi
273 |           .fn()
274 |           .mockResolvedValue(['newest', 'middle', 'oldest']), // newest first
275 |       };
276 | 
277 |       const { result } = renderHook(() => useInputHistoryStore());
278 | 
279 |       await act(async () => {
280 |         await result.current.initializeFromLogger(mockLogger);
281 |       });
282 | 
283 |       // Add current session messages
284 |       act(() => {
285 |         result.current.addInput('current1');
286 |       });
287 |       act(() => {
288 |         result.current.addInput('current2');
289 |       });
290 | 
291 |       // Should maintain oldest-first order
292 |       expect(result.current.inputHistory).toEqual([
293 |         'oldest',
294 |         'middle',
295 |         'newest',
296 |         'current1',
297 |         'current2',
298 |       ]);
299 |     });
300 |   });
301 | });
```

src/ui/hooks/useInputHistoryStore.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { useState, useCallback } from 'react';
8 | 
9 | interface Logger {
10 |   getPreviousUserMessages(): Promise<string[]>;
11 | }
12 | 
13 | export interface UseInputHistoryStoreReturn {
14 |   inputHistory: string[];
15 |   addInput: (input: string) => void;
16 |   initializeFromLogger: (logger: Logger | null) => Promise<void>;
17 | }
18 | 
19 | /**
20 |  * Hook for independently managing input history.
21 |  * Completely separated from chat history and unaffected by /clear commands.
22 |  */
23 | export function useInputHistoryStore(): UseInputHistoryStoreReturn {
24 |   const [inputHistory, setInputHistory] = useState<string[]>([]);
25 |   const [_pastSessionMessages, setPastSessionMessages] = useState<string[]>([]);
26 |   const [_currentSessionMessages, setCurrentSessionMessages] = useState<
27 |     string[]
28 |   >([]);
29 |   const [isInitialized, setIsInitialized] = useState(false);
30 | 
31 |   /**
32 |    * Recalculate the complete input history from past and current sessions.
33 |    * Applies the same deduplication logic as the previous implementation.
34 |    */
35 |   const recalculateHistory = useCallback(
36 |     (currentSession: string[], pastSession: string[]) => {
37 |       // Combine current session (newest first) + past session (newest first)
38 |       const combinedMessages = [...currentSession, ...pastSession];
39 | 
40 |       // Deduplicate consecutive identical messages (same algorithm as before)
41 |       const deduplicatedMessages: string[] = [];
42 |       if (combinedMessages.length > 0) {
43 |         deduplicatedMessages.push(combinedMessages[0]); // Add the newest one unconditionally
44 |         for (let i = 1; i < combinedMessages.length; i++) {
45 |           if (combinedMessages[i] !== combinedMessages[i - 1]) {
46 |             deduplicatedMessages.push(combinedMessages[i]);
47 |           }
48 |         }
49 |       }
50 | 
51 |       // Reverse to oldest first for useInputHistory
52 |       setInputHistory(deduplicatedMessages.reverse());
53 |     },
54 |     [],
55 |   );
56 | 
57 |   /**
58 |    * Initialize input history from logger with past session data.
59 |    * Executed only once at app startup.
60 |    */
61 |   const initializeFromLogger = useCallback(
62 |     async (logger: Logger | null) => {
63 |       if (isInitialized || !logger) return;
64 | 
65 |       try {
66 |         const pastMessages = (await logger.getPreviousUserMessages()) || [];
67 |         setPastSessionMessages(pastMessages); // Store as newest first
68 |         recalculateHistory([], pastMessages);
69 |         setIsInitialized(true);
70 |       } catch (error) {
71 |         // Start with empty history even if logger initialization fails
72 |         console.warn('Failed to initialize input history from logger:', error);
73 |         setPastSessionMessages([]);
74 |         recalculateHistory([], []);
75 |         setIsInitialized(true);
76 |       }
77 |     },
78 |     [isInitialized, recalculateHistory],
79 |   );
80 | 
81 |   /**
82 |    * Add new input to history.
83 |    * Recalculates the entire history with deduplication.
84 |    */
85 |   const addInput = useCallback(
86 |     (input: string) => {
87 |       const trimmedInput = input.trim();
88 |       if (!trimmedInput) return; // Filter empty/whitespace-only inputs
89 | 
90 |       setCurrentSessionMessages((prevCurrent) => {
91 |         const newCurrentSession = [...prevCurrent, trimmedInput];
92 | 
93 |         setPastSessionMessages((prevPast) => {
94 |           recalculateHistory(
95 |             newCurrentSession.slice().reverse(), // Convert to newest first
96 |             prevPast,
97 |           );
98 |           return prevPast; // No change to past messages
99 |         });
100 | 
101 |         return newCurrentSession;
102 |       });
103 |     },
104 |     [recalculateHistory],
105 |   );
106 | 
107 |   return {
108 |     inputHistory,
109 |     addInput,
110 |     initializeFromLogger,
111 |   };
112 | }
```

src/ui/hooks/useKeypress.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import React from 'react';
8 | import { renderHook, act } from '@testing-library/react';
9 | import type { Key } from './useKeypress.js';
10 | import { useKeypress } from './useKeypress.js';
11 | import { KeypressProvider } from '../contexts/KeypressContext.js';
12 | import { useStdin } from 'ink';
13 | import { EventEmitter } from 'node:events';
14 | import { PassThrough } from 'node:stream';
15 | 
16 | // Mock the 'ink' module to control stdin
17 | vi.mock('ink', async (importOriginal) => {
18 |   const original = await importOriginal<typeof import('ink')>();
19 |   return {
20 |     ...original,
21 |     useStdin: vi.fn(),
22 |   };
23 | });
24 | 
25 | // Mock the 'readline' module
26 | vi.mock('readline', () => {
27 |   const mockedReadline = {
28 |     createInterface: vi.fn().mockReturnValue({ close: vi.fn() }),
29 |     // The paste workaround involves replacing stdin with a PassThrough stream.
30 |     // This mock ensures that when emitKeypressEvents is called on that
31 |     // stream, we simulate the 'keypress' events that the hook expects.
32 |     emitKeypressEvents: vi.fn((stream: EventEmitter) => {
33 |       if (stream instanceof PassThrough) {
34 |         stream.on('data', (data) => {
35 |           const str = data.toString();
36 |           for (const char of str) {
37 |             stream.emit('keypress', null, {
38 |               name: char,
39 |               sequence: char,
40 |               ctrl: false,
41 |               meta: false,
42 |               shift: false,
43 |             });
44 |           }
45 |         });
46 |       }
47 |     }),
48 |   };
49 |   return {
50 |     ...mockedReadline,
51 |     default: mockedReadline,
52 |   };
53 | });
54 | 
55 | class MockStdin extends EventEmitter {
56 |   isTTY = true;
57 |   isRaw = false;
58 |   setRawMode = vi.fn();
59 |   on = this.addListener;
60 |   removeListener = this.removeListener;
61 |   write = vi.fn();
62 |   resume = vi.fn();
63 | 
64 |   private isLegacy = false;
65 | 
66 |   setLegacy(isLegacy: boolean) {
67 |     this.isLegacy = isLegacy;
68 |   }
69 | 
70 |   // Helper to simulate a full paste event.
71 |   paste(text: string) {
72 |     if (this.isLegacy) {
73 |       const PASTE_START = '\x1B[200~';
74 |       const PASTE_END = '\x1B[201~';
75 |       this.emit('data', Buffer.from(`${PASTE_START}${text}${PASTE_END}`));
76 |     } else {
77 |       this.emit('keypress', null, { name: 'paste-start' });
78 |       this.emit('keypress', null, { sequence: text });
79 |       this.emit('keypress', null, { name: 'paste-end' });
80 |     }
81 |   }
82 | 
83 |   // Helper to simulate the start of a paste, without the end.
84 |   startPaste(text: string) {
85 |     if (this.isLegacy) {
86 |       this.emit('data', Buffer.from('\x1B[200~' + text));
87 |     } else {
88 |       this.emit('keypress', null, { name: 'paste-start' });
89 |       this.emit('keypress', null, { sequence: text });
90 |     }
91 |   }
92 | 
93 |   // Helper to simulate a single keypress event.
94 |   pressKey(key: Partial<Key>) {
95 |     if (this.isLegacy) {
96 |       this.emit('data', Buffer.from(key.sequence ?? ''));
97 |     } else {
98 |       this.emit('keypress', null, key);
99 |     }
100 |   }
101 | }
102 | 
103 | describe('useKeypress', () => {
104 |   let stdin: MockStdin;
105 |   const mockSetRawMode = vi.fn();
106 |   const onKeypress = vi.fn();
107 |   let originalNodeVersion: string;
108 | 
109 |   const wrapper = ({ children }: { children: React.ReactNode }) =>
110 |     React.createElement(KeypressProvider, null, children);
111 | 
112 |   beforeEach(() => {
113 |     vi.clearAllMocks();
114 |     stdin = new MockStdin();
115 |     (useStdin as vi.Mock).mockReturnValue({
116 |       stdin,
117 |       setRawMode: mockSetRawMode,
118 |     });
119 | 
120 |     originalNodeVersion = process.versions.node;
121 |     vi.unstubAllEnvs();
122 |   });
123 | 
124 |   afterEach(() => {
125 |     Object.defineProperty(process.versions, 'node', {
126 |       value: originalNodeVersion,
127 |       configurable: true,
128 |     });
129 |   });
130 | 
131 |   const setNodeVersion = (version: string) => {
132 |     Object.defineProperty(process.versions, 'node', {
133 |       value: version,
134 |       configurable: true,
135 |     });
136 |   };
137 | 
138 |   it('should not listen if isActive is false', () => {
139 |     renderHook(() => useKeypress(onKeypress, { isActive: false }), {
140 |       wrapper,
141 |     });
142 |     act(() => stdin.pressKey({ name: 'a' }));
143 |     expect(onKeypress).not.toHaveBeenCalled();
144 |   });
145 | 
146 |   it.each([
147 |     { key: { name: 'a', sequence: 'a' } },
148 |     { key: { name: 'left', sequence: '\x1b[D' } },
149 |     { key: { name: 'right', sequence: '\x1b[C' } },
150 |     { key: { name: 'up', sequence: '\x1b[A' } },
151 |     { key: { name: 'down', sequence: '\x1b[B' } },
152 |   ])('should listen for keypress when active for key $key.name', ({ key }) => {
153 |     renderHook(() => useKeypress(onKeypress, { isActive: true }), { wrapper });
154 |     act(() => stdin.pressKey(key));
155 |     expect(onKeypress).toHaveBeenCalledWith(expect.objectContaining(key));
156 |   });
157 | 
158 |   it('should set and release raw mode', () => {
159 |     const { unmount } = renderHook(
160 |       () => useKeypress(onKeypress, { isActive: true }),
161 |       { wrapper },
162 |     );
163 |     expect(mockSetRawMode).toHaveBeenCalledWith(true);
164 |     unmount();
165 |     expect(mockSetRawMode).toHaveBeenCalledWith(false);
166 |   });
167 | 
168 |   it('should stop listening after being unmounted', () => {
169 |     const { unmount } = renderHook(
170 |       () => useKeypress(onKeypress, { isActive: true }),
171 |       { wrapper },
172 |     );
173 |     unmount();
174 |     act(() => stdin.pressKey({ name: 'a' }));
175 |     expect(onKeypress).not.toHaveBeenCalled();
176 |   });
177 | 
178 |   it('should correctly identify alt+enter (meta key)', () => {
179 |     renderHook(() => useKeypress(onKeypress, { isActive: true }), { wrapper });
180 |     const key = { name: 'return', sequence: '\x1B\r' };
181 |     act(() => stdin.pressKey(key));
182 |     expect(onKeypress).toHaveBeenCalledWith(
183 |       expect.objectContaining({ ...key, meta: true, paste: false }),
184 |     );
185 |   });
186 | 
187 |   describe.each([
188 |     {
189 |       description: 'Modern Node (>= v20)',
190 |       setup: () => setNodeVersion('20.0.0'),
191 |       isLegacy: false,
192 |     },
193 |     {
194 |       description: 'Legacy Node (< v20)',
195 |       setup: () => setNodeVersion('18.0.0'),
196 |       isLegacy: true,
197 |     },
198 |     {
199 |       description: 'Workaround Env Var',
200 |       setup: () => {
201 |         setNodeVersion('20.0.0');
202 |         vi.stubEnv('PASTE_WORKAROUND', 'true');
203 |       },
204 |       isLegacy: true,
205 |     },
206 |   ])('in $description', ({ setup, isLegacy }) => {
207 |     beforeEach(() => {
208 |       setup();
209 |       stdin.setLegacy(isLegacy);
210 |     });
211 | 
212 |     it('should process a paste as a single event', () => {
213 |       renderHook(() => useKeypress(onKeypress, { isActive: true }), {
214 |         wrapper,
215 |       });
216 |       const pasteText = 'hello world';
217 |       act(() => stdin.paste(pasteText));
218 | 
219 |       expect(onKeypress).toHaveBeenCalledTimes(1);
220 |       expect(onKeypress).toHaveBeenCalledWith({
221 |         name: '',
222 |         ctrl: false,
223 |         meta: false,
224 |         shift: false,
225 |         paste: true,
226 |         sequence: pasteText,
227 |       });
228 |     });
229 | 
230 |     it('should handle keypress interspersed with pastes', () => {
231 |       renderHook(() => useKeypress(onKeypress, { isActive: true }), {
232 |         wrapper,
233 |       });
234 | 
235 |       const keyA = { name: 'a', sequence: 'a' };
236 |       act(() => stdin.pressKey(keyA));
237 |       expect(onKeypress).toHaveBeenCalledWith(
238 |         expect.objectContaining({ ...keyA, paste: false }),
239 |       );
240 | 
241 |       const pasteText = 'pasted';
242 |       act(() => stdin.paste(pasteText));
243 |       expect(onKeypress).toHaveBeenCalledWith(
244 |         expect.objectContaining({ paste: true, sequence: pasteText }),
245 |       );
246 | 
247 |       const keyB = { name: 'b', sequence: 'b' };
248 |       act(() => stdin.pressKey(keyB));
249 |       expect(onKeypress).toHaveBeenCalledWith(
250 |         expect.objectContaining({ ...keyB, paste: false }),
251 |       );
252 | 
253 |       expect(onKeypress).toHaveBeenCalledTimes(3);
254 |     });
255 | 
256 |     it('should emit partial paste content if unmounted mid-paste', () => {
257 |       const { unmount } = renderHook(
258 |         () => useKeypress(onKeypress, { isActive: true }),
259 |         { wrapper },
260 |       );
261 |       const pasteText = 'incomplete paste';
262 | 
263 |       act(() => stdin.startPaste(pasteText));
264 | 
265 |       // No event should be fired yet.
266 |       expect(onKeypress).not.toHaveBeenCalled();
267 | 
268 |       // Unmounting should trigger the flush.
269 |       unmount();
270 | 
271 |       expect(onKeypress).toHaveBeenCalledTimes(1);
272 |       expect(onKeypress).toHaveBeenCalledWith({
273 |         name: '',
274 |         ctrl: false,
275 |         meta: false,
276 |         shift: false,
277 |         paste: true,
278 |         sequence: pasteText,
279 |       });
280 |     });
281 |   });
282 | });
```

src/ui/hooks/useKeypress.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { useEffect } from 'react';
8 | import type { KeypressHandler, Key } from '../contexts/KeypressContext.js';
9 | import { useKeypressContext } from '../contexts/KeypressContext.js';
10 | 
11 | export type { Key };
12 | 
13 | /**
14 |  * A hook that listens for keypress events from stdin.
15 |  *
16 |  * @param onKeypress - The callback function to execute on each keypress.
17 |  * @param options - Options to control the hook's behavior.
18 |  * @param options.isActive - Whether the hook should be actively listening for input.
19 |  */
20 | export function useKeypress(
21 |   onKeypress: KeypressHandler,
22 |   { isActive }: { isActive: boolean },
23 | ) {
24 |   const { subscribe, unsubscribe } = useKeypressContext();
25 | 
26 |   useEffect(() => {
27 |     if (!isActive) {
28 |       return;
29 |     }
30 | 
31 |     subscribe(onKeypress);
32 |     return () => {
33 |       unsubscribe(onKeypress);
34 |     };
35 |   }, [isActive, onKeypress, subscribe, unsubscribe]);
36 | }
```

src/ui/hooks/useKittyKeyboardProtocol.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { useState } from 'react';
8 | import {
9 |   isKittyProtocolEnabled,
10 |   isKittyProtocolSupported,
11 | } from '../utils/kittyProtocolDetector.js';
12 | 
13 | export interface KittyProtocolStatus {
14 |   supported: boolean;
15 |   enabled: boolean;
16 |   checking: boolean;
17 | }
18 | 
19 | /**
20 |  * Hook that returns the cached Kitty keyboard protocol status.
21 |  * Detection is done once at app startup to avoid repeated queries.
22 |  */
23 | export function useKittyKeyboardProtocol(): KittyProtocolStatus {
24 |   const [status] = useState<KittyProtocolStatus>({
25 |     supported: isKittyProtocolSupported(),
26 |     enabled: isKittyProtocolEnabled(),
27 |     checking: false,
28 |   });
29 | 
30 |   return status;
31 | }
```

src/ui/hooks/useLoadingIndicator.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
8 | import { renderHook, act } from '@testing-library/react';
9 | import { useLoadingIndicator } from './useLoadingIndicator.js';
10 | import { StreamingState } from '../types.js';
11 | import {
12 |   WITTY_LOADING_PHRASES,
13 |   PHRASE_CHANGE_INTERVAL_MS,
14 | } from './usePhraseCycler.js';
15 | 
16 | describe('useLoadingIndicator', () => {
17 |   beforeEach(() => {
18 |     vi.useFakeTimers();
19 |   });
20 | 
21 |   afterEach(() => {
22 |     vi.useRealTimers(); // Restore real timers after each test
23 |     act(() => vi.runOnlyPendingTimers);
24 |   });
25 | 
26 |   it('should initialize with default values when Idle', () => {
27 |     const { result } = renderHook(() =>
28 |       useLoadingIndicator(StreamingState.Idle),
29 |     );
30 |     expect(result.current.elapsedTime).toBe(0);
31 |     expect(WITTY_LOADING_PHRASES).toContain(
32 |       result.current.currentLoadingPhrase,
33 |     );
34 |   });
35 | 
36 |   it('should reflect values when Responding', async () => {
37 |     const { result } = renderHook(() =>
38 |       useLoadingIndicator(StreamingState.Responding),
39 |     );
40 | 
41 |     // Initial state before timers advance
42 |     expect(result.current.elapsedTime).toBe(0);
43 |     expect(WITTY_LOADING_PHRASES).toContain(
44 |       result.current.currentLoadingPhrase,
45 |     );
46 | 
47 |     await act(async () => {
48 |       await vi.advanceTimersByTimeAsync(PHRASE_CHANGE_INTERVAL_MS + 1);
49 |     });
50 | 
51 |     // Phrase should cycle if PHRASE_CHANGE_INTERVAL_MS has passed
52 |     expect(WITTY_LOADING_PHRASES).toContain(
53 |       result.current.currentLoadingPhrase,
54 |     );
55 |   });
56 | 
57 |   it('should show waiting phrase and retain elapsedTime when WaitingForConfirmation', async () => {
58 |     const { result, rerender } = renderHook(
59 |       ({ streamingState }) => useLoadingIndicator(streamingState),
60 |       { initialProps: { streamingState: StreamingState.Responding } },
61 |     );
62 | 
63 |     await act(async () => {
64 |       await vi.advanceTimersByTimeAsync(60000);
65 |     });
66 |     expect(result.current.elapsedTime).toBe(60);
67 | 
68 |     act(() => {
69 |       rerender({ streamingState: StreamingState.WaitingForConfirmation });
70 |     });
71 | 
72 |     expect(result.current.currentLoadingPhrase).toBe(
73 |       'Waiting for user confirmation...',
74 |     );
75 |     expect(result.current.elapsedTime).toBe(60); // Elapsed time should be retained
76 | 
77 |     // Timer should not advance further
78 |     await act(async () => {
79 |       await vi.advanceTimersByTimeAsync(2000);
80 |     });
81 |     expect(result.current.elapsedTime).toBe(60);
82 |   });
83 | 
84 |   it('should reset elapsedTime and use a witty phrase when transitioning from WaitingForConfirmation to Responding', async () => {
85 |     const { result, rerender } = renderHook(
86 |       ({ streamingState }) => useLoadingIndicator(streamingState),
87 |       { initialProps: { streamingState: StreamingState.Responding } },
88 |     );
89 | 
90 |     await act(async () => {
91 |       await vi.advanceTimersByTimeAsync(5000); // 5s
92 |     });
93 |     expect(result.current.elapsedTime).toBe(5);
94 | 
95 |     act(() => {
96 |       rerender({ streamingState: StreamingState.WaitingForConfirmation });
97 |     });
98 |     expect(result.current.elapsedTime).toBe(5);
99 |     expect(result.current.currentLoadingPhrase).toBe(
100 |       'Waiting for user confirmation...',
101 |     );
102 | 
103 |     act(() => {
104 |       rerender({ streamingState: StreamingState.Responding });
105 |     });
106 |     expect(result.current.elapsedTime).toBe(0); // Should reset
107 |     expect(WITTY_LOADING_PHRASES).toContain(
108 |       result.current.currentLoadingPhrase,
109 |     );
110 | 
111 |     await act(async () => {
112 |       await vi.advanceTimersByTimeAsync(1000);
113 |     });
114 |     expect(result.current.elapsedTime).toBe(1);
115 |   });
116 | 
117 |   it('should reset timer and phrase when streamingState changes from Responding to Idle', async () => {
118 |     const { result, rerender } = renderHook(
119 |       ({ streamingState }) => useLoadingIndicator(streamingState),
120 |       { initialProps: { streamingState: StreamingState.Responding } },
121 |     );
122 | 
123 |     await act(async () => {
124 |       await vi.advanceTimersByTimeAsync(10000); // 10s
125 |     });
126 |     expect(result.current.elapsedTime).toBe(10);
127 | 
128 |     act(() => {
129 |       rerender({ streamingState: StreamingState.Idle });
130 |     });
131 | 
132 |     expect(result.current.elapsedTime).toBe(0);
133 |     expect(WITTY_LOADING_PHRASES).toContain(
134 |       result.current.currentLoadingPhrase,
135 |     );
136 | 
137 |     // Timer should not advance
138 |     await act(async () => {
139 |       await vi.advanceTimersByTimeAsync(2000);
140 |     });
141 |     expect(result.current.elapsedTime).toBe(0);
142 |   });
143 | });
```

src/ui/hooks/useLoadingIndicator.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { StreamingState } from '../types.js';
8 | import { useTimer } from './useTimer.js';
9 | import { usePhraseCycler } from './usePhraseCycler.js';
10 | import { useState, useEffect, useRef } from 'react'; // Added useRef
11 | 
12 | export const useLoadingIndicator = (
13 |   streamingState: StreamingState,
14 |   customWittyPhrases?: string[],
15 | ) => {
16 |   const [timerResetKey, setTimerResetKey] = useState(0);
17 |   const isTimerActive = streamingState === StreamingState.Responding;
18 | 
19 |   const elapsedTimeFromTimer = useTimer(isTimerActive, timerResetKey);
20 | 
21 |   const isPhraseCyclingActive = streamingState === StreamingState.Responding;
22 |   const isWaiting = streamingState === StreamingState.WaitingForConfirmation;
23 |   const currentLoadingPhrase = usePhraseCycler(
24 |     isPhraseCyclingActive,
25 |     isWaiting,
26 |     customWittyPhrases,
27 |   );
28 | 
29 |   const [retainedElapsedTime, setRetainedElapsedTime] = useState(0);
30 |   const prevStreamingStateRef = useRef<StreamingState | null>(null);
31 | 
32 |   useEffect(() => {
33 |     if (
34 |       prevStreamingStateRef.current === StreamingState.WaitingForConfirmation &&
35 |       streamingState === StreamingState.Responding
36 |     ) {
37 |       setTimerResetKey((prevKey) => prevKey + 1);
38 |       setRetainedElapsedTime(0); // Clear retained time when going back to responding
39 |     } else if (
40 |       streamingState === StreamingState.Idle &&
41 |       prevStreamingStateRef.current === StreamingState.Responding
42 |     ) {
43 |       setTimerResetKey((prevKey) => prevKey + 1); // Reset timer when becoming idle from responding
44 |       setRetainedElapsedTime(0);
45 |     } else if (streamingState === StreamingState.WaitingForConfirmation) {
46 |       // Capture the time when entering WaitingForConfirmation
47 |       // elapsedTimeFromTimer will hold the last value from when isTimerActive was true.
48 |       setRetainedElapsedTime(elapsedTimeFromTimer);
49 |     }
50 | 
51 |     prevStreamingStateRef.current = streamingState;
52 |   }, [streamingState, elapsedTimeFromTimer]);
53 | 
54 |   return {
55 |     elapsedTime:
56 |       streamingState === StreamingState.WaitingForConfirmation
57 |         ? retainedElapsedTime
58 |         : elapsedTimeFromTimer,
59 |     currentLoadingPhrase,
60 |   };
61 | };
```

src/ui/hooks/useLogger.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { useState, useEffect } from 'react';
8 | import type { Storage } from '@google/gemini-cli-core';
9 | import { sessionId, Logger } from '@google/gemini-cli-core';
10 | 
11 | /**
12 |  * Hook to manage the logger instance.
13 |  */
14 | export const useLogger = (storage: Storage) => {
15 |   const [logger, setLogger] = useState<Logger | null>(null);
16 | 
17 |   useEffect(() => {
18 |     const newLogger = new Logger(sessionId, storage);
19 |     /**
20 |      * Start async initialization, no need to await. Using await slows down the
21 |      * time from launch to see the gemini-cli prompt and it's better to not save
22 |      * messages than for the cli to hanging waiting for the logger to loading.
23 |      */
24 |     newLogger
25 |       .initialize()
26 |       .then(() => {
27 |         setLogger(newLogger);
28 |       })
29 |       .catch(() => {});
30 |   }, [storage]);
31 | 
32 |   return logger;
33 | };
```

src/ui/hooks/useMemoryMonitor.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { renderHook } from '@testing-library/react';
8 | import { vi } from 'vitest';
9 | import {
10 |   useMemoryMonitor,
11 |   MEMORY_CHECK_INTERVAL,
12 |   MEMORY_WARNING_THRESHOLD,
13 | } from './useMemoryMonitor.js';
14 | import process from 'node:process';
15 | import { MessageType } from '../types.js';
16 | 
17 | describe('useMemoryMonitor', () => {
18 |   const memoryUsageSpy = vi.spyOn(process, 'memoryUsage');
19 |   const addItem = vi.fn();
20 | 
21 |   beforeEach(() => {
22 |     vi.useFakeTimers();
23 |     vi.clearAllMocks();
24 |   });
25 | 
26 |   afterEach(() => {
27 |     vi.useRealTimers();
28 |   });
29 | 
30 |   it('should not warn when memory usage is below threshold', () => {
31 |     memoryUsageSpy.mockReturnValue({
32 |       rss: MEMORY_WARNING_THRESHOLD / 2,
33 |     } as NodeJS.MemoryUsage);
34 |     renderHook(() => useMemoryMonitor({ addItem }));
35 |     vi.advanceTimersByTime(10000);
36 |     expect(addItem).not.toHaveBeenCalled();
37 |   });
38 | 
39 |   it('should warn when memory usage is above threshold', () => {
40 |     memoryUsageSpy.mockReturnValue({
41 |       rss: MEMORY_WARNING_THRESHOLD * 1.5,
42 |     } as NodeJS.MemoryUsage);
43 |     renderHook(() => useMemoryMonitor({ addItem }));
44 |     vi.advanceTimersByTime(MEMORY_CHECK_INTERVAL);
45 |     expect(addItem).toHaveBeenCalledTimes(1);
46 |     expect(addItem).toHaveBeenCalledWith(
47 |       {
48 |         type: MessageType.WARNING,
49 |         text: 'High memory usage detected: 10.50 GB. If you experience a crash, please file a bug report by running `/bug`',
50 |       },
51 |       expect.any(Number),
52 |     );
53 |   });
54 | 
55 |   it('should only warn once', () => {
56 |     memoryUsageSpy.mockReturnValue({
57 |       rss: MEMORY_WARNING_THRESHOLD * 1.5,
58 |     } as NodeJS.MemoryUsage);
59 |     const { rerender } = renderHook(() => useMemoryMonitor({ addItem }));
60 |     vi.advanceTimersByTime(MEMORY_CHECK_INTERVAL);
61 |     expect(addItem).toHaveBeenCalledTimes(1);
62 | 
63 |     // Rerender and advance timers, should not warn again
64 |     memoryUsageSpy.mockReturnValue({
65 |       rss: MEMORY_WARNING_THRESHOLD * 1.5,
66 |     } as NodeJS.MemoryUsage);
67 |     rerender();
68 |     vi.advanceTimersByTime(MEMORY_CHECK_INTERVAL);
69 |     expect(addItem).toHaveBeenCalledTimes(1);
70 |   });
71 | });
```

src/ui/hooks/useMemoryMonitor.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { useEffect } from 'react';
8 | import process from 'node:process';
9 | import { type HistoryItemWithoutId, MessageType } from '../types.js';
10 | 
11 | export const MEMORY_WARNING_THRESHOLD = 7 * 1024 * 1024 * 1024; // 7GB in bytes
12 | export const MEMORY_CHECK_INTERVAL = 60 * 1000; // one minute
13 | 
14 | interface MemoryMonitorOptions {
15 |   addItem: (item: HistoryItemWithoutId, timestamp: number) => void;
16 | }
17 | 
18 | export const useMemoryMonitor = ({ addItem }: MemoryMonitorOptions) => {
19 |   useEffect(() => {
20 |     const intervalId = setInterval(() => {
21 |       const usage = process.memoryUsage().rss;
22 |       if (usage > MEMORY_WARNING_THRESHOLD) {
23 |         addItem(
24 |           {
25 |             type: MessageType.WARNING,
26 |             text:
27 |               `High memory usage detected: ${(
28 |                 usage /
29 |                 (1024 * 1024 * 1024)
30 |               ).toFixed(2)} GB. ` +
31 |               'If you experience a crash, please file a bug report by running `/bug`',
32 |           },
33 |           Date.now(),
34 |         );
35 |         clearInterval(intervalId);
36 |       }
37 |     }, MEMORY_CHECK_INTERVAL);
38 | 
39 |     return () => clearInterval(intervalId);
40 |   }, [addItem]);
41 | };
```

src/ui/hooks/useMessageQueue.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
8 | import { renderHook, act } from '@testing-library/react';
9 | import { useMessageQueue } from './useMessageQueue.js';
10 | import { StreamingState } from '../types.js';
11 | 
12 | describe('useMessageQueue', () => {
13 |   let mockSubmitQuery: ReturnType<typeof vi.fn>;
14 | 
15 |   beforeEach(() => {
16 |     mockSubmitQuery = vi.fn();
17 |     vi.useFakeTimers();
18 |   });
19 | 
20 |   afterEach(() => {
21 |     vi.useRealTimers();
22 |     vi.clearAllMocks();
23 |   });
24 | 
25 |   it('should initialize with empty queue', () => {
26 |     const { result } = renderHook(() =>
27 |       useMessageQueue({
28 |         isConfigInitialized: true,
29 |         streamingState: StreamingState.Idle,
30 |         submitQuery: mockSubmitQuery,
31 |       }),
32 |     );
33 | 
34 |     expect(result.current.messageQueue).toEqual([]);
35 |     expect(result.current.getQueuedMessagesText()).toBe('');
36 |   });
37 | 
38 |   it('should add messages to queue', () => {
39 |     const { result } = renderHook(() =>
40 |       useMessageQueue({
41 |         isConfigInitialized: true,
42 |         streamingState: StreamingState.Responding,
43 |         submitQuery: mockSubmitQuery,
44 |       }),
45 |     );
46 | 
47 |     act(() => {
48 |       result.current.addMessage('Test message 1');
49 |       result.current.addMessage('Test message 2');
50 |     });
51 | 
52 |     expect(result.current.messageQueue).toEqual([
53 |       'Test message 1',
54 |       'Test message 2',
55 |     ]);
56 |   });
57 | 
58 |   it('should filter out empty messages', () => {
59 |     const { result } = renderHook(() =>
60 |       useMessageQueue({
61 |         isConfigInitialized: true,
62 |         streamingState: StreamingState.Responding,
63 |         submitQuery: mockSubmitQuery,
64 |       }),
65 |     );
66 | 
67 |     act(() => {
68 |       result.current.addMessage('Valid message');
69 |       result.current.addMessage('   '); // Only whitespace
70 |       result.current.addMessage(''); // Empty
71 |       result.current.addMessage('Another valid message');
72 |     });
73 | 
74 |     expect(result.current.messageQueue).toEqual([
75 |       'Valid message',
76 |       'Another valid message',
77 |     ]);
78 |   });
79 | 
80 |   it('should clear queue', () => {
81 |     const { result } = renderHook(() =>
82 |       useMessageQueue({
83 |         isConfigInitialized: true,
84 |         streamingState: StreamingState.Responding,
85 |         submitQuery: mockSubmitQuery,
86 |       }),
87 |     );
88 | 
89 |     act(() => {
90 |       result.current.addMessage('Test message');
91 |     });
92 | 
93 |     expect(result.current.messageQueue).toEqual(['Test message']);
94 | 
95 |     act(() => {
96 |       result.current.clearQueue();
97 |     });
98 | 
99 |     expect(result.current.messageQueue).toEqual([]);
100 |   });
101 | 
102 |   it('should return queued messages as text with double newlines', () => {
103 |     const { result } = renderHook(() =>
104 |       useMessageQueue({
105 |         isConfigInitialized: true,
106 |         streamingState: StreamingState.Responding,
107 |         submitQuery: mockSubmitQuery,
108 |       }),
109 |     );
110 | 
111 |     act(() => {
112 |       result.current.addMessage('Message 1');
113 |       result.current.addMessage('Message 2');
114 |       result.current.addMessage('Message 3');
115 |     });
116 | 
117 |     expect(result.current.getQueuedMessagesText()).toBe(
118 |       'Message 1\n\nMessage 2\n\nMessage 3',
119 |     );
120 |   });
121 | 
122 |   it('should auto-submit queued messages when transitioning to Idle', () => {
123 |     const { result, rerender } = renderHook(
124 |       ({ streamingState }) =>
125 |         useMessageQueue({
126 |           isConfigInitialized: true,
127 |           streamingState,
128 |           submitQuery: mockSubmitQuery,
129 |         }),
130 |       {
131 |         initialProps: { streamingState: StreamingState.Responding },
132 |       },
133 |     );
134 | 
135 |     // Add some messages
136 |     act(() => {
137 |       result.current.addMessage('Message 1');
138 |       result.current.addMessage('Message 2');
139 |     });
140 | 
141 |     expect(result.current.messageQueue).toEqual(['Message 1', 'Message 2']);
142 | 
143 |     // Transition to Idle
144 |     rerender({ streamingState: StreamingState.Idle });
145 | 
146 |     expect(mockSubmitQuery).toHaveBeenCalledWith('Message 1\n\nMessage 2');
147 |     expect(result.current.messageQueue).toEqual([]);
148 |   });
149 | 
150 |   it('should not auto-submit when queue is empty', () => {
151 |     const { rerender } = renderHook(
152 |       ({ streamingState }) =>
153 |         useMessageQueue({
154 |           isConfigInitialized: true,
155 |           streamingState,
156 |           submitQuery: mockSubmitQuery,
157 |         }),
158 |       {
159 |         initialProps: { streamingState: StreamingState.Responding },
160 |       },
161 |     );
162 | 
163 |     // Transition to Idle with empty queue
164 |     rerender({ streamingState: StreamingState.Idle });
165 | 
166 |     expect(mockSubmitQuery).not.toHaveBeenCalled();
167 |   });
168 | 
169 |   it('should not auto-submit when not transitioning to Idle', () => {
170 |     const { result, rerender } = renderHook(
171 |       ({ streamingState }) =>
172 |         useMessageQueue({
173 |           isConfigInitialized: true,
174 |           streamingState,
175 |           submitQuery: mockSubmitQuery,
176 |         }),
177 |       {
178 |         initialProps: { streamingState: StreamingState.Responding },
179 |       },
180 |     );
181 | 
182 |     // Add messages
183 |     act(() => {
184 |       result.current.addMessage('Message 1');
185 |     });
186 | 
187 |     // Transition to WaitingForConfirmation (not Idle)
188 |     rerender({ streamingState: StreamingState.WaitingForConfirmation });
189 | 
190 |     expect(mockSubmitQuery).not.toHaveBeenCalled();
191 |     expect(result.current.messageQueue).toEqual(['Message 1']);
192 |   });
193 | 
194 |   it('should handle multiple state transitions correctly', () => {
195 |     const { result, rerender } = renderHook(
196 |       ({ streamingState }) =>
197 |         useMessageQueue({
198 |           isConfigInitialized: true,
199 |           streamingState,
200 |           submitQuery: mockSubmitQuery,
201 |         }),
202 |       {
203 |         initialProps: { streamingState: StreamingState.Idle },
204 |       },
205 |     );
206 | 
207 |     // Start responding
208 |     rerender({ streamingState: StreamingState.Responding });
209 | 
210 |     // Add messages while responding
211 |     act(() => {
212 |       result.current.addMessage('First batch');
213 |     });
214 | 
215 |     // Go back to idle - should submit
216 |     rerender({ streamingState: StreamingState.Idle });
217 | 
218 |     expect(mockSubmitQuery).toHaveBeenCalledWith('First batch');
219 |     expect(result.current.messageQueue).toEqual([]);
220 | 
221 |     // Start responding again
222 |     rerender({ streamingState: StreamingState.Responding });
223 | 
224 |     // Add more messages
225 |     act(() => {
226 |       result.current.addMessage('Second batch');
227 |     });
228 | 
229 |     // Go back to idle - should submit again
230 |     rerender({ streamingState: StreamingState.Idle });
231 | 
232 |     expect(mockSubmitQuery).toHaveBeenCalledWith('Second batch');
233 |     expect(mockSubmitQuery).toHaveBeenCalledTimes(2);
234 |   });
235 | });
```

src/ui/hooks/useMessageQueue.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { useCallback, useEffect, useState } from 'react';
8 | import { StreamingState } from '../types.js';
9 | 
10 | export interface UseMessageQueueOptions {
11 |   isConfigInitialized: boolean;
12 |   streamingState: StreamingState;
13 |   submitQuery: (query: string) => void;
14 | }
15 | 
16 | export interface UseMessageQueueReturn {
17 |   messageQueue: string[];
18 |   addMessage: (message: string) => void;
19 |   clearQueue: () => void;
20 |   getQueuedMessagesText: () => string;
21 | }
22 | 
23 | /**
24 |  * Hook for managing message queuing during streaming responses.
25 |  * Allows users to queue messages while the AI is responding and automatically
26 |  * sends them when streaming completes.
27 |  */
28 | export function useMessageQueue({
29 |   isConfigInitialized,
30 |   streamingState,
31 |   submitQuery,
32 | }: UseMessageQueueOptions): UseMessageQueueReturn {
33 |   const [messageQueue, setMessageQueue] = useState<string[]>([]);
34 | 
35 |   // Add a message to the queue
36 |   const addMessage = useCallback((message: string) => {
37 |     const trimmedMessage = message.trim();
38 |     if (trimmedMessage.length > 0) {
39 |       setMessageQueue((prev) => [...prev, trimmedMessage]);
40 |     }
41 |   }, []);
42 | 
43 |   // Clear the entire queue
44 |   const clearQueue = useCallback(() => {
45 |     setMessageQueue([]);
46 |   }, []);
47 | 
48 |   // Get all queued messages as a single text string
49 |   const getQueuedMessagesText = useCallback(() => {
50 |     if (messageQueue.length === 0) return '';
51 |     return messageQueue.join('\n\n');
52 |   }, [messageQueue]);
53 | 
54 |   // Process queued messages when streaming becomes idle
55 |   useEffect(() => {
56 |     if (
57 |       isConfigInitialized &&
58 |       streamingState === StreamingState.Idle &&
59 |       messageQueue.length > 0
60 |     ) {
61 |       // Combine all messages with double newlines for clarity
62 |       const combinedMessage = messageQueue.join('\n\n');
63 |       // Clear the queue and submit
64 |       setMessageQueue([]);
65 |       submitQuery(combinedMessage);
66 |     }
67 |   }, [isConfigInitialized, streamingState, messageQueue, submitQuery]);
68 | 
69 |   return {
70 |     messageQueue,
71 |     addMessage,
72 |     clearQueue,
73 |     getQueuedMessagesText,
74 |   };
75 | }
```

src/ui/hooks/useModelCommand.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect } from 'vitest';
8 | import { renderHook, act } from '@testing-library/react';
9 | import { useModelCommand } from './useModelCommand.js';
10 | 
11 | describe('useModelCommand', () => {
12 |   it('should initialize with the model dialog closed', () => {
13 |     const { result } = renderHook(() => useModelCommand());
14 |     expect(result.current.isModelDialogOpen).toBe(false);
15 |   });
16 | 
17 |   it('should open the model dialog when openModelDialog is called', () => {
18 |     const { result } = renderHook(() => useModelCommand());
19 | 
20 |     act(() => {
21 |       result.current.openModelDialog();
22 |     });
23 | 
24 |     expect(result.current.isModelDialogOpen).toBe(true);
25 |   });
26 | 
27 |   it('should close the model dialog when closeModelDialog is called', () => {
28 |     const { result } = renderHook(() => useModelCommand());
29 | 
30 |     // Open it first
31 |     act(() => {
32 |       result.current.openModelDialog();
33 |     });
34 |     expect(result.current.isModelDialogOpen).toBe(true);
35 | 
36 |     // Then close it
37 |     act(() => {
38 |       result.current.closeModelDialog();
39 |     });
40 |     expect(result.current.isModelDialogOpen).toBe(false);
41 |   });
42 | });
```

src/ui/hooks/useModelCommand.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { useState, useCallback } from 'react';
8 | 
9 | interface UseModelCommandReturn {
10 |   isModelDialogOpen: boolean;
11 |   openModelDialog: () => void;
12 |   closeModelDialog: () => void;
13 | }
14 | 
15 | export const useModelCommand = (): UseModelCommandReturn => {
16 |   const [isModelDialogOpen, setIsModelDialogOpen] = useState(false);
17 | 
18 |   const openModelDialog = useCallback(() => {
19 |     setIsModelDialogOpen(true);
20 |   }, []);
21 | 
22 |   const closeModelDialog = useCallback(() => {
23 |     setIsModelDialogOpen(false);
24 |   }, []);
25 | 
26 |   return {
27 |     isModelDialogOpen,
28 |     openModelDialog,
29 |     closeModelDialog,
30 |   };
31 | };
```

src/ui/hooks/usePermissionsModifyTrust.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | /// <reference types="vitest/globals" />
8 | 
9 | import {
10 |   describe,
11 |   it,
12 |   expect,
13 |   vi,
14 |   beforeEach,
15 |   afterEach,
16 |   type Mock,
17 | } from 'vitest';
18 | import { renderHook, act } from '@testing-library/react';
19 | import { usePermissionsModifyTrust } from './usePermissionsModifyTrust.js';
20 | import { TrustLevel } from '../../config/trustedFolders.js';
21 | import type { LoadedSettings } from '../../config/settings.js';
22 | import type { LoadedTrustedFolders } from '../../config/trustedFolders.js';
23 | 
24 | // Hoist mocks
25 | const mockedCwd = vi.hoisted(() => vi.fn());
26 | const mockedLoadTrustedFolders = vi.hoisted(() => vi.fn());
27 | const mockedIsWorkspaceTrusted = vi.hoisted(() => vi.fn());
28 | const mockedUseSettings = vi.hoisted(() => vi.fn());
29 | 
30 | // Mock modules
31 | vi.mock('node:process', () => ({
32 |   cwd: mockedCwd,
33 | }));
34 | 
35 | vi.mock('../../config/trustedFolders.js', () => ({
36 |   loadTrustedFolders: mockedLoadTrustedFolders,
37 |   isWorkspaceTrusted: mockedIsWorkspaceTrusted,
38 |   TrustLevel: {
39 |     TRUST_FOLDER: 'TRUST_FOLDER',
40 |     TRUST_PARENT: 'TRUST_PARENT',
41 |     DO_NOT_TRUST: 'DO_NOT_TRUST',
42 |   },
43 | }));
44 | 
45 | vi.mock('../contexts/SettingsContext.js', () => ({
46 |   useSettings: mockedUseSettings,
47 | }));
48 | 
49 | describe('usePermissionsModifyTrust', () => {
50 |   let mockOnExit: Mock;
51 |   let mockAddItem: Mock;
52 | 
53 |   beforeEach(() => {
54 |     mockAddItem = vi.fn();
55 |     mockOnExit = vi.fn();
56 | 
57 |     mockedCwd.mockReturnValue('/test/dir');
58 |     mockedUseSettings.mockReturnValue({
59 |       merged: {
60 |         security: {
61 |           folderTrust: {
62 |             enabled: true,
63 |           },
64 |         },
65 |       },
66 |     } as LoadedSettings);
67 |     mockedIsWorkspaceTrusted.mockReturnValue({
68 |       isTrusted: undefined,
69 |       source: undefined,
70 |     });
71 |   });
72 | 
73 |   afterEach(() => {
74 |     vi.resetAllMocks();
75 |   });
76 | 
77 |   it('should initialize with the correct trust level', () => {
78 |     mockedLoadTrustedFolders.mockReturnValue({
79 |       user: { config: { '/test/dir': TrustLevel.TRUST_FOLDER } },
80 |     } as unknown as LoadedTrustedFolders);
81 |     mockedIsWorkspaceTrusted.mockReturnValue({
82 |       isTrusted: true,
83 |       source: 'file',
84 |     });
85 | 
86 |     const { result } = renderHook(() =>
87 |       usePermissionsModifyTrust(mockOnExit, mockAddItem),
88 |     );
89 | 
90 |     expect(result.current.currentTrustLevel).toBe(TrustLevel.TRUST_FOLDER);
91 |   });
92 | 
93 |   it('should detect inherited trust from parent', () => {
94 |     mockedLoadTrustedFolders.mockReturnValue({
95 |       user: { config: {} },
96 |       setValue: vi.fn(),
97 |     } as unknown as LoadedTrustedFolders);
98 |     mockedIsWorkspaceTrusted.mockReturnValue({
99 |       isTrusted: true,
100 |       source: 'file',
101 |     });
102 | 
103 |     const { result } = renderHook(() =>
104 |       usePermissionsModifyTrust(mockOnExit, mockAddItem),
105 |     );
106 | 
107 |     expect(result.current.isInheritedTrustFromParent).toBe(true);
108 |     expect(result.current.isInheritedTrustFromIde).toBe(false);
109 |   });
110 | 
111 |   it('should detect inherited trust from IDE', () => {
112 |     mockedLoadTrustedFolders.mockReturnValue({
113 |       user: { config: {} }, // No explicit trust
114 |     } as unknown as LoadedTrustedFolders);
115 |     mockedIsWorkspaceTrusted.mockReturnValue({
116 |       isTrusted: true,
117 |       source: 'ide',
118 |     });
119 | 
120 |     const { result } = renderHook(() =>
121 |       usePermissionsModifyTrust(mockOnExit, mockAddItem),
122 |     );
123 | 
124 |     expect(result.current.isInheritedTrustFromIde).toBe(true);
125 |     expect(result.current.isInheritedTrustFromParent).toBe(false);
126 |   });
127 | 
128 |   it('should set needsRestart but not save when trust changes', () => {
129 |     const mockSetValue = vi.fn();
130 |     mockedLoadTrustedFolders.mockReturnValue({
131 |       user: { config: {} },
132 |       setValue: mockSetValue,
133 |     } as unknown as LoadedTrustedFolders);
134 | 
135 |     mockedIsWorkspaceTrusted
136 |       .mockReturnValueOnce({ isTrusted: false, source: 'file' })
137 |       .mockReturnValueOnce({ isTrusted: true, source: 'file' });
138 | 
139 |     const { result } = renderHook(() =>
140 |       usePermissionsModifyTrust(mockOnExit, mockAddItem),
141 |     );
142 | 
143 |     act(() => {
144 |       result.current.updateTrustLevel(TrustLevel.TRUST_FOLDER);
145 |     });
146 | 
147 |     expect(result.current.needsRestart).toBe(true);
148 |     expect(mockSetValue).not.toHaveBeenCalled();
149 |   });
150 | 
151 |   it('should save immediately if trust does not change', () => {
152 |     const mockSetValue = vi.fn();
153 |     mockedLoadTrustedFolders.mockReturnValue({
154 |       user: { config: {} },
155 |       setValue: mockSetValue,
156 |     } as unknown as LoadedTrustedFolders);
157 | 
158 |     mockedIsWorkspaceTrusted.mockReturnValue({
159 |       isTrusted: true,
160 |       source: 'file',
161 |     });
162 | 
163 |     const { result } = renderHook(() =>
164 |       usePermissionsModifyTrust(mockOnExit, mockAddItem),
165 |     );
166 | 
167 |     act(() => {
168 |       result.current.updateTrustLevel(TrustLevel.TRUST_PARENT);
169 |     });
170 | 
171 |     expect(result.current.needsRestart).toBe(false);
172 |     expect(mockSetValue).toHaveBeenCalledWith(
173 |       '/test/dir',
174 |       TrustLevel.TRUST_PARENT,
175 |     );
176 |     expect(mockOnExit).toHaveBeenCalled();
177 |   });
178 | 
179 |   it('should commit the pending trust level change', () => {
180 |     const mockSetValue = vi.fn();
181 |     mockedLoadTrustedFolders.mockReturnValue({
182 |       user: { config: {} },
183 |       setValue: mockSetValue,
184 |     } as unknown as LoadedTrustedFolders);
185 | 
186 |     mockedIsWorkspaceTrusted
187 |       .mockReturnValueOnce({ isTrusted: false, source: 'file' })
188 |       .mockReturnValueOnce({ isTrusted: true, source: 'file' });
189 | 
190 |     const { result } = renderHook(() =>
191 |       usePermissionsModifyTrust(mockOnExit, mockAddItem),
192 |     );
193 | 
194 |     act(() => {
195 |       result.current.updateTrustLevel(TrustLevel.TRUST_FOLDER);
196 |     });
197 | 
198 |     expect(result.current.needsRestart).toBe(true);
199 | 
200 |     act(() => {
201 |       result.current.commitTrustLevelChange();
202 |     });
203 | 
204 |     expect(mockSetValue).toHaveBeenCalledWith(
205 |       '/test/dir',
206 |       TrustLevel.TRUST_FOLDER,
207 |     );
208 |   });
209 | 
210 |   it('should add warning when setting DO_NOT_TRUST but still trusted by parent', () => {
211 |     mockedLoadTrustedFolders.mockReturnValue({
212 |       user: { config: {} },
213 |       setValue: vi.fn(),
214 |     } as unknown as LoadedTrustedFolders);
215 |     mockedIsWorkspaceTrusted.mockReturnValue({
216 |       isTrusted: true,
217 |       source: 'file',
218 |     });
219 | 
220 |     const { result } = renderHook(() =>
221 |       usePermissionsModifyTrust(mockOnExit, mockAddItem),
222 |     );
223 | 
224 |     act(() => {
225 |       result.current.updateTrustLevel(TrustLevel.DO_NOT_TRUST);
226 |     });
227 | 
228 |     expect(mockAddItem).toHaveBeenCalledWith(
229 |       {
230 |         type: 'warning',
231 |         text: 'Note: This folder is still trusted because a parent folder is trusted.',
232 |       },
233 |       expect.any(Number),
234 |     );
235 |   });
236 | 
237 |   it('should add warning when setting DO_NOT_TRUST but still trusted by IDE', () => {
238 |     mockedLoadTrustedFolders.mockReturnValue({
239 |       user: { config: {} },
240 |       setValue: vi.fn(),
241 |     } as unknown as LoadedTrustedFolders);
242 |     mockedIsWorkspaceTrusted.mockReturnValue({
243 |       isTrusted: true,
244 |       source: 'ide',
245 |     });
246 | 
247 |     const { result } = renderHook(() =>
248 |       usePermissionsModifyTrust(mockOnExit, mockAddItem),
249 |     );
250 | 
251 |     act(() => {
252 |       result.current.updateTrustLevel(TrustLevel.DO_NOT_TRUST);
253 |     });
254 | 
255 |     expect(mockAddItem).toHaveBeenCalledWith(
256 |       {
257 |         type: 'warning',
258 |         text: 'Note: This folder is still trusted because the connected IDE workspace is trusted.',
259 |       },
260 |       expect.any(Number),
261 |     );
262 |   });
263 | });
```

src/ui/hooks/usePermissionsModifyTrust.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { useState, useCallback } from 'react';
8 | import * as process from 'node:process';
9 | import {
10 |   loadTrustedFolders,
11 |   TrustLevel,
12 |   isWorkspaceTrusted,
13 | } from '../../config/trustedFolders.js';
14 | import { useSettings } from '../contexts/SettingsContext.js';
15 | 
16 | import { MessageType } from '../types.js';
17 | import { type UseHistoryManagerReturn } from './useHistoryManager.js';
18 | import type { LoadedSettings } from '../../config/settings.js';
19 | 
20 | interface TrustState {
21 |   currentTrustLevel: TrustLevel | undefined;
22 |   isInheritedTrustFromParent: boolean;
23 |   isInheritedTrustFromIde: boolean;
24 | }
25 | 
26 | function getInitialTrustState(
27 |   settings: LoadedSettings,
28 |   cwd: string,
29 | ): TrustState {
30 |   const folders = loadTrustedFolders();
31 |   const explicitTrustLevel = folders.user.config[cwd];
32 |   const { isTrusted, source } = isWorkspaceTrusted(settings.merged);
33 | 
34 |   const isInheritedTrust =
35 |     isTrusted &&
36 |     (!explicitTrustLevel || explicitTrustLevel === TrustLevel.DO_NOT_TRUST);
37 | 
38 |   return {
39 |     currentTrustLevel: explicitTrustLevel,
40 |     isInheritedTrustFromParent: !!(source === 'file' && isInheritedTrust),
41 |     isInheritedTrustFromIde: !!(source === 'ide' && isInheritedTrust),
42 |   };
43 | }
44 | 
45 | export const usePermissionsModifyTrust = (
46 |   onExit: () => void,
47 |   addItem: UseHistoryManagerReturn['addItem'],
48 | ) => {
49 |   const settings = useSettings();
50 |   const cwd = process.cwd();
51 | 
52 |   const [initialState] = useState(() => getInitialTrustState(settings, cwd));
53 | 
54 |   const [currentTrustLevel] = useState<TrustLevel | undefined>(
55 |     initialState.currentTrustLevel,
56 |   );
57 |   const [pendingTrustLevel, setPendingTrustLevel] = useState<
58 |     TrustLevel | undefined
59 |   >();
60 |   const [isInheritedTrustFromParent] = useState(
61 |     initialState.isInheritedTrustFromParent,
62 |   );
63 |   const [isInheritedTrustFromIde] = useState(
64 |     initialState.isInheritedTrustFromIde,
65 |   );
66 |   const [needsRestart, setNeedsRestart] = useState(false);
67 | 
68 |   const isFolderTrustEnabled = !!settings.merged.security?.folderTrust?.enabled;
69 | 
70 |   const updateTrustLevel = useCallback(
71 |     (trustLevel: TrustLevel) => {
72 |       const wasTrusted = isWorkspaceTrusted(settings.merged).isTrusted;
73 | 
74 |       // Create a temporary config to check the new trust status without writing
75 |       const currentConfig = loadTrustedFolders().user.config;
76 |       const newConfig = { ...currentConfig, [cwd]: trustLevel };
77 | 
78 |       const { isTrusted, source } = isWorkspaceTrusted(
79 |         settings.merged,
80 |         newConfig,
81 |       );
82 | 
83 |       if (trustLevel === TrustLevel.DO_NOT_TRUST && isTrusted) {
84 |         let message =
85 |           'Note: This folder is still trusted because the connected IDE workspace is trusted.';
86 |         if (source === 'file') {
87 |           message =
88 |             'Note: This folder is still trusted because a parent folder is trusted.';
89 |         }
90 |         addItem(
91 |           {
92 |             type: MessageType.WARNING,
93 |             text: message,
94 |           },
95 |           Date.now(),
96 |         );
97 |       }
98 | 
99 |       if (wasTrusted !== isTrusted) {
100 |         setPendingTrustLevel(trustLevel);
101 |         setNeedsRestart(true);
102 |       } else {
103 |         const folders = loadTrustedFolders();
104 |         folders.setValue(cwd, trustLevel);
105 |         onExit();
106 |       }
107 |     },
108 |     [cwd, settings.merged, onExit, addItem],
109 |   );
110 | 
111 |   const commitTrustLevelChange = useCallback(() => {
112 |     if (pendingTrustLevel) {
113 |       const folders = loadTrustedFolders();
114 |       folders.setValue(cwd, pendingTrustLevel);
115 |     }
116 |   }, [cwd, pendingTrustLevel]);
117 | 
118 |   return {
119 |     cwd,
120 |     currentTrustLevel,
121 |     isInheritedTrustFromParent,
122 |     isInheritedTrustFromIde,
123 |     needsRestart,
124 |     updateTrustLevel,
125 |     commitTrustLevelChange,
126 |     isFolderTrustEnabled,
127 |   };
128 | };
```

src/ui/hooks/usePhraseCycler.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
8 | import { renderHook, act } from '@testing-library/react';
9 | import {
10 |   usePhraseCycler,
11 |   WITTY_LOADING_PHRASES,
12 |   PHRASE_CHANGE_INTERVAL_MS,
13 | } from './usePhraseCycler.js';
14 | 
15 | describe('usePhraseCycler', () => {
16 |   beforeEach(() => {
17 |     vi.useFakeTimers();
18 |   });
19 | 
20 |   afterEach(() => {
21 |     vi.restoreAllMocks();
22 |   });
23 | 
24 |   it('should initialize with a witty phrase when not active and not waiting', () => {
25 |     const { result } = renderHook(() => usePhraseCycler(false, false));
26 |     expect(WITTY_LOADING_PHRASES).toContain(result.current);
27 |   });
28 | 
29 |   it('should show "Waiting for user confirmation..." when isWaiting is true', () => {
30 |     const { result, rerender } = renderHook(
31 |       ({ isActive, isWaiting }) => usePhraseCycler(isActive, isWaiting),
32 |       { initialProps: { isActive: true, isWaiting: false } },
33 |     );
34 |     rerender({ isActive: true, isWaiting: true });
35 |     expect(result.current).toBe('Waiting for user confirmation...');
36 |   });
37 | 
38 |   it('should not cycle phrases if isActive is false and not waiting', () => {
39 |     const { result } = renderHook(() => usePhraseCycler(false, false));
40 |     const initialPhrase = result.current;
41 |     act(() => {
42 |       vi.advanceTimersByTime(PHRASE_CHANGE_INTERVAL_MS * 2);
43 |     });
44 |     expect(result.current).toBe(initialPhrase);
45 |   });
46 | 
47 |   it('should cycle through witty phrases when isActive is true and not waiting', () => {
48 |     const { result } = renderHook(() => usePhraseCycler(true, false));
49 |     // Initial phrase should be one of the witty phrases
50 |     expect(WITTY_LOADING_PHRASES).toContain(result.current);
51 |     const _initialPhrase = result.current;
52 | 
53 |     act(() => {
54 |       vi.advanceTimersByTime(PHRASE_CHANGE_INTERVAL_MS);
55 |     });
56 |     // Phrase should change and be one of the witty phrases
57 |     expect(WITTY_LOADING_PHRASES).toContain(result.current);
58 | 
59 |     const _secondPhrase = result.current;
60 |     act(() => {
61 |       vi.advanceTimersByTime(PHRASE_CHANGE_INTERVAL_MS);
62 |     });
63 |     expect(WITTY_LOADING_PHRASES).toContain(result.current);
64 |   });
65 | 
66 |   it('should reset to a witty phrase when isActive becomes true after being false (and not waiting)', () => {
67 |     // Ensure there are at least two phrases for this test to be meaningful.
68 |     if (WITTY_LOADING_PHRASES.length < 2) {
69 |       return;
70 |     }
71 | 
72 |     // Mock Math.random to make the test deterministic.
73 |     let callCount = 0;
74 |     vi.spyOn(Math, 'random').mockImplementation(() => {
75 |       // Cycle through 0, 1, 0, 1, ...
76 |       const val = callCount % 2;
77 |       callCount++;
78 |       return val / WITTY_LOADING_PHRASES.length;
79 |     });
80 | 
81 |     const { result, rerender } = renderHook(
82 |       ({ isActive, isWaiting }) => usePhraseCycler(isActive, isWaiting),
83 |       { initialProps: { isActive: false, isWaiting: false } },
84 |     );
85 | 
86 |     // Activate
87 |     rerender({ isActive: true, isWaiting: false });
88 |     const firstActivePhrase = result.current;
89 |     expect(WITTY_LOADING_PHRASES).toContain(firstActivePhrase);
90 |     // With our mock, this should be the first phrase.
91 |     expect(firstActivePhrase).toBe(WITTY_LOADING_PHRASES[0]);
92 | 
93 |     act(() => {
94 |       vi.advanceTimersByTime(PHRASE_CHANGE_INTERVAL_MS);
95 |     });
96 | 
97 |     // Phrase should change to the second phrase.
98 |     expect(result.current).not.toBe(firstActivePhrase);
99 |     expect(result.current).toBe(WITTY_LOADING_PHRASES[1]);
100 | 
101 |     // Set to inactive - should reset to the default initial phrase
102 |     rerender({ isActive: false, isWaiting: false });
103 |     expect(WITTY_LOADING_PHRASES).toContain(result.current);
104 | 
105 |     // Set back to active - should pick a random witty phrase (which our mock controls)
106 |     act(() => {
107 |       rerender({ isActive: true, isWaiting: false });
108 |     });
109 |     // The random mock will now return 0, so it should be the first phrase again.
110 |     expect(result.current).toBe(WITTY_LOADING_PHRASES[0]);
111 |   });
112 | 
113 |   it('should clear phrase interval on unmount when active', () => {
114 |     const { unmount } = renderHook(() => usePhraseCycler(true, false));
115 |     const clearIntervalSpy = vi.spyOn(global, 'clearInterval');
116 |     unmount();
117 |     expect(clearIntervalSpy).toHaveBeenCalledOnce();
118 |   });
119 | 
120 |   it('should use custom phrases when provided', () => {
121 |     const customPhrases = ['Custom Phrase 1', 'Custom Phrase 2'];
122 |     let callCount = 0;
123 |     vi.spyOn(Math, 'random').mockImplementation(() => {
124 |       const val = callCount % 2;
125 |       callCount++;
126 |       return val / customPhrases.length;
127 |     });
128 | 
129 |     const { result, rerender } = renderHook(
130 |       ({ isActive, isWaiting, customPhrases: phrases }) =>
131 |         usePhraseCycler(isActive, isWaiting, phrases),
132 |       {
133 |         initialProps: {
134 |           isActive: true,
135 |           isWaiting: false,
136 |           customPhrases,
137 |         },
138 |       },
139 |     );
140 | 
141 |     expect(result.current).toBe(customPhrases[0]);
142 | 
143 |     act(() => {
144 |       vi.advanceTimersByTime(PHRASE_CHANGE_INTERVAL_MS);
145 |     });
146 | 
147 |     expect(result.current).toBe(customPhrases[1]);
148 | 
149 |     rerender({ isActive: true, isWaiting: false, customPhrases: undefined });
150 | 
151 |     expect(WITTY_LOADING_PHRASES).toContain(result.current);
152 |   });
153 | 
154 |   it('should fall back to witty phrases if custom phrases are an empty array', () => {
155 |     const { result } = renderHook(
156 |       ({ isActive, isWaiting, customPhrases: phrases }) =>
157 |         usePhraseCycler(isActive, isWaiting, phrases),
158 |       {
159 |         initialProps: {
160 |           isActive: true,
161 |           isWaiting: false,
162 |           customPhrases: [],
163 |         },
164 |       },
165 |     );
166 | 
167 |     expect(WITTY_LOADING_PHRASES).toContain(result.current);
168 |   });
169 | 
170 |   it('should reset to a witty phrase when transitioning from waiting to active', () => {
171 |     const { result, rerender } = renderHook(
172 |       ({ isActive, isWaiting }) => usePhraseCycler(isActive, isWaiting),
173 |       { initialProps: { isActive: true, isWaiting: false } },
174 |     );
175 | 
176 |     const _initialPhrase = result.current;
177 |     expect(WITTY_LOADING_PHRASES).toContain(_initialPhrase);
178 | 
179 |     // Cycle to a different phrase (potentially)
180 |     act(() => {
181 |       vi.advanceTimersByTime(PHRASE_CHANGE_INTERVAL_MS);
182 |     });
183 |     if (WITTY_LOADING_PHRASES.length > 1) {
184 |       // This check is probabilistic with random selection
185 |     }
186 |     expect(WITTY_LOADING_PHRASES).toContain(result.current);
187 | 
188 |     // Go to waiting state
189 |     rerender({ isActive: false, isWaiting: true });
190 |     expect(result.current).toBe('Waiting for user confirmation...');
191 | 
192 |     // Go back to active cycling - should pick a random witty phrase
193 |     rerender({ isActive: true, isWaiting: false });
194 |     expect(WITTY_LOADING_PHRASES).toContain(result.current);
195 |   });
196 | });
```

src/ui/hooks/usePhraseCycler.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { useState, useEffect, useRef } from 'react';
8 | 
9 | export const WITTY_LOADING_PHRASES = [
10 |   "I'm Feeling Lucky",
11 |   'Shipping awesomeness... ',
12 |   'Painting the serifs back on...',
13 |   'Navigating the slime mold...',
14 |   'Consulting the digital spirits...',
15 |   'Reticulating splines...',
16 |   'Warming up the AI hamsters...',
17 |   'Asking the magic conch shell...',
18 |   'Generating witty retort...',
19 |   'Polishing the algorithms...',
20 |   "Don't rush perfection (or my code)...",
21 |   'Brewing fresh bytes...',
22 |   'Counting electrons...',
23 |   'Engaging cognitive processors...',
24 |   'Checking for syntax errors in the universe...',
25 |   'One moment, optimizing humor...',
26 |   'Shuffling punchlines...',
27 |   'Untangling neural nets...',
28 |   'Compiling brilliance...',
29 |   'Loading wit.exe...',
30 |   'Summoning the cloud of wisdom...',
31 |   'Preparing a witty response...',
32 |   "Just a sec, I'm debugging reality...",
33 |   'Confuzzling the options...',
34 |   'Tuning the cosmic frequencies...',
35 |   'Crafting a response worthy of your patience...',
36 |   'Compiling the 1s and 0s...',
37 |   'Resolving dependencies... and existential crises...',
38 |   'Defragmenting memories... both RAM and personal...',
39 |   'Rebooting the humor module...',
40 |   'Caching the essentials (mostly cat memes)...',
41 |   'Optimizing for ludicrous speed',
42 |   "Swapping bits... don't tell the bytes...",
43 |   'Garbage collecting... be right back...',
44 |   'Assembling the interwebs...',
45 |   'Converting coffee into code...',
46 |   'Updating the syntax for reality...',
47 |   'Rewiring the synapses...',
48 |   'Looking for a misplaced semicolon...',
49 |   "Greasin' the cogs of the machine...",
50 |   'Pre-heating the servers...',
51 |   'Calibrating the flux capacitor...',
52 |   'Engaging the improbability drive...',
53 |   'Channeling the Force...',
54 |   'Aligning the stars for optimal response...',
55 |   'So say we all...',
56 |   'Loading the next great idea...',
57 |   "Just a moment, I'm in the zone...",
58 |   'Preparing to dazzle you with brilliance...',
59 |   "Just a tick, I'm polishing my wit...",
60 |   "Hold tight, I'm crafting a masterpiece...",
61 |   "Just a jiffy, I'm debugging the universe...",
62 |   "Just a moment, I'm aligning the pixels...",
63 |   "Just a sec, I'm optimizing the humor...",
64 |   "Just a moment, I'm tuning the algorithms...",
65 |   'Warp speed engaged...',
66 |   'Mining for more Dilithium crystals...',
67 |   "Don't panic...",
68 |   'Following the white rabbit...',
69 |   'The truth is in here... somewhere...',
70 |   'Blowing on the cartridge...',
71 |   'Loading... Do a barrel roll!',
72 |   'Waiting for the respawn...',
73 |   'Finishing the Kessel Run in less than 12 parsecs...',
74 |   "The cake is not a lie, it's just still loading...",
75 |   'Fiddling with the character creation screen...',
76 |   "Just a moment, I'm finding the right meme...",
77 |   "Pressing 'A' to continue...",
78 |   'Herding digital cats...',
79 |   'Polishing the pixels...',
80 |   'Finding a suitable loading screen pun...',
81 |   'Distracting you with this witty phrase...',
82 |   'Almost there... probably...',
83 |   'Our hamsters are working as fast as they can...',
84 |   'Giving Cloudy a pat on the head...',
85 |   'Petting the cat...',
86 |   'Rickrolling my boss...',
87 |   'Never gonna give you up, never gonna let you down...',
88 |   'Slapping the bass...',
89 |   'Tasting the snozberries...',
90 |   "I'm going the distance, I'm going for speed...",
91 |   'Is this the real life? Is this just fantasy?...',
92 |   "I've got a good feeling about this...",
93 |   'Poking the bear...',
94 |   'Doing research on the latest memes...',
95 |   'Figuring out how to make this more witty...',
96 |   'Hmmm... let me think...',
97 |   'What do you call a fish with no eyes? A fsh...',
98 |   'Why did the computer go to therapy? It had too many bytes...',
99 |   "Why don't programmers like nature? It has too many bugs...",
100 |   'Why do programmers prefer dark mode? Because light attracts bugs...',
101 |   'Why did the developer go broke? Because they used up all their cache...',
102 |   "What can you do with a broken pencil? Nothing, it's pointless...",
103 |   'Applying percussive maintenance...',
104 |   'Searching for the correct USB orientation...',
105 |   'Ensuring the magic smoke stays inside the wires...',
106 |   'Rewriting in Rust for no particular reason...',
107 |   'Trying to exit Vim...',
108 |   'Spinning up the hamster wheel...',
109 |   "That's not a bug, it's an undocumented feature...",
110 |   'Engage.',
111 |   "I'll be back... with an answer.",
112 |   'My other process is a TARDIS...',
113 |   'Communing with the machine spirit...',
114 |   'Letting the thoughts marinate...',
115 |   'Just remembered where I put my keys...',
116 |   'Pondering the orb...',
117 |   "I've seen things you people wouldn't believe... like a user who reads loading messages.",
118 |   'Initiating thoughtful gaze...',
119 |   "What's a computer's favorite snack? Microchips.",
120 |   "Why do Java developers wear glasses? Because they don't C#.",
121 |   'Charging the laser... pew pew!',
122 |   'Dividing by zero... just kidding!',
123 |   'Looking for an adult superviso... I mean, processing.',
124 |   'Making it go beep boop.',
125 |   'Buffering... because even AIs need a moment.',
126 |   'Entangling quantum particles for a faster response...',
127 |   'Polishing the chrome... on the algorithms.',
128 |   'Are you not entertained? (Working on it!)',
129 |   'Summoning the code gremlins... to help, of course.',
130 |   'Just waiting for the dial-up tone to finish...',
131 |   'Recalibrating the humor-o-meter.',
132 |   'My other loading screen is even funnier.',
133 |   "Pretty sure there's a cat walking on the keyboard somewhere...",
134 |   'Enhancing... Enhancing... Still loading.',
135 |   "It's not a bug, it's a feature... of this loading screen.",
136 |   'Have you tried turning it off and on again? (The loading screen, not me.)',
137 |   'Constructing additional pylons...',
138 |   'New line? That’s Ctrl+J.',
139 |   'Releasing the HypnoDrones...',
140 | ];
141 | 
142 | export const PHRASE_CHANGE_INTERVAL_MS = 15000;
143 | 
144 | /**
145 |  * Custom hook to manage cycling through loading phrases.
146 |  * @param isActive Whether the phrase cycling should be active.
147 |  * @param isWaiting Whether to show a specific waiting phrase.
148 |  * @returns The current loading phrase.
149 |  */
150 | export const usePhraseCycler = (
151 |   isActive: boolean,
152 |   isWaiting: boolean,
153 |   customPhrases?: string[],
154 | ) => {
155 |   const loadingPhrases =
156 |     customPhrases && customPhrases.length > 0
157 |       ? customPhrases
158 |       : WITTY_LOADING_PHRASES;
159 | 
160 |   const [currentLoadingPhrase, setCurrentLoadingPhrase] = useState(
161 |     loadingPhrases[0],
162 |   );
163 |   const phraseIntervalRef = useRef<NodeJS.Timeout | null>(null);
164 | 
165 |   useEffect(() => {
166 |     if (isWaiting) {
167 |       setCurrentLoadingPhrase('Waiting for user confirmation...');
168 |       if (phraseIntervalRef.current) {
169 |         clearInterval(phraseIntervalRef.current);
170 |         phraseIntervalRef.current = null;
171 |       }
172 |     } else if (isActive) {
173 |       if (phraseIntervalRef.current) {
174 |         clearInterval(phraseIntervalRef.current);
175 |       }
176 |       // Select an initial random phrase
177 |       const initialRandomIndex = Math.floor(
178 |         Math.random() * loadingPhrases.length,
179 |       );
180 |       setCurrentLoadingPhrase(loadingPhrases[initialRandomIndex]);
181 | 
182 |       phraseIntervalRef.current = setInterval(() => {
183 |         // Select a new random phrase
184 |         const randomIndex = Math.floor(Math.random() * loadingPhrases.length);
185 |         setCurrentLoadingPhrase(loadingPhrases[randomIndex]);
186 |       }, PHRASE_CHANGE_INTERVAL_MS);
187 |     } else {
188 |       // Idle or other states, clear the phrase interval
189 |       // and reset to the first phrase for next active state.
190 |       if (phraseIntervalRef.current) {
191 |         clearInterval(phraseIntervalRef.current);
192 |         phraseIntervalRef.current = null;
193 |       }
194 |       setCurrentLoadingPhrase(loadingPhrases[0]);
195 |     }
196 | 
197 |     return () => {
198 |       if (phraseIntervalRef.current) {
199 |         clearInterval(phraseIntervalRef.current);
200 |         phraseIntervalRef.current = null;
201 |       }
202 |     };
203 |   }, [isActive, isWaiting, loadingPhrases]);
204 | 
205 |   return currentLoadingPhrase;
206 | };
```

src/ui/hooks/usePrivacySettings.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect, beforeEach, vi } from 'vitest';
8 | import { renderHook, waitFor } from '@testing-library/react';
9 | import type {
10 |   Config,
11 |   CodeAssistServer,
12 |   LoadCodeAssistResponse,
13 | } from '@google/gemini-cli-core';
14 | import { UserTierId, getCodeAssistServer } from '@google/gemini-cli-core';
15 | import { usePrivacySettings } from './usePrivacySettings.js';
16 | 
17 | // Mock the dependencies
18 | vi.mock('@google/gemini-cli-core', async (importOriginal) => {
19 |   const actual =
20 |     await importOriginal<typeof import('@google/gemini-cli-core')>();
21 |   return {
22 |     ...actual,
23 |     getCodeAssistServer: vi.fn(),
24 |   };
25 | });
26 | 
27 | describe('usePrivacySettings', () => {
28 |   const mockConfig = {} as unknown as Config;
29 | 
30 |   beforeEach(() => {
31 |     vi.clearAllMocks();
32 |   });
33 | 
34 |   it('should throw error when content generator is not a CodeAssistServer', async () => {
35 |     vi.mocked(getCodeAssistServer).mockReturnValue(undefined);
36 | 
37 |     const { result } = renderHook(() => usePrivacySettings(mockConfig));
38 | 
39 |     await waitFor(() => {
40 |       expect(result.current.privacyState.isLoading).toBe(false);
41 |     });
42 | 
43 |     expect(result.current.privacyState.error).toBe('Oauth not being used');
44 |   });
45 | 
46 |   it('should handle paid tier users correctly', async () => {
47 |     // Mock paid tier response
48 |     vi.mocked(getCodeAssistServer).mockReturnValue({
49 |       projectId: 'test-project-id',
50 |       loadCodeAssist: () =>
51 |         ({
52 |           currentTier: { id: UserTierId.STANDARD },
53 |         }) as unknown as LoadCodeAssistResponse,
54 |     } as unknown as CodeAssistServer);
55 | 
56 |     const { result } = renderHook(() => usePrivacySettings(mockConfig));
57 | 
58 |     await waitFor(() => {
59 |       expect(result.current.privacyState.isLoading).toBe(false);
60 |     });
61 | 
62 |     expect(result.current.privacyState.error).toBeUndefined();
63 |     expect(result.current.privacyState.isFreeTier).toBe(false);
64 |     expect(result.current.privacyState.dataCollectionOptIn).toBeUndefined();
65 |   });
66 | 
67 |   it('should throw error when CodeAssistServer has no projectId', async () => {
68 |     vi.mocked(getCodeAssistServer).mockReturnValue({
69 |       loadCodeAssist: () =>
70 |         ({
71 |           currentTier: { id: UserTierId.FREE },
72 |         }) as unknown as LoadCodeAssistResponse,
73 |     } as unknown as CodeAssistServer);
74 | 
75 |     const { result } = renderHook(() => usePrivacySettings(mockConfig));
76 | 
77 |     await waitFor(() => {
78 |       expect(result.current.privacyState.isLoading).toBe(false);
79 |     });
80 | 
81 |     expect(result.current.privacyState.error).toBe(
82 |       'CodeAssist server is missing a project ID',
83 |     );
84 |   });
85 | 
86 |   it('should update data collection opt-in setting', async () => {
87 |     const mockCodeAssistServer = {
88 |       projectId: 'test-project-id',
89 |       getCodeAssistGlobalUserSetting: vi.fn().mockResolvedValue({
90 |         freeTierDataCollectionOptin: true,
91 |       }),
92 |       setCodeAssistGlobalUserSetting: vi.fn().mockResolvedValue({
93 |         freeTierDataCollectionOptin: false,
94 |       }),
95 |       loadCodeAssist: () =>
96 |         ({
97 |           currentTier: { id: UserTierId.FREE },
98 |         }) as unknown as LoadCodeAssistResponse,
99 |     } as unknown as CodeAssistServer;
100 |     vi.mocked(getCodeAssistServer).mockReturnValue(mockCodeAssistServer);
101 | 
102 |     const { result } = renderHook(() => usePrivacySettings(mockConfig));
103 | 
104 |     // Wait for initial load
105 |     await waitFor(() => {
106 |       expect(result.current.privacyState.isLoading).toBe(false);
107 |     });
108 | 
109 |     // Update the setting
110 |     await result.current.updateDataCollectionOptIn(false);
111 | 
112 |     // Wait for update to complete
113 |     await waitFor(() => {
114 |       expect(result.current.privacyState.dataCollectionOptIn).toBe(false);
115 |     });
116 | 
117 |     expect(
118 |       mockCodeAssistServer.setCodeAssistGlobalUserSetting,
119 |     ).toHaveBeenCalledWith({
120 |       cloudaicompanionProject: 'test-project-id',
121 |       freeTierDataCollectionOptin: false,
122 |     });
123 |   });
124 | });
```

src/ui/hooks/usePrivacySettings.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { useState, useEffect, useCallback } from 'react';
8 | import {
9 |   type Config,
10 |   type CodeAssistServer,
11 |   UserTierId,
12 |   getCodeAssistServer,
13 | } from '@google/gemini-cli-core';
14 | 
15 | export interface PrivacyState {
16 |   isLoading: boolean;
17 |   error?: string;
18 |   isFreeTier?: boolean;
19 |   dataCollectionOptIn?: boolean;
20 | }
21 | 
22 | export const usePrivacySettings = (config: Config) => {
23 |   const [privacyState, setPrivacyState] = useState<PrivacyState>({
24 |     isLoading: true,
25 |   });
26 | 
27 |   useEffect(() => {
28 |     const fetchInitialState = async () => {
29 |       setPrivacyState({
30 |         isLoading: true,
31 |       });
32 |       try {
33 |         const server = getCodeAssistServerOrFail(config);
34 |         const tier = await getTier(server);
35 |         if (tier !== UserTierId.FREE) {
36 |           // We don't need to fetch opt-out info since non-free tier
37 |           // data gathering is already worked out some other way.
38 |           setPrivacyState({
39 |             isLoading: false,
40 |             isFreeTier: false,
41 |           });
42 |           return;
43 |         }
44 | 
45 |         const optIn = await getRemoteDataCollectionOptIn(server);
46 |         setPrivacyState({
47 |           isLoading: false,
48 |           isFreeTier: true,
49 |           dataCollectionOptIn: optIn,
50 |         });
51 |       } catch (e) {
52 |         setPrivacyState({
53 |           isLoading: false,
54 |           error: e instanceof Error ? e.message : String(e),
55 |         });
56 |       }
57 |     };
58 |     fetchInitialState();
59 |   }, [config]);
60 | 
61 |   const updateDataCollectionOptIn = useCallback(
62 |     async (optIn: boolean) => {
63 |       try {
64 |         const server = getCodeAssistServerOrFail(config);
65 |         const updatedOptIn = await setRemoteDataCollectionOptIn(server, optIn);
66 |         setPrivacyState({
67 |           isLoading: false,
68 |           isFreeTier: true,
69 |           dataCollectionOptIn: updatedOptIn,
70 |         });
71 |       } catch (e) {
72 |         setPrivacyState({
73 |           isLoading: false,
74 |           error: e instanceof Error ? e.message : String(e),
75 |         });
76 |       }
77 |     },
78 |     [config],
79 |   );
80 | 
81 |   return {
82 |     privacyState,
83 |     updateDataCollectionOptIn,
84 |   };
85 | };
86 | 
87 | function getCodeAssistServerOrFail(config: Config): CodeAssistServer {
88 |   const server = getCodeAssistServer(config);
89 |   if (server === undefined) {
90 |     throw new Error('Oauth not being used');
91 |   } else if (server.projectId === undefined) {
92 |     throw new Error('CodeAssist server is missing a project ID');
93 |   }
94 |   return server;
95 | }
96 | 
97 | async function getTier(server: CodeAssistServer): Promise<UserTierId> {
98 |   const loadRes = await server.loadCodeAssist({
99 |     cloudaicompanionProject: server.projectId,
100 |     metadata: {
101 |       ideType: 'IDE_UNSPECIFIED',
102 |       platform: 'PLATFORM_UNSPECIFIED',
103 |       pluginType: 'GEMINI',
104 |       duetProject: server.projectId,
105 |     },
106 |   });
107 |   if (!loadRes.currentTier) {
108 |     throw new Error('User does not have a current tier');
109 |   }
110 |   return loadRes.currentTier.id;
111 | }
112 | 
113 | async function getRemoteDataCollectionOptIn(
114 |   server: CodeAssistServer,
115 | ): Promise<boolean> {
116 |   try {
117 |     const resp = await server.getCodeAssistGlobalUserSetting();
118 |     return resp.freeTierDataCollectionOptin;
119 |   } catch (error: unknown) {
120 |     if (error && typeof error === 'object' && 'response' in error) {
121 |       const gaxiosError = error as {
122 |         response?: {
123 |           status?: unknown;
124 |         };
125 |       };
126 |       if (gaxiosError.response?.status === 404) {
127 |         return true;
128 |       }
129 |     }
130 |     throw error;
131 |   }
132 | }
133 | 
134 | async function setRemoteDataCollectionOptIn(
135 |   server: CodeAssistServer,
136 |   optIn: boolean,
137 | ): Promise<boolean> {
138 |   const resp = await server.setCodeAssistGlobalUserSetting({
139 |     cloudaicompanionProject: server.projectId,
140 |     freeTierDataCollectionOptin: optIn,
141 |   });
142 |   return resp.freeTierDataCollectionOptin;
143 | }
```

src/ui/hooks/usePromptCompletion.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { useState, useCallback, useRef, useEffect, useMemo } from 'react';
8 | import type { Config } from '@google/gemini-cli-core';
9 | import {
10 |   DEFAULT_GEMINI_FLASH_LITE_MODEL,
11 |   getResponseText,
12 | } from '@google/gemini-cli-core';
13 | import type { Content, GenerateContentConfig } from '@google/genai';
14 | import type { TextBuffer } from '../components/shared/text-buffer.js';
15 | import { isSlashCommand } from '../utils/commandUtils.js';
16 | 
17 | export const PROMPT_COMPLETION_MIN_LENGTH = 5;
18 | export const PROMPT_COMPLETION_DEBOUNCE_MS = 250;
19 | 
20 | export interface PromptCompletion {
21 |   text: string;
22 |   isLoading: boolean;
23 |   isActive: boolean;
24 |   accept: () => void;
25 |   clear: () => void;
26 |   markSelected: (selectedText: string) => void;
27 | }
28 | 
29 | export interface UsePromptCompletionOptions {
30 |   buffer: TextBuffer;
31 |   config?: Config;
32 |   enabled: boolean;
33 | }
34 | 
35 | export function usePromptCompletion({
36 |   buffer,
37 |   config,
38 |   enabled,
39 | }: UsePromptCompletionOptions): PromptCompletion {
40 |   const [ghostText, setGhostText] = useState<string>('');
41 |   const [isLoadingGhostText, setIsLoadingGhostText] = useState<boolean>(false);
42 |   const abortControllerRef = useRef<AbortController | null>(null);
43 |   const [justSelectedSuggestion, setJustSelectedSuggestion] =
44 |     useState<boolean>(false);
45 |   const lastSelectedTextRef = useRef<string>('');
46 |   const lastRequestedTextRef = useRef<string>('');
47 | 
48 |   const isPromptCompletionEnabled =
49 |     enabled && (config?.getEnablePromptCompletion() ?? false);
50 | 
51 |   const clearGhostText = useCallback(() => {
52 |     setGhostText('');
53 |     setIsLoadingGhostText(false);
54 |   }, []);
55 | 
56 |   const acceptGhostText = useCallback(() => {
57 |     if (ghostText && ghostText.length > buffer.text.length) {
58 |       buffer.setText(ghostText);
59 |       setGhostText('');
60 |       setJustSelectedSuggestion(true);
61 |       lastSelectedTextRef.current = ghostText;
62 |     }
63 |   }, [ghostText, buffer]);
64 | 
65 |   const markSuggestionSelected = useCallback((selectedText: string) => {
66 |     setJustSelectedSuggestion(true);
67 |     lastSelectedTextRef.current = selectedText;
68 |   }, []);
69 | 
70 |   const generatePromptSuggestions = useCallback(async () => {
71 |     const trimmedText = buffer.text.trim();
72 |     const geminiClient = config?.getGeminiClient();
73 | 
74 |     if (trimmedText === lastRequestedTextRef.current) {
75 |       return;
76 |     }
77 | 
78 |     if (abortControllerRef.current) {
79 |       abortControllerRef.current.abort();
80 |     }
81 | 
82 |     if (
83 |       trimmedText.length < PROMPT_COMPLETION_MIN_LENGTH ||
84 |       !geminiClient ||
85 |       isSlashCommand(trimmedText) ||
86 |       trimmedText.includes('@') ||
87 |       !isPromptCompletionEnabled
88 |     ) {
89 |       clearGhostText();
90 |       lastRequestedTextRef.current = '';
91 |       return;
92 |     }
93 | 
94 |     lastRequestedTextRef.current = trimmedText;
95 |     setIsLoadingGhostText(true);
96 | 
97 |     abortControllerRef.current = new AbortController();
98 |     const signal = abortControllerRef.current.signal;
99 | 
100 |     try {
101 |       const contents: Content[] = [
102 |         {
103 |           role: 'user',
104 |           parts: [
105 |             {
106 |               text: `You are a professional prompt engineering assistant. Complete the user's partial prompt with expert precision and clarity. User's input: "${trimmedText}" Continue this prompt by adding specific, actionable details that align with the user's intent. Focus on: clear, precise language; structured requirements; professional terminology; measurable outcomes. Length Guidelines: Keep suggestions concise (ideally 10-20 characters); prioritize brevity while maintaining clarity; use essential keywords only; avoid redundant phrases. Start your response with the exact user text ("${trimmedText}") followed by your completion. Provide practical, implementation-focused suggestions rather than creative interpretations. Format: Plain text only. Single completion. Match the user's language. Emphasize conciseness over elaboration.`,
107 |             },
108 |           ],
109 |         },
110 |       ];
111 | 
112 |       const generationConfig: GenerateContentConfig = {
113 |         temperature: 0.3,
114 |         maxOutputTokens: 16000,
115 |         thinkingConfig: {
116 |           thinkingBudget: 0,
117 |         },
118 |       };
119 | 
120 |       const response = await geminiClient.generateContent(
121 |         contents,
122 |         generationConfig,
123 |         signal,
124 |         DEFAULT_GEMINI_FLASH_LITE_MODEL,
125 |       );
126 | 
127 |       if (signal.aborted) {
128 |         return;
129 |       }
130 | 
131 |       if (response) {
132 |         const responseText = getResponseText(response);
133 | 
134 |         if (responseText) {
135 |           const suggestionText = responseText.trim();
136 | 
137 |           if (
138 |             suggestionText.length > 0 &&
139 |             suggestionText.startsWith(trimmedText)
140 |           ) {
141 |             setGhostText(suggestionText);
142 |           } else {
143 |             clearGhostText();
144 |           }
145 |         }
146 |       }
147 |     } catch (error) {
148 |       if (
149 |         !(
150 |           signal.aborted ||
151 |           (error instanceof Error && error.name === 'AbortError')
152 |         )
153 |       ) {
154 |         console.error('prompt completion error:', error);
155 |         // Clear the last requested text to allow retry only on real errors
156 |         lastRequestedTextRef.current = '';
157 |       }
158 |       clearGhostText();
159 |     } finally {
160 |       if (!signal.aborted) {
161 |         setIsLoadingGhostText(false);
162 |       }
163 |     }
164 |   }, [buffer.text, config, clearGhostText, isPromptCompletionEnabled]);
165 | 
166 |   const isCursorAtEnd = useCallback(() => {
167 |     const [cursorRow, cursorCol] = buffer.cursor;
168 |     const totalLines = buffer.lines.length;
169 |     if (cursorRow !== totalLines - 1) {
170 |       return false;
171 |     }
172 | 
173 |     const lastLine = buffer.lines[cursorRow] || '';
174 |     return cursorCol === lastLine.length;
175 |   }, [buffer.cursor, buffer.lines]);
176 | 
177 |   const handlePromptCompletion = useCallback(() => {
178 |     if (!isCursorAtEnd()) {
179 |       clearGhostText();
180 |       return;
181 |     }
182 | 
183 |     const trimmedText = buffer.text.trim();
184 | 
185 |     if (justSelectedSuggestion && trimmedText === lastSelectedTextRef.current) {
186 |       return;
187 |     }
188 | 
189 |     if (trimmedText !== lastSelectedTextRef.current) {
190 |       setJustSelectedSuggestion(false);
191 |       lastSelectedTextRef.current = '';
192 |     }
193 | 
194 |     generatePromptSuggestions();
195 |   }, [
196 |     buffer.text,
197 |     generatePromptSuggestions,
198 |     justSelectedSuggestion,
199 |     isCursorAtEnd,
200 |     clearGhostText,
201 |   ]);
202 | 
203 |   // Debounce prompt completion
204 |   useEffect(() => {
205 |     const timeoutId = setTimeout(
206 |       handlePromptCompletion,
207 |       PROMPT_COMPLETION_DEBOUNCE_MS,
208 |     );
209 |     return () => clearTimeout(timeoutId);
210 |   }, [buffer.text, buffer.cursor, handlePromptCompletion]);
211 | 
212 |   // Ghost text validation - clear if it doesn't match current text or cursor not at end
213 |   useEffect(() => {
214 |     const currentText = buffer.text.trim();
215 | 
216 |     if (ghostText && !isCursorAtEnd()) {
217 |       clearGhostText();
218 |       return;
219 |     }
220 | 
221 |     if (
222 |       ghostText &&
223 |       currentText.length > 0 &&
224 |       !ghostText.startsWith(currentText)
225 |     ) {
226 |       clearGhostText();
227 |     }
228 |   }, [buffer.text, buffer.cursor, ghostText, clearGhostText, isCursorAtEnd]);
229 | 
230 |   // Cleanup on unmount
231 |   useEffect(() => () => abortControllerRef.current?.abort(), []);
232 | 
233 |   const isActive = useMemo(() => {
234 |     if (!isPromptCompletionEnabled) return false;
235 | 
236 |     if (!isCursorAtEnd()) return false;
237 | 
238 |     const trimmedText = buffer.text.trim();
239 |     return (
240 |       trimmedText.length >= PROMPT_COMPLETION_MIN_LENGTH &&
241 |       !isSlashCommand(trimmedText) &&
242 |       !trimmedText.includes('@')
243 |     );
244 |   }, [buffer.text, isPromptCompletionEnabled, isCursorAtEnd]);
245 | 
246 |   return {
247 |     text: ghostText,
248 |     isLoading: isLoadingGhostText,
249 |     isActive,
250 |     accept: acceptGhostText,
251 |     clear: clearGhostText,
252 |     markSelected: markSuggestionSelected,
253 |   };
254 | }
```

src/ui/hooks/useQuotaAndFallback.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import {
8 |   vi,
9 |   describe,
10 |   it,
11 |   expect,
12 |   beforeEach,
13 |   afterEach,
14 |   type Mock,
15 | } from 'vitest';
16 | import { act, renderHook } from '@testing-library/react';
17 | import {
18 |   type Config,
19 |   type FallbackModelHandler,
20 |   UserTierId,
21 |   AuthType,
22 |   TerminalQuotaError,
23 |   makeFakeConfig,
24 |   type GoogleApiError,
25 | } from '@google/gemini-cli-core';
26 | import { useQuotaAndFallback } from './useQuotaAndFallback.js';
27 | import type { UseHistoryManagerReturn } from './useHistoryManager.js';
28 | import { AuthState, MessageType } from '../types.js';
29 | 
30 | // Use a type alias for SpyInstance as it's not directly exported
31 | type SpyInstance = ReturnType<typeof vi.spyOn>;
32 | 
33 | describe('useQuotaAndFallback', () => {
34 |   let mockConfig: Config;
35 |   let mockHistoryManager: UseHistoryManagerReturn;
36 |   let mockSetAuthState: Mock;
37 |   let mockSetModelSwitchedFromQuotaError: Mock;
38 |   let setFallbackHandlerSpy: SpyInstance;
39 |   let mockGoogleApiError: GoogleApiError;
40 | 
41 |   beforeEach(() => {
42 |     mockConfig = makeFakeConfig();
43 |     mockGoogleApiError = {
44 |       code: 429,
45 |       message: 'mock error',
46 |       details: [],
47 |     };
48 | 
49 |     // Spy on the method that requires the private field and mock its return.
50 |     // This is cleaner than modifying the config class for tests.
51 |     vi.spyOn(mockConfig, 'getContentGeneratorConfig').mockReturnValue({
52 |       authType: AuthType.LOGIN_WITH_GOOGLE,
53 |     });
54 | 
55 |     mockHistoryManager = {
56 |       addItem: vi.fn(),
57 |       history: [],
58 |       updateItem: vi.fn(),
59 |       clearItems: vi.fn(),
60 |       loadHistory: vi.fn(),
61 |     };
62 |     mockSetAuthState = vi.fn();
63 |     mockSetModelSwitchedFromQuotaError = vi.fn();
64 | 
65 |     setFallbackHandlerSpy = vi.spyOn(mockConfig, 'setFallbackModelHandler');
66 |     vi.spyOn(mockConfig, 'setQuotaErrorOccurred');
67 |   });
68 | 
69 |   afterEach(() => {
70 |     vi.clearAllMocks();
71 |   });
72 | 
73 |   it('should register a fallback handler on initialization', () => {
74 |     renderHook(() =>
75 |       useQuotaAndFallback({
76 |         config: mockConfig,
77 |         historyManager: mockHistoryManager,
78 |         userTier: UserTierId.FREE,
79 |         setAuthState: mockSetAuthState,
80 |         setModelSwitchedFromQuotaError: mockSetModelSwitchedFromQuotaError,
81 |       }),
82 |     );
83 | 
84 |     expect(setFallbackHandlerSpy).toHaveBeenCalledTimes(1);
85 |     expect(setFallbackHandlerSpy.mock.calls[0][0]).toBeInstanceOf(Function);
86 |   });
87 | 
88 |   describe('Fallback Handler Logic', () => {
89 |     // Helper function to render the hook and extract the registered handler
90 |     const getRegisteredHandler = (
91 |       userTier: UserTierId = UserTierId.FREE,
92 |     ): FallbackModelHandler => {
93 |       renderHook(
94 |         (props) =>
95 |           useQuotaAndFallback({
96 |             config: mockConfig,
97 |             historyManager: mockHistoryManager,
98 |             userTier: props.userTier,
99 |             setAuthState: mockSetAuthState,
100 |             setModelSwitchedFromQuotaError: mockSetModelSwitchedFromQuotaError,
101 |           }),
102 |         { initialProps: { userTier } },
103 |       );
104 |       return setFallbackHandlerSpy.mock.calls[0][0] as FallbackModelHandler;
105 |     };
106 | 
107 |     it('should return null and take no action if already in fallback mode', async () => {
108 |       vi.spyOn(mockConfig, 'isInFallbackMode').mockReturnValue(true);
109 |       const handler = getRegisteredHandler();
110 |       const result = await handler('gemini-pro', 'gemini-flash', new Error());
111 | 
112 |       expect(result).toBeNull();
113 |       expect(mockHistoryManager.addItem).not.toHaveBeenCalled();
114 |     });
115 | 
116 |     it('should return null and take no action if authType is not LOGIN_WITH_GOOGLE', async () => {
117 |       // Override the default mock from beforeEach for this specific test
118 |       vi.spyOn(mockConfig, 'getContentGeneratorConfig').mockReturnValue({
119 |         authType: AuthType.USE_GEMINI,
120 |       });
121 | 
122 |       const handler = getRegisteredHandler();
123 |       const result = await handler('gemini-pro', 'gemini-flash', new Error());
124 | 
125 |       expect(result).toBeNull();
126 |       expect(mockHistoryManager.addItem).not.toHaveBeenCalled();
127 |     });
128 | 
129 |     describe('Automatic Fallback Scenarios', () => {
130 |       const testCases = [
131 |         {
132 |           errorType: 'other',
133 |           tier: UserTierId.FREE,
134 |           expectedMessageSnippets: [
135 |             'Automatically switching from model-A to model-B for faster responses',
136 |             'upgrade to a Gemini Code Assist Standard or Enterprise plan',
137 |           ],
138 |         },
139 |         {
140 |           errorType: 'other',
141 |           tier: UserTierId.LEGACY, // Paid tier
142 |           expectedMessageSnippets: [
143 |             'Automatically switching from model-A to model-B for faster responses',
144 |             'switch to using a paid API key from AI Studio',
145 |           ],
146 |         },
147 |       ];
148 | 
149 |       for (const { errorType, tier, expectedMessageSnippets } of testCases) {
150 |         it(`should handle ${errorType} error for ${tier} tier correctly`, async () => {
151 |           const handler = getRegisteredHandler(tier);
152 |           const result = await handler(
153 |             'model-A',
154 |             'model-B',
155 |             new Error('some error'),
156 |           );
157 | 
158 |           // Automatic fallbacks should return 'stop'
159 |           expect(result).toBe('stop');
160 | 
161 |           expect(mockHistoryManager.addItem).toHaveBeenCalledWith(
162 |             expect.objectContaining({ type: MessageType.INFO }),
163 |             expect.any(Number),
164 |           );
165 | 
166 |           const message = (mockHistoryManager.addItem as Mock).mock.calls[0][0]
167 |             .text;
168 |           for (const snippet of expectedMessageSnippets) {
169 |             expect(message).toContain(snippet);
170 |           }
171 | 
172 |           expect(mockSetModelSwitchedFromQuotaError).toHaveBeenCalledWith(true);
173 |           expect(mockConfig.setQuotaErrorOccurred).toHaveBeenCalledWith(true);
174 |         });
175 |       }
176 |     });
177 | 
178 |     describe('Interactive Fallback (Pro Quota Error)', () => {
179 |       it('should set an interactive request and wait for user choice', async () => {
180 |         const { result } = renderHook(() =>
181 |           useQuotaAndFallback({
182 |             config: mockConfig,
183 |             historyManager: mockHistoryManager,
184 |             userTier: UserTierId.FREE,
185 |             setAuthState: mockSetAuthState,
186 |             setModelSwitchedFromQuotaError: mockSetModelSwitchedFromQuotaError,
187 |           }),
188 |         );
189 | 
190 |         const handler = setFallbackHandlerSpy.mock
191 |           .calls[0][0] as FallbackModelHandler;
192 | 
193 |         // Call the handler but do not await it, to check the intermediate state
194 |         const promise = handler(
195 |           'gemini-pro',
196 |           'gemini-flash',
197 |           new TerminalQuotaError('pro quota', mockGoogleApiError),
198 |         );
199 | 
200 |         await act(async () => {});
201 | 
202 |         // The hook should now have a pending request for the UI to handle
203 |         expect(result.current.proQuotaRequest).not.toBeNull();
204 |         expect(result.current.proQuotaRequest?.failedModel).toBe('gemini-pro');
205 | 
206 |         // Simulate the user choosing to continue with the fallback model
207 |         act(() => {
208 |           result.current.handleProQuotaChoice('continue');
209 |         });
210 | 
211 |         // The original promise from the handler should now resolve
212 |         const intent = await promise;
213 |         expect(intent).toBe('retry');
214 | 
215 |         // The pending request should be cleared from the state
216 |         expect(result.current.proQuotaRequest).toBeNull();
217 |       });
218 | 
219 |       it('should handle race conditions by stopping subsequent requests', async () => {
220 |         const { result } = renderHook(() =>
221 |           useQuotaAndFallback({
222 |             config: mockConfig,
223 |             historyManager: mockHistoryManager,
224 |             userTier: UserTierId.FREE,
225 |             setAuthState: mockSetAuthState,
226 |             setModelSwitchedFromQuotaError: mockSetModelSwitchedFromQuotaError,
227 |           }),
228 |         );
229 | 
230 |         const handler = setFallbackHandlerSpy.mock
231 |           .calls[0][0] as FallbackModelHandler;
232 | 
233 |         const promise1 = handler(
234 |           'gemini-pro',
235 |           'gemini-flash',
236 |           new TerminalQuotaError('pro quota 1', mockGoogleApiError),
237 |         );
238 |         await act(async () => {});
239 | 
240 |         const firstRequest = result.current.proQuotaRequest;
241 |         expect(firstRequest).not.toBeNull();
242 | 
243 |         const result2 = await handler(
244 |           'gemini-pro',
245 |           'gemini-flash',
246 |           new TerminalQuotaError('pro quota 2', mockGoogleApiError),
247 |         );
248 | 
249 |         // The lock should have stopped the second request
250 |         expect(result2).toBe('stop');
251 |         expect(result.current.proQuotaRequest).toBe(firstRequest);
252 | 
253 |         act(() => {
254 |           result.current.handleProQuotaChoice('continue');
255 |         });
256 | 
257 |         const intent1 = await promise1;
258 |         expect(intent1).toBe('retry');
259 |         expect(result.current.proQuotaRequest).toBeNull();
260 |       });
261 |     });
262 |   });
263 | 
264 |   describe('handleProQuotaChoice', () => {
265 |     it('should do nothing if there is no pending pro quota request', () => {
266 |       const { result } = renderHook(() =>
267 |         useQuotaAndFallback({
268 |           config: mockConfig,
269 |           historyManager: mockHistoryManager,
270 |           userTier: UserTierId.FREE,
271 |           setAuthState: mockSetAuthState,
272 |           setModelSwitchedFromQuotaError: mockSetModelSwitchedFromQuotaError,
273 |         }),
274 |       );
275 | 
276 |       act(() => {
277 |         result.current.handleProQuotaChoice('auth');
278 |       });
279 | 
280 |       expect(mockSetAuthState).not.toHaveBeenCalled();
281 |       expect(mockHistoryManager.addItem).not.toHaveBeenCalled();
282 |     });
283 | 
284 |     it('should resolve intent to "auth" and trigger auth state update', async () => {
285 |       const { result } = renderHook(() =>
286 |         useQuotaAndFallback({
287 |           config: mockConfig,
288 |           historyManager: mockHistoryManager,
289 |           userTier: UserTierId.FREE,
290 |           setAuthState: mockSetAuthState,
291 |           setModelSwitchedFromQuotaError: mockSetModelSwitchedFromQuotaError,
292 |         }),
293 |       );
294 | 
295 |       const handler = setFallbackHandlerSpy.mock
296 |         .calls[0][0] as FallbackModelHandler;
297 |       const promise = handler(
298 |         'gemini-pro',
299 |         'gemini-flash',
300 |         new TerminalQuotaError('pro quota', mockGoogleApiError),
301 |       );
302 |       await act(async () => {}); // Allow state to update
303 | 
304 |       act(() => {
305 |         result.current.handleProQuotaChoice('auth');
306 |       });
307 | 
308 |       const intent = await promise;
309 |       expect(intent).toBe('auth');
310 |       expect(mockSetAuthState).toHaveBeenCalledWith(AuthState.Updating);
311 |       expect(result.current.proQuotaRequest).toBeNull();
312 |     });
313 | 
314 |     it('should resolve intent to "retry" and add info message on continue', async () => {
315 |       const { result } = renderHook(() =>
316 |         useQuotaAndFallback({
317 |           config: mockConfig,
318 |           historyManager: mockHistoryManager,
319 |           userTier: UserTierId.FREE,
320 |           setAuthState: mockSetAuthState,
321 |           setModelSwitchedFromQuotaError: mockSetModelSwitchedFromQuotaError,
322 |         }),
323 |       );
324 | 
325 |       const handler = setFallbackHandlerSpy.mock
326 |         .calls[0][0] as FallbackModelHandler;
327 |       // The first `addItem` call is for the initial quota error message
328 |       const promise = handler(
329 |         'gemini-pro',
330 |         'gemini-flash',
331 |         new TerminalQuotaError('pro quota', mockGoogleApiError),
332 |       );
333 |       await act(async () => {}); // Allow state to update
334 | 
335 |       act(() => {
336 |         result.current.handleProQuotaChoice('continue');
337 |       });
338 | 
339 |       const intent = await promise;
340 |       expect(intent).toBe('retry');
341 |       expect(result.current.proQuotaRequest).toBeNull();
342 | 
343 |       // Check for the second "Switched to fallback model" message
344 |       expect(mockHistoryManager.addItem).toHaveBeenCalledTimes(2);
345 |       const lastCall = (mockHistoryManager.addItem as Mock).mock.calls[1][0];
346 |       expect(lastCall.type).toBe(MessageType.INFO);
347 |       expect(lastCall.text).toContain('Switched to fallback model.');
348 |     });
349 |   });
350 | });
```

src/ui/hooks/useQuotaAndFallback.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import {
8 |   AuthType,
9 |   type Config,
10 |   type FallbackModelHandler,
11 |   type FallbackIntent,
12 |   TerminalQuotaError,
13 |   UserTierId,
14 | } from '@google/gemini-cli-core';
15 | import { useCallback, useEffect, useRef, useState } from 'react';
16 | import { type UseHistoryManagerReturn } from './useHistoryManager.js';
17 | import { AuthState, MessageType } from '../types.js';
18 | import { type ProQuotaDialogRequest } from '../contexts/UIStateContext.js';
19 | 
20 | interface UseQuotaAndFallbackArgs {
21 |   config: Config;
22 |   historyManager: UseHistoryManagerReturn;
23 |   userTier: UserTierId | undefined;
24 |   setAuthState: (state: AuthState) => void;
25 |   setModelSwitchedFromQuotaError: (value: boolean) => void;
26 | }
27 | 
28 | export function useQuotaAndFallback({
29 |   config,
30 |   historyManager,
31 |   userTier,
32 |   setAuthState,
33 |   setModelSwitchedFromQuotaError,
34 | }: UseQuotaAndFallbackArgs) {
35 |   const [proQuotaRequest, setProQuotaRequest] =
36 |     useState<ProQuotaDialogRequest | null>(null);
37 |   const isDialogPending = useRef(false);
38 | 
39 |   // Set up Flash fallback handler
40 |   useEffect(() => {
41 |     const fallbackHandler: FallbackModelHandler = async (
42 |       failedModel,
43 |       fallbackModel,
44 |       error,
45 |     ): Promise<FallbackIntent | null> => {
46 |       if (config.isInFallbackMode()) {
47 |         return null;
48 |       }
49 | 
50 |       // Fallbacks are currently only handled for OAuth users.
51 |       const contentGeneratorConfig = config.getContentGeneratorConfig();
52 |       if (
53 |         !contentGeneratorConfig ||
54 |         contentGeneratorConfig.authType !== AuthType.LOGIN_WITH_GOOGLE
55 |       ) {
56 |         return null;
57 |       }
58 | 
59 |       // Use actual user tier if available; otherwise, default to FREE tier behavior (safe default)
60 |       const isPaidTier =
61 |         userTier === UserTierId.LEGACY || userTier === UserTierId.STANDARD;
62 | 
63 |       let message: string;
64 | 
65 |       if (error instanceof TerminalQuotaError) {
66 |         // Pro Quota specific messages (Interactive)
67 |         if (isPaidTier) {
68 |           message = `⚡ You have reached your daily ${failedModel} quota limit.
69 | ⚡ You can choose to authenticate with a paid API key or continue with the fallback model.
70 | ⚡ To continue accessing the ${failedModel} model today, consider using /auth to switch to using a paid API key from AI Studio at https://aistudio.google.com/apikey`;
71 |         } else {
72 |           message = `⚡ You have reached your daily ${failedModel} quota limit.
73 | ⚡ You can choose to authenticate with a paid API key or continue with the fallback model.
74 | ⚡ To increase your limits, upgrade to a Gemini Code Assist Standard or Enterprise plan with higher limits at https://goo.gle/set-up-gemini-code-assist
75 | ⚡ Or you can utilize a Gemini API Key. See: https://goo.gle/gemini-cli-docs-auth#gemini-api-key
76 | ⚡ You can switch authentication methods by typing /auth`;
77 |         }
78 |       } else {
79 |         // Consecutive 429s or other errors (Automatic fallback)
80 |         const actionMessage = `⚡ Automatically switching from ${failedModel} to ${fallbackModel} for faster responses for the remainder of this session.`;
81 | 
82 |         if (isPaidTier) {
83 |           message = `${actionMessage}
84 | ⚡ Possible reasons for this are that you have received multiple consecutive capacity errors or you have reached your daily ${failedModel} quota limit
85 | ⚡ To continue accessing the ${failedModel} model today, consider using /auth to switch to using a paid API key from AI Studio at https://aistudio.google.com/apikey`;
86 |         } else {
87 |           message = `${actionMessage}
88 | ⚡ Possible reasons for this are that you have received multiple consecutive capacity errors or you have reached your daily ${failedModel} quota limit
89 | ⚡ To increase your limits, upgrade to a Gemini Code Assist Standard or Enterprise plan with higher limits at https://goo.gle/set-up-gemini-code-assist
90 | ⚡ Or you can utilize a Gemini API Key. See: https://goo.gle/gemini-cli-docs-auth#gemini-api-key
91 | ⚡ You can switch authentication methods by typing /auth`;
92 |         }
93 |       }
94 | 
95 |       // Add message to UI history
96 |       historyManager.addItem(
97 |         {
98 |           type: MessageType.INFO,
99 |           text: message,
100 |         },
101 |         Date.now(),
102 |       );
103 | 
104 |       setModelSwitchedFromQuotaError(true);
105 |       config.setQuotaErrorOccurred(true);
106 | 
107 |       // Interactive Fallback for Pro quota
108 |       if (error instanceof TerminalQuotaError) {
109 |         if (isDialogPending.current) {
110 |           return 'stop'; // A dialog is already active, so just stop this request.
111 |         }
112 |         isDialogPending.current = true;
113 | 
114 |         const intent: FallbackIntent = await new Promise<FallbackIntent>(
115 |           (resolve) => {
116 |             setProQuotaRequest({
117 |               failedModel,
118 |               fallbackModel,
119 |               resolve,
120 |             });
121 |           },
122 |         );
123 | 
124 |         return intent;
125 |       }
126 | 
127 |       return 'stop';
128 |     };
129 | 
130 |     config.setFallbackModelHandler(fallbackHandler);
131 |   }, [config, historyManager, userTier, setModelSwitchedFromQuotaError]);
132 | 
133 |   const handleProQuotaChoice = useCallback(
134 |     (choice: 'auth' | 'continue') => {
135 |       if (!proQuotaRequest) return;
136 | 
137 |       const intent: FallbackIntent = choice === 'auth' ? 'auth' : 'retry';
138 |       proQuotaRequest.resolve(intent);
139 |       setProQuotaRequest(null);
140 |       isDialogPending.current = false; // Reset the flag here
141 | 
142 |       if (choice === 'auth') {
143 |         setAuthState(AuthState.Updating);
144 |       } else {
145 |         historyManager.addItem(
146 |           {
147 |             type: MessageType.INFO,
148 |             text: 'Switched to fallback model. Tip: Press Ctrl+P (or Up Arrow) to recall your previous prompt and submit it again if you wish.',
149 |           },
150 |           Date.now(),
151 |         );
152 |       }
153 |     },
154 |     [proQuotaRequest, setAuthState, historyManager],
155 |   );
156 | 
157 |   return {
158 |     proQuotaRequest,
159 |     handleProQuotaChoice,
160 |   };
161 | }
```

src/ui/hooks/useReactToolScheduler.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type {
8 |   Config,
9 |   ToolCallRequestInfo,
10 |   ExecutingToolCall,
11 |   ScheduledToolCall,
12 |   ValidatingToolCall,
13 |   WaitingToolCall,
14 |   CompletedToolCall,
15 |   CancelledToolCall,
16 |   OutputUpdateHandler,
17 |   AllToolCallsCompleteHandler,
18 |   ToolCallsUpdateHandler,
19 |   ToolCall,
20 |   Status as CoreStatus,
21 |   EditorType,
22 | } from '@google/gemini-cli-core';
23 | import { CoreToolScheduler } from '@google/gemini-cli-core';
24 | import { useCallback, useState, useMemo } from 'react';
25 | import type {
26 |   HistoryItemToolGroup,
27 |   IndividualToolCallDisplay,
28 | } from '../types.js';
29 | import { ToolCallStatus } from '../types.js';
30 | 
31 | export type ScheduleFn = (
32 |   request: ToolCallRequestInfo | ToolCallRequestInfo[],
33 |   signal: AbortSignal,
34 | ) => void;
35 | export type MarkToolsAsSubmittedFn = (callIds: string[]) => void;
36 | 
37 | export type TrackedScheduledToolCall = ScheduledToolCall & {
38 |   responseSubmittedToGemini?: boolean;
39 | };
40 | export type TrackedValidatingToolCall = ValidatingToolCall & {
41 |   responseSubmittedToGemini?: boolean;
42 | };
43 | export type TrackedWaitingToolCall = WaitingToolCall & {
44 |   responseSubmittedToGemini?: boolean;
45 | };
46 | export type TrackedExecutingToolCall = ExecutingToolCall & {
47 |   responseSubmittedToGemini?: boolean;
48 |   pid?: number;
49 | };
50 | export type TrackedCompletedToolCall = CompletedToolCall & {
51 |   responseSubmittedToGemini?: boolean;
52 | };
53 | export type TrackedCancelledToolCall = CancelledToolCall & {
54 |   responseSubmittedToGemini?: boolean;
55 | };
56 | 
57 | export type TrackedToolCall =
58 |   | TrackedScheduledToolCall
59 |   | TrackedValidatingToolCall
60 |   | TrackedWaitingToolCall
61 |   | TrackedExecutingToolCall
62 |   | TrackedCompletedToolCall
63 |   | TrackedCancelledToolCall;
64 | 
65 | export function useReactToolScheduler(
66 |   onComplete: (tools: CompletedToolCall[]) => Promise<void>,
67 |   config: Config,
68 |   getPreferredEditor: () => EditorType | undefined,
69 |   onEditorClose: () => void,
70 | ): [TrackedToolCall[], ScheduleFn, MarkToolsAsSubmittedFn] {
71 |   const [toolCallsForDisplay, setToolCallsForDisplay] = useState<
72 |     TrackedToolCall[]
73 |   >([]);
74 | 
75 |   const outputUpdateHandler: OutputUpdateHandler = useCallback(
76 |     (toolCallId, outputChunk) => {
77 |       setToolCallsForDisplay((prevCalls) =>
78 |         prevCalls.map((tc) => {
79 |           if (tc.request.callId === toolCallId && tc.status === 'executing') {
80 |             const executingTc = tc as TrackedExecutingToolCall;
81 |             return { ...executingTc, liveOutput: outputChunk };
82 |           }
83 |           return tc;
84 |         }),
85 |       );
86 |     },
87 |     [],
88 |   );
89 | 
90 |   const allToolCallsCompleteHandler: AllToolCallsCompleteHandler = useCallback(
91 |     async (completedToolCalls) => {
92 |       await onComplete(completedToolCalls);
93 |     },
94 |     [onComplete],
95 |   );
96 | 
97 |   const toolCallsUpdateHandler: ToolCallsUpdateHandler = useCallback(
98 |     (updatedCoreToolCalls: ToolCall[]) => {
99 |       setToolCallsForDisplay((prevTrackedCalls) =>
100 |         updatedCoreToolCalls.map((coreTc) => {
101 |           const existingTrackedCall = prevTrackedCalls.find(
102 |             (ptc) => ptc.request.callId === coreTc.request.callId,
103 |           );
104 |           // Start with the new core state, then layer on the existing UI state
105 |           // to ensure UI-only properties like pid are preserved.
106 |           const responseSubmittedToGemini =
107 |             existingTrackedCall?.responseSubmittedToGemini ?? false;
108 | 
109 |           if (coreTc.status === 'executing') {
110 |             return {
111 |               ...coreTc,
112 |               responseSubmittedToGemini,
113 |               liveOutput: (existingTrackedCall as TrackedExecutingToolCall)
114 |                 ?.liveOutput,
115 |               pid: (coreTc as ExecutingToolCall).pid,
116 |             };
117 |           }
118 | 
119 |           // For other statuses, explicitly set liveOutput and pid to undefined
120 |           // to ensure they are not carried over from a previous executing state.
121 |           return {
122 |             ...coreTc,
123 |             responseSubmittedToGemini,
124 |             liveOutput: undefined,
125 |             pid: undefined,
126 |           };
127 |         }),
128 |       );
129 |     },
130 |     [setToolCallsForDisplay],
131 |   );
132 | 
133 |   const scheduler = useMemo(
134 |     () =>
135 |       new CoreToolScheduler({
136 |         outputUpdateHandler,
137 |         onAllToolCallsComplete: allToolCallsCompleteHandler,
138 |         onToolCallsUpdate: toolCallsUpdateHandler,
139 |         getPreferredEditor,
140 |         config,
141 |         onEditorClose,
142 |         // eslint-disable-next-line @typescript-eslint/no-explicit-any
143 |       } as any),
144 |     [
145 |       config,
146 |       outputUpdateHandler,
147 |       allToolCallsCompleteHandler,
148 |       toolCallsUpdateHandler,
149 |       getPreferredEditor,
150 |       onEditorClose,
151 |     ],
152 |   );
153 | 
154 |   const schedule: ScheduleFn = useCallback(
155 |     (
156 |       request: ToolCallRequestInfo | ToolCallRequestInfo[],
157 |       signal: AbortSignal,
158 |     ) => {
159 |       void scheduler.schedule(request, signal);
160 |     },
161 |     [scheduler],
162 |   );
163 | 
164 |   const markToolsAsSubmitted: MarkToolsAsSubmittedFn = useCallback(
165 |     (callIdsToMark: string[]) => {
166 |       setToolCallsForDisplay((prevCalls) =>
167 |         prevCalls.map((tc) =>
168 |           callIdsToMark.includes(tc.request.callId)
169 |             ? { ...tc, responseSubmittedToGemini: true }
170 |             : tc,
171 |         ),
172 |       );
173 |     },
174 |     [],
175 |   );
176 | 
177 |   return [toolCallsForDisplay, schedule, markToolsAsSubmitted];
178 | }
179 | 
180 | /**
181 |  * Maps a CoreToolScheduler status to the UI's ToolCallStatus enum.
182 |  */
183 | function mapCoreStatusToDisplayStatus(coreStatus: CoreStatus): ToolCallStatus {
184 |   switch (coreStatus) {
185 |     case 'validating':
186 |       return ToolCallStatus.Executing;
187 |     case 'awaiting_approval':
188 |       return ToolCallStatus.Confirming;
189 |     case 'executing':
190 |       return ToolCallStatus.Executing;
191 |     case 'success':
192 |       return ToolCallStatus.Success;
193 |     case 'cancelled':
194 |       return ToolCallStatus.Canceled;
195 |     case 'error':
196 |       return ToolCallStatus.Error;
197 |     case 'scheduled':
198 |       return ToolCallStatus.Pending;
199 |     default: {
200 |       const exhaustiveCheck: never = coreStatus;
201 |       console.warn(`Unknown core status encountered: ${exhaustiveCheck}`);
202 |       return ToolCallStatus.Error;
203 |     }
204 |   }
205 | }
206 | 
207 | /**
208 |  * Transforms `TrackedToolCall` objects into `HistoryItemToolGroup` objects for UI display.
209 |  */
210 | export function mapToDisplay(
211 |   toolOrTools: TrackedToolCall[] | TrackedToolCall,
212 | ): HistoryItemToolGroup {
213 |   const toolCalls = Array.isArray(toolOrTools) ? toolOrTools : [toolOrTools];
214 | 
215 |   const toolDisplays = toolCalls.map(
216 |     (trackedCall): IndividualToolCallDisplay => {
217 |       let displayName: string;
218 |       let description: string;
219 |       let renderOutputAsMarkdown = false;
220 | 
221 |       if (trackedCall.status === 'error') {
222 |         displayName =
223 |           trackedCall.tool === undefined
224 |             ? trackedCall.request.name
225 |             : trackedCall.tool.displayName;
226 |         description = JSON.stringify(trackedCall.request.args);
227 |       } else {
228 |         displayName = trackedCall.tool.displayName;
229 |         description = trackedCall.invocation.getDescription();
230 |         renderOutputAsMarkdown = trackedCall.tool.isOutputMarkdown;
231 |       }
232 | 
233 |       const baseDisplayProperties: Omit<
234 |         IndividualToolCallDisplay,
235 |         'status' | 'resultDisplay' | 'confirmationDetails'
236 |       > = {
237 |         callId: trackedCall.request.callId,
238 |         name: displayName,
239 |         description,
240 |         renderOutputAsMarkdown,
241 |       };
242 | 
243 |       switch (trackedCall.status) {
244 |         case 'success':
245 |           return {
246 |             ...baseDisplayProperties,
247 |             status: mapCoreStatusToDisplayStatus(trackedCall.status),
248 |             resultDisplay: trackedCall.response.resultDisplay,
249 |             confirmationDetails: undefined,
250 |             outputFile: trackedCall.response.outputFile,
251 |           };
252 |         case 'error':
253 |           return {
254 |             ...baseDisplayProperties,
255 |             status: mapCoreStatusToDisplayStatus(trackedCall.status),
256 |             resultDisplay: trackedCall.response.resultDisplay,
257 |             confirmationDetails: undefined,
258 |           };
259 |         case 'cancelled':
260 |           return {
261 |             ...baseDisplayProperties,
262 |             status: mapCoreStatusToDisplayStatus(trackedCall.status),
263 |             resultDisplay: trackedCall.response.resultDisplay,
264 |             confirmationDetails: undefined,
265 |           };
266 |         case 'awaiting_approval':
267 |           return {
268 |             ...baseDisplayProperties,
269 |             status: mapCoreStatusToDisplayStatus(trackedCall.status),
270 |             resultDisplay: undefined,
271 |             confirmationDetails: trackedCall.confirmationDetails,
272 |           };
273 |         case 'executing':
274 |           return {
275 |             ...baseDisplayProperties,
276 |             status: mapCoreStatusToDisplayStatus(trackedCall.status),
277 |             resultDisplay:
278 |               (trackedCall as TrackedExecutingToolCall).liveOutput ?? undefined,
279 |             confirmationDetails: undefined,
280 |             ptyId: (trackedCall as TrackedExecutingToolCall).pid,
281 |           };
282 |         case 'validating': // Fallthrough
283 |         case 'scheduled':
284 |           return {
285 |             ...baseDisplayProperties,
286 |             status: mapCoreStatusToDisplayStatus(trackedCall.status),
287 |             resultDisplay: undefined,
288 |             confirmationDetails: undefined,
289 |           };
290 |         default: {
291 |           const exhaustiveCheck: never = trackedCall;
292 |           return {
293 |             callId: (exhaustiveCheck as TrackedToolCall).request.callId,
294 |             name: 'Unknown Tool',
295 |             description: 'Encountered an unknown tool call state.',
296 |             status: ToolCallStatus.Error,
297 |             resultDisplay: 'Unknown tool call state',
298 |             confirmationDetails: undefined,
299 |             renderOutputAsMarkdown: false,
300 |           };
301 |         }
302 |       }
303 |     },
304 |   );
305 | 
306 |   return {
307 |     type: 'tool_group',
308 |     tools: toolDisplays,
309 |   };
310 | }
```

src/ui/hooks/useRefreshMemoryCommand.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | export const REFRESH_MEMORY_COMMAND_NAME = '/refreshmemory';
```

src/ui/hooks/useReverseSearchCompletion.test.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | /** @vitest-environment jsdom */
8 | 
9 | import { describe, it, expect } from 'vitest';
10 | import { renderHook, act } from '@testing-library/react';
11 | import { useReverseSearchCompletion } from './useReverseSearchCompletion.js';
12 | import { useTextBuffer } from '../components/shared/text-buffer.js';
13 | 
14 | describe('useReverseSearchCompletion', () => {
15 |   function useTextBufferForTest(text: string) {
16 |     return useTextBuffer({
17 |       initialText: text,
18 |       initialCursorOffset: text.length,
19 |       viewport: { width: 80, height: 20 },
20 |       isValidPath: () => false,
21 |       onChange: () => {},
22 |     });
23 |   }
24 | 
25 |   describe('Core Hook Behavior', () => {
26 |     describe('State Management', () => {
27 |       it('should initialize with default state', () => {
28 |         const mockShellHistory = ['echo hello'];
29 | 
30 |         const { result } = renderHook(() =>
31 |           useReverseSearchCompletion(
32 |             useTextBufferForTest(''),
33 |             mockShellHistory,
34 |             false,
35 |           ),
36 |         );
37 | 
38 |         expect(result.current.suggestions).toEqual([]);
39 |         expect(result.current.activeSuggestionIndex).toBe(-1);
40 |         expect(result.current.visibleStartIndex).toBe(0);
41 |         expect(result.current.showSuggestions).toBe(false);
42 |         expect(result.current.isLoadingSuggestions).toBe(false);
43 |       });
44 | 
45 |       it('should reset state when reverseSearchActive becomes false', () => {
46 |         const mockShellHistory = ['echo hello'];
47 |         const { result, rerender } = renderHook(
48 |           ({ text, active }) => {
49 |             const textBuffer = useTextBufferForTest(text);
50 |             return useReverseSearchCompletion(
51 |               textBuffer,
52 |               mockShellHistory,
53 |               active,
54 |             );
55 |           },
56 |           { initialProps: { text: 'echo', active: true } },
57 |         );
58 | 
59 |         // Simulate reverseSearchActive becoming false
60 |         rerender({ text: 'echo', active: false });
61 | 
62 |         expect(result.current.suggestions).toEqual([]);
63 |         expect(result.current.activeSuggestionIndex).toBe(-1);
64 |         expect(result.current.visibleStartIndex).toBe(0);
65 |         expect(result.current.showSuggestions).toBe(false);
66 |       });
67 | 
68 |       describe('Navigation', () => {
69 |         it('should handle navigateUp with no suggestions', () => {
70 |           const mockShellHistory = ['echo hello'];
71 | 
72 |           const { result } = renderHook(() =>
73 |             useReverseSearchCompletion(
74 |               useTextBufferForTest('grep'),
75 |               mockShellHistory,
76 |               true,
77 |             ),
78 |           );
79 | 
80 |           act(() => {
81 |             result.current.navigateUp();
82 |           });
83 | 
84 |           expect(result.current.activeSuggestionIndex).toBe(-1);
85 |         });
86 | 
87 |         it('should handle navigateDown with no suggestions', () => {
88 |           const mockShellHistory = ['echo hello'];
89 |           const { result } = renderHook(() =>
90 |             useReverseSearchCompletion(
91 |               useTextBufferForTest('grep'),
92 |               mockShellHistory,
93 |               true,
94 |             ),
95 |           );
96 | 
97 |           act(() => {
98 |             result.current.navigateDown();
99 |           });
100 | 
101 |           expect(result.current.activeSuggestionIndex).toBe(-1);
102 |         });
103 | 
104 |         it('should navigate up through suggestions with wrap-around', () => {
105 |           const mockShellHistory = [
106 |             'ls -l',
107 |             'ls -la',
108 |             'cd /some/path',
109 |             'git status',
110 |             'echo "Hello, World!"',
111 |             'echo Hi',
112 |           ];
113 | 
114 |           const { result } = renderHook(() =>
115 |             useReverseSearchCompletion(
116 |               useTextBufferForTest('echo'),
117 |               mockShellHistory,
118 |               true,
119 |             ),
120 |           );
121 | 
122 |           expect(result.current.suggestions.length).toBe(2);
123 |           expect(result.current.activeSuggestionIndex).toBe(0);
124 | 
125 |           act(() => {
126 |             result.current.navigateUp();
127 |           });
128 | 
129 |           expect(result.current.activeSuggestionIndex).toBe(1);
130 |         });
131 | 
132 |         it('should navigate down through suggestions with wrap-around', () => {
133 |           const mockShellHistory = [
134 |             'ls -l',
135 |             'ls -la',
136 |             'cd /some/path',
137 |             'git status',
138 |             'echo "Hello, World!"',
139 |             'echo Hi',
140 |           ];
141 |           const { result } = renderHook(() =>
142 |             useReverseSearchCompletion(
143 |               useTextBufferForTest('ls'),
144 |               mockShellHistory,
145 |               true,
146 |             ),
147 |           );
148 | 
149 |           expect(result.current.suggestions.length).toBe(2);
150 |           expect(result.current.activeSuggestionIndex).toBe(0);
151 | 
152 |           act(() => {
153 |             result.current.navigateDown();
154 |           });
155 | 
156 |           expect(result.current.activeSuggestionIndex).toBe(1);
157 |         });
158 | 
159 |         it('should handle navigation with multiple suggestions', () => {
160 |           const mockShellHistory = [
161 |             'ls -l',
162 |             'ls -la',
163 |             'cd /some/path/l',
164 |             'git status',
165 |             'echo "Hello, World!"',
166 |             'echo "Hi all"',
167 |           ];
168 | 
169 |           const { result } = renderHook(() =>
170 |             useReverseSearchCompletion(
171 |               useTextBufferForTest('l'),
172 |               mockShellHistory,
173 |               true,
174 |             ),
175 |           );
176 | 
177 |           expect(result.current.suggestions.length).toBe(5);
178 |           expect(result.current.activeSuggestionIndex).toBe(0);
179 | 
180 |           act(() => {
181 |             result.current.navigateDown();
182 |           });
183 |           expect(result.current.activeSuggestionIndex).toBe(1);
184 | 
185 |           act(() => {
186 |             result.current.navigateDown();
187 |           });
188 |           expect(result.current.activeSuggestionIndex).toBe(2);
189 | 
190 |           act(() => {
191 |             result.current.navigateUp();
192 |           });
193 |           expect(result.current.activeSuggestionIndex).toBe(1);
194 | 
195 |           act(() => {
196 |             result.current.navigateUp();
197 |           });
198 |           expect(result.current.activeSuggestionIndex).toBe(0);
199 | 
200 |           act(() => {
201 |             result.current.navigateUp();
202 |           });
203 |           expect(result.current.activeSuggestionIndex).toBe(4);
204 |         });
205 | 
206 |         it('should handle navigation with large suggestion lists and scrolling', () => {
207 |           const largeMockCommands = Array.from(
208 |             { length: 15 },
209 |             (_, i) => `echo ${i}`,
210 |           );
211 | 
212 |           const { result } = renderHook(() =>
213 |             useReverseSearchCompletion(
214 |               useTextBufferForTest('echo'),
215 |               largeMockCommands,
216 |               true,
217 |             ),
218 |           );
219 | 
220 |           expect(result.current.suggestions.length).toBe(15);
221 |           expect(result.current.activeSuggestionIndex).toBe(0);
222 |           expect(result.current.visibleStartIndex).toBe(0);
223 | 
224 |           act(() => {
225 |             result.current.navigateUp();
226 |           });
227 | 
228 |           expect(result.current.activeSuggestionIndex).toBe(14);
229 |           expect(result.current.visibleStartIndex).toBe(Math.max(0, 15 - 8));
230 |         });
231 |       });
232 |     });
233 |   });
234 | 
235 |   describe('Filtering', () => {
236 |     it('filters history by buffer.text and sets showSuggestions', () => {
237 |       const history = ['foo', 'barfoo', 'baz'];
238 |       const { result } = renderHook(() =>
239 |         useReverseSearchCompletion(useTextBufferForTest('foo'), history, true),
240 |       );
241 | 
242 |       // should only return the two entries containing "foo"
243 |       expect(result.current.suggestions.map((s) => s.value)).toEqual([
244 |         'foo',
245 |         'barfoo',
246 |       ]);
247 |       expect(result.current.showSuggestions).toBe(true);
248 |     });
249 | 
250 |     it('hides suggestions when there are no matches', () => {
251 |       const history = ['alpha', 'beta'];
252 |       const { result } = renderHook(() =>
253 |         useReverseSearchCompletion(useTextBufferForTest('γ'), history, true),
254 |       );
255 | 
256 |       expect(result.current.suggestions).toEqual([]);
257 |       expect(result.current.showSuggestions).toBe(false);
258 |     });
259 |   });
260 | });
```

src/ui/hooks/useReverseSearchCompletion.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { useState, useEffect, useMemo, useCallback, useRef } from 'react';
8 | import { useCompletion } from './useCompletion.js';
9 | import type { TextBuffer } from '../components/shared/text-buffer.js';
10 | import type { Suggestion } from '../components/SuggestionsDisplay.js';
11 | 
12 | function useDebouncedValue<T>(value: T, delay = 200): T {
13 |   const [debounced, setDebounced] = useState(value);
14 |   useEffect(() => {
15 |     const handle = setTimeout(() => setDebounced(value), delay);
16 |     return () => clearTimeout(handle);
17 |   }, [value, delay]);
18 |   return debounced;
19 | }
20 | 
21 | export interface UseReverseSearchCompletionReturn {
22 |   suggestions: Suggestion[];
23 |   activeSuggestionIndex: number;
24 |   visibleStartIndex: number;
25 |   showSuggestions: boolean;
26 |   isLoadingSuggestions: boolean;
27 |   navigateUp: () => void;
28 |   navigateDown: () => void;
29 |   handleAutocomplete: (i: number) => void;
30 |   resetCompletionState: () => void;
31 | }
32 | 
33 | export function useReverseSearchCompletion(
34 |   buffer: TextBuffer,
35 |   history: readonly string[],
36 |   reverseSearchActive: boolean,
37 | ): UseReverseSearchCompletionReturn {
38 |   const {
39 |     suggestions,
40 |     activeSuggestionIndex,
41 |     visibleStartIndex,
42 |     showSuggestions,
43 |     isLoadingSuggestions,
44 |     setSuggestions,
45 |     setShowSuggestions,
46 |     setActiveSuggestionIndex,
47 |     resetCompletionState,
48 |     navigateUp,
49 |     navigateDown,
50 |     setVisibleStartIndex,
51 |   } = useCompletion();
52 | 
53 |   const debouncedQuery = useDebouncedValue(buffer.text, 100);
54 | 
55 |   // incremental search
56 |   const prevQueryRef = useRef<string>('');
57 |   const prevMatchesRef = useRef<Suggestion[]>([]);
58 | 
59 |   // Clear incremental cache when activating reverse search
60 |   useEffect(() => {
61 |     if (reverseSearchActive) {
62 |       prevQueryRef.current = '';
63 |       prevMatchesRef.current = [];
64 |     }
65 |   }, [reverseSearchActive]);
66 | 
67 |   // Also clear cache when history changes so new items are considered
68 |   useEffect(() => {
69 |     prevQueryRef.current = '';
70 |     prevMatchesRef.current = [];
71 |   }, [history]);
72 | 
73 |   const searchHistory = useCallback(
74 |     (query: string, items: readonly string[]) => {
75 |       const out: Suggestion[] = [];
76 |       for (let i = 0; i < items.length; i++) {
77 |         const cmd = items[i];
78 |         const idx = cmd.toLowerCase().indexOf(query);
79 |         if (idx !== -1) {
80 |           out.push({ label: cmd, value: cmd, matchedIndex: idx });
81 |         }
82 |       }
83 |       return out;
84 |     },
85 |     [],
86 |   );
87 | 
88 |   const matches = useMemo<Suggestion[]>(() => {
89 |     if (!reverseSearchActive) return [];
90 |     if (debouncedQuery.length === 0)
91 |       return history.map((cmd) => ({
92 |         label: cmd,
93 |         value: cmd,
94 |         matchedIndex: -1,
95 |       }));
96 | 
97 |     const query = debouncedQuery.toLowerCase();
98 |     const canUseCache =
99 |       prevQueryRef.current &&
100 |       query.startsWith(prevQueryRef.current) &&
101 |       prevMatchesRef.current.length > 0;
102 | 
103 |     const source = canUseCache
104 |       ? prevMatchesRef.current.map((m) => m.value)
105 |       : history;
106 | 
107 |     return searchHistory(query, source);
108 |   }, [debouncedQuery, history, reverseSearchActive, searchHistory]);
109 | 
110 |   useEffect(() => {
111 |     if (!reverseSearchActive) {
112 |       resetCompletionState();
113 |       return;
114 |     }
115 | 
116 |     setSuggestions(matches);
117 |     const hasAny = matches.length > 0;
118 |     setShowSuggestions(hasAny);
119 |     setActiveSuggestionIndex(hasAny ? 0 : -1);
120 |     setVisibleStartIndex(0);
121 | 
122 |     prevQueryRef.current = debouncedQuery.toLowerCase();
123 |     prevMatchesRef.current = matches;
124 |   }, [
125 |     debouncedQuery,
126 |     matches,
127 |     reverseSearchActive,
128 |     setSuggestions,
129 |     setShowSuggestions,
130 |     setActiveSuggestionIndex,
131 |     setVisibleStartIndex,
132 |     resetCompletionState,
133 |   ]);
134 | 
135 |   const handleAutocomplete = useCallback(
136 |     (i: number) => {
137 |       if (i < 0 || i >= suggestions.length) return;
138 |       buffer.setText(suggestions[i].value);
139 |       resetCompletionState();
140 |     },
141 |     [buffer, suggestions, resetCompletionState],
142 |   );
143 | 
144 |   return {
145 |     suggestions,
146 |     activeSuggestionIndex,
147 |     visibleStartIndex,
148 |     showSuggestions,
149 |     isLoadingSuggestions,
150 |     navigateUp,
151 |     navigateDown,
152 |     handleAutocomplete,
153 |     resetCompletionState,
154 |   };
155 | }
```

src/ui/hooks/useSelectionList.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
8 | import { renderHook, act } from '@testing-library/react';
9 | import {
10 |   useSelectionList,
11 |   type SelectionListItem,
12 | } from './useSelectionList.js';
13 | import { useKeypress } from './useKeypress.js';
14 | 
15 | import type { KeypressHandler, Key } from '../contexts/KeypressContext.js';
16 | 
17 | type UseKeypressMockOptions = { isActive: boolean };
18 | 
19 | vi.mock('./useKeypress.js');
20 | 
21 | let activeKeypressHandler: KeypressHandler | null = null;
22 | 
23 | describe('useSelectionList', () => {
24 |   const mockOnSelect = vi.fn();
25 |   const mockOnHighlight = vi.fn();
26 | 
27 |   const items: Array<SelectionListItem<string>> = [
28 |     { value: 'A', key: 'A' },
29 |     { value: 'B', disabled: true, key: 'B' },
30 |     { value: 'C', key: 'C' },
31 |     { value: 'D', key: 'D' },
32 |   ];
33 | 
34 |   beforeEach(() => {
35 |     activeKeypressHandler = null;
36 |     vi.mocked(useKeypress).mockImplementation(
37 |       (handler: KeypressHandler, options?: UseKeypressMockOptions) => {
38 |         if (options?.isActive) {
39 |           activeKeypressHandler = handler;
40 |         } else {
41 |           activeKeypressHandler = null;
42 |         }
43 |       },
44 |     );
45 |     mockOnSelect.mockClear();
46 |     mockOnHighlight.mockClear();
47 |   });
48 | 
49 |   const pressKey = (name: string, sequence: string = name) => {
50 |     act(() => {
51 |       if (activeKeypressHandler) {
52 |         const key: Key = {
53 |           name,
54 |           sequence,
55 |           ctrl: false,
56 |           meta: false,
57 |           shift: false,
58 |           paste: false,
59 |         };
60 |         activeKeypressHandler(key);
61 |       } else {
62 |         throw new Error(
63 |           `Test attempted to press key (${name}) but the keypress handler is not active. Ensure the hook is focused (isFocused=true) and the list is not empty.`,
64 |         );
65 |       }
66 |     });
67 |   };
68 | 
69 |   describe('Initialization', () => {
70 |     it('should initialize with the default index (0) if enabled', () => {
71 |       const { result } = renderHook(() =>
72 |         useSelectionList({ items, onSelect: mockOnSelect }),
73 |       );
74 |       expect(result.current.activeIndex).toBe(0);
75 |     });
76 | 
77 |     it('should initialize with the provided initialIndex if enabled', () => {
78 |       const { result } = renderHook(() =>
79 |         useSelectionList({
80 |           items,
81 |           initialIndex: 2,
82 |           onSelect: mockOnSelect,
83 |         }),
84 |       );
85 |       expect(result.current.activeIndex).toBe(2);
86 |     });
87 | 
88 |     it('should handle an empty list gracefully', () => {
89 |       const { result } = renderHook(() =>
90 |         useSelectionList({ items: [], onSelect: mockOnSelect }),
91 |       );
92 |       expect(result.current.activeIndex).toBe(0);
93 |     });
94 | 
95 |     it('should find the next enabled item (downwards) if initialIndex is disabled', () => {
96 |       const { result } = renderHook(() =>
97 |         useSelectionList({
98 |           items,
99 |           initialIndex: 1,
100 |           onSelect: mockOnSelect,
101 |         }),
102 |       );
103 |       expect(result.current.activeIndex).toBe(2);
104 |     });
105 | 
106 |     it('should wrap around to find the next enabled item if initialIndex is disabled', () => {
107 |       const wrappingItems = [
108 |         { value: 'A', key: 'A' },
109 |         { value: 'B', disabled: true, key: 'B' },
110 |         { value: 'C', disabled: true, key: 'C' },
111 |       ];
112 |       const { result } = renderHook(() =>
113 |         useSelectionList({
114 |           items: wrappingItems,
115 |           initialIndex: 2,
116 |           onSelect: mockOnSelect,
117 |         }),
118 |       );
119 |       expect(result.current.activeIndex).toBe(0);
120 |     });
121 | 
122 |     it('should default to 0 if initialIndex is out of bounds', () => {
123 |       const { result } = renderHook(() =>
124 |         useSelectionList({
125 |           items,
126 |           initialIndex: 10,
127 |           onSelect: mockOnSelect,
128 |         }),
129 |       );
130 |       expect(result.current.activeIndex).toBe(0);
131 | 
132 |       const { result: resultNeg } = renderHook(() =>
133 |         useSelectionList({
134 |           items,
135 |           initialIndex: -1,
136 |           onSelect: mockOnSelect,
137 |         }),
138 |       );
139 |       expect(resultNeg.current.activeIndex).toBe(0);
140 |     });
141 | 
142 |     it('should stick to the initial index if all items are disabled', () => {
143 |       const allDisabled = [
144 |         { value: 'A', disabled: true, key: 'A' },
145 |         { value: 'B', disabled: true, key: 'B' },
146 |       ];
147 |       const { result } = renderHook(() =>
148 |         useSelectionList({
149 |           items: allDisabled,
150 |           initialIndex: 1,
151 |           onSelect: mockOnSelect,
152 |         }),
153 |       );
154 |       expect(result.current.activeIndex).toBe(1);
155 |     });
156 |   });
157 | 
158 |   describe('Keyboard Navigation (Up/Down/J/K)', () => {
159 |     it('should move down with "j" and "down" keys, skipping disabled items', () => {
160 |       const { result } = renderHook(() =>
161 |         useSelectionList({ items, onSelect: mockOnSelect }),
162 |       );
163 |       expect(result.current.activeIndex).toBe(0);
164 |       pressKey('j');
165 |       expect(result.current.activeIndex).toBe(2);
166 |       pressKey('down');
167 |       expect(result.current.activeIndex).toBe(3);
168 |     });
169 | 
170 |     it('should move up with "k" and "up" keys, skipping disabled items', () => {
171 |       const { result } = renderHook(() =>
172 |         useSelectionList({ items, initialIndex: 3, onSelect: mockOnSelect }),
173 |       );
174 |       expect(result.current.activeIndex).toBe(3);
175 |       pressKey('k');
176 |       expect(result.current.activeIndex).toBe(2);
177 |       pressKey('up');
178 |       expect(result.current.activeIndex).toBe(0);
179 |     });
180 | 
181 |     it('should wrap navigation correctly', () => {
182 |       const { result } = renderHook(() =>
183 |         useSelectionList({
184 |           items,
185 |           initialIndex: items.length - 1,
186 |           onSelect: mockOnSelect,
187 |         }),
188 |       );
189 |       expect(result.current.activeIndex).toBe(3);
190 |       pressKey('down');
191 |       expect(result.current.activeIndex).toBe(0);
192 | 
193 |       pressKey('up');
194 |       expect(result.current.activeIndex).toBe(3);
195 |     });
196 | 
197 |     it('should call onHighlight when index changes', () => {
198 |       renderHook(() =>
199 |         useSelectionList({
200 |           items,
201 |           onSelect: mockOnSelect,
202 |           onHighlight: mockOnHighlight,
203 |         }),
204 |       );
205 |       pressKey('down');
206 |       expect(mockOnHighlight).toHaveBeenCalledTimes(1);
207 |       expect(mockOnHighlight).toHaveBeenCalledWith('C');
208 |     });
209 | 
210 |     it('should not move or call onHighlight if navigation results in the same index (e.g., single item)', () => {
211 |       const singleItem = [{ value: 'A', key: 'A' }];
212 |       const { result } = renderHook(() =>
213 |         useSelectionList({
214 |           items: singleItem,
215 |           onSelect: mockOnSelect,
216 |           onHighlight: mockOnHighlight,
217 |         }),
218 |       );
219 |       pressKey('down');
220 |       expect(result.current.activeIndex).toBe(0);
221 |       expect(mockOnHighlight).not.toHaveBeenCalled();
222 |     });
223 | 
224 |     it('should not move or call onHighlight if all items are disabled', () => {
225 |       const allDisabled = [
226 |         { value: 'A', disabled: true, key: 'A' },
227 |         { value: 'B', disabled: true, key: 'B' },
228 |       ];
229 |       const { result } = renderHook(() =>
230 |         useSelectionList({
231 |           items: allDisabled,
232 |           onSelect: mockOnSelect,
233 |           onHighlight: mockOnHighlight,
234 |         }),
235 |       );
236 |       const initialIndex = result.current.activeIndex;
237 |       pressKey('down');
238 |       expect(result.current.activeIndex).toBe(initialIndex);
239 |       expect(mockOnHighlight).not.toHaveBeenCalled();
240 |     });
241 |   });
242 | 
243 |   describe('Selection (Enter)', () => {
244 |     it('should call onSelect when "return" is pressed on enabled item', () => {
245 |       renderHook(() =>
246 |         useSelectionList({
247 |           items,
248 |           initialIndex: 2,
249 |           onSelect: mockOnSelect,
250 |         }),
251 |       );
252 |       pressKey('return');
253 |       expect(mockOnSelect).toHaveBeenCalledTimes(1);
254 |       expect(mockOnSelect).toHaveBeenCalledWith('C');
255 |     });
256 | 
257 |     it('should not call onSelect if the active item is disabled', () => {
258 |       const { result } = renderHook(() =>
259 |         useSelectionList({
260 |           items,
261 |           onSelect: mockOnSelect,
262 |         }),
263 |       );
264 | 
265 |       act(() => result.current.setActiveIndex(1));
266 | 
267 |       pressKey('return');
268 |       expect(mockOnSelect).not.toHaveBeenCalled();
269 |     });
270 |   });
271 | 
272 |   describe('Keyboard Navigation Robustness (Rapid Input)', () => {
273 |     it('should handle rapid navigation and selection robustly (avoiding stale state)', () => {
274 |       const { result } = renderHook(() =>
275 |         useSelectionList({
276 |           items, // A, B(disabled), C, D. Initial index 0 (A).
277 |           onSelect: mockOnSelect,
278 |           onHighlight: mockOnHighlight,
279 |         }),
280 |       );
281 | 
282 |       // Simulate rapid inputs with separate act blocks to allow effects to run
283 |       if (!activeKeypressHandler) throw new Error('Handler not active');
284 | 
285 |       const handler = activeKeypressHandler;
286 | 
287 |       const press = (name: string) => {
288 |         const key: Key = {
289 |           name,
290 |           sequence: name,
291 |           ctrl: false,
292 |           meta: false,
293 |           shift: false,
294 |           paste: false,
295 |         };
296 |         handler(key);
297 |       };
298 | 
299 |       // 1. Press Down. Should move 0 (A) -> 2 (C).
300 |       act(() => {
301 |         press('down');
302 |       });
303 |       // 2. Press Down again. Should move 2 (C) -> 3 (D).
304 |       act(() => {
305 |         press('down');
306 |       });
307 |       // 3. Press Enter. Should select D.
308 |       act(() => {
309 |         press('return');
310 |       });
311 | 
312 |       expect(result.current.activeIndex).toBe(3);
313 | 
314 |       expect(mockOnHighlight).toHaveBeenCalledTimes(2);
315 |       expect(mockOnHighlight).toHaveBeenNthCalledWith(1, 'C');
316 |       expect(mockOnHighlight).toHaveBeenNthCalledWith(2, 'D');
317 | 
318 |       expect(mockOnSelect).toHaveBeenCalledTimes(1);
319 |       expect(mockOnSelect).toHaveBeenCalledWith('D');
320 |       expect(mockOnSelect).not.toHaveBeenCalledWith('A');
321 |     });
322 | 
323 |     it('should handle ultra-rapid input (multiple presses in single act) without stale state', () => {
324 |       const { result } = renderHook(() =>
325 |         useSelectionList({
326 |           items, // A, B(disabled), C, D. Initial index 0 (A).
327 |           onSelect: mockOnSelect,
328 |           onHighlight: mockOnHighlight,
329 |         }),
330 |       );
331 | 
332 |       // Simulate ultra-rapid inputs where all keypresses happen faster than React can re-render
333 |       act(() => {
334 |         if (!activeKeypressHandler) throw new Error('Handler not active');
335 | 
336 |         const handler = activeKeypressHandler;
337 | 
338 |         const press = (name: string) => {
339 |           const key: Key = {
340 |             name,
341 |             sequence: name,
342 |             ctrl: false,
343 |             meta: false,
344 |             shift: false,
345 |             paste: false,
346 |           };
347 |           handler(key);
348 |         };
349 | 
350 |         // All presses happen in same render cycle - React batches the state updates
351 |         press('down'); // Should move 0 (A) -> 2 (C)
352 |         press('down'); // Should move 2 (C) -> 3 (D)
353 |         press('return'); // Should select D
354 |       });
355 | 
356 |       expect(result.current.activeIndex).toBe(3);
357 | 
358 |       expect(mockOnHighlight).toHaveBeenCalledWith('D');
359 |       expect(mockOnSelect).toHaveBeenCalledTimes(1);
360 |       expect(mockOnSelect).toHaveBeenCalledWith('D');
361 |     });
362 |   });
363 | 
364 |   describe('Focus Management (isFocused)', () => {
365 |     it('should activate the keypress handler when focused (default) and items exist', () => {
366 |       const { result } = renderHook(() =>
367 |         useSelectionList({ items, onSelect: mockOnSelect }),
368 |       );
369 |       expect(activeKeypressHandler).not.toBeNull();
370 |       pressKey('down');
371 |       expect(result.current.activeIndex).toBe(2);
372 |     });
373 | 
374 |     it('should not activate the keypress handler when isFocused is false', () => {
375 |       renderHook(() =>
376 |         useSelectionList({ items, onSelect: mockOnSelect, isFocused: false }),
377 |       );
378 |       expect(activeKeypressHandler).toBeNull();
379 |       expect(() => pressKey('down')).toThrow(/keypress handler is not active/);
380 |     });
381 | 
[TRUNCATED]
```

src/ui/hooks/useSelectionList.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { useReducer, useRef, useEffect, useCallback } from 'react';
8 | import { useKeypress, type Key } from './useKeypress.js';
9 | 
10 | export interface SelectionListItem<T> {
11 |   key: string;
12 |   value: T;
13 |   disabled?: boolean;
14 | }
15 | 
16 | interface BaseSelectionItem {
17 |   key: string;
18 |   disabled?: boolean;
19 | }
20 | 
21 | export interface UseSelectionListOptions<T> {
22 |   items: Array<SelectionListItem<T>>;
23 |   initialIndex?: number;
24 |   onSelect: (value: T) => void;
25 |   onHighlight?: (value: T) => void;
26 |   isFocused?: boolean;
27 |   showNumbers?: boolean;
28 | }
29 | 
30 | export interface UseSelectionListResult {
31 |   activeIndex: number;
32 |   setActiveIndex: (index: number) => void;
33 | }
34 | 
35 | interface SelectionListState {
36 |   activeIndex: number;
37 |   initialIndex: number;
38 |   pendingHighlight: boolean;
39 |   pendingSelect: boolean;
40 |   items: BaseSelectionItem[];
41 | }
42 | 
43 | type SelectionListAction =
44 |   | {
45 |       type: 'SET_ACTIVE_INDEX';
46 |       payload: {
47 |         index: number;
48 |       };
49 |     }
50 |   | {
51 |       type: 'MOVE_UP';
52 |     }
53 |   | {
54 |       type: 'MOVE_DOWN';
55 |     }
56 |   | {
57 |       type: 'SELECT_CURRENT';
58 |     }
59 |   | {
60 |       type: 'INITIALIZE';
61 |       payload: { initialIndex: number; items: BaseSelectionItem[] };
62 |     }
63 |   | {
64 |       type: 'CLEAR_PENDING_FLAGS';
65 |     };
66 | 
67 | const NUMBER_INPUT_TIMEOUT_MS = 1000;
68 | 
69 | /**
70 |  * Helper function to find the next enabled index in a given direction, supporting wrapping.
71 |  */
72 | const findNextValidIndex = (
73 |   currentIndex: number,
74 |   direction: 'up' | 'down',
75 |   items: BaseSelectionItem[],
76 | ): number => {
77 |   const len = items.length;
78 |   if (len === 0) return currentIndex;
79 | 
80 |   let nextIndex = currentIndex;
81 |   const step = direction === 'down' ? 1 : -1;
82 | 
83 |   for (let i = 0; i < len; i++) {
84 |     // Calculate the next index, wrapping around if necessary.
85 |     // We add `len` before the modulo to ensure a positive result in JS for negative steps.
86 |     nextIndex = (nextIndex + step + len) % len;
87 | 
88 |     if (!items[nextIndex]?.disabled) {
89 |       return nextIndex;
90 |     }
91 |   }
92 | 
93 |   // If all items are disabled, return the original index
94 |   return currentIndex;
95 | };
96 | 
97 | const computeInitialIndex = (
98 |   initialIndex: number,
99 |   items: BaseSelectionItem[],
100 |   initialKey?: string,
101 | ): number => {
102 |   if (items.length === 0) {
103 |     return 0;
104 |   }
105 | 
106 |   if (initialKey !== undefined) {
107 |     for (let i = 0; i < items.length; i++) {
108 |       if (items[i]!.key === initialKey && !items[i]!.disabled) {
109 |         return i;
110 |       }
111 |     }
112 |   }
113 | 
114 |   let targetIndex = initialIndex;
115 | 
116 |   if (targetIndex < 0 || targetIndex >= items.length) {
117 |     targetIndex = 0;
118 |   }
119 | 
120 |   if (items[targetIndex]?.disabled) {
121 |     const nextValid = findNextValidIndex(targetIndex, 'down', items);
122 |     targetIndex = nextValid;
123 |   }
124 | 
125 |   return targetIndex;
126 | };
127 | 
128 | function selectionListReducer(
129 |   state: SelectionListState,
130 |   action: SelectionListAction,
131 | ): SelectionListState {
132 |   switch (action.type) {
133 |     case 'SET_ACTIVE_INDEX': {
134 |       const { index } = action.payload;
135 |       const { items } = state;
136 | 
137 |       // Only update if index actually changed and is valid
138 |       if (index === state.activeIndex) {
139 |         return state;
140 |       }
141 | 
142 |       if (index >= 0 && index < items.length) {
143 |         return { ...state, activeIndex: index, pendingHighlight: true };
144 |       }
145 |       return state;
146 |     }
147 | 
148 |     case 'MOVE_UP': {
149 |       const { items } = state;
150 |       const newIndex = findNextValidIndex(state.activeIndex, 'up', items);
151 |       if (newIndex !== state.activeIndex) {
152 |         return { ...state, activeIndex: newIndex, pendingHighlight: true };
153 |       }
154 |       return state;
155 |     }
156 | 
157 |     case 'MOVE_DOWN': {
158 |       const { items } = state;
159 |       const newIndex = findNextValidIndex(state.activeIndex, 'down', items);
160 |       if (newIndex !== state.activeIndex) {
161 |         return { ...state, activeIndex: newIndex, pendingHighlight: true };
162 |       }
163 |       return state;
164 |     }
165 | 
166 |     case 'SELECT_CURRENT': {
167 |       return { ...state, pendingSelect: true };
168 |     }
169 | 
170 |     case 'INITIALIZE': {
171 |       const { initialIndex, items } = action.payload;
172 |       const activeKey =
173 |         initialIndex === state.initialIndex &&
174 |         state.activeIndex !== state.initialIndex
175 |           ? state.items[state.activeIndex]?.key
176 |           : undefined;
177 | 
178 |       // We don't need to check for equality here anymore as it is handled in the effect
179 |       const targetIndex = computeInitialIndex(initialIndex, items, activeKey);
180 | 
181 |       return {
182 |         ...state,
183 |         items,
184 |         initialIndex,
185 |         activeIndex: targetIndex,
186 |         pendingHighlight: false,
187 |       };
188 |     }
189 | 
190 |     case 'CLEAR_PENDING_FLAGS': {
191 |       return {
192 |         ...state,
193 |         pendingHighlight: false,
194 |         pendingSelect: false,
195 |       };
196 |     }
197 | 
198 |     default: {
199 |       const exhaustiveCheck: never = action;
200 |       console.error(`Unknown selection list action: ${exhaustiveCheck}`);
201 |       return state;
202 |     }
203 |   }
204 | }
205 | 
206 | function areBaseItemsEqual(
207 |   a: BaseSelectionItem[],
208 |   b: BaseSelectionItem[],
209 | ): boolean {
210 |   if (a === b) return true;
211 |   if (a.length !== b.length) return false;
212 | 
213 |   for (let i = 0; i < a.length; i++) {
214 |     if (a[i]!.key !== b[i]!.key || a[i]!.disabled !== b[i]!.disabled) {
215 |       return false;
216 |     }
217 |   }
218 | 
219 |   return true;
220 | }
221 | 
222 | function toBaseItems<T>(
223 |   items: Array<SelectionListItem<T>>,
224 | ): BaseSelectionItem[] {
225 |   return items.map(({ key, disabled }) => ({ key, disabled }));
226 | }
227 | 
228 | /**
229 |  * A headless hook that provides keyboard navigation and selection logic
230 |  * for list-based selection components like radio buttons and menus.
231 |  *
232 |  * Features:
233 |  * - Keyboard navigation with j/k and arrow keys
234 |  * - Selection with Enter key
235 |  * - Numeric quick selection (when showNumbers is true)
236 |  * - Handles disabled items (skips them during navigation)
237 |  * - Wrapping navigation (last to first, first to last)
238 |  */
239 | export function useSelectionList<T>({
240 |   items,
241 |   initialIndex = 0,
242 |   onSelect,
243 |   onHighlight,
244 |   isFocused = true,
245 |   showNumbers = false,
246 | }: UseSelectionListOptions<T>): UseSelectionListResult {
247 |   const baseItems = toBaseItems(items);
248 | 
249 |   const [state, dispatch] = useReducer(selectionListReducer, {
250 |     activeIndex: computeInitialIndex(initialIndex, baseItems),
251 |     initialIndex,
252 |     pendingHighlight: false,
253 |     pendingSelect: false,
254 |     items: baseItems,
255 |   });
256 |   const numberInputRef = useRef('');
257 |   const numberInputTimer = useRef<NodeJS.Timeout | null>(null);
258 | 
259 |   const prevBaseItemsRef = useRef(baseItems);
260 |   const prevInitialIndexRef = useRef(initialIndex);
261 | 
262 |   // Initialize/synchronize state when initialIndex or items change
263 |   useEffect(() => {
264 |     const baseItemsChanged = !areBaseItemsEqual(
265 |       prevBaseItemsRef.current,
266 |       baseItems,
267 |     );
268 |     const initialIndexChanged = prevInitialIndexRef.current !== initialIndex;
269 | 
270 |     if (baseItemsChanged || initialIndexChanged) {
271 |       dispatch({
272 |         type: 'INITIALIZE',
273 |         payload: { initialIndex, items: baseItems },
274 |       });
275 |       prevBaseItemsRef.current = baseItems;
276 |       prevInitialIndexRef.current = initialIndex;
277 |     }
278 |   });
279 | 
280 |   // Handle side effects based on state changes
281 |   useEffect(() => {
282 |     let needsClear = false;
283 | 
284 |     if (state.pendingHighlight && items[state.activeIndex]) {
285 |       onHighlight?.(items[state.activeIndex]!.value);
286 |       needsClear = true;
287 |     }
288 | 
289 |     if (state.pendingSelect && items[state.activeIndex]) {
290 |       const currentItem = items[state.activeIndex];
291 |       if (currentItem && !currentItem.disabled) {
292 |         onSelect(currentItem.value);
293 |       }
294 |       needsClear = true;
295 |     }
296 | 
297 |     if (needsClear) {
298 |       dispatch({ type: 'CLEAR_PENDING_FLAGS' });
299 |     }
300 |   }, [
301 |     state.pendingHighlight,
302 |     state.pendingSelect,
303 |     state.activeIndex,
304 |     items,
305 |     onHighlight,
306 |     onSelect,
307 |   ]);
308 | 
309 |   useEffect(
310 |     () => () => {
311 |       if (numberInputTimer.current) {
312 |         clearTimeout(numberInputTimer.current);
313 |       }
314 |     },
315 |     [],
316 |   );
317 | 
318 |   const itemsLength = items.length;
319 |   const handleKeypress = useCallback(
320 |     (key: Key) => {
321 |       const { sequence, name } = key;
322 |       const isNumeric = showNumbers && /^[0-9]$/.test(sequence);
323 | 
324 |       // Clear number input buffer on non-numeric key press
325 |       if (!isNumeric && numberInputTimer.current) {
326 |         clearTimeout(numberInputTimer.current);
327 |         numberInputRef.current = '';
328 |       }
329 | 
330 |       if (name === 'k' || name === 'up') {
331 |         dispatch({ type: 'MOVE_UP' });
332 |         return;
333 |       }
334 | 
335 |       if (name === 'j' || name === 'down') {
336 |         dispatch({ type: 'MOVE_DOWN' });
337 |         return;
338 |       }
339 | 
340 |       if (name === 'return') {
341 |         dispatch({ type: 'SELECT_CURRENT' });
342 |         return;
343 |       }
344 | 
345 |       // Handle numeric input for quick selection
346 |       if (isNumeric) {
347 |         if (numberInputTimer.current) {
348 |           clearTimeout(numberInputTimer.current);
349 |         }
350 | 
351 |         const newNumberInput = numberInputRef.current + sequence;
352 |         numberInputRef.current = newNumberInput;
353 | 
354 |         const targetIndex = Number.parseInt(newNumberInput, 10) - 1;
355 | 
356 |         // Single '0' is invalid (1-indexed)
357 |         if (newNumberInput === '0') {
358 |           numberInputTimer.current = setTimeout(() => {
359 |             numberInputRef.current = '';
360 |           }, NUMBER_INPUT_TIMEOUT_MS);
361 |           return;
362 |         }
363 | 
364 |         if (targetIndex >= 0 && targetIndex < itemsLength) {
365 |           dispatch({
366 |             type: 'SET_ACTIVE_INDEX',
367 |             payload: { index: targetIndex },
368 |           });
369 | 
370 |           // If the number can't be a prefix for another valid number, select immediately
371 |           const potentialNextNumber = Number.parseInt(newNumberInput + '0', 10);
372 |           if (potentialNextNumber > itemsLength) {
373 |             dispatch({
374 |               type: 'SELECT_CURRENT',
375 |             });
376 |             numberInputRef.current = '';
377 |           } else {
378 |             // Otherwise wait for more input or timeout
379 |             numberInputTimer.current = setTimeout(() => {
380 |               dispatch({
381 |                 type: 'SELECT_CURRENT',
382 |               });
383 |               numberInputRef.current = '';
384 |             }, NUMBER_INPUT_TIMEOUT_MS);
385 |           }
386 |         } else {
387 |           // Number is out of bounds
388 |           numberInputRef.current = '';
389 |         }
390 |       }
391 |     },
392 |     [dispatch, itemsLength, showNumbers],
393 |   );
394 | 
395 |   useKeypress(handleKeypress, { isActive: !!(isFocused && itemsLength > 0) });
396 | 
397 |   const setActiveIndex = (index: number) => {
398 |     dispatch({
399 |       type: 'SET_ACTIVE_INDEX',
400 |       payload: { index },
401 |     });
402 |   };
403 | 
404 |   return {
405 |     activeIndex: state.activeIndex,
406 |     setActiveIndex,
407 |   };
408 | }
```

src/ui/hooks/useSettingsCommand.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { useState, useCallback } from 'react';
8 | 
9 | export function useSettingsCommand() {
10 |   const [isSettingsDialogOpen, setIsSettingsDialogOpen] = useState(false);
11 | 
12 |   const openSettingsDialog = useCallback(() => {
13 |     setIsSettingsDialogOpen(true);
14 |   }, []);
15 | 
16 |   const closeSettingsDialog = useCallback(() => {
17 |     setIsSettingsDialogOpen(false);
18 |   }, []);
19 | 
20 |   return {
21 |     isSettingsDialogOpen,
22 |     openSettingsDialog,
23 |     closeSettingsDialog,
24 |   };
25 | }
```

src/ui/hooks/useShellHistory.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { renderHook, act, waitFor } from '@testing-library/react';
8 | import { useShellHistory } from './useShellHistory.js';
9 | import * as fs from 'node:fs/promises';
10 | import * as path from 'node:path';
11 | import * as os from 'node:os';
12 | import * as crypto from 'node:crypto';
13 | 
14 | vi.mock('fs/promises', () => ({
15 |   readFile: vi.fn(),
16 |   writeFile: vi.fn(),
17 |   mkdir: vi.fn(),
18 | }));
19 | vi.mock('os');
20 | vi.mock('crypto');
21 | vi.mock('fs', async (importOriginal) => {
22 |   const actualFs = await importOriginal<typeof import('fs')>();
23 |   return {
24 |     ...actualFs,
25 |     mkdirSync: vi.fn(),
26 |   };
27 | });
28 | vi.mock('@google/gemini-cli-core', () => {
29 |   class Storage {
30 |     getProjectTempDir(): string {
31 |       return path.join('/test/home/', '.gemini', 'tmp', 'mocked_hash');
32 |     }
33 |     getHistoryFilePath(): string {
34 |       return path.join(
35 |         '/test/home/',
36 |         '.gemini',
37 |         'tmp',
38 |         'mocked_hash',
39 |         'shell_history',
40 |       );
41 |     }
42 |   }
43 |   return {
44 |     isNodeError: (err: unknown): err is NodeJS.ErrnoException =>
45 |       typeof err === 'object' && err !== null && 'code' in err,
46 |     Storage,
47 |   };
48 | });
49 | 
50 | const MOCKED_PROJECT_ROOT = '/test/project';
51 | const MOCKED_HOME_DIR = '/test/home';
52 | const MOCKED_PROJECT_HASH = 'mocked_hash';
53 | 
54 | const MOCKED_HISTORY_DIR = path.join(
55 |   MOCKED_HOME_DIR,
56 |   '.gemini',
57 |   'tmp',
58 |   MOCKED_PROJECT_HASH,
59 | );
60 | const MOCKED_HISTORY_FILE = path.join(MOCKED_HISTORY_DIR, 'shell_history');
61 | 
62 | describe('useShellHistory', () => {
63 |   const mockedFs = vi.mocked(fs);
64 |   const mockedOs = vi.mocked(os);
65 |   const mockedCrypto = vi.mocked(crypto);
66 | 
67 |   beforeEach(() => {
68 |     vi.resetAllMocks();
69 | 
70 |     mockedFs.readFile.mockResolvedValue('');
71 |     mockedFs.writeFile.mockResolvedValue(undefined);
72 |     mockedFs.mkdir.mockResolvedValue(undefined);
73 |     mockedOs.homedir.mockReturnValue(MOCKED_HOME_DIR);
74 | 
75 |     const hashMock = {
76 |       update: vi.fn().mockReturnThis(),
77 |       digest: vi.fn().mockReturnValue(MOCKED_PROJECT_HASH),
78 |     };
79 |     mockedCrypto.createHash.mockReturnValue(hashMock as never);
80 |   });
81 | 
82 |   it('should initialize and read the history file from the correct path', async () => {
83 |     mockedFs.readFile.mockResolvedValue('cmd1\ncmd2');
84 |     const { result } = renderHook(() => useShellHistory(MOCKED_PROJECT_ROOT));
85 | 
86 |     await waitFor(() => {
87 |       expect(mockedFs.readFile).toHaveBeenCalledWith(
88 |         MOCKED_HISTORY_FILE,
89 |         'utf-8',
90 |       );
91 |     });
92 | 
93 |     let command: string | null = null;
94 |     act(() => {
95 |       command = result.current.getPreviousCommand();
96 |     });
97 | 
98 |     // History is loaded newest-first: ['cmd2', 'cmd1']
99 |     expect(command).toBe('cmd2');
100 |   });
101 | 
102 |   it('should handle a nonexistent history file gracefully', async () => {
103 |     const error = new Error('File not found') as NodeJS.ErrnoException;
104 |     error.code = 'ENOENT';
105 |     mockedFs.readFile.mockRejectedValue(error);
106 | 
107 |     const { result } = renderHook(() => useShellHistory(MOCKED_PROJECT_ROOT));
108 | 
109 |     await waitFor(() => {
110 |       expect(mockedFs.readFile).toHaveBeenCalled();
111 |     });
112 | 
113 |     let command: string | null = null;
114 |     act(() => {
115 |       command = result.current.getPreviousCommand();
116 |     });
117 | 
118 |     expect(command).toBe(null);
119 |   });
120 | 
121 |   it('should add a command and write to the history file', async () => {
122 |     const { result } = renderHook(() => useShellHistory(MOCKED_PROJECT_ROOT));
123 | 
124 |     await waitFor(() => expect(mockedFs.readFile).toHaveBeenCalled());
125 | 
126 |     act(() => {
127 |       result.current.addCommandToHistory('new_command');
128 |     });
129 | 
130 |     await waitFor(() => {
131 |       expect(mockedFs.mkdir).toHaveBeenCalledWith(MOCKED_HISTORY_DIR, {
132 |         recursive: true,
133 |       });
134 |       expect(mockedFs.writeFile).toHaveBeenCalledWith(
135 |         MOCKED_HISTORY_FILE,
136 |         'new_command', // Written to file oldest-first.
137 |       );
138 |     });
139 | 
140 |     let command: string | null = null;
141 |     act(() => {
142 |       command = result.current.getPreviousCommand();
143 |     });
144 |     expect(command).toBe('new_command');
145 |   });
146 | 
147 |   it('should navigate history correctly with previous/next commands', async () => {
148 |     mockedFs.readFile.mockResolvedValue('cmd1\ncmd2\ncmd3');
149 |     const { result } = renderHook(() => useShellHistory(MOCKED_PROJECT_ROOT));
150 | 
151 |     // Wait for history to be loaded: ['cmd3', 'cmd2', 'cmd1']
152 |     await waitFor(() => expect(mockedFs.readFile).toHaveBeenCalled());
153 | 
154 |     let command: string | null = null;
155 | 
156 |     act(() => {
157 |       command = result.current.getPreviousCommand();
158 |     });
159 |     expect(command).toBe('cmd3');
160 | 
161 |     act(() => {
162 |       command = result.current.getPreviousCommand();
163 |     });
164 |     expect(command).toBe('cmd2');
165 | 
166 |     act(() => {
167 |       command = result.current.getPreviousCommand();
168 |     });
169 |     expect(command).toBe('cmd1');
170 | 
171 |     // Should stay at the oldest command
172 |     act(() => {
173 |       command = result.current.getPreviousCommand();
174 |     });
175 |     expect(command).toBe('cmd1');
176 | 
177 |     act(() => {
178 |       command = result.current.getNextCommand();
179 |     });
180 |     expect(command).toBe('cmd2');
181 | 
182 |     act(() => {
183 |       command = result.current.getNextCommand();
184 |     });
185 |     expect(command).toBe('cmd3');
186 | 
187 |     // Should return to the "new command" line (represented as empty string)
188 |     act(() => {
189 |       command = result.current.getNextCommand();
190 |     });
191 |     expect(command).toBe('');
192 |   });
193 | 
194 |   it('should not add empty or whitespace-only commands to history', async () => {
195 |     const { result } = renderHook(() => useShellHistory(MOCKED_PROJECT_ROOT));
196 |     await waitFor(() => expect(mockedFs.readFile).toHaveBeenCalled());
197 | 
198 |     act(() => {
199 |       result.current.addCommandToHistory('   ');
200 |     });
201 | 
202 |     expect(mockedFs.writeFile).not.toHaveBeenCalled();
203 |   });
204 | 
205 |   it('should truncate history to MAX_HISTORY_LENGTH (100)', async () => {
206 |     const oldCommands = Array.from({ length: 120 }, (_, i) => `old_cmd_${i}`);
207 |     mockedFs.readFile.mockResolvedValue(oldCommands.join('\n'));
208 | 
209 |     const { result } = renderHook(() => useShellHistory(MOCKED_PROJECT_ROOT));
210 |     await waitFor(() => expect(mockedFs.readFile).toHaveBeenCalled());
211 | 
212 |     act(() => {
213 |       result.current.addCommandToHistory('new_cmd');
214 |     });
215 | 
216 |     // Wait for the async write to happen and then inspect the arguments.
217 |     await waitFor(() => expect(mockedFs.writeFile).toHaveBeenCalled());
218 | 
219 |     // The hook stores history newest-first.
220 |     // Initial state: ['old_cmd_119', ..., 'old_cmd_0']
221 |     // After adding 'new_cmd': ['new_cmd', 'old_cmd_119', ..., 'old_cmd_21'] (100 items)
222 |     // Written to file (reversed): ['old_cmd_21', ..., 'old_cmd_119', 'new_cmd']
223 |     const writtenContent = mockedFs.writeFile.mock.calls[0][1] as string;
224 |     const writtenLines = writtenContent.split('\n');
225 | 
226 |     expect(writtenLines.length).toBe(100);
227 |     expect(writtenLines[0]).toBe('old_cmd_21'); // New oldest command
228 |     expect(writtenLines[99]).toBe('new_cmd'); // Newest command
229 |   });
230 | 
231 |   it('should move an existing command to the top when re-added', async () => {
232 |     mockedFs.readFile.mockResolvedValue('cmd1\ncmd2\ncmd3');
233 |     const { result } = renderHook(() => useShellHistory(MOCKED_PROJECT_ROOT));
234 | 
235 |     // Initial state: ['cmd3', 'cmd2', 'cmd1']
236 |     await waitFor(() => expect(mockedFs.readFile).toHaveBeenCalled());
237 | 
238 |     act(() => {
239 |       result.current.addCommandToHistory('cmd1');
240 |     });
241 | 
242 |     // After re-adding 'cmd1': ['cmd1', 'cmd3', 'cmd2']
243 |     // Written to file (reversed): ['cmd2', 'cmd3', 'cmd1']
244 |     await waitFor(() => expect(mockedFs.writeFile).toHaveBeenCalled());
245 | 
246 |     const writtenContent = mockedFs.writeFile.mock.calls[0][1] as string;
247 |     const writtenLines = writtenContent.split('\n');
248 | 
249 |     expect(writtenLines).toEqual(['cmd2', 'cmd3', 'cmd1']);
250 |   });
251 | });
```

src/ui/hooks/useShellHistory.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { useState, useEffect, useCallback } from 'react';
8 | import * as fs from 'node:fs/promises';
9 | import * as path from 'node:path';
10 | import { isNodeError, Storage } from '@google/gemini-cli-core';
11 | 
12 | const MAX_HISTORY_LENGTH = 100;
13 | 
14 | export interface UseShellHistoryReturn {
15 |   history: string[];
16 |   addCommandToHistory: (command: string) => void;
17 |   getPreviousCommand: () => string | null;
18 |   getNextCommand: () => string | null;
19 |   resetHistoryPosition: () => void;
20 | }
21 | 
22 | async function getHistoryFilePath(
23 |   projectRoot: string,
24 |   configStorage?: Storage,
25 | ): Promise<string> {
26 |   const storage = configStorage ?? new Storage(projectRoot);
27 |   return storage.getHistoryFilePath();
28 | }
29 | 
30 | // Handle multiline commands
31 | async function readHistoryFile(filePath: string): Promise<string[]> {
32 |   try {
33 |     const text = await fs.readFile(filePath, 'utf-8');
34 |     const result: string[] = [];
35 |     let cur = '';
36 | 
37 |     for (const raw of text.split(/\r?\n/)) {
38 |       if (!raw.trim()) continue;
39 |       const line = raw;
40 | 
41 |       const m = cur.match(/(\\+)$/);
42 |       if (m && m[1].length % 2) {
43 |         // odd number of trailing '\'
44 |         cur = cur.slice(0, -1) + ' ' + line;
45 |       } else {
46 |         if (cur) result.push(cur);
47 |         cur = line;
48 |       }
49 |     }
50 | 
51 |     if (cur) result.push(cur);
52 |     return result;
53 |   } catch (err) {
54 |     if (isNodeError(err) && err.code === 'ENOENT') return [];
55 |     console.error('Error reading history:', err);
56 |     return [];
57 |   }
58 | }
59 | 
60 | async function writeHistoryFile(
61 |   filePath: string,
62 |   history: string[],
63 | ): Promise<void> {
64 |   try {
65 |     await fs.mkdir(path.dirname(filePath), { recursive: true });
66 |     await fs.writeFile(filePath, history.join('\n'));
67 |   } catch (error) {
68 |     console.error('Error writing shell history:', error);
69 |   }
70 | }
71 | 
72 | export function useShellHistory(
73 |   projectRoot: string,
74 |   storage?: Storage,
75 | ): UseShellHistoryReturn {
76 |   const [history, setHistory] = useState<string[]>([]);
77 |   const [historyIndex, setHistoryIndex] = useState(-1);
78 |   const [historyFilePath, setHistoryFilePath] = useState<string | null>(null);
79 | 
80 |   useEffect(() => {
81 |     async function loadHistory() {
82 |       const filePath = await getHistoryFilePath(projectRoot, storage);
83 |       setHistoryFilePath(filePath);
84 |       const loadedHistory = await readHistoryFile(filePath);
85 |       setHistory(loadedHistory.reverse()); // Newest first
86 |     }
87 |     loadHistory();
88 |   }, [projectRoot, storage]);
89 | 
90 |   const addCommandToHistory = useCallback(
91 |     (command: string) => {
92 |       if (!command.trim() || !historyFilePath) {
93 |         return;
94 |       }
95 |       const newHistory = [command, ...history.filter((c) => c !== command)]
96 |         .slice(0, MAX_HISTORY_LENGTH)
97 |         .filter(Boolean);
98 |       setHistory(newHistory);
99 |       // Write to file in reverse order (oldest first)
100 |       writeHistoryFile(historyFilePath, [...newHistory].reverse());
101 |       setHistoryIndex(-1);
102 |     },
103 |     [history, historyFilePath],
104 |   );
105 | 
106 |   const getPreviousCommand = useCallback(() => {
107 |     if (history.length === 0) {
108 |       return null;
109 |     }
110 |     const newIndex = Math.min(historyIndex + 1, history.length - 1);
111 |     setHistoryIndex(newIndex);
112 |     return history[newIndex] ?? null;
113 |   }, [history, historyIndex]);
114 | 
115 |   const getNextCommand = useCallback(() => {
116 |     if (historyIndex < 0) {
117 |       return null;
118 |     }
119 |     const newIndex = historyIndex - 1;
120 |     setHistoryIndex(newIndex);
121 |     if (newIndex < 0) {
122 |       return '';
123 |     }
124 |     return history[newIndex] ?? null;
125 |   }, [history, historyIndex]);
126 | 
127 |   const resetHistoryPosition = useCallback(() => {
128 |     setHistoryIndex(-1);
129 |   }, []);
130 | 
131 |   return {
132 |     history,
133 |     addCommandToHistory,
134 |     getPreviousCommand,
135 |     getNextCommand,
136 |     resetHistoryPosition,
137 |   };
138 | }
```

src/ui/hooks/useShowMemoryCommand.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type { Message } from '../types.js';
8 | import { MessageType } from '../types.js';
9 | import type { Config } from '@google/gemini-cli-core';
10 | import type { LoadedSettings } from '../../config/settings.js';
11 | 
12 | export function createShowMemoryAction(
13 |   config: Config | null,
14 |   settings: LoadedSettings,
15 |   addMessage: (message: Message) => void,
16 | ) {
17 |   return async () => {
18 |     if (!config) {
19 |       addMessage({
20 |         type: MessageType.ERROR,
21 |         content: 'Configuration not available. Cannot show memory.',
22 |         timestamp: new Date(),
23 |       });
24 |       return;
25 |     }
26 | 
27 |     const debugMode = config.getDebugMode();
28 | 
29 |     if (debugMode) {
30 |       console.log('[DEBUG] Show Memory command invoked.');
31 |     }
32 | 
33 |     const currentMemory = config.getUserMemory();
34 |     const fileCount = config.getGeminiMdFileCount();
35 |     const contextFileName = settings.merged.context?.fileName;
36 |     const contextFileNames = Array.isArray(contextFileName)
37 |       ? contextFileName
38 |       : [contextFileName];
39 | 
40 |     if (debugMode) {
41 |       console.log(
42 |         `[DEBUG] Showing memory. Content from config.getUserMemory() (first 200 chars): ${currentMemory.substring(0, 200)}...`,
43 |       );
44 |       console.log(`[DEBUG] Number of context files loaded: ${fileCount}`);
45 |     }
46 | 
47 |     if (fileCount > 0) {
48 |       const allNamesTheSame = new Set(contextFileNames).size < 2;
49 |       const name = allNamesTheSame ? contextFileNames[0] : 'context';
50 |       addMessage({
51 |         type: MessageType.INFO,
52 |         content: `Loaded memory from ${fileCount} ${name} file${
53 |           fileCount > 1 ? 's' : ''
54 |         }.`,
55 |         timestamp: new Date(),
56 |       });
57 |     }
58 | 
59 |     if (currentMemory && currentMemory.trim().length > 0) {
60 |       addMessage({
61 |         type: MessageType.INFO,
62 |         content: `Current combined memory content:\n\`\`\`markdown\n${currentMemory}\n\`\`\``,
63 |         timestamp: new Date(),
64 |       });
65 |     } else {
66 |       addMessage({
67 |         type: MessageType.INFO,
68 |         content:
69 |           fileCount > 0
70 |             ? 'Hierarchical memory (GEMINI.md or other context files) is loaded but content is empty.'
71 |             : 'No hierarchical memory (GEMINI.md or other context files) is currently loaded.',
72 |         timestamp: new Date(),
73 |       });
74 |     }
75 |   };
76 | }
```

src/ui/hooks/useSlashCompletion.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | /** @vitest-environment jsdom */
8 | 
9 | import { describe, it, expect, vi } from 'vitest';
10 | import { renderHook, waitFor } from '@testing-library/react';
11 | import { useSlashCompletion } from './useSlashCompletion.js';
12 | import type { CommandContext, SlashCommand } from '../commands/types.js';
13 | import { CommandKind } from '../commands/types.js';
14 | import { useState } from 'react';
15 | import type { Suggestion } from '../components/SuggestionsDisplay.js';
16 | 
17 | // Test utility type and helper function for creating test SlashCommands
18 | type TestSlashCommand = Omit<SlashCommand, 'kind'> &
19 |   Partial<Pick<SlashCommand, 'kind'>>;
20 | 
21 | function createTestCommand(command: TestSlashCommand): SlashCommand {
22 |   return {
23 |     kind: CommandKind.BUILT_IN, // default for tests
24 |     ...command,
25 |   };
26 | }
27 | 
28 | // Track AsyncFzf constructor calls for cache testing
29 | let asyncFzfConstructorCalls = 0;
30 | const resetConstructorCallCount = () => {
31 |   asyncFzfConstructorCalls = 0;
32 | };
33 | const getConstructorCallCount = () => asyncFzfConstructorCalls;
34 | 
35 | // Centralized fuzzy matching simulation logic
36 | // Note: This is a simplified reimplementation that may diverge from real fzf behavior.
37 | // Integration tests in useSlashCompletion.integration.test.ts use the real fzf library
38 | // to catch any behavioral differences and serve as our "canary in a coal mine."
39 | function simulateFuzzyMatching(items: readonly string[], query: string) {
40 |   const results = [];
41 |   if (query) {
42 |     const lowerQuery = query.toLowerCase();
43 |     for (const item of items) {
44 |       const lowerItem = item.toLowerCase();
45 | 
46 |       // Exact match gets highest score
47 |       if (lowerItem === lowerQuery) {
48 |         results.push({
49 |           item,
50 |           positions: [],
51 |           score: 100,
52 |           start: 0,
53 |           end: item.length,
54 |         });
55 |         continue;
56 |       }
57 | 
58 |       // Prefix match gets high score
59 |       if (lowerItem.startsWith(lowerQuery)) {
60 |         results.push({
61 |           item,
62 |           positions: [],
63 |           score: 80,
64 |           start: 0,
65 |           end: query.length,
66 |         });
67 |         continue;
68 |       }
69 | 
70 |       // Fuzzy matching: check if query chars appear in order
71 |       let queryIndex = 0;
72 |       let score = 0;
73 |       for (
74 |         let i = 0;
75 |         i < lowerItem.length && queryIndex < lowerQuery.length;
76 |         i++
77 |       ) {
78 |         if (lowerItem[i] === lowerQuery[queryIndex]) {
79 |           queryIndex++;
80 |           score += 10 - i; // Earlier matches get higher scores
81 |         }
82 |       }
83 | 
84 |       // If all query characters were found in order, include this item
85 |       if (queryIndex === lowerQuery.length) {
86 |         results.push({
87 |           item,
88 |           positions: [],
89 |           score,
90 |           start: 0,
91 |           end: query.length,
92 |         });
93 |       }
94 |     }
95 |   }
96 | 
97 |   // Sort by score descending (better matches first)
98 |   results.sort((a, b) => b.score - a.score);
99 |   return Promise.resolve(results);
100 | }
101 | 
102 | // Mock the fzf module to provide a working fuzzy search implementation for tests
103 | vi.mock('fzf', async () => {
104 |   const actual = await vi.importActual<typeof import('fzf')>('fzf');
105 |   return {
106 |     ...actual,
107 |     AsyncFzf: vi.fn().mockImplementation((items, _options) => {
108 |       asyncFzfConstructorCalls++;
109 |       return {
110 |         find: vi
111 |           .fn()
112 |           .mockImplementation((query: string) =>
113 |             simulateFuzzyMatching(items, query),
114 |           ),
115 |         // eslint-disable-next-line @typescript-eslint/no-explicit-any
116 |       } as any;
117 |     }),
118 |   };
119 | });
120 | 
121 | // Default mock behavior helper - now uses centralized logic
122 | const createDefaultAsyncFzfMock =
123 |   () => (items: readonly string[], _options: unknown) => {
124 |     asyncFzfConstructorCalls++;
125 |     return {
126 |       find: vi
127 |         .fn()
128 |         .mockImplementation((query: string) =>
129 |           simulateFuzzyMatching(items, query),
130 |         ),
131 |       // eslint-disable-next-line @typescript-eslint/no-explicit-any
132 |     } as any;
133 |   };
134 | 
135 | // Export test utilities
136 | export {
137 |   resetConstructorCallCount,
138 |   getConstructorCallCount,
139 |   createDefaultAsyncFzfMock,
140 | };
141 | 
142 | // Test harness to capture the state from the hook's callbacks.
143 | function useTestHarnessForSlashCompletion(
144 |   enabled: boolean,
145 |   query: string | null,
146 |   slashCommands: readonly SlashCommand[],
147 |   commandContext: CommandContext,
148 | ) {
149 |   const [suggestions, setSuggestions] = useState<Suggestion[]>([]);
150 |   const [isLoadingSuggestions, setIsLoadingSuggestions] = useState(false);
151 |   const [isPerfectMatch, setIsPerfectMatch] = useState(false);
152 | 
153 |   const { completionStart, completionEnd } = useSlashCompletion({
154 |     enabled,
155 |     query,
156 |     slashCommands,
157 |     commandContext,
158 |     setSuggestions,
159 |     setIsLoadingSuggestions,
160 |     setIsPerfectMatch,
161 |   });
162 | 
163 |   return {
164 |     suggestions,
165 |     isLoadingSuggestions,
166 |     isPerfectMatch,
167 |     completionStart,
168 |     completionEnd,
169 |   };
170 | }
171 | 
172 | describe('useSlashCompletion', () => {
173 |   // A minimal mock is sufficient for these tests.
174 |   const mockCommandContext = {} as CommandContext;
175 | 
176 |   describe('Top-Level Commands', () => {
177 |     it('should suggest all top-level commands for the root slash', async () => {
178 |       const slashCommands = [
179 |         createTestCommand({
180 |           name: 'help',
181 |           altNames: ['?'],
182 |           description: 'Show help',
183 |         }),
184 |         createTestCommand({
185 |           name: 'stats',
186 |           altNames: ['usage'],
187 |           description: 'check session stats. Usage: /stats [model|tools]',
188 |         }),
189 |         createTestCommand({ name: 'clear', description: 'Clear the screen' }),
190 |         createTestCommand({
191 |           name: 'memory',
192 |           description: 'Manage memory',
193 |           subCommands: [
194 |             createTestCommand({ name: 'show', description: 'Show memory' }),
195 |           ],
196 |         }),
197 |         createTestCommand({ name: 'chat', description: 'Manage chat history' }),
198 |       ];
199 |       const { result } = renderHook(() =>
200 |         useTestHarnessForSlashCompletion(
201 |           true,
202 |           '/',
203 |           slashCommands,
204 |           mockCommandContext,
205 |         ),
206 |       );
207 | 
208 |       expect(result.current.suggestions.length).toBe(slashCommands.length);
209 |       expect(result.current.suggestions.map((s) => s.label)).toEqual(
210 |         expect.arrayContaining(['help', 'clear', 'memory', 'chat', 'stats']),
211 |       );
212 |     });
213 | 
214 |     it('should filter commands based on partial input', async () => {
215 |       const slashCommands = [
216 |         createTestCommand({ name: 'memory', description: 'Manage memory' }),
217 |       ];
218 |       const { result } = renderHook(() =>
219 |         useTestHarnessForSlashCompletion(
220 |           true,
221 |           '/mem',
222 |           slashCommands,
223 |           mockCommandContext,
224 |         ),
225 |       );
226 | 
227 |       await waitFor(() => {
228 |         expect(result.current.suggestions).toEqual([
229 |           {
230 |             label: 'memory',
231 |             value: 'memory',
232 |             description: 'Manage memory',
233 |             commandKind: CommandKind.BUILT_IN,
234 |           },
235 |         ]);
236 |       });
237 |     });
238 | 
239 |     it('should suggest commands based on partial altNames', async () => {
240 |       const slashCommands = [
241 |         createTestCommand({
242 |           name: 'stats',
243 |           altNames: ['usage'],
244 |           description: 'check session stats. Usage: /stats [model|tools]',
245 |         }),
246 |       ];
247 |       const { result } = renderHook(() =>
248 |         useTestHarnessForSlashCompletion(
249 |           true,
250 |           '/usag',
251 |           slashCommands,
252 |           mockCommandContext,
253 |         ),
254 |       );
255 | 
256 |       await waitFor(() => {
257 |         expect(result.current.suggestions).toEqual([
258 |           {
259 |             label: 'stats',
260 |             value: 'stats',
261 |             description: 'check session stats. Usage: /stats [model|tools]',
262 |             commandKind: CommandKind.BUILT_IN,
263 |           },
264 |         ]);
265 |       });
266 |     });
267 | 
268 |     it('should NOT provide suggestions for a perfectly typed command that is a leaf node', async () => {
269 |       const slashCommands = [
270 |         createTestCommand({
271 |           name: 'clear',
272 |           description: 'Clear the screen',
273 |           action: vi.fn(),
274 |         }),
275 |       ];
276 |       const { result } = renderHook(() =>
277 |         useTestHarnessForSlashCompletion(
278 |           true,
279 |           '/clear',
280 |           slashCommands,
281 |           mockCommandContext,
282 |         ),
283 |       );
284 | 
285 |       expect(result.current.suggestions).toHaveLength(0);
286 |     });
287 | 
288 |     it.each([['/?'], ['/usage']])(
289 |       'should not suggest commands when altNames is fully typed',
290 |       async (query) => {
291 |         const mockSlashCommands = [
292 |           createTestCommand({
293 |             name: 'help',
294 |             altNames: ['?'],
295 |             description: 'Show help',
296 |             action: vi.fn(),
297 |           }),
298 |           createTestCommand({
299 |             name: 'stats',
300 |             altNames: ['usage'],
301 |             description: 'check session stats. Usage: /stats [model|tools]',
302 |             action: vi.fn(),
303 |           }),
304 |         ];
305 | 
306 |         const { result } = renderHook(() =>
307 |           useTestHarnessForSlashCompletion(
308 |             true,
309 |             query,
310 |             mockSlashCommands,
311 |             mockCommandContext,
312 |           ),
313 |         );
314 | 
315 |         expect(result.current.suggestions).toHaveLength(0);
316 |       },
317 |     );
318 | 
319 |     it('should not provide suggestions for a fully typed command that has no sub-commands or argument completion', async () => {
320 |       const slashCommands = [
321 |         createTestCommand({ name: 'clear', description: 'Clear the screen' }),
322 |       ];
323 |       const { result } = renderHook(() =>
324 |         useTestHarnessForSlashCompletion(
325 |           true,
326 |           '/clear ',
327 |           slashCommands,
328 |           mockCommandContext,
329 |         ),
330 |       );
331 | 
332 |       expect(result.current.suggestions).toHaveLength(0);
333 |     });
334 | 
335 |     it('should not provide suggestions for an unknown command', async () => {
336 |       const slashCommands = [
337 |         createTestCommand({ name: 'help', description: 'Show help' }),
338 |       ];
339 |       const { result } = renderHook(() =>
340 |         useTestHarnessForSlashCompletion(
341 |           true,
342 |           '/unknown-command',
343 |           slashCommands,
344 |           mockCommandContext,
345 |         ),
346 |       );
347 | 
348 |       expect(result.current.suggestions).toHaveLength(0);
349 |     });
350 | 
351 |     it('should not suggest hidden commands', async () => {
352 |       const slashCommands = [
353 |         createTestCommand({
354 |           name: 'visible',
355 |           description: 'A visible command',
356 |         }),
357 |         createTestCommand({
358 |           name: 'hidden',
359 |           description: 'A hidden command',
360 |           hidden: true,
361 |         }),
362 |       ];
363 |       const { result } = renderHook(() =>
364 |         useTestHarnessForSlashCompletion(
365 |           true,
366 |           '/',
367 |           slashCommands,
368 |           mockCommandContext,
369 |         ),
370 |       );
371 | 
372 |       expect(result.current.suggestions.length).toBe(1);
373 |       expect(result.current.suggestions[0].label).toBe('visible');
374 |     });
375 |   });
376 | 
377 |   describe('Sub-Commands', () => {
378 |     it('should suggest sub-commands for a parent command', async () => {
379 |       const slashCommands = [
380 |         createTestCommand({
381 |           name: 'memory',
382 |           description: 'Manage memory',
383 |           subCommands: [
384 |             createTestCommand({ name: 'show', description: 'Show memory' }),
385 |             createTestCommand({ name: 'add', description: 'Add to memory' }),
386 |           ],
387 |         }),
388 |       ];
389 | 
390 |       const { result } = renderHook(() =>
391 |         useTestHarnessForSlashCompletion(
392 |           true,
393 |           '/memory',
394 |           slashCommands,
395 |           mockCommandContext,
396 |         ),
397 |       );
398 | 
399 |       expect(result.current.suggestions).toHaveLength(2);
400 |       expect(result.current.suggestions).toEqual(
401 |         expect.arrayContaining([
402 |           {
403 |             label: 'show',
404 |             value: 'show',
405 |             description: 'Show memory',
406 |             commandKind: CommandKind.BUILT_IN,
407 |           },
408 |           {
409 |             label: 'add',
410 |             value: 'add',
411 |             description: 'Add to memory',
412 |             commandKind: CommandKind.BUILT_IN,
413 |           },
414 |         ]),
415 |       );
416 |     });
417 | 
418 |     it('should suggest all sub-commands when the query ends with the parent command and a space', async () => {
419 |       const slashCommands = [
420 |         createTestCommand({
421 |           name: 'memory',
422 |           description: 'Manage memory',
423 |           subCommands: [
[TRUNCATED]
```

src/ui/hooks/useSlashCompletion.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { useState, useEffect, useMemo } from 'react';
8 | import { AsyncFzf } from 'fzf';
9 | import type { Suggestion } from '../components/SuggestionsDisplay.js';
10 | import {
11 |   CommandKind,
12 |   type CommandContext,
13 |   type SlashCommand,
14 | } from '../commands/types.js';
15 | 
16 | // Type alias for improved type safety based on actual fzf result structure
17 | type FzfCommandResult = {
18 |   item: string;
19 |   start: number;
20 |   end: number;
21 |   score: number;
22 |   positions?: number[]; // Optional - fzf doesn't always provide match positions depending on algorithm/options used
23 | };
24 | 
25 | // Interface for FZF command cache entry
26 | interface FzfCommandCacheEntry {
27 |   fzf: AsyncFzf<string[]>;
28 |   commandMap: Map<string, SlashCommand>;
29 | }
30 | 
31 | // Utility function to safely handle errors without information disclosure
32 | function logErrorSafely(error: unknown, context: string): void {
33 |   if (error instanceof Error) {
34 |     // Log full error details securely for debugging
35 |     console.error(`[${context}]`, error);
36 |   } else {
37 |     console.error(`[${context}] Non-error thrown:`, error);
38 |   }
39 | }
40 | 
41 | // Shared utility function for command matching logic
42 | function matchesCommand(cmd: SlashCommand, query: string): boolean {
43 |   return (
44 |     cmd.name.toLowerCase() === query.toLowerCase() ||
45 |     cmd.altNames?.some((alt) => alt.toLowerCase() === query.toLowerCase()) ||
46 |     false
47 |   );
48 | }
49 | 
50 | interface CommandParserResult {
51 |   hasTrailingSpace: boolean;
52 |   commandPathParts: string[];
53 |   partial: string;
54 |   currentLevel: readonly SlashCommand[] | undefined;
55 |   leafCommand: SlashCommand | null;
56 |   exactMatchAsParent: SlashCommand | undefined;
57 |   isArgumentCompletion: boolean;
58 | }
59 | 
60 | function useCommandParser(
61 |   query: string | null,
62 |   slashCommands: readonly SlashCommand[],
63 | ): CommandParserResult {
64 |   return useMemo(() => {
65 |     if (!query) {
66 |       return {
67 |         hasTrailingSpace: false,
68 |         commandPathParts: [],
69 |         partial: '',
70 |         currentLevel: slashCommands,
71 |         leafCommand: null,
72 |         exactMatchAsParent: undefined,
73 |         isArgumentCompletion: false,
74 |       };
75 |     }
76 | 
77 |     const fullPath = query.substring(1) || '';
78 |     const hasTrailingSpace = !!query.endsWith(' ');
79 |     const rawParts = fullPath.split(/\s+/).filter((p) => p);
80 |     let commandPathParts = rawParts;
81 |     let partial = '';
82 | 
83 |     if (!hasTrailingSpace && rawParts.length > 0) {
84 |       partial = rawParts[rawParts.length - 1];
85 |       commandPathParts = rawParts.slice(0, -1);
86 |     }
87 | 
88 |     let currentLevel: readonly SlashCommand[] | undefined = slashCommands;
89 |     let leafCommand: SlashCommand | null = null;
90 | 
91 |     for (const part of commandPathParts) {
92 |       if (!currentLevel) {
93 |         leafCommand = null;
94 |         currentLevel = [];
95 |         break;
96 |       }
97 |       const found: SlashCommand | undefined = currentLevel.find((cmd) =>
98 |         matchesCommand(cmd, part),
99 |       );
100 | 
101 |       if (found) {
102 |         leafCommand = found;
103 |         currentLevel = found.subCommands as readonly SlashCommand[] | undefined;
104 |         if (found.kind === CommandKind.MCP_PROMPT) {
105 |           break;
106 |         }
107 |       } else {
108 |         leafCommand = null;
109 |         currentLevel = [];
110 |         break;
111 |       }
112 |     }
113 | 
114 |     let exactMatchAsParent: SlashCommand | undefined;
115 |     if (!hasTrailingSpace && currentLevel) {
116 |       exactMatchAsParent = currentLevel.find(
117 |         (cmd) => matchesCommand(cmd, partial) && cmd.subCommands,
118 |       );
119 | 
120 |       if (exactMatchAsParent) {
121 |         leafCommand = exactMatchAsParent;
122 |         currentLevel = exactMatchAsParent.subCommands;
123 |         partial = '';
124 |       }
125 |     }
126 | 
127 |     const depth = commandPathParts.length;
128 |     const isArgumentCompletion = !!(
129 |       leafCommand?.completion &&
130 |       (hasTrailingSpace ||
131 |         (rawParts.length > depth && depth > 0 && partial !== ''))
132 |     );
133 | 
134 |     return {
135 |       hasTrailingSpace,
136 |       commandPathParts,
137 |       partial,
138 |       currentLevel,
139 |       leafCommand,
140 |       exactMatchAsParent,
141 |       isArgumentCompletion,
142 |     };
143 |   }, [query, slashCommands]);
144 | }
145 | 
146 | interface SuggestionsResult {
147 |   suggestions: Suggestion[];
148 |   isLoading: boolean;
149 | }
150 | 
151 | interface CompletionPositions {
152 |   start: number;
153 |   end: number;
154 | }
155 | 
156 | interface PerfectMatchResult {
157 |   isPerfectMatch: boolean;
158 | }
159 | 
160 | function useCommandSuggestions(
161 |   parserResult: CommandParserResult,
162 |   commandContext: CommandContext,
163 |   getFzfForCommands: (
164 |     commands: readonly SlashCommand[],
165 |   ) => FzfCommandCacheEntry | null,
166 |   getPrefixSuggestions: (
167 |     commands: readonly SlashCommand[],
168 |     partial: string,
169 |   ) => SlashCommand[],
170 | ): SuggestionsResult {
171 |   const [suggestions, setSuggestions] = useState<Suggestion[]>([]);
172 |   const [isLoading, setIsLoading] = useState(false);
173 | 
174 |   useEffect(() => {
175 |     const abortController = new AbortController();
176 |     const { signal } = abortController;
177 | 
178 |     const {
179 |       isArgumentCompletion,
180 |       leafCommand,
181 |       commandPathParts,
182 |       partial,
183 |       currentLevel,
184 |     } = parserResult;
185 | 
186 |     if (isArgumentCompletion) {
187 |       const fetchAndSetSuggestions = async () => {
188 |         if (signal.aborted) return;
189 | 
190 |         // Safety check: ensure leafCommand and completion exist
191 |         if (!leafCommand?.completion) {
192 |           console.warn(
193 |             'Attempted argument completion without completion function',
194 |           );
195 |           return;
196 |         }
197 | 
198 |         setIsLoading(true);
199 |         try {
200 |           const rawParts = [...commandPathParts];
201 |           if (partial) rawParts.push(partial);
202 |           const depth = commandPathParts.length;
203 |           const argString = rawParts.slice(depth).join(' ');
204 |           const results =
205 |             (await leafCommand.completion(
206 |               {
207 |                 ...commandContext,
208 |                 invocation: {
209 |                   raw: `/${rawParts.join(' ')}`,
210 |                   name: leafCommand.name,
211 |                   args: argString,
212 |                 },
213 |               },
214 |               argString,
215 |             )) || [];
216 | 
217 |           if (!signal.aborted) {
218 |             const finalSuggestions = results.map((s) => ({
219 |               label: s,
220 |               value: s,
221 |             }));
222 |             setSuggestions(finalSuggestions);
223 |             setIsLoading(false);
224 |           }
225 |         } catch (error) {
226 |           if (!signal.aborted) {
227 |             logErrorSafely(error, 'Argument completion');
228 |             setSuggestions([]);
229 |             setIsLoading(false);
230 |           }
231 |         }
232 |       };
233 |       fetchAndSetSuggestions();
234 |       return () => abortController.abort();
235 |     }
236 | 
237 |     const commandsToSearch = currentLevel || [];
238 |     if (commandsToSearch.length > 0) {
239 |       const performFuzzySearch = async () => {
240 |         if (signal.aborted) return;
241 |         let potentialSuggestions: SlashCommand[] = [];
242 | 
243 |         if (partial === '') {
244 |           // If no partial query, show all available commands
245 |           potentialSuggestions = commandsToSearch.filter(
246 |             (cmd) => cmd.description && !cmd.hidden,
247 |           );
248 |         } else {
249 |           // Use fuzzy search for non-empty partial queries with fallback
250 |           const fzfInstance = getFzfForCommands(commandsToSearch);
251 |           if (fzfInstance) {
252 |             try {
253 |               const fzfResults = await fzfInstance.fzf.find(partial);
254 |               if (signal.aborted) return;
255 |               const uniqueCommands = new Set<SlashCommand>();
256 |               fzfResults.forEach((result: FzfCommandResult) => {
257 |                 const cmd = fzfInstance.commandMap.get(result.item);
258 |                 if (cmd && cmd.description) {
259 |                   uniqueCommands.add(cmd);
260 |                 }
261 |               });
262 |               potentialSuggestions = Array.from(uniqueCommands);
263 |             } catch (error) {
264 |               logErrorSafely(
265 |                 error,
266 |                 'Fuzzy search - falling back to prefix matching',
267 |               );
268 |               // Fallback to prefix-based filtering
269 |               potentialSuggestions = getPrefixSuggestions(
270 |                 commandsToSearch,
271 |                 partial,
272 |               );
273 |             }
274 |           } else {
275 |             // Fallback to prefix-based filtering when fzf instance creation fails
276 |             potentialSuggestions = getPrefixSuggestions(
277 |               commandsToSearch,
278 |               partial,
279 |             );
280 |           }
281 |         }
282 | 
283 |         if (!signal.aborted) {
284 |           const finalSuggestions = potentialSuggestions.map((cmd) => ({
285 |             label: cmd.name,
286 |             value: cmd.name,
287 |             description: cmd.description,
288 |             commandKind: cmd.kind,
289 |           }));
290 | 
291 |           setSuggestions(finalSuggestions);
292 |         }
293 |       };
294 | 
295 |       performFuzzySearch().catch((error) => {
296 |         logErrorSafely(error, 'Unexpected fuzzy search error');
297 |         if (!signal.aborted) {
298 |           // Ultimate fallback: show no suggestions rather than confusing the user
299 |           // with all available commands when their query clearly doesn't match anything
300 |           setSuggestions([]);
301 |         }
302 |       });
303 |       return () => abortController.abort();
304 |     }
305 | 
306 |     setSuggestions([]);
307 |     return () => abortController.abort();
308 |   }, [parserResult, commandContext, getFzfForCommands, getPrefixSuggestions]);
309 | 
310 |   return { suggestions, isLoading };
311 | }
312 | 
313 | function useCompletionPositions(
314 |   query: string | null,
315 |   parserResult: CommandParserResult,
316 | ): CompletionPositions {
317 |   return useMemo(() => {
318 |     if (!query) {
319 |       return { start: -1, end: -1 };
320 |     }
321 | 
322 |     const { hasTrailingSpace, partial, exactMatchAsParent } = parserResult;
323 | 
324 |     // Set completion start/end positions
325 |     if (hasTrailingSpace || exactMatchAsParent) {
326 |       return { start: query.length, end: query.length };
327 |     } else if (partial) {
328 |       if (parserResult.isArgumentCompletion) {
329 |         const commandSoFar = `/${parserResult.commandPathParts.join(' ')}`;
330 |         const argStartIndex =
331 |           commandSoFar.length +
332 |           (parserResult.commandPathParts.length > 0 ? 1 : 0);
333 |         return { start: argStartIndex, end: query.length };
334 |       } else {
335 |         return { start: query.length - partial.length, end: query.length };
336 |       }
337 |     } else {
338 |       return { start: 1, end: query.length };
339 |     }
340 |   }, [query, parserResult]);
341 | }
342 | 
343 | function usePerfectMatch(
344 |   parserResult: CommandParserResult,
345 | ): PerfectMatchResult {
346 |   return useMemo(() => {
347 |     const { hasTrailingSpace, partial, leafCommand, currentLevel } =
348 |       parserResult;
349 | 
350 |     if (hasTrailingSpace) {
351 |       return { isPerfectMatch: false };
352 |     }
353 | 
354 |     if (leafCommand && partial === '' && leafCommand.action) {
355 |       return { isPerfectMatch: true };
356 |     }
357 | 
358 |     if (currentLevel) {
359 |       const perfectMatch = currentLevel.find(
360 |         (cmd) => matchesCommand(cmd, partial) && cmd.action,
361 |       );
362 |       if (perfectMatch) {
363 |         return { isPerfectMatch: true };
364 |       }
365 |     }
366 | 
367 |     return { isPerfectMatch: false };
368 |   }, [parserResult]);
369 | }
370 | 
371 | export interface UseSlashCompletionProps {
372 |   enabled: boolean;
373 |   query: string | null;
374 |   slashCommands: readonly SlashCommand[];
375 |   commandContext: CommandContext;
376 |   setSuggestions: (suggestions: Suggestion[]) => void;
377 |   setIsLoadingSuggestions: (isLoading: boolean) => void;
378 |   setIsPerfectMatch: (isMatch: boolean) => void;
379 | }
380 | 
381 | export function useSlashCompletion(props: UseSlashCompletionProps): {
382 |   completionStart: number;
383 |   completionEnd: number;
384 | } {
385 |   const {
386 |     enabled,
387 |     query,
388 |     slashCommands,
389 |     commandContext,
390 |     setSuggestions,
391 |     setIsLoadingSuggestions,
392 |     setIsPerfectMatch,
393 |   } = props;
394 |   const [completionStart, setCompletionStart] = useState(-1);
395 |   const [completionEnd, setCompletionEnd] = useState(-1);
396 | 
397 |   // Simplified cache for AsyncFzf instances - WeakMap handles automatic cleanup
398 |   const fzfInstanceCache = useMemo(
399 |     () => new WeakMap<readonly SlashCommand[], FzfCommandCacheEntry>(),
400 |     [],
401 |   );
402 | 
403 |   // Helper function to create or retrieve cached AsyncFzf instance for a command level
404 |   const getFzfForCommands = useMemo(
405 |     () => (commands: readonly SlashCommand[]) => {
406 |       if (!commands || commands.length === 0) {
407 |         return null;
408 |       }
409 | 
410 |       // Check if we already have a cached instance
411 |       const cached = fzfInstanceCache.get(commands);
412 |       if (cached) {
413 |         return cached;
414 |       }
415 | 
416 |       // Create new fzf instance
417 |       const commandItems: string[] = [];
[TRUNCATED]
```

src/ui/hooks/useStateAndRef.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import React from 'react';
8 | 
9 | // Hook to return state, state setter, and ref to most up-to-date value of state.
10 | // We need this in order to setState and reference the updated state multiple
11 | // times in the same function.
12 | export const useStateAndRef = <
13 |   // Everything but function.
14 |   T extends object | null | undefined | number | string,
15 | >(
16 |   initialValue: T,
17 | ) => {
18 |   const [state, setState] = React.useState<T>(initialValue);
19 |   const ref = React.useRef<T>(initialValue);
20 | 
21 |   const setStateInternal = React.useCallback<typeof setState>(
22 |     (newStateOrCallback) => {
23 |       let newValue: T;
24 |       if (typeof newStateOrCallback === 'function') {
25 |         newValue = newStateOrCallback(ref.current);
26 |       } else {
27 |         newValue = newStateOrCallback;
28 |       }
29 |       setState(newValue);
30 |       ref.current = newValue;
31 |     },
32 |     [],
33 |   );
34 | 
35 |   return [state, ref, setStateInternal] as const;
36 | };
```

src/ui/hooks/useTerminalSize.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { useEffect, useState } from 'react';
8 | 
9 | export function useTerminalSize(): { columns: number; rows: number } {
10 |   const [size, setSize] = useState({
11 |     columns: process.stdout.columns || 60,
12 |     rows: process.stdout.rows || 20,
13 |   });
14 | 
15 |   useEffect(() => {
16 |     function updateSize() {
17 |       setSize({
18 |         columns: process.stdout.columns || 60,
19 |         rows: process.stdout.rows || 20,
20 |       });
21 |     }
22 | 
23 |     process.stdout.on('resize', updateSize);
24 |     return () => {
25 |       process.stdout.off('resize', updateSize);
26 |     };
27 |   }, []);
28 | 
29 |   return size;
30 | }
```

src/ui/hooks/useThemeCommand.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { useState, useCallback } from 'react';
8 | import { themeManager } from '../themes/theme-manager.js';
9 | import type { LoadedSettings, SettingScope } from '../../config/settings.js'; // Import LoadedSettings, AppSettings, MergedSetting
10 | import { type HistoryItem, MessageType } from '../types.js';
11 | import process from 'node:process';
12 | 
13 | interface UseThemeCommandReturn {
14 |   isThemeDialogOpen: boolean;
15 |   openThemeDialog: () => void;
16 |   handleThemeSelect: (
17 |     themeName: string | undefined,
18 |     scope: SettingScope,
19 |   ) => void; // Added scope
20 |   handleThemeHighlight: (themeName: string | undefined) => void;
21 | }
22 | 
23 | export const useThemeCommand = (
24 |   loadedSettings: LoadedSettings,
25 |   setThemeError: (error: string | null) => void,
26 |   addItem: (item: Omit<HistoryItem, 'id'>, timestamp: number) => void,
27 |   initialThemeError: string | null,
28 | ): UseThemeCommandReturn => {
29 |   const [isThemeDialogOpen, setIsThemeDialogOpen] =
30 |     useState(!!initialThemeError);
31 | 
32 |   const openThemeDialog = useCallback(() => {
33 |     if (process.env['NO_COLOR']) {
34 |       addItem(
35 |         {
36 |           type: MessageType.INFO,
37 |           text: 'Theme configuration unavailable due to NO_COLOR env variable.',
38 |         },
39 |         Date.now(),
40 |       );
41 |       return;
42 |     }
43 |     setIsThemeDialogOpen(true);
44 |   }, [addItem]);
45 | 
46 |   const applyTheme = useCallback(
47 |     (themeName: string | undefined) => {
48 |       if (!themeManager.setActiveTheme(themeName)) {
49 |         // If theme is not found, open the theme selection dialog and set error message
50 |         setIsThemeDialogOpen(true);
51 |         setThemeError(`Theme "${themeName}" not found.`);
52 |       } else {
53 |         setThemeError(null); // Clear any previous theme error on success
54 |       }
55 |     },
56 |     [setThemeError],
57 |   );
58 | 
59 |   const handleThemeHighlight = useCallback(
60 |     (themeName: string | undefined) => {
61 |       applyTheme(themeName);
62 |     },
63 |     [applyTheme],
64 |   );
65 | 
66 |   const handleThemeSelect = useCallback(
67 |     (themeName: string | undefined, scope: SettingScope) => {
68 |       try {
69 |         // Merge user and workspace custom themes (workspace takes precedence)
70 |         const mergedCustomThemes = {
71 |           ...(loadedSettings.user.settings.ui?.customThemes || {}),
72 |           ...(loadedSettings.workspace.settings.ui?.customThemes || {}),
73 |         };
74 |         // Only allow selecting themes available in the merged custom themes or built-in themes
75 |         const isBuiltIn = themeManager.findThemeByName(themeName);
76 |         const isCustom = themeName && mergedCustomThemes[themeName];
77 |         if (!isBuiltIn && !isCustom) {
78 |           setThemeError(`Theme "${themeName}" not found in selected scope.`);
79 |           setIsThemeDialogOpen(true);
80 |           return;
81 |         }
82 |         loadedSettings.setValue(scope, 'ui.theme', themeName); // Update the merged settings
83 |         if (loadedSettings.merged.ui?.customThemes) {
84 |           themeManager.loadCustomThemes(loadedSettings.merged.ui?.customThemes);
85 |         }
86 |         applyTheme(loadedSettings.merged.ui?.theme); // Apply the current theme
87 |         setThemeError(null);
88 |       } finally {
89 |         setIsThemeDialogOpen(false); // Close the dialog
90 |       }
91 |     },
92 |     [applyTheme, loadedSettings, setThemeError],
93 |   );
94 | 
95 |   return {
96 |     isThemeDialogOpen,
97 |     openThemeDialog,
98 |     handleThemeSelect,
99 |     handleThemeHighlight,
100 |   };
101 | };
```

src/ui/hooks/useTimer.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
8 | import { renderHook, act } from '@testing-library/react';
9 | import { useTimer } from './useTimer.js';
10 | 
11 | describe('useTimer', () => {
12 |   beforeEach(() => {
13 |     vi.useFakeTimers();
14 |   });
15 | 
16 |   afterEach(() => {
17 |     vi.restoreAllMocks();
18 |   });
19 | 
20 |   it('should initialize with 0', () => {
21 |     const { result } = renderHook(() => useTimer(false, 0));
22 |     expect(result.current).toBe(0);
23 |   });
24 | 
25 |   it('should not increment time if isActive is false', () => {
26 |     const { result } = renderHook(() => useTimer(false, 0));
27 |     act(() => {
28 |       vi.advanceTimersByTime(5000);
29 |     });
30 |     expect(result.current).toBe(0);
31 |   });
32 | 
33 |   it('should increment time every second if isActive is true', () => {
34 |     const { result } = renderHook(() => useTimer(true, 0));
35 |     act(() => {
36 |       vi.advanceTimersByTime(1000);
37 |     });
38 |     expect(result.current).toBe(1);
39 |     act(() => {
40 |       vi.advanceTimersByTime(2000);
41 |     });
42 |     expect(result.current).toBe(3);
43 |   });
44 | 
45 |   it('should reset to 0 and start incrementing when isActive becomes true from false', () => {
46 |     const { result, rerender } = renderHook(
47 |       ({ isActive, resetKey }) => useTimer(isActive, resetKey),
48 |       { initialProps: { isActive: false, resetKey: 0 } },
49 |     );
50 |     expect(result.current).toBe(0);
51 | 
52 |     rerender({ isActive: true, resetKey: 0 });
53 |     expect(result.current).toBe(0); // Should reset to 0 upon becoming active
54 | 
55 |     act(() => {
56 |       vi.advanceTimersByTime(1000);
57 |     });
58 |     expect(result.current).toBe(1);
59 |   });
60 | 
61 |   it('should reset to 0 when resetKey changes while active', () => {
62 |     const { result, rerender } = renderHook(
63 |       ({ isActive, resetKey }) => useTimer(isActive, resetKey),
64 |       { initialProps: { isActive: true, resetKey: 0 } },
65 |     );
66 |     act(() => {
67 |       vi.advanceTimersByTime(3000); // 3s
68 |     });
69 |     expect(result.current).toBe(3);
70 | 
71 |     rerender({ isActive: true, resetKey: 1 }); // Change resetKey
72 |     expect(result.current).toBe(0); // Should reset to 0
73 | 
74 |     act(() => {
75 |       vi.advanceTimersByTime(1000);
76 |     });
77 |     expect(result.current).toBe(1); // Starts incrementing from 0
78 |   });
79 | 
80 |   it('should be 0 if isActive is false, regardless of resetKey changes', () => {
81 |     const { result, rerender } = renderHook(
82 |       ({ isActive, resetKey }) => useTimer(isActive, resetKey),
83 |       { initialProps: { isActive: false, resetKey: 0 } },
84 |     );
85 |     expect(result.current).toBe(0);
86 | 
87 |     rerender({ isActive: false, resetKey: 1 });
88 |     expect(result.current).toBe(0);
89 |   });
90 | 
91 |   it('should clear timer on unmount', () => {
92 |     const { unmount } = renderHook(() => useTimer(true, 0));
93 |     const clearIntervalSpy = vi.spyOn(global, 'clearInterval');
94 |     unmount();
95 |     expect(clearIntervalSpy).toHaveBeenCalledOnce();
96 |   });
97 | 
98 |   it('should preserve elapsedTime when isActive becomes false, and reset to 0 when it becomes active again', () => {
99 |     const { result, rerender } = renderHook(
100 |       ({ isActive, resetKey }) => useTimer(isActive, resetKey),
101 |       { initialProps: { isActive: true, resetKey: 0 } },
102 |     );
103 | 
104 |     act(() => {
105 |       vi.advanceTimersByTime(3000); // Advance to 3 seconds
106 |     });
107 |     expect(result.current).toBe(3);
108 | 
109 |     rerender({ isActive: false, resetKey: 0 });
110 |     expect(result.current).toBe(3); // Time should be preserved when timer becomes inactive
111 | 
112 |     // Now make it active again, it should reset to 0
113 |     rerender({ isActive: true, resetKey: 0 });
114 |     expect(result.current).toBe(0);
115 |     act(() => {
116 |       vi.advanceTimersByTime(1000);
117 |     });
118 |     expect(result.current).toBe(1);
119 |   });
120 | });
```

src/ui/hooks/useTimer.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { useState, useEffect, useRef } from 'react';
8 | 
9 | /**
10 |  * Custom hook to manage a timer that increments every second.
11 |  * @param isActive Whether the timer should be running.
12 |  * @param resetKey A key that, when changed, will reset the timer to 0 and restart the interval.
13 |  * @returns The elapsed time in seconds.
14 |  */
15 | export const useTimer = (isActive: boolean, resetKey: unknown) => {
16 |   const [elapsedTime, setElapsedTime] = useState(0);
17 |   const timerRef = useRef<NodeJS.Timeout | null>(null);
18 |   const prevResetKeyRef = useRef(resetKey);
19 |   const prevIsActiveRef = useRef(isActive);
20 | 
21 |   useEffect(() => {
22 |     let shouldResetTime = false;
23 | 
24 |     if (prevResetKeyRef.current !== resetKey) {
25 |       shouldResetTime = true;
26 |       prevResetKeyRef.current = resetKey;
27 |     }
28 | 
29 |     if (prevIsActiveRef.current === false && isActive) {
30 |       // Transitioned from inactive to active
31 |       shouldResetTime = true;
32 |     }
33 | 
34 |     if (shouldResetTime) {
35 |       setElapsedTime(0);
36 |     }
37 |     prevIsActiveRef.current = isActive;
38 | 
39 |     // Manage interval
40 |     if (isActive) {
41 |       // Clear previous interval unconditionally before starting a new one
42 |       // This handles resetKey changes while active, ensuring a fresh interval start.
43 |       if (timerRef.current) {
44 |         clearInterval(timerRef.current);
45 |       }
46 |       timerRef.current = setInterval(() => {
47 |         setElapsedTime((prev) => prev + 1);
48 |       }, 1000);
49 |     } else {
50 |       if (timerRef.current) {
51 |         clearInterval(timerRef.current);
52 |         timerRef.current = null;
53 |       }
54 |     }
55 | 
56 |     return () => {
57 |       if (timerRef.current) {
58 |         clearInterval(timerRef.current);
59 |         timerRef.current = null;
60 |       }
61 |     };
62 |   }, [isActive, resetKey]);
63 | 
64 |   return elapsedTime;
65 | };
```

src/ui/hooks/useToolScheduler.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | /* eslint-disable @typescript-eslint/no-explicit-any */
8 | import type { Mock } from 'vitest';
9 | import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
10 | import { renderHook, act } from '@testing-library/react';
11 | import {
12 |   useReactToolScheduler,
13 |   mapToDisplay,
14 | } from './useReactToolScheduler.js';
15 | import type { PartUnion, FunctionResponse } from '@google/genai';
16 | import type {
17 |   Config,
18 |   ToolCallRequestInfo,
19 |   ToolRegistry,
20 |   ToolResult,
21 |   ToolCallConfirmationDetails,
22 |   ToolCallResponseInfo,
23 |   ToolCall, // Import from core
24 |   Status as ToolCallStatusType,
25 |   AnyDeclarativeTool,
26 |   AnyToolInvocation,
27 | } from '@google/gemini-cli-core';
28 | import {
29 |   DEFAULT_TRUNCATE_TOOL_OUTPUT_LINES,
30 |   DEFAULT_TRUNCATE_TOOL_OUTPUT_THRESHOLD,
31 |   ToolConfirmationOutcome,
32 |   ApprovalMode,
33 |   MockTool,
34 | } from '@google/gemini-cli-core';
35 | import type { HistoryItemWithoutId, HistoryItemToolGroup } from '../types.js';
36 | import { ToolCallStatus } from '../types.js';
37 | 
38 | // Mocks
39 | vi.mock('@google/gemini-cli-core', async () => {
40 |   const actual = await vi.importActual('@google/gemini-cli-core');
41 |   return {
42 |     ...actual,
43 |     ToolRegistry: vi.fn(),
44 |     Config: vi.fn(),
45 |   };
46 | });
47 | 
48 | const mockToolRegistry = {
49 |   getTool: vi.fn(),
50 |   getAllToolNames: vi.fn(() => ['mockTool', 'anotherTool']),
51 | };
52 | 
53 | const mockConfig = {
54 |   getToolRegistry: vi.fn(() => mockToolRegistry as unknown as ToolRegistry),
55 |   getApprovalMode: vi.fn(() => ApprovalMode.DEFAULT),
56 |   getSessionId: () => 'test-session-id',
57 |   getUsageStatisticsEnabled: () => true,
58 |   getDebugMode: () => false,
59 |   storage: {
60 |     getProjectTempDir: () => '/tmp',
61 |   },
62 |   getTruncateToolOutputThreshold: () => DEFAULT_TRUNCATE_TOOL_OUTPUT_THRESHOLD,
63 |   getTruncateToolOutputLines: () => DEFAULT_TRUNCATE_TOOL_OUTPUT_LINES,
64 |   getAllowedTools: vi.fn(() => []),
65 |   getContentGeneratorConfig: () => ({
66 |     model: 'test-model',
67 |     authType: 'oauth-personal',
68 |   }),
69 |   getUseSmartEdit: () => false,
70 |   getUseModelRouter: () => false,
71 |   getGeminiClient: () => null, // No client needed for these tests
72 |   getShellExecutionConfig: () => ({ terminalWidth: 80, terminalHeight: 24 }),
73 | } as unknown as Config;
74 | 
75 | const mockTool = new MockTool({
76 |   name: 'mockTool',
77 |   displayName: 'Mock Tool',
78 |   execute: vi.fn(),
79 |   shouldConfirmExecute: vi.fn(),
80 | });
81 | const mockToolWithLiveOutput = new MockTool({
82 |   name: 'mockToolWithLiveOutput',
83 |   displayName: 'Mock Tool With Live Output',
84 |   description: 'A mock tool for testing',
85 |   params: {},
86 |   isOutputMarkdown: true,
87 |   canUpdateOutput: true,
88 |   execute: vi.fn(),
89 |   shouldConfirmExecute: vi.fn(),
90 | });
91 | let mockOnUserConfirmForToolConfirmation: Mock;
92 | const mockToolRequiresConfirmation = new MockTool({
93 |   name: 'mockToolRequiresConfirmation',
94 |   displayName: 'Mock Tool Requires Confirmation',
95 |   execute: vi.fn(),
96 |   shouldConfirmExecute: vi.fn(),
97 | });
98 | 
99 | describe('useReactToolScheduler in YOLO Mode', () => {
100 |   let onComplete: Mock;
101 |   let setPendingHistoryItem: Mock;
102 | 
103 |   beforeEach(() => {
104 |     onComplete = vi.fn();
105 |     setPendingHistoryItem = vi.fn();
106 |     mockToolRegistry.getTool.mockClear();
107 |     (mockToolRequiresConfirmation.execute as Mock).mockClear();
108 |     (mockToolRequiresConfirmation.shouldConfirmExecute as Mock).mockClear();
109 | 
110 |     // IMPORTANT: Enable YOLO mode for this test suite
111 |     (mockConfig.getApprovalMode as Mock).mockReturnValue(ApprovalMode.YOLO);
112 | 
113 |     vi.useFakeTimers();
114 |   });
115 | 
116 |   afterEach(() => {
117 |     vi.clearAllTimers();
118 |     vi.useRealTimers();
119 |     // IMPORTANT: Disable YOLO mode after this test suite
120 |     (mockConfig.getApprovalMode as Mock).mockReturnValue(ApprovalMode.DEFAULT);
121 |   });
122 | 
123 |   const renderSchedulerInYoloMode = () =>
124 |     renderHook(() =>
125 |       useReactToolScheduler(
126 |         onComplete,
127 |         mockConfig as unknown as Config,
128 |         setPendingHistoryItem,
129 |         () => {},
130 |       ),
131 |     );
132 | 
133 |   it('should skip confirmation and execute tool directly when yoloMode is true', async () => {
134 |     mockToolRegistry.getTool.mockReturnValue(mockToolRequiresConfirmation);
135 |     const expectedOutput = 'YOLO Confirmed output';
136 |     (mockToolRequiresConfirmation.execute as Mock).mockResolvedValue({
137 |       llmContent: expectedOutput,
138 |       returnDisplay: 'YOLO Formatted tool output',
139 |     } as ToolResult);
140 | 
141 |     const { result } = renderSchedulerInYoloMode();
142 |     const schedule = result.current[1];
143 |     const request: ToolCallRequestInfo = {
144 |       callId: 'yoloCall',
145 |       name: 'mockToolRequiresConfirmation',
146 |       args: { data: 'any data' },
147 |     } as any;
148 | 
149 |     act(() => {
150 |       schedule(request, new AbortController().signal);
151 |     });
152 | 
153 |     await act(async () => {
154 |       await vi.runAllTimersAsync(); // Process validation
155 |     });
156 |     await act(async () => {
157 |       await vi.runAllTimersAsync(); // Process scheduling
158 |     });
159 |     await act(async () => {
160 |       await vi.runAllTimersAsync(); // Process execution
161 |     });
162 | 
163 |     // Check that execute WAS called
164 |     expect(mockToolRequiresConfirmation.execute).toHaveBeenCalledWith(
165 |       request.args,
166 |     );
167 | 
168 |     // Check that onComplete was called with success
169 |     expect(onComplete).toHaveBeenCalledWith([
170 |       expect.objectContaining({
171 |         status: 'success',
172 |         request,
173 |         response: expect.objectContaining({
174 |           resultDisplay: 'YOLO Formatted tool output',
175 |           responseParts: [
176 |             {
177 |               functionResponse: {
178 |                 id: 'yoloCall',
179 |                 name: 'mockToolRequiresConfirmation',
180 |                 response: { output: expectedOutput },
181 |               },
182 |             },
183 |           ],
184 |         }),
185 |       }),
186 |     ]);
187 | 
188 |     // Ensure no confirmation UI was triggered (setPendingHistoryItem should not have been called with confirmation details)
189 |     const setPendingHistoryItemCalls = setPendingHistoryItem.mock.calls;
190 |     const confirmationCall = setPendingHistoryItemCalls.find((call) => {
191 |       const item = typeof call[0] === 'function' ? call[0]({}) : call[0];
192 |       return item?.tools?.[0]?.confirmationDetails;
193 |     });
194 |     expect(confirmationCall).toBeUndefined();
195 |   });
196 | });
197 | 
198 | describe('useReactToolScheduler', () => {
199 |   // TODO(ntaylormullen): The following tests are skipped due to difficulties in
200 |   // reliably testing the asynchronous state updates and interactions with timers.
201 |   // These tests involve complex sequences of events, including confirmations,
202 |   // live output updates, and cancellations, which are challenging to assert
203 |   // correctly with the current testing setup. Further investigation is needed
204 |   // to find a robust way to test these scenarios.
205 |   let onComplete: Mock;
206 |   let setPendingHistoryItem: Mock;
207 |   let capturedOnConfirmForTest:
208 |     | ((outcome: ToolConfirmationOutcome) => void | Promise<void>)
209 |     | undefined;
210 | 
211 |   beforeEach(() => {
212 |     onComplete = vi.fn();
213 |     capturedOnConfirmForTest = undefined;
214 |     setPendingHistoryItem = vi.fn((updaterOrValue) => {
215 |       let pendingItem: HistoryItemWithoutId | null = null;
216 |       if (typeof updaterOrValue === 'function') {
217 |         // Loosen the type for prevState to allow for more flexible updates in tests
218 |         const prevState: Partial<HistoryItemToolGroup> = {
219 |           type: 'tool_group', // Still default to tool_group for most cases
220 |           tools: [],
221 |         };
222 | 
223 |         pendingItem = updaterOrValue(prevState as any); // Allow any for more flexibility
224 |       } else {
225 |         pendingItem = updaterOrValue;
226 |       }
227 |       // Capture onConfirm if it exists, regardless of the exact type of pendingItem
228 |       // This is a common pattern in these tests.
229 |       if (
230 |         (pendingItem as HistoryItemToolGroup)?.tools?.[0]?.confirmationDetails
231 |           ?.onConfirm
232 |       ) {
233 |         capturedOnConfirmForTest = (pendingItem as HistoryItemToolGroup)
234 |           .tools[0].confirmationDetails?.onConfirm;
235 |       }
236 |     });
237 | 
238 |     mockToolRegistry.getTool.mockClear();
239 |     (mockTool.execute as Mock).mockClear();
240 |     (mockTool.shouldConfirmExecute as Mock).mockClear();
241 |     (mockToolWithLiveOutput.execute as Mock).mockClear();
242 |     (mockToolWithLiveOutput.shouldConfirmExecute as Mock).mockClear();
243 |     (mockToolRequiresConfirmation.execute as Mock).mockClear();
244 |     (mockToolRequiresConfirmation.shouldConfirmExecute as Mock).mockClear();
245 | 
246 |     mockOnUserConfirmForToolConfirmation = vi.fn();
247 |     (
248 |       mockToolRequiresConfirmation.shouldConfirmExecute as Mock
249 |     ).mockImplementation(
250 |       async (): Promise<ToolCallConfirmationDetails | null> =>
251 |         ({
252 |           onConfirm: mockOnUserConfirmForToolConfirmation,
253 |           fileName: 'mockToolRequiresConfirmation.ts',
254 |           fileDiff: 'Mock tool requires confirmation',
255 |           type: 'edit',
256 |           title: 'Mock Tool Requires Confirmation',
257 |         }) as any,
258 |     );
259 | 
260 |     vi.useFakeTimers();
261 |   });
262 | 
263 |   afterEach(() => {
264 |     vi.clearAllTimers();
265 |     vi.useRealTimers();
266 |   });
267 | 
268 |   const renderScheduler = () =>
269 |     renderHook(() =>
270 |       useReactToolScheduler(
271 |         onComplete,
272 |         mockConfig as unknown as Config,
273 |         setPendingHistoryItem,
274 |         () => {},
275 |       ),
276 |     );
277 | 
278 |   it('initial state should be empty', () => {
279 |     const { result } = renderScheduler();
280 |     expect(result.current[0]).toEqual([]);
281 |   });
282 | 
283 |   it('should schedule and execute a tool call successfully', async () => {
284 |     mockToolRegistry.getTool.mockReturnValue(mockTool);
285 |     (mockTool.execute as Mock).mockResolvedValue({
286 |       llmContent: 'Tool output',
287 |       returnDisplay: 'Formatted tool output',
288 |     } as ToolResult);
289 |     (mockTool.shouldConfirmExecute as Mock).mockResolvedValue(null);
290 | 
291 |     const { result } = renderScheduler();
292 |     const schedule = result.current[1];
293 |     const request: ToolCallRequestInfo = {
294 |       callId: 'call1',
295 |       name: 'mockTool',
296 |       args: { param: 'value' },
297 |     } as any;
298 | 
299 |     act(() => {
300 |       schedule(request, new AbortController().signal);
301 |     });
302 |     await act(async () => {
303 |       await vi.runAllTimersAsync();
304 |     });
305 |     await act(async () => {
306 |       await vi.runAllTimersAsync();
307 |     });
308 |     await act(async () => {
309 |       await vi.runAllTimersAsync();
310 |     });
311 | 
312 |     expect(mockTool.execute).toHaveBeenCalledWith(request.args);
313 |     expect(onComplete).toHaveBeenCalledWith([
314 |       expect.objectContaining({
315 |         status: 'success',
316 |         request,
317 |         response: expect.objectContaining({
318 |           resultDisplay: 'Formatted tool output',
319 |           responseParts: [
320 |             {
321 |               functionResponse: {
322 |                 id: 'call1',
323 |                 name: 'mockTool',
324 |                 response: { output: 'Tool output' },
325 |               },
326 |             },
327 |           ],
328 |         }),
329 |       }),
330 |     ]);
331 |     expect(result.current[0]).toEqual([]);
332 |   });
333 | 
334 |   it('should handle tool not found', async () => {
335 |     mockToolRegistry.getTool.mockReturnValue(undefined);
336 |     const { result } = renderScheduler();
337 |     const schedule = result.current[1];
338 |     const request: ToolCallRequestInfo = {
339 |       callId: 'call1',
340 |       name: 'nonexistentTool',
341 |       args: {},
342 |     } as any;
343 | 
344 |     act(() => {
345 |       schedule(request, new AbortController().signal);
346 |     });
347 |     await act(async () => {
348 |       await vi.runAllTimersAsync();
349 |     });
350 |     await act(async () => {
351 |       await vi.runAllTimersAsync();
352 |     });
353 | 
354 |     expect(onComplete).toHaveBeenCalledWith([
355 |       expect.objectContaining({
356 |         status: 'error',
357 |         request,
358 |         response: expect.objectContaining({
359 |           error: expect.objectContaining({
360 |             message: expect.stringMatching(
361 |               /Tool "nonexistentTool" not found in registry/,
362 |             ),
363 |           }),
364 |         }),
365 |       }),
366 |     ]);
367 |     const errorMessage = onComplete.mock.calls[0][0][0].response.error.message;
368 |     expect(errorMessage).toContain('Did you mean one of:');
369 |     expect(errorMessage).toContain('"mockTool"');
370 |     expect(errorMessage).toContain('"anotherTool"');
371 |     expect(result.current[0]).toEqual([]);
372 |   });
373 | 
374 |   it('should handle error during shouldConfirmExecute', async () => {
375 |     mockToolRegistry.getTool.mockReturnValue(mockTool);
376 |     const confirmError = new Error('Confirmation check failed');
377 |     (mockTool.shouldConfirmExecute as Mock).mockRejectedValue(confirmError);
378 | 
379 |     const { result } = renderScheduler();
380 |     const schedule = result.current[1];
381 |     const request: ToolCallRequestInfo = {
382 |       callId: 'call1',
383 |       name: 'mockTool',
384 |       args: {},
385 |     } as any;
386 | 
[TRUNCATED]
```

src/ui/hooks/useWorkspaceMigration.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { useState, useEffect, useCallback, useMemo } from 'react';
8 | import type { GeminiCLIExtension } from '@google/gemini-cli-core';
9 | import { getWorkspaceExtensions } from '../../config/extension.js';
10 | import { type LoadedSettings, SettingScope } from '../../config/settings.js';
11 | import process from 'node:process';
12 | 
13 | export function useWorkspaceMigration(settings: LoadedSettings) {
14 |   const [showWorkspaceMigrationDialog, setShowWorkspaceMigrationDialog] =
15 |     useState(false);
16 |   const [workspaceExtensions, setWorkspaceExtensions] = useState<
17 |     GeminiCLIExtension[]
18 |   >([]);
19 | 
20 |   useEffect(() => {
21 |     // Default to true if not set.
22 |     if (!(settings.merged.experimental?.extensionManagement ?? true)) {
23 |       return;
24 |     }
25 |     const cwd = process.cwd();
26 |     const extensions = getWorkspaceExtensions(cwd);
27 |     if (
28 |       extensions.length > 0 &&
29 |       !settings.merged.extensions?.workspacesWithMigrationNudge?.includes(cwd)
30 |     ) {
31 |       setWorkspaceExtensions(extensions);
32 |       setShowWorkspaceMigrationDialog(true);
33 |       console.log(settings.merged.extensions);
34 |     }
35 |   }, [
36 |     settings.merged.extensions,
37 |     settings.merged.experimental?.extensionManagement,
38 |   ]);
39 | 
40 |   const onWorkspaceMigrationDialogOpen = useCallback(() => {
41 |     const userSettings = settings.forScope(SettingScope.User);
42 |     const extensionSettings = userSettings.settings.extensions || {
43 |       disabled: [],
44 |     };
45 |     const workspacesWithMigrationNudge =
46 |       extensionSettings.workspacesWithMigrationNudge || [];
47 | 
48 |     const cwd = process.cwd();
49 |     if (!workspacesWithMigrationNudge.includes(cwd)) {
50 |       workspacesWithMigrationNudge.push(cwd);
51 |     }
52 | 
53 |     extensionSettings.workspacesWithMigrationNudge =
54 |       workspacesWithMigrationNudge;
55 |     settings.setValue(SettingScope.User, 'extensions', extensionSettings);
56 |   }, [settings]);
57 | 
58 |   const onWorkspaceMigrationDialogClose = useCallback(() => {
59 |     setShowWorkspaceMigrationDialog(false);
60 |   }, [setShowWorkspaceMigrationDialog]);
61 | 
62 |   return useMemo(
63 |     () => ({
64 |       showWorkspaceMigrationDialog,
65 |       workspaceExtensions,
66 |       onWorkspaceMigrationDialogOpen,
67 |       onWorkspaceMigrationDialogClose,
68 |     }),
69 |     [
70 |       showWorkspaceMigrationDialog,
71 |       workspaceExtensions,
72 |       onWorkspaceMigrationDialogOpen,
73 |       onWorkspaceMigrationDialogClose,
74 |     ],
75 |   );
76 | }
```

src/ui/hooks/vim.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect, vi, beforeEach } from 'vitest';
8 | import { renderHook, act } from '@testing-library/react';
9 | import type React from 'react';
10 | import { useVim } from './vim.js';
11 | import type { TextBuffer } from '../components/shared/text-buffer.js';
12 | import { textBufferReducer } from '../components/shared/text-buffer.js';
13 | 
14 | // Mock the VimModeContext
15 | const mockVimContext = {
16 |   vimEnabled: true,
17 |   vimMode: 'NORMAL' as const,
18 |   toggleVimEnabled: vi.fn(),
19 |   setVimMode: vi.fn(),
20 | };
21 | 
22 | vi.mock('../contexts/VimModeContext.js', () => ({
23 |   useVimMode: () => mockVimContext,
24 |   VimModeProvider: ({ children }: { children: React.ReactNode }) => children,
25 | }));
26 | 
27 | // Test constants
28 | const TEST_SEQUENCES = {
29 |   ESCAPE: { sequence: '\u001b', name: 'escape' },
30 |   LEFT: { sequence: 'h' },
31 |   RIGHT: { sequence: 'l' },
32 |   UP: { sequence: 'k' },
33 |   DOWN: { sequence: 'j' },
34 |   INSERT: { sequence: 'i' },
35 |   APPEND: { sequence: 'a' },
36 |   DELETE_CHAR: { sequence: 'x' },
37 |   DELETE: { sequence: 'd' },
38 |   CHANGE: { sequence: 'c' },
39 |   WORD_FORWARD: { sequence: 'w' },
40 |   WORD_BACKWARD: { sequence: 'b' },
41 |   WORD_END: { sequence: 'e' },
42 |   LINE_START: { sequence: '0' },
43 |   LINE_END: { sequence: '$' },
44 |   REPEAT: { sequence: '.' },
45 | } as const;
46 | 
47 | describe('useVim hook', () => {
48 |   let mockBuffer: Partial<TextBuffer>;
49 |   let mockHandleFinalSubmit: vi.Mock;
50 | 
51 |   const createMockBuffer = (
52 |     text = 'hello world',
53 |     cursor: [number, number] = [0, 5],
54 |   ) => {
55 |     const cursorState = { pos: cursor };
56 |     const lines = text.split('\n');
57 | 
58 |     return {
59 |       lines,
60 |       get cursor() {
61 |         return cursorState.pos;
62 |       },
63 |       set cursor(newPos: [number, number]) {
64 |         cursorState.pos = newPos;
65 |       },
66 |       text,
67 |       move: vi.fn().mockImplementation((direction: string) => {
68 |         let [row, col] = cursorState.pos;
69 |         const _line = lines[row] || '';
70 |         if (direction === 'left') {
71 |           col = Math.max(0, col - 1);
72 |         } else if (direction === 'right') {
73 |           col = Math.min(line.length, col + 1);
74 |         } else if (direction === 'home') {
75 |           col = 0;
76 |         } else if (direction === 'end') {
77 |           col = line.length;
78 |         }
79 |         cursorState.pos = [row, col];
80 |       }),
81 |       del: vi.fn(),
82 |       moveToOffset: vi.fn(),
83 |       insert: vi.fn(),
84 |       newline: vi.fn(),
85 |       replaceRangeByOffset: vi.fn(),
86 |       handleInput: vi.fn(),
87 |       setText: vi.fn(),
88 |       // Vim-specific methods
89 |       vimDeleteWordForward: vi.fn(),
90 |       vimDeleteWordBackward: vi.fn(),
91 |       vimDeleteWordEnd: vi.fn(),
92 |       vimChangeWordForward: vi.fn(),
93 |       vimChangeWordBackward: vi.fn(),
94 |       vimChangeWordEnd: vi.fn(),
95 |       vimDeleteLine: vi.fn(),
96 |       vimChangeLine: vi.fn(),
97 |       vimDeleteToEndOfLine: vi.fn(),
98 |       vimChangeToEndOfLine: vi.fn(),
99 |       vimChangeMovement: vi.fn(),
100 |       vimMoveLeft: vi.fn(),
101 |       vimMoveRight: vi.fn(),
102 |       vimMoveUp: vi.fn(),
103 |       vimMoveDown: vi.fn(),
104 |       vimMoveWordForward: vi.fn(),
105 |       vimMoveWordBackward: vi.fn(),
106 |       vimMoveWordEnd: vi.fn(),
107 |       vimDeleteChar: vi.fn(),
108 |       vimInsertAtCursor: vi.fn(),
109 |       vimAppendAtCursor: vi.fn().mockImplementation(() => {
110 |         // Append moves cursor right (vim 'a' behavior - position after current char)
111 |         const [row, col] = cursorState.pos;
112 |         const _line = lines[row] || '';
113 |         // In vim, 'a' moves cursor to position after current character
114 |         // This allows inserting at the end of the line
115 |         cursorState.pos = [row, col + 1];
116 |       }),
117 |       vimOpenLineBelow: vi.fn(),
118 |       vimOpenLineAbove: vi.fn(),
119 |       vimAppendAtLineEnd: vi.fn(),
120 |       vimInsertAtLineStart: vi.fn(),
121 |       vimMoveToLineStart: vi.fn(),
122 |       vimMoveToLineEnd: vi.fn(),
123 |       vimMoveToFirstNonWhitespace: vi.fn(),
124 |       vimMoveToFirstLine: vi.fn(),
125 |       vimMoveToLastLine: vi.fn(),
126 |       vimMoveToLine: vi.fn(),
127 |       vimEscapeInsertMode: vi.fn().mockImplementation(() => {
128 |         // Escape moves cursor left unless at beginning of line
129 |         const [row, col] = cursorState.pos;
130 |         if (col > 0) {
131 |           cursorState.pos = [row, col - 1];
132 |         }
133 |       }),
134 |     };
135 |   };
136 | 
137 |   const _createMockSettings = (vimMode = true) => ({
138 |     getValue: vi.fn().mockReturnValue(vimMode),
139 |     setValue: vi.fn(),
140 |     merged: { vimMode },
141 |   });
142 | 
143 |   const renderVimHook = (buffer?: Partial<TextBuffer>) =>
144 |     renderHook(() =>
145 |       useVim((buffer || mockBuffer) as TextBuffer, mockHandleFinalSubmit),
146 |     );
147 | 
148 |   const exitInsertMode = (result: {
149 |     current: {
150 |       handleInput: (input: { sequence: string; name: string }) => void;
151 |     };
152 |   }) => {
153 |     act(() => {
154 |       result.current.handleInput({ sequence: '\u001b', name: 'escape' });
155 |     });
156 |   };
157 | 
158 |   beforeEach(() => {
159 |     vi.clearAllMocks();
160 |     mockHandleFinalSubmit = vi.fn();
161 |     mockBuffer = createMockBuffer();
162 |     // Reset mock context to default state
163 |     mockVimContext.vimEnabled = true;
164 |     mockVimContext.vimMode = 'NORMAL';
165 |     mockVimContext.toggleVimEnabled.mockClear();
166 |     mockVimContext.setVimMode.mockClear();
167 |   });
168 | 
169 |   describe('Mode switching', () => {
170 |     it('should start in NORMAL mode', () => {
171 |       const { result } = renderVimHook();
172 |       expect(result.current.mode).toBe('NORMAL');
173 |     });
174 | 
175 |     it('should switch to INSERT mode with i command', () => {
176 |       const { result } = renderVimHook();
177 | 
178 |       act(() => {
179 |         result.current.handleInput(TEST_SEQUENCES.INSERT);
180 |       });
181 | 
182 |       expect(result.current.mode).toBe('INSERT');
183 |       expect(mockVimContext.setVimMode).toHaveBeenCalledWith('INSERT');
184 |     });
185 | 
186 |     it('should switch back to NORMAL mode with Escape', () => {
187 |       const { result } = renderVimHook();
188 | 
189 |       act(() => {
190 |         result.current.handleInput(TEST_SEQUENCES.INSERT);
191 |       });
192 |       expect(result.current.mode).toBe('INSERT');
193 | 
194 |       exitInsertMode(result);
195 |       expect(result.current.mode).toBe('NORMAL');
196 |     });
197 | 
198 |     it('should properly handle escape followed immediately by a command', () => {
199 |       const testBuffer = createMockBuffer('hello world test', [0, 6]);
200 |       const { result } = renderVimHook(testBuffer);
201 | 
202 |       act(() => {
203 |         result.current.handleInput({ sequence: 'i' });
204 |       });
205 |       expect(result.current.mode).toBe('INSERT');
206 | 
207 |       vi.clearAllMocks();
208 | 
209 |       exitInsertMode(result);
210 |       expect(result.current.mode).toBe('NORMAL');
211 | 
212 |       act(() => {
213 |         result.current.handleInput({ sequence: 'b' });
214 |       });
215 | 
216 |       expect(testBuffer.vimMoveWordBackward).toHaveBeenCalledWith(1);
217 |     });
218 |   });
219 | 
220 |   describe('Navigation commands', () => {
221 |     it('should handle h (left movement)', () => {
222 |       const { result } = renderVimHook();
223 | 
224 |       act(() => {
225 |         result.current.handleInput({ sequence: 'h' });
226 |       });
227 | 
228 |       expect(mockBuffer.vimMoveLeft).toHaveBeenCalledWith(1);
229 |     });
230 | 
231 |     it('should handle l (right movement)', () => {
232 |       const { result } = renderVimHook();
233 | 
234 |       act(() => {
235 |         result.current.handleInput({ sequence: 'l' });
236 |       });
237 | 
238 |       expect(mockBuffer.vimMoveRight).toHaveBeenCalledWith(1);
239 |     });
240 | 
241 |     it('should handle j (down movement)', () => {
242 |       const testBuffer = createMockBuffer('first line\nsecond line');
243 |       const { result } = renderVimHook(testBuffer);
244 | 
245 |       act(() => {
246 |         result.current.handleInput({ sequence: 'j' });
247 |       });
248 | 
249 |       expect(testBuffer.vimMoveDown).toHaveBeenCalledWith(1);
250 |     });
251 | 
252 |     it('should handle k (up movement)', () => {
253 |       const testBuffer = createMockBuffer('first line\nsecond line');
254 |       const { result } = renderVimHook(testBuffer);
255 | 
256 |       act(() => {
257 |         result.current.handleInput({ sequence: 'k' });
258 |       });
259 | 
260 |       expect(testBuffer.vimMoveUp).toHaveBeenCalledWith(1);
261 |     });
262 | 
263 |     it('should handle 0 (move to start of line)', () => {
264 |       const { result } = renderVimHook();
265 | 
266 |       act(() => {
267 |         result.current.handleInput({ sequence: '0' });
268 |       });
269 | 
270 |       expect(mockBuffer.vimMoveToLineStart).toHaveBeenCalled();
271 |     });
272 | 
273 |     it('should handle $ (move to end of line)', () => {
274 |       const { result } = renderVimHook();
275 | 
276 |       act(() => {
277 |         result.current.handleInput({ sequence: '$' });
278 |       });
279 | 
280 |       expect(mockBuffer.vimMoveToLineEnd).toHaveBeenCalled();
281 |     });
282 |   });
283 | 
284 |   describe('Mode switching commands', () => {
285 |     it('should handle a (append after cursor)', () => {
286 |       const { result } = renderVimHook();
287 | 
288 |       act(() => {
289 |         result.current.handleInput({ sequence: 'a' });
290 |       });
291 | 
292 |       expect(mockBuffer.vimAppendAtCursor).toHaveBeenCalled();
293 |       expect(result.current.mode).toBe('INSERT');
294 |     });
295 | 
296 |     it('should handle A (append at end of line)', () => {
297 |       const { result } = renderVimHook();
298 | 
299 |       act(() => {
300 |         result.current.handleInput({ sequence: 'A' });
301 |       });
302 | 
303 |       expect(mockBuffer.vimAppendAtLineEnd).toHaveBeenCalled();
304 |       expect(result.current.mode).toBe('INSERT');
305 |     });
306 | 
307 |     it('should handle o (open line below)', () => {
308 |       const { result } = renderVimHook();
309 | 
310 |       act(() => {
311 |         result.current.handleInput({ sequence: 'o' });
312 |       });
313 | 
314 |       expect(mockBuffer.vimOpenLineBelow).toHaveBeenCalled();
315 |       expect(result.current.mode).toBe('INSERT');
316 |     });
317 | 
318 |     it('should handle O (open line above)', () => {
319 |       const { result } = renderVimHook();
320 | 
321 |       act(() => {
322 |         result.current.handleInput({ sequence: 'O' });
323 |       });
324 | 
325 |       expect(mockBuffer.vimOpenLineAbove).toHaveBeenCalled();
326 |       expect(result.current.mode).toBe('INSERT');
327 |     });
328 |   });
329 | 
330 |   describe('Edit commands', () => {
331 |     it('should handle x (delete character)', () => {
332 |       const { result } = renderVimHook();
333 |       vi.clearAllMocks();
334 | 
335 |       act(() => {
336 |         result.current.handleInput({ sequence: 'x' });
337 |       });
338 | 
339 |       expect(mockBuffer.vimDeleteChar).toHaveBeenCalledWith(1);
340 |     });
341 | 
342 |     it('should move cursor left when deleting last character on line (vim behavior)', () => {
343 |       const testBuffer = createMockBuffer('hello', [0, 4]);
344 |       const { result } = renderVimHook(testBuffer);
345 | 
346 |       act(() => {
347 |         result.current.handleInput({ sequence: 'x' });
348 |       });
349 | 
350 |       expect(testBuffer.vimDeleteChar).toHaveBeenCalledWith(1);
351 |     });
352 | 
353 |     it('should handle first d key (sets pending state)', () => {
354 |       const { result } = renderVimHook();
355 | 
356 |       act(() => {
357 |         result.current.handleInput({ sequence: 'd' });
358 |       });
359 | 
360 |       expect(mockBuffer.replaceRangeByOffset).not.toHaveBeenCalled();
361 |     });
362 |   });
363 | 
364 |   describe('Count handling', () => {
365 |     it('should handle count input and return to count 0 after command', () => {
366 |       const { result } = renderVimHook();
367 | 
368 |       act(() => {
369 |         const handled = result.current.handleInput({ sequence: '3' });
370 |         expect(handled).toBe(true);
371 |       });
372 | 
373 |       act(() => {
374 |         const handled = result.current.handleInput({ sequence: 'h' });
375 |         expect(handled).toBe(true);
376 |       });
377 | 
378 |       expect(mockBuffer.vimMoveLeft).toHaveBeenCalledWith(3);
379 |     });
380 | 
381 |     it('should only delete 1 character with x command when no count is specified', () => {
[TRUNCATED]
```

src/ui/hooks/vim.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { useCallback, useReducer, useEffect } from 'react';
8 | import type { Key } from './useKeypress.js';
9 | import type { TextBuffer } from '../components/shared/text-buffer.js';
10 | import { useVimMode } from '../contexts/VimModeContext.js';
11 | 
12 | export type VimMode = 'NORMAL' | 'INSERT';
13 | 
14 | // Constants
15 | const DIGIT_MULTIPLIER = 10;
16 | const DEFAULT_COUNT = 1;
17 | const DIGIT_1_TO_9 = /^[1-9]$/;
18 | 
19 | // Command types
20 | const CMD_TYPES = {
21 |   DELETE_WORD_FORWARD: 'dw',
22 |   DELETE_WORD_BACKWARD: 'db',
23 |   DELETE_WORD_END: 'de',
24 |   CHANGE_WORD_FORWARD: 'cw',
25 |   CHANGE_WORD_BACKWARD: 'cb',
26 |   CHANGE_WORD_END: 'ce',
27 |   DELETE_CHAR: 'x',
28 |   DELETE_LINE: 'dd',
29 |   CHANGE_LINE: 'cc',
30 |   DELETE_TO_EOL: 'D',
31 |   CHANGE_TO_EOL: 'C',
32 |   CHANGE_MOVEMENT: {
33 |     LEFT: 'ch',
34 |     DOWN: 'cj',
35 |     UP: 'ck',
36 |     RIGHT: 'cl',
37 |   },
38 | } as const;
39 | 
40 | // Helper function to clear pending state
41 | const createClearPendingState = () => ({
42 |   count: 0,
43 |   pendingOperator: null as 'g' | 'd' | 'c' | null,
44 | });
45 | 
46 | // State and action types for useReducer
47 | type VimState = {
48 |   mode: VimMode;
49 |   count: number;
50 |   pendingOperator: 'g' | 'd' | 'c' | null;
51 |   lastCommand: { type: string; count: number } | null;
52 | };
53 | 
54 | type VimAction =
55 |   | { type: 'SET_MODE'; mode: VimMode }
56 |   | { type: 'SET_COUNT'; count: number }
57 |   | { type: 'INCREMENT_COUNT'; digit: number }
58 |   | { type: 'CLEAR_COUNT' }
59 |   | { type: 'SET_PENDING_OPERATOR'; operator: 'g' | 'd' | 'c' | null }
60 |   | {
61 |       type: 'SET_LAST_COMMAND';
62 |       command: { type: string; count: number } | null;
63 |     }
64 |   | { type: 'CLEAR_PENDING_STATES' }
65 |   | { type: 'ESCAPE_TO_NORMAL' };
66 | 
67 | const initialVimState: VimState = {
68 |   mode: 'NORMAL',
69 |   count: 0,
70 |   pendingOperator: null,
71 |   lastCommand: null,
72 | };
73 | 
74 | // Reducer function
75 | const vimReducer = (state: VimState, action: VimAction): VimState => {
76 |   switch (action.type) {
77 |     case 'SET_MODE':
78 |       return { ...state, mode: action.mode };
79 | 
80 |     case 'SET_COUNT':
81 |       return { ...state, count: action.count };
82 | 
83 |     case 'INCREMENT_COUNT':
84 |       return { ...state, count: state.count * DIGIT_MULTIPLIER + action.digit };
85 | 
86 |     case 'CLEAR_COUNT':
87 |       return { ...state, count: 0 };
88 | 
89 |     case 'SET_PENDING_OPERATOR':
90 |       return { ...state, pendingOperator: action.operator };
91 | 
92 |     case 'SET_LAST_COMMAND':
93 |       return { ...state, lastCommand: action.command };
94 | 
95 |     case 'CLEAR_PENDING_STATES':
96 |       return {
97 |         ...state,
98 |         ...createClearPendingState(),
99 |       };
100 | 
101 |     case 'ESCAPE_TO_NORMAL':
102 |       // Handle escape - clear all pending states (mode is updated via context)
103 |       return {
104 |         ...state,
105 |         ...createClearPendingState(),
106 |       };
107 | 
108 |     default:
109 |       return state;
110 |   }
111 | };
112 | 
113 | /**
114 |  * React hook that provides vim-style editing functionality for text input.
115 |  *
116 |  * Features:
117 |  * - Modal editing (INSERT/NORMAL modes)
118 |  * - Navigation: h,j,k,l,w,b,e,0,$,^,gg,G with count prefixes
119 |  * - Editing: x,a,i,o,O,A,I,d,c,D,C with count prefixes
120 |  * - Complex operations: dd,cc,dw,cw,db,cb,de,ce
121 |  * - Command repetition (.)
122 |  * - Settings persistence
123 |  *
124 |  * @param buffer - TextBuffer instance for text manipulation
125 |  * @param onSubmit - Optional callback for command submission
126 |  * @returns Object with vim state and input handler
127 |  */
128 | export function useVim(buffer: TextBuffer, onSubmit?: (value: string) => void) {
129 |   const { vimEnabled, vimMode, setVimMode } = useVimMode();
130 |   const [state, dispatch] = useReducer(vimReducer, initialVimState);
131 | 
132 |   // Sync vim mode from context to local state
133 |   useEffect(() => {
134 |     dispatch({ type: 'SET_MODE', mode: vimMode });
135 |   }, [vimMode]);
136 | 
137 |   // Helper to update mode in both reducer and context
138 |   const updateMode = useCallback(
139 |     (mode: VimMode) => {
140 |       setVimMode(mode);
141 |       dispatch({ type: 'SET_MODE', mode });
142 |     },
143 |     [setVimMode],
144 |   );
145 | 
146 |   // Helper functions using the reducer state
147 |   const getCurrentCount = useCallback(
148 |     () => state.count || DEFAULT_COUNT,
149 |     [state.count],
150 |   );
151 | 
152 |   /** Executes common commands to eliminate duplication in dot (.) repeat command */
153 |   const executeCommand = useCallback(
154 |     (cmdType: string, count: number) => {
155 |       switch (cmdType) {
156 |         case CMD_TYPES.DELETE_WORD_FORWARD: {
157 |           buffer.vimDeleteWordForward(count);
158 |           break;
159 |         }
160 | 
161 |         case CMD_TYPES.DELETE_WORD_BACKWARD: {
162 |           buffer.vimDeleteWordBackward(count);
163 |           break;
164 |         }
165 | 
166 |         case CMD_TYPES.DELETE_WORD_END: {
167 |           buffer.vimDeleteWordEnd(count);
168 |           break;
169 |         }
170 | 
171 |         case CMD_TYPES.CHANGE_WORD_FORWARD: {
172 |           buffer.vimChangeWordForward(count);
173 |           updateMode('INSERT');
174 |           break;
175 |         }
176 | 
177 |         case CMD_TYPES.CHANGE_WORD_BACKWARD: {
178 |           buffer.vimChangeWordBackward(count);
179 |           updateMode('INSERT');
180 |           break;
181 |         }
182 | 
183 |         case CMD_TYPES.CHANGE_WORD_END: {
184 |           buffer.vimChangeWordEnd(count);
185 |           updateMode('INSERT');
186 |           break;
187 |         }
188 | 
189 |         case CMD_TYPES.DELETE_CHAR: {
190 |           buffer.vimDeleteChar(count);
191 |           break;
192 |         }
193 | 
194 |         case CMD_TYPES.DELETE_LINE: {
195 |           buffer.vimDeleteLine(count);
196 |           break;
197 |         }
198 | 
199 |         case CMD_TYPES.CHANGE_LINE: {
200 |           buffer.vimChangeLine(count);
201 |           updateMode('INSERT');
202 |           break;
203 |         }
204 | 
205 |         case CMD_TYPES.CHANGE_MOVEMENT.LEFT:
206 |         case CMD_TYPES.CHANGE_MOVEMENT.DOWN:
207 |         case CMD_TYPES.CHANGE_MOVEMENT.UP:
208 |         case CMD_TYPES.CHANGE_MOVEMENT.RIGHT: {
209 |           const movementMap: Record<string, 'h' | 'j' | 'k' | 'l'> = {
210 |             [CMD_TYPES.CHANGE_MOVEMENT.LEFT]: 'h',
211 |             [CMD_TYPES.CHANGE_MOVEMENT.DOWN]: 'j',
212 |             [CMD_TYPES.CHANGE_MOVEMENT.UP]: 'k',
213 |             [CMD_TYPES.CHANGE_MOVEMENT.RIGHT]: 'l',
214 |           };
215 |           const movementType = movementMap[cmdType];
216 |           if (movementType) {
217 |             buffer.vimChangeMovement(movementType, count);
218 |             updateMode('INSERT');
219 |           }
220 |           break;
221 |         }
222 | 
223 |         case CMD_TYPES.DELETE_TO_EOL: {
224 |           buffer.vimDeleteToEndOfLine();
225 |           break;
226 |         }
227 | 
228 |         case CMD_TYPES.CHANGE_TO_EOL: {
229 |           buffer.vimChangeToEndOfLine();
230 |           updateMode('INSERT');
231 |           break;
232 |         }
233 | 
234 |         default:
235 |           return false;
236 |       }
237 |       return true;
238 |     },
239 |     [buffer, updateMode],
240 |   );
241 | 
242 |   /**
243 |    * Handles key input in INSERT mode
244 |    * @param normalizedKey - The normalized key input
245 |    * @returns boolean indicating if the key was handled
246 |    */
247 |   const handleInsertModeInput = useCallback(
248 |     (normalizedKey: Key): boolean => {
249 |       // Handle escape key immediately - switch to NORMAL mode on any escape
250 |       if (normalizedKey.name === 'escape') {
251 |         // Vim behavior: move cursor left when exiting insert mode (unless at beginning of line)
252 |         buffer.vimEscapeInsertMode();
253 |         dispatch({ type: 'ESCAPE_TO_NORMAL' });
254 |         updateMode('NORMAL');
255 |         return true;
256 |       }
257 | 
258 |       // In INSERT mode, let InputPrompt handle completion keys and special commands
259 |       if (
260 |         normalizedKey.name === 'tab' ||
261 |         (normalizedKey.name === 'return' && !normalizedKey.ctrl) ||
262 |         normalizedKey.name === 'up' ||
263 |         normalizedKey.name === 'down' ||
264 |         (normalizedKey.ctrl && normalizedKey.name === 'r')
265 |       ) {
266 |         return false; // Let InputPrompt handle completion
267 |       }
268 | 
269 |       // Let InputPrompt handle Ctrl+V for clipboard image pasting
270 |       if (normalizedKey.ctrl && normalizedKey.name === 'v') {
271 |         return false; // Let InputPrompt handle clipboard functionality
272 |       }
273 | 
274 |       // Let InputPrompt handle shell commands
275 |       if (normalizedKey.sequence === '!' && buffer.text.length === 0) {
276 |         return false;
277 |       }
278 | 
279 |       // Special handling for Enter key to allow command submission (lower priority than completion)
280 |       if (
281 |         normalizedKey.name === 'return' &&
282 |         !normalizedKey.ctrl &&
283 |         !normalizedKey.meta
284 |       ) {
285 |         if (buffer.text.trim() && onSubmit) {
286 |           // Handle command submission directly
287 |           const submittedValue = buffer.text;
288 |           buffer.setText('');
289 |           onSubmit(submittedValue);
290 |           return true;
291 |         }
292 |         return true; // Handled by vim (even if no onSubmit callback)
293 |       }
294 | 
295 |       // useKeypress already provides the correct format for TextBuffer
296 |       buffer.handleInput(normalizedKey);
297 |       return true; // Handled by vim
298 |     },
299 |     [buffer, dispatch, updateMode, onSubmit],
300 |   );
301 | 
302 |   /**
303 |    * Normalizes key input to ensure all required properties are present
304 |    * @param key - Raw key input
305 |    * @returns Normalized key with all properties
306 |    */
307 |   const normalizeKey = useCallback(
308 |     (key: Key): Key => ({
309 |       name: key.name || '',
310 |       sequence: key.sequence || '',
311 |       ctrl: key.ctrl || false,
312 |       meta: key.meta || false,
313 |       shift: key.shift || false,
314 |       paste: key.paste || false,
315 |     }),
316 |     [],
317 |   );
318 | 
319 |   /**
320 |    * Handles change movement commands (ch, cj, ck, cl)
321 |    * @param movement - The movement direction
322 |    * @returns boolean indicating if command was handled
323 |    */
324 |   const handleChangeMovement = useCallback(
325 |     (movement: 'h' | 'j' | 'k' | 'l'): boolean => {
326 |       const count = getCurrentCount();
327 |       dispatch({ type: 'CLEAR_COUNT' });
328 |       buffer.vimChangeMovement(movement, count);
329 |       updateMode('INSERT');
330 | 
331 |       const cmdTypeMap = {
332 |         h: CMD_TYPES.CHANGE_MOVEMENT.LEFT,
333 |         j: CMD_TYPES.CHANGE_MOVEMENT.DOWN,
334 |         k: CMD_TYPES.CHANGE_MOVEMENT.UP,
335 |         l: CMD_TYPES.CHANGE_MOVEMENT.RIGHT,
336 |       };
337 | 
338 |       dispatch({
339 |         type: 'SET_LAST_COMMAND',
340 |         command: { type: cmdTypeMap[movement], count },
341 |       });
342 |       dispatch({ type: 'SET_PENDING_OPERATOR', operator: null });
343 |       return true;
344 |     },
345 |     [getCurrentCount, dispatch, buffer, updateMode],
346 |   );
347 | 
348 |   /**
349 |    * Handles operator-motion commands (dw/cw, db/cb, de/ce)
350 |    * @param operator - The operator type ('d' for delete, 'c' for change)
351 |    * @param motion - The motion type ('w', 'b', 'e')
352 |    * @returns boolean indicating if command was handled
353 |    */
354 |   const handleOperatorMotion = useCallback(
355 |     (operator: 'd' | 'c', motion: 'w' | 'b' | 'e'): boolean => {
356 |       const count = getCurrentCount();
357 | 
358 |       const commandMap = {
359 |         d: {
360 |           w: CMD_TYPES.DELETE_WORD_FORWARD,
361 |           b: CMD_TYPES.DELETE_WORD_BACKWARD,
362 |           e: CMD_TYPES.DELETE_WORD_END,
363 |         },
364 |         c: {
[TRUNCATED]
```

src/ui/noninteractive/nonInteractiveUi.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type { CommandContext } from '../commands/types.js';
8 | import type { ExtensionUpdateAction } from '../state/extensions.js';
9 | 
10 | /**
11 |  * Creates a UI context object with no-op functions.
12 |  * Useful for non-interactive environments where UI operations
13 |  * are not applicable.
14 |  */
15 | export function createNonInteractiveUI(): CommandContext['ui'] {
16 |   return {
17 |     addItem: (_item, _timestamp) => 0,
18 |     clear: () => {},
19 |     setDebugMessage: (_message) => {},
20 |     loadHistory: (_newHistory) => {},
21 |     pendingItem: null,
22 |     setPendingItem: (_item) => {},
23 |     toggleCorgiMode: () => {},
24 |     toggleDebugProfiler: () => {},
25 |     toggleVimEnabled: async () => false,
26 |     setGeminiMdFileCount: (_count) => {},
27 |     reloadCommands: () => {},
28 |     extensionsUpdateState: new Map(),
29 |     dispatchExtensionStateUpdate: (_action: ExtensionUpdateAction) => {},
30 |     addConfirmUpdateExtensionRequest: (_request) => {},
31 |   };
32 | }
```

src/ui/privacy/CloudFreePrivacyNotice.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { Box, Newline, Text } from 'ink';
8 | import { RadioButtonSelect } from '../components/shared/RadioButtonSelect.js';
9 | import { usePrivacySettings } from '../hooks/usePrivacySettings.js';
10 | 
11 | import type { Config } from '@google/gemini-cli-core';
12 | import { theme } from '../semantic-colors.js';
13 | import { useKeypress } from '../hooks/useKeypress.js';
14 | 
15 | interface CloudFreePrivacyNoticeProps {
16 |   config: Config;
17 |   onExit: () => void;
18 | }
19 | 
20 | export const CloudFreePrivacyNotice = ({
21 |   config,
22 |   onExit,
23 | }: CloudFreePrivacyNoticeProps) => {
24 |   const { privacyState, updateDataCollectionOptIn } =
25 |     usePrivacySettings(config);
26 | 
27 |   useKeypress(
28 |     (key) => {
29 |       if (
30 |         (privacyState.error || privacyState.isFreeTier === false) &&
31 |         key.name === 'escape'
32 |       ) {
33 |         onExit();
34 |       }
35 |     },
36 |     { isActive: true },
37 |   );
38 | 
39 |   if (privacyState.isLoading) {
40 |     return <Text color={theme.text.secondary}>Loading...</Text>;
41 |   }
42 | 
43 |   if (privacyState.error) {
44 |     return (
45 |       <Box flexDirection="column" marginY={1}>
46 |         <Text color={theme.status.error}>
47 |           Error loading Opt-in settings: {privacyState.error}
48 |         </Text>
49 |         <Text color={theme.text.secondary}>Press Esc to exit.</Text>
50 |       </Box>
51 |     );
52 |   }
53 | 
54 |   if (privacyState.isFreeTier === false) {
55 |     return (
56 |       <Box flexDirection="column" marginY={1}>
57 |         <Text bold color={theme.text.accent}>
58 |           Gemini Code Assist Privacy Notice
59 |         </Text>
60 |         <Newline />
61 |         <Text>
62 |           https://developers.google.com/gemini-code-assist/resources/privacy-notices
63 |         </Text>
64 |         <Newline />
65 |         <Text color={theme.text.secondary}>Press Esc to exit.</Text>
66 |       </Box>
67 |     );
68 |   }
69 | 
70 |   const items = [
71 |     { label: 'Yes', value: true, key: 'true' },
72 |     { label: 'No', value: false, key: 'false' },
73 |   ];
74 | 
75 |   return (
76 |     <Box flexDirection="column" marginY={1}>
77 |       <Text bold color={theme.text.accent}>
78 |         Gemini Code Assist for Individuals Privacy Notice
79 |       </Text>
80 |       <Newline />
81 |       <Text color={theme.text.primary}>
82 |         This notice and our Privacy Policy
83 |         <Text color={theme.text.link}>[1]</Text> describe how Gemini Code Assist
84 |         handles your data. Please read them carefully.
85 |       </Text>
86 |       <Newline />
87 |       <Text color={theme.text.primary}>
88 |         When you use Gemini Code Assist for individuals with Gemini CLI, Google
89 |         collects your prompts, related code, generated output, code edits,
90 |         related feature usage information, and your feedback to provide,
91 |         improve, and develop Google products and services and machine learning
92 |         technologies.
93 |       </Text>
94 |       <Newline />
95 |       <Text color={theme.text.primary}>
96 |         To help with quality and improve our products (such as generative
97 |         machine-learning models), human reviewers may read, annotate, and
98 |         process the data collected above. We take steps to protect your privacy
99 |         as part of this process. This includes disconnecting the data from your
100 |         Google Account before reviewers see or annotate it, and storing those
101 |         disconnected copies for up to 18 months. Please don&apos;t submit
102 |         confidential information or any data you wouldn&apos;t want a reviewer
103 |         to see or Google to use to improve our products, services and
104 |         machine-learning technologies.
105 |       </Text>
106 |       <Newline />
107 |       <Box flexDirection="column">
108 |         <Text color={theme.text.primary}>
109 |           Allow Google to use this data to develop and improve our products?
110 |         </Text>
111 |         <RadioButtonSelect
112 |           items={items}
113 |           initialIndex={privacyState.dataCollectionOptIn ? 0 : 1}
114 |           onSelect={(value) => {
115 |             updateDataCollectionOptIn(value);
116 |             // Only exit if there was no error.
117 |             if (!privacyState.error) {
118 |               onExit();
119 |             }
120 |           }}
121 |         />
122 |       </Box>
123 |       <Newline />
124 |       <Text>
125 |         <Text color={theme.text.link}>[1]</Text>{' '}
126 |         https://policies.google.com/privacy
127 |       </Text>
128 |       <Newline />
129 |       <Text color={theme.text.secondary}>
130 |         Press Enter to choose an option and exit.
131 |       </Text>
132 |     </Box>
133 |   );
134 | };
```

src/ui/privacy/CloudPaidPrivacyNotice.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { Box, Newline, Text } from 'ink';
8 | import { theme } from '../semantic-colors.js';
9 | import { useKeypress } from '../hooks/useKeypress.js';
10 | 
11 | interface CloudPaidPrivacyNoticeProps {
12 |   onExit: () => void;
13 | }
14 | 
15 | export const CloudPaidPrivacyNotice = ({
16 |   onExit,
17 | }: CloudPaidPrivacyNoticeProps) => {
18 |   useKeypress(
19 |     (key) => {
20 |       if (key.name === 'escape') {
21 |         onExit();
22 |       }
23 |     },
24 |     { isActive: true },
25 |   );
26 | 
27 |   return (
28 |     <Box flexDirection="column" marginBottom={1}>
29 |       <Text bold color={theme.text.accent}>
30 |         Vertex AI Notice
31 |       </Text>
32 |       <Newline />
33 |       <Text color={theme.text.primary}>
34 |         Service Specific Terms<Text color={theme.text.link}>[1]</Text> are
35 |         incorporated into the agreement under which Google has agreed to provide
36 |         Google Cloud Platform<Text color={theme.status.success}>[2]</Text> to
37 |         Customer (the “Agreement”). If the Agreement authorizes the resale or
38 |         supply of Google Cloud Platform under a Google Cloud partner or reseller
39 |         program, then except for in the section entitled “Partner-Specific
40 |         Terms”, all references to Customer in the Service Specific Terms mean
41 |         Partner or Reseller (as applicable), and all references to Customer Data
42 |         in the Service Specific Terms mean Partner Data. Capitalized terms used
43 |         but not defined in the Service Specific Terms have the meaning given to
44 |         them in the Agreement.
45 |       </Text>
46 |       <Newline />
47 |       <Text color={theme.text.primary}>
48 |         <Text color={theme.text.link}>[1]</Text>{' '}
49 |         https://cloud.google.com/terms/service-terms
50 |       </Text>
51 |       <Text color={theme.text.primary}>
52 |         <Text color={theme.status.success}>[2]</Text>{' '}
53 |         https://cloud.google.com/terms/services
54 |       </Text>
55 |       <Newline />
56 |       <Text color={theme.text.secondary}>Press Esc to exit.</Text>
57 |     </Box>
58 |   );
59 | };
```

src/ui/privacy/GeminiPrivacyNotice.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { Box, Newline, Text } from 'ink';
8 | import { theme } from '../semantic-colors.js';
9 | import { useKeypress } from '../hooks/useKeypress.js';
10 | 
11 | interface GeminiPrivacyNoticeProps {
12 |   onExit: () => void;
13 | }
14 | 
15 | export const GeminiPrivacyNotice = ({ onExit }: GeminiPrivacyNoticeProps) => {
16 |   useKeypress(
17 |     (key) => {
18 |       if (key.name === 'escape') {
19 |         onExit();
20 |       }
21 |     },
22 |     { isActive: true },
23 |   );
24 | 
25 |   return (
26 |     <Box flexDirection="column" marginBottom={1}>
27 |       <Text bold color={theme.text.accent}>
28 |         Gemini API Key Notice
29 |       </Text>
30 |       <Newline />
31 |       <Text color={theme.text.primary}>
32 |         By using the Gemini API<Text color={theme.text.link}>[1]</Text>, Google
33 |         AI Studio
34 |         <Text color={theme.status.error}>[2]</Text>, and the other Google
35 |         developer services that reference these terms (collectively, the
36 |         &quot;APIs&quot; or &quot;Services&quot;), you are agreeing to Google
37 |         APIs Terms of Service (the &quot;API Terms&quot;)
38 |         <Text color={theme.status.success}>[3]</Text>, and the Gemini API
39 |         Additional Terms of Service (the &quot;Additional Terms&quot;)
40 |         <Text color={theme.text.accent}>[4]</Text>.
41 |       </Text>
42 |       <Newline />
43 |       <Text color={theme.text.primary}>
44 |         <Text color={theme.text.link}>[1]</Text>{' '}
45 |         https://ai.google.dev/docs/gemini_api_overview
46 |       </Text>
47 |       <Text color={theme.text.primary}>
48 |         <Text color={theme.status.error}>[2]</Text> https://aistudio.google.com/
49 |       </Text>
50 |       <Text color={theme.text.primary}>
51 |         <Text color={theme.status.success}>[3]</Text>{' '}
52 |         https://developers.google.com/terms
53 |       </Text>
54 |       <Text color={theme.text.primary}>
55 |         <Text color={theme.text.accent}>[4]</Text>{' '}
56 |         https://ai.google.dev/gemini-api/terms
57 |       </Text>
58 |       <Newline />
59 |       <Text color={theme.text.secondary}>Press Esc to exit.</Text>
60 |     </Box>
61 |   );
62 | };
```

src/ui/privacy/PrivacyNotice.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { Box } from 'ink';
8 | import { type Config, AuthType } from '@google/gemini-cli-core';
9 | import { GeminiPrivacyNotice } from './GeminiPrivacyNotice.js';
10 | import { CloudPaidPrivacyNotice } from './CloudPaidPrivacyNotice.js';
11 | import { CloudFreePrivacyNotice } from './CloudFreePrivacyNotice.js';
12 | 
13 | interface PrivacyNoticeProps {
14 |   onExit: () => void;
15 |   config: Config;
16 | }
17 | 
18 | const PrivacyNoticeText = ({
19 |   config,
20 |   onExit,
21 | }: {
22 |   config: Config;
23 |   onExit: () => void;
24 | }) => {
25 |   const authType = config.getContentGeneratorConfig()?.authType;
26 | 
27 |   switch (authType) {
28 |     case AuthType.USE_GEMINI:
29 |       return <GeminiPrivacyNotice onExit={onExit} />;
30 |     case AuthType.USE_VERTEX_AI:
31 |       return <CloudPaidPrivacyNotice onExit={onExit} />;
32 |     case AuthType.LOGIN_WITH_GOOGLE:
33 |     default:
34 |       return <CloudFreePrivacyNotice config={config} onExit={onExit} />;
35 |   }
36 | };
37 | 
38 | export const PrivacyNotice = ({ onExit, config }: PrivacyNoticeProps) => (
39 |   <Box borderStyle="round" padding={1} flexDirection="column">
40 |     <PrivacyNoticeText config={config} onExit={onExit} />
41 |   </Box>
42 | );
```

src/ui/themes/ansi-light.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { type ColorsTheme, Theme } from './theme.js';
8 | import { lightSemanticColors } from './semantic-tokens.js';
9 | 
10 | const ansiLightColors: ColorsTheme = {
11 |   type: 'light',
12 |   Background: 'white',
13 |   Foreground: '#444',
14 |   LightBlue: 'blue',
15 |   AccentBlue: 'blue',
16 |   AccentPurple: 'purple',
17 |   AccentCyan: 'cyan',
18 |   AccentGreen: 'green',
19 |   AccentYellow: 'orange',
20 |   AccentRed: 'red',
21 |   DiffAdded: '#E5F2E5',
22 |   DiffRemoved: '#FFE5E5',
23 |   Comment: 'gray',
24 |   Gray: 'gray',
25 |   GradientColors: ['blue', 'green'],
26 | };
27 | 
28 | export const ANSILight: Theme = new Theme(
29 |   'ANSI Light',
30 |   'light',
31 |   {
32 |     hljs: {
33 |       display: 'block',
34 |       overflowX: 'auto',
35 |       padding: '0.5em',
36 |       background: 'white',
37 |       color: 'black',
38 |     },
39 |     'hljs-keyword': {
40 |       color: 'blue',
41 |     },
42 |     'hljs-literal': {
43 |       color: 'blue',
44 |     },
45 |     'hljs-symbol': {
46 |       color: 'blue',
47 |     },
48 |     'hljs-name': {
49 |       color: 'blue',
50 |     },
51 |     'hljs-link': {
52 |       color: 'blue',
53 |     },
54 |     'hljs-built_in': {
55 |       color: 'cyan',
56 |     },
57 |     'hljs-type': {
58 |       color: 'cyan',
59 |     },
60 |     'hljs-number': {
61 |       color: 'green',
62 |     },
63 |     'hljs-class': {
64 |       color: 'green',
65 |     },
66 |     'hljs-string': {
67 |       color: 'red',
68 |     },
69 |     'hljs-meta-string': {
70 |       color: 'red',
71 |     },
72 |     'hljs-regexp': {
73 |       color: 'magenta',
74 |     },
75 |     'hljs-template-tag': {
76 |       color: 'magenta',
77 |     },
78 |     'hljs-subst': {
79 |       color: 'black',
80 |     },
81 |     'hljs-function': {
82 |       color: 'black',
83 |     },
84 |     'hljs-title': {
85 |       color: 'black',
86 |     },
87 |     'hljs-params': {
88 |       color: 'black',
89 |     },
90 |     'hljs-formula': {
91 |       color: 'black',
92 |     },
93 |     'hljs-comment': {
94 |       color: 'gray',
95 |     },
96 |     'hljs-quote': {
97 |       color: 'gray',
98 |     },
99 |     'hljs-doctag': {
100 |       color: 'gray',
101 |     },
102 |     'hljs-meta': {
103 |       color: 'gray',
104 |     },
105 |     'hljs-meta-keyword': {
106 |       color: 'gray',
107 |     },
108 |     'hljs-tag': {
109 |       color: 'gray',
110 |     },
111 |     'hljs-variable': {
112 |       color: 'purple',
113 |     },
114 |     'hljs-template-variable': {
115 |       color: 'purple',
116 |     },
117 |     'hljs-attr': {
118 |       color: 'blue',
119 |     },
120 |     'hljs-attribute': {
121 |       color: 'blue',
122 |     },
123 |     'hljs-builtin-name': {
124 |       color: 'blue',
125 |     },
126 |     'hljs-section': {
127 |       color: 'orange',
128 |     },
129 |     'hljs-bullet': {
130 |       color: 'orange',
131 |     },
132 |     'hljs-selector-tag': {
133 |       color: 'orange',
134 |     },
135 |     'hljs-selector-id': {
136 |       color: 'orange',
137 |     },
138 |     'hljs-selector-class': {
139 |       color: 'orange',
140 |     },
141 |     'hljs-selector-attr': {
142 |       color: 'orange',
143 |     },
144 |     'hljs-selector-pseudo': {
145 |       color: 'orange',
146 |     },
147 |   },
148 |   ansiLightColors,
149 |   lightSemanticColors,
150 | );
```

src/ui/themes/ansi.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { type ColorsTheme, Theme } from './theme.js';
8 | import { darkSemanticColors } from './semantic-tokens.js';
9 | 
10 | const ansiColors: ColorsTheme = {
11 |   type: 'dark',
12 |   Background: 'black',
13 |   Foreground: 'white',
14 |   LightBlue: 'bluebright',
15 |   AccentBlue: 'blue',
16 |   AccentPurple: 'magenta',
17 |   AccentCyan: 'cyan',
18 |   AccentGreen: 'green',
19 |   AccentYellow: 'yellow',
20 |   AccentRed: 'red',
21 |   DiffAdded: '#003300',
22 |   DiffRemoved: '#4D0000',
23 |   Comment: 'gray',
24 |   Gray: 'gray',
25 |   GradientColors: ['cyan', 'green'],
26 | };
27 | 
28 | export const ANSI: Theme = new Theme(
29 |   'ANSI',
30 |   'dark', // Consistent with its color palette base
31 |   {
32 |     hljs: {
33 |       display: 'block',
34 |       overflowX: 'auto',
35 |       padding: '0.5em',
36 |       background: 'black', // Mapped from #1E1E1E
37 |       color: 'white', // Mapped from #DCDCDC
38 |     },
39 |     'hljs-keyword': {
40 |       color: 'blue', // Mapped from #569CD6
41 |     },
42 |     'hljs-literal': {
43 |       color: 'blue', // Mapped from #569CD6
44 |     },
45 |     'hljs-symbol': {
46 |       color: 'blue', // Mapped from #569CD6
47 |     },
48 |     'hljs-name': {
49 |       color: 'blue', // Mapped from #569CD6
50 |     },
51 |     'hljs-link': {
52 |       color: 'blue', // Mapped from #569CD6
53 |       // textDecoration is ignored by Theme class
54 |     },
55 |     'hljs-built_in': {
56 |       color: 'cyan', // Mapped from #4EC9B0
57 |     },
58 |     'hljs-type': {
59 |       color: 'cyan', // Mapped from #4EC9B0
60 |     },
61 |     'hljs-number': {
62 |       color: 'green', // Mapped from #B8D7A3
63 |     },
64 |     'hljs-class': {
65 |       color: 'green', // Mapped from #B8D7A3
66 |     },
67 |     'hljs-string': {
68 |       color: 'yellow', // Mapped from #D69D85
69 |     },
70 |     'hljs-meta-string': {
71 |       color: 'yellow', // Mapped from #D69D85
72 |     },
73 |     'hljs-regexp': {
74 |       color: 'red', // Mapped from #9A5334
75 |     },
76 |     'hljs-template-tag': {
77 |       color: 'red', // Mapped from #9A5334
78 |     },
79 |     'hljs-subst': {
80 |       color: 'white', // Mapped from #DCDCDC
81 |     },
82 |     'hljs-function': {
83 |       color: 'white', // Mapped from #DCDCDC
84 |     },
85 |     'hljs-title': {
86 |       color: 'white', // Mapped from #DCDCDC
87 |     },
88 |     'hljs-params': {
89 |       color: 'white', // Mapped from #DCDCDC
90 |     },
91 |     'hljs-formula': {
92 |       color: 'white', // Mapped from #DCDCDC
93 |     },
94 |     'hljs-comment': {
95 |       color: 'green', // Mapped from #57A64A
96 |       // fontStyle is ignored by Theme class
97 |     },
98 |     'hljs-quote': {
99 |       color: 'green', // Mapped from #57A64A
100 |       // fontStyle is ignored by Theme class
101 |     },
102 |     'hljs-doctag': {
103 |       color: 'green', // Mapped from #608B4E
104 |     },
105 |     'hljs-meta': {
106 |       color: 'gray', // Mapped from #9B9B9B
107 |     },
108 |     'hljs-meta-keyword': {
109 |       color: 'gray', // Mapped from #9B9B9B
110 |     },
111 |     'hljs-tag': {
112 |       color: 'gray', // Mapped from #9B9B9B
113 |     },
114 |     'hljs-variable': {
115 |       color: 'magenta', // Mapped from #BD63C5
116 |     },
117 |     'hljs-template-variable': {
118 |       color: 'magenta', // Mapped from #BD63C5
119 |     },
120 |     'hljs-attr': {
121 |       color: 'bluebright', // Mapped from #9CDCFE
122 |     },
123 |     'hljs-attribute': {
124 |       color: 'bluebright', // Mapped from #9CDCFE
125 |     },
126 |     'hljs-builtin-name': {
127 |       color: 'bluebright', // Mapped from #9CDCFE
128 |     },
129 |     'hljs-section': {
130 |       color: 'yellow', // Mapped from gold
131 |     },
132 |     'hljs-emphasis': {
133 |       // fontStyle is ignored by Theme class
134 |     },
135 |     'hljs-strong': {
136 |       // fontWeight is ignored by Theme class
137 |     },
138 |     'hljs-bullet': {
139 |       color: 'yellow', // Mapped from #D7BA7D
140 |     },
141 |     'hljs-selector-tag': {
142 |       color: 'yellow', // Mapped from #D7BA7D
143 |     },
144 |     'hljs-selector-id': {
145 |       color: 'yellow', // Mapped from #D7BA7D
146 |     },
147 |     'hljs-selector-class': {
148 |       color: 'yellow', // Mapped from #D7BA7D
149 |     },
150 |     'hljs-selector-attr': {
151 |       color: 'yellow', // Mapped from #D7BA7D
152 |     },
153 |     'hljs-selector-pseudo': {
154 |       color: 'yellow', // Mapped from #D7BA7D
155 |     },
156 |   },
157 |   ansiColors,
158 |   darkSemanticColors,
159 | );
```

src/ui/themes/atom-one-dark.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { type ColorsTheme, Theme } from './theme.js';
8 | 
9 | const atomOneDarkColors: ColorsTheme = {
10 |   type: 'dark',
11 |   Background: '#282c34',
12 |   Foreground: '#abb2bf',
13 |   LightBlue: '#61aeee',
14 |   AccentBlue: '#61aeee',
15 |   AccentPurple: '#c678dd',
16 |   AccentCyan: '#56b6c2',
17 |   AccentGreen: '#98c379',
18 |   AccentYellow: '#e6c07b',
19 |   AccentRed: '#e06c75',
20 |   DiffAdded: '#39544E',
21 |   DiffRemoved: '#562B2F',
22 |   Comment: '#5c6370',
23 |   Gray: '#5c6370',
24 |   GradientColors: ['#61aeee', '#98c379'],
25 | };
26 | 
27 | export const AtomOneDark: Theme = new Theme(
28 |   'Atom One',
29 |   'dark',
30 |   {
31 |     hljs: {
32 |       display: 'block',
33 |       overflowX: 'auto',
34 |       padding: '0.5em',
35 |       color: atomOneDarkColors.Foreground,
36 |       background: atomOneDarkColors.Background,
37 |     },
38 |     'hljs-comment': {
39 |       color: atomOneDarkColors.Comment,
40 |       fontStyle: 'italic',
41 |     },
42 |     'hljs-quote': {
43 |       color: atomOneDarkColors.Comment,
44 |       fontStyle: 'italic',
45 |     },
46 |     'hljs-doctag': {
47 |       color: atomOneDarkColors.AccentPurple,
48 |     },
49 |     'hljs-keyword': {
50 |       color: atomOneDarkColors.AccentPurple,
51 |     },
52 |     'hljs-formula': {
53 |       color: atomOneDarkColors.AccentPurple,
54 |     },
55 |     'hljs-section': {
56 |       color: atomOneDarkColors.AccentRed,
57 |     },
58 |     'hljs-name': {
59 |       color: atomOneDarkColors.AccentRed,
60 |     },
61 |     'hljs-selector-tag': {
62 |       color: atomOneDarkColors.AccentRed,
63 |     },
64 |     'hljs-deletion': {
65 |       color: atomOneDarkColors.AccentRed,
66 |     },
67 |     'hljs-subst': {
68 |       color: atomOneDarkColors.AccentRed,
69 |     },
70 |     'hljs-literal': {
71 |       color: atomOneDarkColors.AccentCyan,
72 |     },
73 |     'hljs-string': {
74 |       color: atomOneDarkColors.AccentGreen,
75 |     },
76 |     'hljs-regexp': {
77 |       color: atomOneDarkColors.AccentGreen,
78 |     },
79 |     'hljs-addition': {
80 |       color: atomOneDarkColors.AccentGreen,
81 |     },
82 |     'hljs-attribute': {
83 |       color: atomOneDarkColors.AccentGreen,
84 |     },
85 |     'hljs-meta-string': {
86 |       color: atomOneDarkColors.AccentGreen,
87 |     },
88 |     'hljs-built_in': {
89 |       color: atomOneDarkColors.AccentYellow,
90 |     },
91 |     'hljs-class .hljs-title': {
92 |       color: atomOneDarkColors.AccentYellow,
93 |     },
94 |     'hljs-attr': {
95 |       color: atomOneDarkColors.AccentYellow,
96 |     },
97 |     'hljs-variable': {
98 |       color: atomOneDarkColors.AccentYellow,
99 |     },
100 |     'hljs-template-variable': {
101 |       color: atomOneDarkColors.AccentYellow,
102 |     },
103 |     'hljs-type': {
104 |       color: atomOneDarkColors.AccentYellow,
105 |     },
106 |     'hljs-selector-class': {
107 |       color: atomOneDarkColors.AccentYellow,
108 |     },
109 |     'hljs-selector-attr': {
110 |       color: atomOneDarkColors.AccentYellow,
111 |     },
112 |     'hljs-selector-pseudo': {
113 |       color: atomOneDarkColors.AccentYellow,
114 |     },
115 |     'hljs-number': {
116 |       color: atomOneDarkColors.AccentYellow,
117 |     },
118 |     'hljs-symbol': {
119 |       color: atomOneDarkColors.AccentBlue,
120 |     },
121 |     'hljs-bullet': {
122 |       color: atomOneDarkColors.AccentBlue,
123 |     },
124 |     'hljs-link': {
125 |       color: atomOneDarkColors.AccentBlue,
126 |       textDecoration: 'underline',
127 |     },
128 |     'hljs-meta': {
129 |       color: atomOneDarkColors.AccentBlue,
130 |     },
131 |     'hljs-selector-id': {
132 |       color: atomOneDarkColors.AccentBlue,
133 |     },
134 |     'hljs-title': {
135 |       color: atomOneDarkColors.AccentBlue,
136 |     },
137 |     'hljs-emphasis': {
138 |       fontStyle: 'italic',
139 |     },
140 |     'hljs-strong': {
141 |       fontWeight: 'bold',
142 |     },
143 |   },
144 |   atomOneDarkColors,
145 | );
```

src/ui/themes/ayu-light.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { type ColorsTheme, Theme } from './theme.js';
8 | 
9 | const ayuLightColors: ColorsTheme = {
10 |   type: 'light',
11 |   Background: '#f8f9fa',
12 |   Foreground: '#5c6166',
13 |   LightBlue: '#55b4d4',
14 |   AccentBlue: '#399ee6',
15 |   AccentPurple: '#a37acc',
16 |   AccentCyan: '#4cbf99',
17 |   AccentGreen: '#86b300',
18 |   AccentYellow: '#f2ae49',
19 |   AccentRed: '#f07171',
20 |   DiffAdded: '#C6EAD8',
21 |   DiffRemoved: '#FFCCCC',
22 |   Comment: '#ABADB1',
23 |   Gray: '#a6aaaf',
24 |   GradientColors: ['#399ee6', '#86b300'],
25 | };
26 | 
27 | export const AyuLight: Theme = new Theme(
28 |   'Ayu Light',
29 |   'light',
30 |   {
31 |     hljs: {
32 |       display: 'block',
33 |       overflowX: 'auto',
34 |       padding: '0.5em',
35 |       background: ayuLightColors.Background,
36 |       color: ayuLightColors.Foreground,
37 |     },
38 |     'hljs-comment': {
39 |       color: ayuLightColors.Comment,
40 |       fontStyle: 'italic',
41 |     },
42 |     'hljs-quote': {
43 |       color: ayuLightColors.AccentCyan,
44 |       fontStyle: 'italic',
45 |     },
46 |     'hljs-string': {
47 |       color: ayuLightColors.AccentGreen,
48 |     },
49 |     'hljs-constant': {
50 |       color: ayuLightColors.AccentCyan,
51 |     },
52 |     'hljs-number': {
53 |       color: ayuLightColors.AccentPurple,
54 |     },
55 |     'hljs-keyword': {
56 |       color: ayuLightColors.AccentYellow,
57 |     },
58 |     'hljs-selector-tag': {
59 |       color: ayuLightColors.AccentYellow,
60 |     },
61 |     'hljs-attribute': {
62 |       color: ayuLightColors.AccentYellow,
63 |     },
64 |     'hljs-variable': {
65 |       color: ayuLightColors.Foreground,
66 |     },
67 |     'hljs-variable.language': {
68 |       color: ayuLightColors.LightBlue,
69 |       fontStyle: 'italic',
70 |     },
71 |     'hljs-title': {
72 |       color: ayuLightColors.AccentBlue,
73 |     },
74 |     'hljs-section': {
75 |       color: ayuLightColors.AccentGreen,
76 |       fontWeight: 'bold',
77 |     },
78 |     'hljs-type': {
79 |       color: ayuLightColors.LightBlue,
80 |     },
81 |     'hljs-class .hljs-title': {
82 |       color: ayuLightColors.AccentBlue,
83 |     },
84 |     'hljs-tag': {
85 |       color: ayuLightColors.LightBlue,
86 |     },
87 |     'hljs-name': {
88 |       color: ayuLightColors.AccentBlue,
89 |     },
90 |     'hljs-builtin-name': {
91 |       color: ayuLightColors.AccentYellow,
92 |     },
93 |     'hljs-meta': {
94 |       color: ayuLightColors.AccentYellow,
95 |     },
96 |     'hljs-symbol': {
97 |       color: ayuLightColors.AccentRed,
98 |     },
99 |     'hljs-bullet': {
100 |       color: ayuLightColors.AccentYellow,
101 |     },
102 |     'hljs-regexp': {
103 |       color: ayuLightColors.AccentCyan,
104 |     },
105 |     'hljs-link': {
106 |       color: ayuLightColors.LightBlue,
107 |     },
108 |     'hljs-deletion': {
109 |       color: ayuLightColors.AccentRed,
110 |     },
111 |     'hljs-addition': {
112 |       color: ayuLightColors.AccentGreen,
113 |     },
114 |     'hljs-emphasis': {
115 |       fontStyle: 'italic',
116 |     },
117 |     'hljs-strong': {
118 |       fontWeight: 'bold',
119 |     },
120 |     'hljs-literal': {
121 |       color: ayuLightColors.AccentCyan,
122 |     },
123 |     'hljs-built_in': {
124 |       color: ayuLightColors.AccentRed,
125 |     },
126 |     'hljs-doctag': {
127 |       color: ayuLightColors.AccentRed,
128 |     },
129 |     'hljs-template-variable': {
130 |       color: ayuLightColors.AccentCyan,
131 |     },
132 |     'hljs-selector-id': {
133 |       color: ayuLightColors.AccentRed,
134 |     },
135 |   },
136 |   ayuLightColors,
137 | );
```

src/ui/themes/ayu.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { type ColorsTheme, Theme } from './theme.js';
8 | 
9 | const ayuDarkColors: ColorsTheme = {
10 |   type: 'dark',
11 |   Background: '#0b0e14',
12 |   Foreground: '#aeaca6',
13 |   LightBlue: '#59C2FF',
14 |   AccentBlue: '#39BAE6',
15 |   AccentPurple: '#D2A6FF',
16 |   AccentCyan: '#95E6CB',
17 |   AccentGreen: '#AAD94C',
18 |   AccentYellow: '#FFB454',
19 |   AccentRed: '#F26D78',
20 |   DiffAdded: '#293022',
21 |   DiffRemoved: '#3D1215',
22 |   Comment: '#646A71',
23 |   Gray: '#3D4149',
24 |   GradientColors: ['#FFB454', '#F26D78'],
25 | };
26 | 
27 | export const AyuDark: Theme = new Theme(
28 |   'Ayu',
29 |   'dark',
30 |   {
31 |     hljs: {
32 |       display: 'block',
33 |       overflowX: 'auto',
34 |       padding: '0.5em',
35 |       background: ayuDarkColors.Background,
36 |       color: ayuDarkColors.Foreground,
37 |     },
38 |     'hljs-keyword': {
39 |       color: ayuDarkColors.AccentYellow,
40 |     },
41 |     'hljs-literal': {
42 |       color: ayuDarkColors.AccentPurple,
43 |     },
44 |     'hljs-symbol': {
45 |       color: ayuDarkColors.AccentCyan,
46 |     },
47 |     'hljs-name': {
48 |       color: ayuDarkColors.LightBlue,
49 |     },
50 |     'hljs-link': {
51 |       color: ayuDarkColors.AccentBlue,
52 |     },
53 |     'hljs-function .hljs-keyword': {
54 |       color: ayuDarkColors.AccentYellow,
55 |     },
56 |     'hljs-subst': {
57 |       color: ayuDarkColors.Foreground,
58 |     },
59 |     'hljs-string': {
60 |       color: ayuDarkColors.AccentGreen,
61 |     },
62 |     'hljs-title': {
63 |       color: ayuDarkColors.AccentYellow,
64 |     },
65 |     'hljs-type': {
66 |       color: ayuDarkColors.AccentBlue,
67 |     },
68 |     'hljs-attribute': {
69 |       color: ayuDarkColors.AccentYellow,
70 |     },
71 |     'hljs-bullet': {
72 |       color: ayuDarkColors.AccentYellow,
73 |     },
74 |     'hljs-addition': {
75 |       color: ayuDarkColors.AccentGreen,
76 |     },
77 |     'hljs-variable': {
78 |       color: ayuDarkColors.Foreground,
79 |     },
80 |     'hljs-template-tag': {
81 |       color: ayuDarkColors.AccentYellow,
82 |     },
83 |     'hljs-template-variable': {
84 |       color: ayuDarkColors.AccentYellow,
85 |     },
86 |     'hljs-comment': {
87 |       color: ayuDarkColors.Comment,
88 |       fontStyle: 'italic',
89 |     },
90 |     'hljs-quote': {
91 |       color: ayuDarkColors.AccentCyan,
92 |       fontStyle: 'italic',
93 |     },
94 |     'hljs-deletion': {
95 |       color: ayuDarkColors.AccentRed,
96 |     },
97 |     'hljs-meta': {
98 |       color: ayuDarkColors.AccentYellow,
99 |     },
100 |     'hljs-doctag': {
101 |       fontWeight: 'bold',
102 |     },
103 |     'hljs-strong': {
104 |       fontWeight: 'bold',
105 |     },
106 |     'hljs-emphasis': {
107 |       fontStyle: 'italic',
108 |     },
109 |   },
110 |   ayuDarkColors,
111 | );
```

src/ui/themes/color-utils.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect } from 'vitest';
8 | import {
9 |   isValidColor,
10 |   resolveColor,
11 |   CSS_NAME_TO_HEX_MAP,
12 |   INK_SUPPORTED_NAMES,
13 | } from './color-utils.js';
14 | 
15 | describe('Color Utils', () => {
16 |   describe('isValidColor', () => {
17 |     it('should validate hex colors', () => {
18 |       expect(isValidColor('#ff0000')).toBe(true);
19 |       expect(isValidColor('#00ff00')).toBe(true);
20 |       expect(isValidColor('#0000ff')).toBe(true);
21 |       expect(isValidColor('#fff')).toBe(true);
22 |       expect(isValidColor('#000')).toBe(true);
23 |       expect(isValidColor('#FF0000')).toBe(true); // Case insensitive
24 |     });
25 | 
26 |     it('should validate Ink-supported color names', () => {
27 |       expect(isValidColor('black')).toBe(true);
28 |       expect(isValidColor('red')).toBe(true);
29 |       expect(isValidColor('green')).toBe(true);
30 |       expect(isValidColor('yellow')).toBe(true);
31 |       expect(isValidColor('blue')).toBe(true);
32 |       expect(isValidColor('cyan')).toBe(true);
33 |       expect(isValidColor('magenta')).toBe(true);
34 |       expect(isValidColor('white')).toBe(true);
35 |       expect(isValidColor('gray')).toBe(true);
36 |       expect(isValidColor('grey')).toBe(true);
37 |       expect(isValidColor('blackbright')).toBe(true);
38 |       expect(isValidColor('redbright')).toBe(true);
39 |       expect(isValidColor('greenbright')).toBe(true);
40 |       expect(isValidColor('yellowbright')).toBe(true);
41 |       expect(isValidColor('bluebright')).toBe(true);
42 |       expect(isValidColor('cyanbright')).toBe(true);
43 |       expect(isValidColor('magentabright')).toBe(true);
44 |       expect(isValidColor('whitebright')).toBe(true);
45 |     });
46 | 
47 |     it('should validate Ink-supported color names case insensitive', () => {
48 |       expect(isValidColor('BLACK')).toBe(true);
49 |       expect(isValidColor('Red')).toBe(true);
50 |       expect(isValidColor('GREEN')).toBe(true);
51 |     });
52 | 
53 |     it('should validate CSS color names', () => {
54 |       expect(isValidColor('darkkhaki')).toBe(true);
55 |       expect(isValidColor('coral')).toBe(true);
56 |       expect(isValidColor('teal')).toBe(true);
57 |       expect(isValidColor('tomato')).toBe(true);
58 |       expect(isValidColor('turquoise')).toBe(true);
59 |       expect(isValidColor('violet')).toBe(true);
60 |       expect(isValidColor('wheat')).toBe(true);
61 |       expect(isValidColor('whitesmoke')).toBe(true);
62 |       expect(isValidColor('yellowgreen')).toBe(true);
63 |     });
64 | 
65 |     it('should validate CSS color names case insensitive', () => {
66 |       expect(isValidColor('DARKKHAKI')).toBe(true);
67 |       expect(isValidColor('Coral')).toBe(true);
68 |       expect(isValidColor('TEAL')).toBe(true);
69 |     });
70 | 
71 |     it('should reject invalid color names', () => {
72 |       expect(isValidColor('invalidcolor')).toBe(false);
73 |       expect(isValidColor('notacolor')).toBe(false);
74 |       expect(isValidColor('')).toBe(false);
75 |     });
76 |   });
77 | 
78 |   describe('resolveColor', () => {
79 |     it('should resolve hex colors', () => {
80 |       expect(resolveColor('#ff0000')).toBe('#ff0000');
81 |       expect(resolveColor('#00ff00')).toBe('#00ff00');
82 |       expect(resolveColor('#0000ff')).toBe('#0000ff');
83 |       expect(resolveColor('#fff')).toBe('#fff');
84 |       expect(resolveColor('#000')).toBe('#000');
85 |     });
86 | 
87 |     it('should resolve Ink-supported color names', () => {
88 |       expect(resolveColor('black')).toBe('black');
89 |       expect(resolveColor('red')).toBe('red');
90 |       expect(resolveColor('green')).toBe('green');
91 |       expect(resolveColor('yellow')).toBe('yellow');
92 |       expect(resolveColor('blue')).toBe('blue');
93 |       expect(resolveColor('cyan')).toBe('cyan');
94 |       expect(resolveColor('magenta')).toBe('magenta');
95 |       expect(resolveColor('white')).toBe('white');
96 |       expect(resolveColor('gray')).toBe('gray');
97 |       expect(resolveColor('grey')).toBe('grey');
98 |     });
99 | 
100 |     it('should resolve CSS color names to hex', () => {
101 |       expect(resolveColor('darkkhaki')).toBe('#bdb76b');
102 |       expect(resolveColor('coral')).toBe('#ff7f50');
103 |       expect(resolveColor('teal')).toBe('#008080');
104 |       expect(resolveColor('tomato')).toBe('#ff6347');
105 |       expect(resolveColor('turquoise')).toBe('#40e0d0');
106 |       expect(resolveColor('violet')).toBe('#ee82ee');
107 |       expect(resolveColor('wheat')).toBe('#f5deb3');
108 |       expect(resolveColor('whitesmoke')).toBe('#f5f5f5');
109 |       expect(resolveColor('yellowgreen')).toBe('#9acd32');
110 |     });
111 | 
112 |     it('should handle case insensitive color names', () => {
113 |       expect(resolveColor('DARKKHAKI')).toBe('#bdb76b');
114 |       expect(resolveColor('Coral')).toBe('#ff7f50');
115 |       expect(resolveColor('TEAL')).toBe('#008080');
116 |     });
117 | 
118 |     it('should return undefined for invalid colors', () => {
119 |       expect(resolveColor('invalidcolor')).toBeUndefined();
120 |       expect(resolveColor('notacolor')).toBeUndefined();
121 |       expect(resolveColor('')).toBeUndefined();
122 |     });
123 |   });
124 | 
125 |   describe('CSS_NAME_TO_HEX_MAP', () => {
126 |     it('should contain expected CSS color mappings', () => {
127 |       expect(CSS_NAME_TO_HEX_MAP['darkkhaki']).toBe('#bdb76b');
128 |       expect(CSS_NAME_TO_HEX_MAP['coral']).toBe('#ff7f50');
129 |       expect(CSS_NAME_TO_HEX_MAP['teal']).toBe('#008080');
130 |       expect(CSS_NAME_TO_HEX_MAP['tomato']).toBe('#ff6347');
131 |       expect(CSS_NAME_TO_HEX_MAP['turquoise']).toBe('#40e0d0');
132 |     });
133 | 
134 |     it('should not contain Ink-supported color names', () => {
135 |       expect(CSS_NAME_TO_HEX_MAP['black']).toBeUndefined();
136 |       expect(CSS_NAME_TO_HEX_MAP['red']).toBeUndefined();
137 |       expect(CSS_NAME_TO_HEX_MAP['green']).toBeUndefined();
138 |       expect(CSS_NAME_TO_HEX_MAP['blue']).toBeUndefined();
139 |     });
140 |   });
141 | 
142 |   describe('INK_SUPPORTED_NAMES', () => {
143 |     it('should contain all Ink-supported color names', () => {
144 |       expect(INK_SUPPORTED_NAMES.has('black')).toBe(true);
145 |       expect(INK_SUPPORTED_NAMES.has('red')).toBe(true);
146 |       expect(INK_SUPPORTED_NAMES.has('green')).toBe(true);
147 |       expect(INK_SUPPORTED_NAMES.has('yellow')).toBe(true);
148 |       expect(INK_SUPPORTED_NAMES.has('blue')).toBe(true);
149 |       expect(INK_SUPPORTED_NAMES.has('cyan')).toBe(true);
150 |       expect(INK_SUPPORTED_NAMES.has('magenta')).toBe(true);
151 |       expect(INK_SUPPORTED_NAMES.has('white')).toBe(true);
152 |       expect(INK_SUPPORTED_NAMES.has('gray')).toBe(true);
153 |       expect(INK_SUPPORTED_NAMES.has('grey')).toBe(true);
154 |       expect(INK_SUPPORTED_NAMES.has('blackbright')).toBe(true);
155 |       expect(INK_SUPPORTED_NAMES.has('redbright')).toBe(true);
156 |       expect(INK_SUPPORTED_NAMES.has('greenbright')).toBe(true);
157 |       expect(INK_SUPPORTED_NAMES.has('yellowbright')).toBe(true);
158 |       expect(INK_SUPPORTED_NAMES.has('bluebright')).toBe(true);
159 |       expect(INK_SUPPORTED_NAMES.has('cyanbright')).toBe(true);
160 |       expect(INK_SUPPORTED_NAMES.has('magentabright')).toBe(true);
161 |       expect(INK_SUPPORTED_NAMES.has('whitebright')).toBe(true);
162 |     });
163 | 
164 |     it('should not contain CSS color names', () => {
165 |       expect(INK_SUPPORTED_NAMES.has('darkkhaki')).toBe(false);
166 |       expect(INK_SUPPORTED_NAMES.has('coral')).toBe(false);
167 |       expect(INK_SUPPORTED_NAMES.has('teal')).toBe(false);
168 |     });
169 |   });
170 | 
171 |   describe('Consistency between validation and resolution', () => {
172 |     it('should have consistent behavior between isValidColor and resolveColor', () => {
173 |       // Test that any color that isValidColor returns true for can be resolved
174 |       const testColors = [
175 |         '#ff0000',
176 |         '#00ff00',
177 |         '#0000ff',
178 |         '#fff',
179 |         '#000',
180 |         'black',
181 |         'red',
182 |         'green',
183 |         'yellow',
184 |         'blue',
185 |         'cyan',
186 |         'magenta',
187 |         'white',
188 |         'gray',
189 |         'grey',
190 |         'darkkhaki',
191 |         'coral',
192 |         'teal',
193 |         'tomato',
194 |         'turquoise',
195 |         'violet',
196 |         'wheat',
197 |         'whitesmoke',
198 |         'yellowgreen',
199 |       ];
200 | 
201 |       for (const color of testColors) {
202 |         expect(isValidColor(color)).toBe(true);
203 |         expect(resolveColor(color)).toBeDefined();
204 |       }
205 | 
206 |       // Test that invalid colors are consistently rejected
207 |       const invalidColors = [
208 |         'invalidcolor',
209 |         'notacolor',
210 |         '',
211 |         '#gg0000',
212 |         '#ff00',
213 |       ];
214 | 
215 |       for (const color of invalidColors) {
216 |         expect(isValidColor(color)).toBe(false);
217 |         expect(resolveColor(color)).toBeUndefined();
218 |       }
219 |     });
220 |   });
221 | });
```

src/ui/themes/color-utils.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | // Mapping from common CSS color names (lowercase) to hex codes (lowercase)
8 | // Excludes names directly supported by Ink
9 | export const CSS_NAME_TO_HEX_MAP: Readonly<Record<string, string>> = {
10 |   aliceblue: '#f0f8ff',
11 |   antiquewhite: '#faebd7',
12 |   aqua: '#00ffff',
13 |   aquamarine: '#7fffd4',
14 |   azure: '#f0ffff',
15 |   beige: '#f5f5dc',
16 |   bisque: '#ffe4c4',
17 |   blanchedalmond: '#ffebcd',
18 |   blueviolet: '#8a2be2',
19 |   brown: '#a52a2a',
20 |   burlywood: '#deb887',
21 |   cadetblue: '#5f9ea0',
22 |   chartreuse: '#7fff00',
23 |   chocolate: '#d2691e',
24 |   coral: '#ff7f50',
25 |   cornflowerblue: '#6495ed',
26 |   cornsilk: '#fff8dc',
27 |   crimson: '#dc143c',
28 |   darkblue: '#00008b',
29 |   darkcyan: '#008b8b',
30 |   darkgoldenrod: '#b8860b',
31 |   darkgray: '#a9a9a9',
32 |   darkgrey: '#a9a9a9',
33 |   darkgreen: '#006400',
34 |   darkkhaki: '#bdb76b',
35 |   darkmagenta: '#8b008b',
36 |   darkolivegreen: '#556b2f',
37 |   darkorange: '#ff8c00',
38 |   darkorchid: '#9932cc',
39 |   darkred: '#8b0000',
40 |   darksalmon: '#e9967a',
41 |   darkseagreen: '#8fbc8f',
42 |   darkslateblue: '#483d8b',
43 |   darkslategray: '#2f4f4f',
44 |   darkslategrey: '#2f4f4f',
45 |   darkturquoise: '#00ced1',
46 |   darkviolet: '#9400d3',
47 |   deeppink: '#ff1493',
48 |   deepskyblue: '#00bfff',
49 |   dimgray: '#696969',
50 |   dimgrey: '#696969',
51 |   dodgerblue: '#1e90ff',
52 |   firebrick: '#b22222',
53 |   floralwhite: '#fffaf0',
54 |   forestgreen: '#228b22',
55 |   fuchsia: '#ff00ff',
56 |   gainsboro: '#dcdcdc',
57 |   ghostwhite: '#f8f8ff',
58 |   gold: '#ffd700',
59 |   goldenrod: '#daa520',
60 |   greenyellow: '#adff2f',
61 |   honeydew: '#f0fff0',
62 |   hotpink: '#ff69b4',
63 |   indianred: '#cd5c5c',
64 |   indigo: '#4b0082',
65 |   ivory: '#fffff0',
66 |   khaki: '#f0e68c',
67 |   lavender: '#e6e6fa',
68 |   lavenderblush: '#fff0f5',
69 |   lawngreen: '#7cfc00',
70 |   lemonchiffon: '#fffacd',
71 |   lightblue: '#add8e6',
72 |   lightcoral: '#f08080',
73 |   lightcyan: '#e0ffff',
74 |   lightgoldenrodyellow: '#fafad2',
75 |   lightgray: '#d3d3d3',
76 |   lightgrey: '#d3d3d3',
77 |   lightgreen: '#90ee90',
78 |   lightpink: '#ffb6c1',
79 |   lightsalmon: '#ffa07a',
80 |   lightseagreen: '#20b2aa',
81 |   lightskyblue: '#87cefa',
82 |   lightslategray: '#778899',
83 |   lightslategrey: '#778899',
84 |   lightsteelblue: '#b0c4de',
85 |   lightyellow: '#ffffe0',
86 |   lime: '#00ff00',
87 |   limegreen: '#32cd32',
88 |   linen: '#faf0e6',
89 |   maroon: '#800000',
90 |   mediumaquamarine: '#66cdaa',
91 |   mediumblue: '#0000cd',
92 |   mediumorchid: '#ba55d3',
93 |   mediumpurple: '#9370db',
94 |   mediumseagreen: '#3cb371',
95 |   mediumslateblue: '#7b68ee',
96 |   mediumspringgreen: '#00fa9a',
97 |   mediumturquoise: '#48d1cc',
98 |   mediumvioletred: '#c71585',
99 |   midnightblue: '#191970',
100 |   mintcream: '#f5fffa',
101 |   mistyrose: '#ffe4e1',
102 |   moccasin: '#ffe4b5',
103 |   navajowhite: '#ffdead',
104 |   navy: '#000080',
105 |   oldlace: '#fdf5e6',
106 |   olive: '#808000',
107 |   olivedrab: '#6b8e23',
108 |   orange: '#ffa500',
109 |   orangered: '#ff4500',
110 |   orchid: '#da70d6',
111 |   palegoldenrod: '#eee8aa',
112 |   palegreen: '#98fb98',
113 |   paleturquoise: '#afeeee',
114 |   palevioletred: '#db7093',
115 |   papayawhip: '#ffefd5',
116 |   peachpuff: '#ffdab9',
117 |   peru: '#cd853f',
118 |   pink: '#ffc0cb',
119 |   plum: '#dda0dd',
120 |   powderblue: '#b0e0e6',
121 |   purple: '#800080',
122 |   rebeccapurple: '#663399',
123 |   rosybrown: '#bc8f8f',
124 |   royalblue: '#4169e1',
125 |   saddlebrown: '#8b4513',
126 |   salmon: '#fa8072',
127 |   sandybrown: '#f4a460',
128 |   seagreen: '#2e8b57',
129 |   seashell: '#fff5ee',
130 |   sienna: '#a0522d',
131 |   silver: '#c0c0c0',
132 |   skyblue: '#87ceeb',
133 |   slateblue: '#6a5acd',
134 |   slategray: '#708090',
135 |   slategrey: '#708090',
136 |   snow: '#fffafa',
137 |   springgreen: '#00ff7f',
138 |   steelblue: '#4682b4',
139 |   tan: '#d2b48c',
140 |   teal: '#008080',
141 |   thistle: '#d8bfd8',
142 |   tomato: '#ff6347',
143 |   turquoise: '#40e0d0',
144 |   violet: '#ee82ee',
145 |   wheat: '#f5deb3',
146 |   whitesmoke: '#f5f5f5',
147 |   yellowgreen: '#9acd32',
148 | };
149 | 
150 | // Define the set of Ink's named colors for quick lookup
151 | export const INK_SUPPORTED_NAMES = new Set([
152 |   'black',
153 |   'red',
154 |   'green',
155 |   'yellow',
156 |   'blue',
157 |   'cyan',
158 |   'magenta',
159 |   'white',
160 |   'gray',
161 |   'grey',
162 |   'blackbright',
163 |   'redbright',
164 |   'greenbright',
165 |   'yellowbright',
166 |   'bluebright',
167 |   'cyanbright',
168 |   'magentabright',
169 |   'whitebright',
170 | ]);
171 | 
172 | /**
173 |  * Checks if a color string is valid (hex, Ink-supported color name, or CSS color name).
174 |  * This function uses the same validation logic as the Theme class's _resolveColor method
175 |  * to ensure consistency between validation and resolution.
176 |  * @param color The color string to validate.
177 |  * @returns True if the color is valid.
178 |  */
179 | export function isValidColor(color: string): boolean {
180 |   const lowerColor = color.toLowerCase();
181 | 
182 |   // 1. Check if it's a hex code
183 |   if (lowerColor.startsWith('#')) {
184 |     return /^#[0-9A-Fa-f]{3}([0-9A-Fa-f]{3})?$/.test(color);
185 |   }
186 | 
187 |   // 2. Check if it's an Ink supported name
188 |   if (INK_SUPPORTED_NAMES.has(lowerColor)) {
189 |     return true;
190 |   }
191 | 
192 |   // 3. Check if it's a known CSS name we can map to hex
193 |   if (CSS_NAME_TO_HEX_MAP[lowerColor]) {
194 |     return true;
195 |   }
196 | 
197 |   // 4. Not a valid color
198 |   return false;
199 | }
200 | 
201 | /**
202 |  * Resolves a CSS color value (name or hex) into an Ink-compatible color string.
203 |  * @param colorValue The raw color string (e.g., 'blue', '#ff0000', 'darkkhaki').
204 |  * @returns An Ink-compatible color string (hex or name), or undefined if not resolvable.
205 |  */
206 | export function resolveColor(colorValue: string): string | undefined {
207 |   const lowerColor = colorValue.toLowerCase();
208 | 
209 |   // 1. Check if it's already a hex code and valid
210 |   if (lowerColor.startsWith('#')) {
211 |     if (/^#[0-9A-Fa-f]{3}([0-9A-Fa-f]{3})?$/.test(colorValue)) {
212 |       return lowerColor;
213 |     } else {
214 |       return undefined;
215 |     }
216 |   }
217 |   // 2. Check if it's an Ink supported name (lowercase)
218 |   else if (INK_SUPPORTED_NAMES.has(lowerColor)) {
219 |     return lowerColor; // Use Ink name directly
220 |   }
221 |   // 3. Check if it's a known CSS name we can map to hex
222 |   else if (CSS_NAME_TO_HEX_MAP[lowerColor]) {
223 |     return CSS_NAME_TO_HEX_MAP[lowerColor]; // Use mapped hex
224 |   }
225 | 
226 |   // 4. Could not resolve
227 |   console.warn(
228 |     `[ColorUtils] Could not resolve color "${colorValue}" to an Ink-compatible format.`,
229 |   );
230 |   return undefined;
231 | }
```

src/ui/themes/default-light.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { lightTheme, Theme } from './theme.js';
8 | 
9 | export const DefaultLight: Theme = new Theme(
10 |   'Default Light',
11 |   'light',
12 |   {
13 |     hljs: {
14 |       display: 'block',
15 |       overflowX: 'auto',
16 |       padding: '0.5em',
17 |       background: lightTheme.Background,
18 |       color: lightTheme.Foreground,
19 |     },
20 |     'hljs-comment': {
21 |       color: lightTheme.Comment,
22 |     },
23 |     'hljs-quote': {
24 |       color: lightTheme.Comment,
25 |     },
26 |     'hljs-variable': {
27 |       color: lightTheme.Foreground,
28 |     },
29 |     'hljs-keyword': {
30 |       color: lightTheme.AccentBlue,
31 |     },
32 |     'hljs-selector-tag': {
33 |       color: lightTheme.AccentBlue,
34 |     },
35 |     'hljs-built_in': {
36 |       color: lightTheme.AccentBlue,
37 |     },
38 |     'hljs-name': {
39 |       color: lightTheme.AccentBlue,
40 |     },
41 |     'hljs-tag': {
42 |       color: lightTheme.AccentBlue,
43 |     },
44 |     'hljs-string': {
45 |       color: lightTheme.AccentRed,
46 |     },
47 |     'hljs-title': {
48 |       color: lightTheme.AccentRed,
49 |     },
50 |     'hljs-section': {
51 |       color: lightTheme.AccentRed,
52 |     },
53 |     'hljs-attribute': {
54 |       color: lightTheme.AccentRed,
55 |     },
56 |     'hljs-literal': {
57 |       color: lightTheme.AccentRed,
58 |     },
59 |     'hljs-template-tag': {
60 |       color: lightTheme.AccentRed,
61 |     },
62 |     'hljs-template-variable': {
63 |       color: lightTheme.AccentRed,
64 |     },
65 |     'hljs-type': {
66 |       color: lightTheme.AccentRed,
67 |     },
68 |     'hljs-addition': {
69 |       color: lightTheme.AccentGreen,
70 |     },
71 |     'hljs-deletion': {
72 |       color: lightTheme.AccentRed,
73 |     },
74 |     'hljs-selector-attr': {
75 |       color: lightTheme.AccentCyan,
76 |     },
77 |     'hljs-selector-pseudo': {
78 |       color: lightTheme.AccentCyan,
79 |     },
80 |     'hljs-meta': {
81 |       color: lightTheme.AccentCyan,
82 |     },
83 |     'hljs-doctag': {
84 |       color: lightTheme.Gray,
85 |     },
86 |     'hljs-attr': {
87 |       color: lightTheme.AccentRed,
88 |     },
89 |     'hljs-symbol': {
90 |       color: lightTheme.AccentCyan,
91 |     },
92 |     'hljs-bullet': {
93 |       color: lightTheme.AccentCyan,
94 |     },
95 |     'hljs-link': {
96 |       color: lightTheme.AccentCyan,
97 |     },
98 |     'hljs-emphasis': {
99 |       fontStyle: 'italic',
100 |     },
101 |     'hljs-strong': {
102 |       fontWeight: 'bold',
103 |     },
104 |   },
105 |   lightTheme,
106 | );
```

src/ui/themes/default.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { darkTheme, Theme } from './theme.js';
8 | 
9 | export const DefaultDark: Theme = new Theme(
10 |   'Default',
11 |   'dark',
12 |   {
13 |     hljs: {
14 |       display: 'block',
15 |       overflowX: 'auto',
16 |       padding: '0.5em',
17 |       background: darkTheme.Background,
18 |       color: darkTheme.Foreground,
19 |     },
20 |     'hljs-keyword': {
21 |       color: darkTheme.AccentBlue,
22 |     },
23 |     'hljs-literal': {
24 |       color: darkTheme.AccentBlue,
25 |     },
26 |     'hljs-symbol': {
27 |       color: darkTheme.AccentBlue,
28 |     },
29 |     'hljs-name': {
30 |       color: darkTheme.AccentBlue,
31 |     },
32 |     'hljs-link': {
33 |       color: darkTheme.AccentBlue,
34 |       textDecoration: 'underline',
35 |     },
36 |     'hljs-built_in': {
37 |       color: darkTheme.AccentCyan,
38 |     },
39 |     'hljs-type': {
40 |       color: darkTheme.AccentCyan,
41 |     },
42 |     'hljs-number': {
43 |       color: darkTheme.AccentGreen,
44 |     },
45 |     'hljs-class': {
46 |       color: darkTheme.AccentGreen,
47 |     },
48 |     'hljs-string': {
49 |       color: darkTheme.AccentYellow,
50 |     },
51 |     'hljs-meta-string': {
52 |       color: darkTheme.AccentYellow,
53 |     },
54 |     'hljs-regexp': {
55 |       color: darkTheme.AccentRed,
56 |     },
57 |     'hljs-template-tag': {
58 |       color: darkTheme.AccentRed,
59 |     },
60 |     'hljs-subst': {
61 |       color: darkTheme.Foreground,
62 |     },
63 |     'hljs-function': {
64 |       color: darkTheme.Foreground,
65 |     },
66 |     'hljs-title': {
67 |       color: darkTheme.Foreground,
68 |     },
69 |     'hljs-params': {
70 |       color: darkTheme.Foreground,
71 |     },
72 |     'hljs-formula': {
73 |       color: darkTheme.Foreground,
74 |     },
75 |     'hljs-comment': {
76 |       color: darkTheme.Comment,
77 |       fontStyle: 'italic',
78 |     },
79 |     'hljs-quote': {
80 |       color: darkTheme.Comment,
81 |       fontStyle: 'italic',
82 |     },
83 |     'hljs-doctag': {
84 |       color: darkTheme.Comment,
85 |     },
86 |     'hljs-meta': {
87 |       color: darkTheme.Gray,
88 |     },
89 |     'hljs-meta-keyword': {
90 |       color: darkTheme.Gray,
91 |     },
92 |     'hljs-tag': {
93 |       color: darkTheme.Gray,
94 |     },
95 |     'hljs-variable': {
96 |       color: darkTheme.AccentPurple,
97 |     },
98 |     'hljs-template-variable': {
99 |       color: darkTheme.AccentPurple,
100 |     },
101 |     'hljs-attr': {
102 |       color: darkTheme.LightBlue,
103 |     },
104 |     'hljs-attribute': {
105 |       color: darkTheme.LightBlue,
106 |     },
107 |     'hljs-builtin-name': {
108 |       color: darkTheme.LightBlue,
109 |     },
110 |     'hljs-section': {
111 |       color: darkTheme.AccentYellow,
112 |     },
113 |     'hljs-emphasis': {
114 |       fontStyle: 'italic',
115 |     },
116 |     'hljs-strong': {
117 |       fontWeight: 'bold',
118 |     },
119 |     'hljs-bullet': {
120 |       color: darkTheme.AccentYellow,
121 |     },
122 |     'hljs-selector-tag': {
123 |       color: darkTheme.AccentYellow,
124 |     },
125 |     'hljs-selector-id': {
126 |       color: darkTheme.AccentYellow,
127 |     },
128 |     'hljs-selector-class': {
129 |       color: darkTheme.AccentYellow,
130 |     },
131 |     'hljs-selector-attr': {
132 |       color: darkTheme.AccentYellow,
133 |     },
134 |     'hljs-selector-pseudo': {
135 |       color: darkTheme.AccentYellow,
136 |     },
137 |     'hljs-addition': {
138 |       backgroundColor: '#144212',
139 |       display: 'inline-block',
140 |       width: '100%',
141 |     },
142 |     'hljs-deletion': {
143 |       backgroundColor: '#600',
144 |       display: 'inline-block',
145 |       width: '100%',
146 |     },
147 |   },
148 |   darkTheme,
149 | );
```

src/ui/themes/dracula.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { type ColorsTheme, Theme } from './theme.js';
8 | 
9 | const draculaColors: ColorsTheme = {
10 |   type: 'dark',
11 |   Background: '#282a36',
12 |   Foreground: '#a3afb7',
13 |   LightBlue: '#8be9fd',
14 |   AccentBlue: '#8be9fd',
15 |   AccentPurple: '#ff79c6',
16 |   AccentCyan: '#8be9fd',
17 |   AccentGreen: '#50fa7b',
18 |   AccentYellow: '#fff783',
19 |   AccentRed: '#ff5555',
20 |   DiffAdded: '#11431d',
21 |   DiffRemoved: '#6e1818',
22 |   Comment: '#6272a4',
23 |   Gray: '#6272a4',
24 |   GradientColors: ['#ff79c6', '#8be9fd'],
25 | };
26 | 
27 | export const Dracula: Theme = new Theme(
28 |   'Dracula',
29 |   'dark',
30 |   {
31 |     hljs: {
32 |       display: 'block',
33 |       overflowX: 'auto',
34 |       padding: '0.5em',
35 |       background: draculaColors.Background,
36 |       color: draculaColors.Foreground,
37 |     },
38 |     'hljs-keyword': {
39 |       color: draculaColors.AccentBlue,
40 |       fontWeight: 'bold',
41 |     },
42 |     'hljs-selector-tag': {
43 |       color: draculaColors.AccentBlue,
44 |       fontWeight: 'bold',
45 |     },
46 |     'hljs-literal': {
47 |       color: draculaColors.AccentBlue,
48 |       fontWeight: 'bold',
49 |     },
50 |     'hljs-section': {
51 |       color: draculaColors.AccentBlue,
52 |       fontWeight: 'bold',
53 |     },
54 |     'hljs-link': {
55 |       color: draculaColors.AccentBlue,
56 |     },
57 |     'hljs-function .hljs-keyword': {
58 |       color: draculaColors.AccentPurple,
59 |     },
60 |     'hljs-subst': {
61 |       color: draculaColors.Foreground,
62 |     },
63 |     'hljs-string': {
64 |       color: draculaColors.AccentYellow,
65 |     },
66 |     'hljs-title': {
67 |       color: draculaColors.AccentYellow,
68 |       fontWeight: 'bold',
69 |     },
70 |     'hljs-name': {
71 |       color: draculaColors.AccentYellow,
72 |       fontWeight: 'bold',
73 |     },
74 |     'hljs-type': {
75 |       color: draculaColors.AccentYellow,
76 |       fontWeight: 'bold',
77 |     },
78 |     'hljs-attribute': {
79 |       color: draculaColors.AccentYellow,
80 |     },
81 |     'hljs-symbol': {
82 |       color: draculaColors.AccentYellow,
83 |     },
84 |     'hljs-bullet': {
85 |       color: draculaColors.AccentYellow,
86 |     },
87 |     'hljs-addition': {
88 |       color: draculaColors.AccentGreen,
89 |     },
90 |     'hljs-variable': {
91 |       color: draculaColors.AccentYellow,
92 |     },
93 |     'hljs-template-tag': {
94 |       color: draculaColors.AccentYellow,
95 |     },
96 |     'hljs-template-variable': {
97 |       color: draculaColors.AccentYellow,
98 |     },
99 |     'hljs-comment': {
100 |       color: draculaColors.Comment,
101 |     },
102 |     'hljs-quote': {
103 |       color: draculaColors.Comment,
104 |     },
105 |     'hljs-deletion': {
106 |       color: draculaColors.AccentRed,
107 |     },
108 |     'hljs-meta': {
109 |       color: draculaColors.Comment,
110 |     },
111 |     'hljs-doctag': {
112 |       fontWeight: 'bold',
113 |     },
114 |     'hljs-strong': {
115 |       fontWeight: 'bold',
116 |     },
117 |     'hljs-emphasis': {
118 |       fontStyle: 'italic',
119 |     },
120 |   },
121 |   draculaColors,
122 | );
```

src/ui/themes/github-dark.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { type ColorsTheme, Theme } from './theme.js';
8 | 
9 | const githubDarkColors: ColorsTheme = {
10 |   type: 'dark',
11 |   Background: '#24292e',
12 |   Foreground: '#c0c4c8',
13 |   LightBlue: '#79B8FF',
14 |   AccentBlue: '#79B8FF',
15 |   AccentPurple: '#B392F0',
16 |   AccentCyan: '#9ECBFF',
17 |   AccentGreen: '#85E89D',
18 |   AccentYellow: '#FFAB70',
19 |   AccentRed: '#F97583',
20 |   DiffAdded: '#3C4636',
21 |   DiffRemoved: '#502125',
22 |   Comment: '#6A737D',
23 |   Gray: '#6A737D',
24 |   GradientColors: ['#79B8FF', '#85E89D'],
25 | };
26 | 
27 | export const GitHubDark: Theme = new Theme(
28 |   'GitHub',
29 |   'dark',
30 |   {
31 |     hljs: {
32 |       display: 'block',
33 |       overflowX: 'auto',
34 |       padding: '0.5em',
35 |       color: githubDarkColors.Foreground,
36 |       background: githubDarkColors.Background,
37 |     },
38 |     'hljs-comment': {
39 |       color: githubDarkColors.Comment,
40 |       fontStyle: 'italic',
41 |     },
42 |     'hljs-quote': {
43 |       color: githubDarkColors.Comment,
44 |       fontStyle: 'italic',
45 |     },
46 |     'hljs-keyword': {
47 |       color: githubDarkColors.AccentRed,
48 |       fontWeight: 'bold',
49 |     },
50 |     'hljs-selector-tag': {
51 |       color: githubDarkColors.AccentRed,
52 |       fontWeight: 'bold',
53 |     },
54 |     'hljs-subst': {
55 |       color: githubDarkColors.Foreground,
56 |     },
57 |     'hljs-number': {
58 |       color: githubDarkColors.LightBlue,
59 |     },
60 |     'hljs-literal': {
61 |       color: githubDarkColors.LightBlue,
62 |     },
63 |     'hljs-variable': {
64 |       color: githubDarkColors.AccentYellow,
65 |     },
66 |     'hljs-template-variable': {
67 |       color: githubDarkColors.AccentYellow,
68 |     },
69 |     'hljs-tag .hljs-attr': {
70 |       color: githubDarkColors.AccentYellow,
71 |     },
72 |     'hljs-string': {
73 |       color: githubDarkColors.AccentCyan,
74 |     },
75 |     'hljs-doctag': {
76 |       color: githubDarkColors.AccentCyan,
77 |     },
78 |     'hljs-title': {
79 |       color: githubDarkColors.AccentPurple,
80 |       fontWeight: 'bold',
81 |     },
82 |     'hljs-section': {
83 |       color: githubDarkColors.AccentPurple,
84 |       fontWeight: 'bold',
85 |     },
86 |     'hljs-selector-id': {
87 |       color: githubDarkColors.AccentPurple,
88 |       fontWeight: 'bold',
89 |     },
90 |     'hljs-type': {
91 |       color: githubDarkColors.AccentGreen,
92 |       fontWeight: 'bold',
93 |     },
94 |     'hljs-class .hljs-title': {
95 |       color: githubDarkColors.AccentGreen,
96 |       fontWeight: 'bold',
97 |     },
98 |     'hljs-tag': {
99 |       color: githubDarkColors.AccentGreen,
100 |     },
101 |     'hljs-name': {
102 |       color: githubDarkColors.AccentGreen,
103 |     },
104 |     'hljs-attribute': {
105 |       color: githubDarkColors.LightBlue,
106 |     },
107 |     'hljs-regexp': {
108 |       color: githubDarkColors.AccentCyan,
109 |     },
110 |     'hljs-link': {
111 |       color: githubDarkColors.AccentCyan,
112 |     },
113 |     'hljs-symbol': {
114 |       color: githubDarkColors.AccentPurple,
115 |     },
116 |     'hljs-bullet': {
117 |       color: githubDarkColors.AccentPurple,
118 |     },
119 |     'hljs-built_in': {
120 |       color: githubDarkColors.LightBlue,
121 |     },
122 |     'hljs-builtin-name': {
123 |       color: githubDarkColors.LightBlue,
124 |     },
125 |     'hljs-meta': {
126 |       color: githubDarkColors.LightBlue,
127 |       fontWeight: 'bold',
128 |     },
129 |     'hljs-deletion': {
130 |       background: '#86181D',
131 |       color: githubDarkColors.AccentRed,
132 |     },
133 |     'hljs-addition': {
134 |       background: '#144620',
135 |       color: githubDarkColors.AccentGreen,
136 |     },
137 |     'hljs-emphasis': {
138 |       fontStyle: 'italic',
139 |     },
140 |     'hljs-strong': {
141 |       fontWeight: 'bold',
142 |     },
143 |   },
144 |   githubDarkColors,
145 | );
```

src/ui/themes/github-light.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { type ColorsTheme, Theme } from './theme.js';
8 | 
9 | const githubLightColors: ColorsTheme = {
10 |   type: 'light',
11 |   Background: '#f8f8f8',
12 |   Foreground: '#24292E',
13 |   LightBlue: '#0086b3',
14 |   AccentBlue: '#458',
15 |   AccentPurple: '#900',
16 |   AccentCyan: '#009926',
17 |   AccentGreen: '#008080',
18 |   AccentYellow: '#990073',
19 |   AccentRed: '#d14',
20 |   DiffAdded: '#C6EAD8',
21 |   DiffRemoved: '#FFCCCC',
22 |   Comment: '#998',
23 |   Gray: '#999',
24 |   GradientColors: ['#458', '#008080'],
25 | };
26 | 
27 | export const GitHubLight: Theme = new Theme(
28 |   'GitHub Light',
29 |   'light',
30 |   {
31 |     hljs: {
32 |       display: 'block',
33 |       overflowX: 'auto',
34 |       padding: '0.5em',
35 |       color: githubLightColors.Foreground,
36 |       background: githubLightColors.Background,
37 |     },
38 |     'hljs-comment': {
39 |       color: githubLightColors.Comment,
40 |       fontStyle: 'italic',
41 |     },
42 |     'hljs-quote': {
43 |       color: githubLightColors.Comment,
44 |       fontStyle: 'italic',
45 |     },
46 |     'hljs-keyword': {
47 |       color: githubLightColors.Foreground,
48 |       fontWeight: 'bold',
49 |     },
50 |     'hljs-selector-tag': {
51 |       color: githubLightColors.Foreground,
52 |       fontWeight: 'bold',
53 |     },
54 |     'hljs-subst': {
55 |       color: githubLightColors.Foreground,
56 |       fontWeight: 'normal',
57 |     },
58 |     'hljs-number': {
59 |       color: githubLightColors.AccentGreen,
60 |     },
61 |     'hljs-literal': {
62 |       color: githubLightColors.AccentGreen,
63 |     },
64 |     'hljs-variable': {
65 |       color: githubLightColors.AccentGreen,
66 |     },
67 |     'hljs-template-variable': {
68 |       color: githubLightColors.AccentGreen,
69 |     },
70 |     'hljs-tag .hljs-attr': {
71 |       color: githubLightColors.AccentGreen,
72 |     },
73 |     'hljs-string': {
74 |       color: githubLightColors.AccentRed,
75 |     },
76 |     'hljs-doctag': {
77 |       color: githubLightColors.AccentRed,
78 |     },
79 |     'hljs-title': {
80 |       color: githubLightColors.AccentPurple,
81 |       fontWeight: 'bold',
82 |     },
83 |     'hljs-section': {
84 |       color: githubLightColors.AccentPurple,
85 |       fontWeight: 'bold',
86 |     },
87 |     'hljs-selector-id': {
88 |       color: githubLightColors.AccentPurple,
89 |       fontWeight: 'bold',
90 |     },
91 |     'hljs-type': {
92 |       color: githubLightColors.AccentBlue,
93 |       fontWeight: 'bold',
94 |     },
95 |     'hljs-class .hljs-title': {
96 |       color: githubLightColors.AccentBlue,
97 |       fontWeight: 'bold',
98 |     },
99 |     'hljs-tag': {
100 |       color: githubLightColors.AccentBlue,
101 |       fontWeight: 'normal',
102 |     },
103 |     'hljs-name': {
104 |       color: githubLightColors.AccentBlue,
105 |       fontWeight: 'normal',
106 |     },
107 |     'hljs-attribute': {
108 |       color: githubLightColors.AccentBlue,
109 |       fontWeight: 'normal',
110 |     },
111 |     'hljs-regexp': {
112 |       color: githubLightColors.AccentCyan,
113 |     },
114 |     'hljs-link': {
115 |       color: githubLightColors.AccentCyan,
116 |     },
117 |     'hljs-symbol': {
118 |       color: githubLightColors.AccentYellow,
119 |     },
120 |     'hljs-bullet': {
121 |       color: githubLightColors.AccentYellow,
122 |     },
123 |     'hljs-built_in': {
124 |       color: githubLightColors.LightBlue,
125 |     },
126 |     'hljs-builtin-name': {
127 |       color: githubLightColors.LightBlue,
128 |     },
129 |     'hljs-meta': {
130 |       color: githubLightColors.Gray,
131 |       fontWeight: 'bold',
132 |     },
133 |     'hljs-deletion': {
134 |       background: '#fdd',
135 |     },
136 |     'hljs-addition': {
137 |       background: '#dfd',
138 |     },
139 |     'hljs-emphasis': {
140 |       fontStyle: 'italic',
141 |     },
142 |     'hljs-strong': {
143 |       fontWeight: 'bold',
144 |     },
145 |   },
146 |   githubLightColors,
147 | );
```

src/ui/themes/googlecode.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { type ColorsTheme, Theme, lightTheme } from './theme.js';
8 | 
9 | const googleCodeColors: ColorsTheme = {
10 |   type: 'light',
11 |   Background: 'white',
12 |   Foreground: '#444',
13 |   LightBlue: '#066',
14 |   AccentBlue: '#008',
15 |   AccentPurple: '#606',
16 |   AccentCyan: '#066',
17 |   AccentGreen: '#080',
18 |   AccentYellow: '#660',
19 |   AccentRed: '#800',
20 |   DiffAdded: '#C6EAD8',
21 |   DiffRemoved: '#FEDEDE',
22 |   Comment: '#5f6368',
23 |   Gray: lightTheme.Gray,
24 |   GradientColors: ['#066', '#606'],
25 | };
26 | 
27 | export const GoogleCode: Theme = new Theme(
28 |   'Google Code',
29 |   'light',
30 |   {
31 |     hljs: {
32 |       display: 'block',
33 |       overflowX: 'auto',
34 |       padding: '0.5em',
35 |       background: googleCodeColors.Background,
36 |       color: googleCodeColors.Foreground,
37 |     },
38 |     'hljs-comment': {
39 |       color: googleCodeColors.AccentRed,
40 |     },
41 |     'hljs-quote': {
42 |       color: googleCodeColors.AccentRed,
43 |     },
44 |     'hljs-keyword': {
45 |       color: googleCodeColors.AccentBlue,
46 |     },
47 |     'hljs-selector-tag': {
48 |       color: googleCodeColors.AccentBlue,
49 |     },
50 |     'hljs-section': {
51 |       color: googleCodeColors.AccentBlue,
52 |     },
53 |     'hljs-title': {
54 |       color: googleCodeColors.AccentPurple,
55 |     },
56 |     'hljs-name': {
57 |       color: googleCodeColors.AccentBlue,
58 |     },
59 |     'hljs-variable': {
60 |       color: googleCodeColors.AccentYellow,
61 |     },
62 |     'hljs-template-variable': {
63 |       color: googleCodeColors.AccentYellow,
64 |     },
65 |     'hljs-string': {
66 |       color: googleCodeColors.AccentGreen,
67 |     },
68 |     'hljs-selector-attr': {
69 |       color: googleCodeColors.AccentGreen,
70 |     },
71 |     'hljs-selector-pseudo': {
72 |       color: googleCodeColors.AccentGreen,
73 |     },
74 |     'hljs-regexp': {
75 |       color: googleCodeColors.AccentGreen,
76 |     },
77 |     'hljs-literal': {
78 |       color: googleCodeColors.AccentCyan,
79 |     },
80 |     'hljs-symbol': {
81 |       color: googleCodeColors.AccentCyan,
82 |     },
83 |     'hljs-bullet': {
84 |       color: googleCodeColors.AccentCyan,
85 |     },
86 |     'hljs-meta': {
87 |       color: googleCodeColors.AccentCyan,
88 |     },
89 |     'hljs-number': {
90 |       color: googleCodeColors.AccentCyan,
91 |     },
92 |     'hljs-link': {
93 |       color: googleCodeColors.AccentCyan,
94 |     },
95 |     'hljs-doctag': {
96 |       color: googleCodeColors.AccentPurple,
97 |       fontWeight: 'bold',
98 |     },
99 |     'hljs-type': {
100 |       color: googleCodeColors.AccentPurple,
101 |     },
102 |     'hljs-attr': {
103 |       color: googleCodeColors.AccentPurple,
104 |     },
105 |     'hljs-built_in': {
106 |       color: googleCodeColors.AccentPurple,
107 |     },
108 |     'hljs-builtin-name': {
109 |       color: googleCodeColors.AccentPurple,
110 |     },
111 |     'hljs-params': {
112 |       color: googleCodeColors.AccentPurple,
113 |     },
114 |     'hljs-attribute': {
115 |       color: googleCodeColors.Foreground,
116 |     },
117 |     'hljs-subst': {
118 |       color: googleCodeColors.Foreground,
119 |     },
120 |     'hljs-formula': {
121 |       backgroundColor: '#eee',
122 |       fontStyle: 'italic',
123 |     },
124 |     'hljs-selector-id': {
125 |       color: googleCodeColors.AccentYellow,
126 |     },
127 |     'hljs-selector-class': {
128 |       color: googleCodeColors.AccentYellow,
129 |     },
130 |     'hljs-addition': {
131 |       backgroundColor: '#baeeba',
132 |     },
133 |     'hljs-deletion': {
134 |       backgroundColor: '#ffc8bd',
135 |     },
136 |     'hljs-strong': {
137 |       fontWeight: 'bold',
138 |     },
139 |     'hljs-emphasis': {
140 |       fontStyle: 'italic',
141 |     },
142 |   },
143 |   googleCodeColors,
144 | );
```

src/ui/themes/no-color.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type { ColorsTheme } from './theme.js';
8 | import { Theme } from './theme.js';
9 | import type { SemanticColors } from './semantic-tokens.js';
10 | 
11 | const noColorColorsTheme: ColorsTheme = {
12 |   type: 'ansi',
13 |   Background: '',
14 |   Foreground: '',
15 |   LightBlue: '',
16 |   AccentBlue: '',
17 |   AccentPurple: '',
18 |   AccentCyan: '',
19 |   AccentGreen: '',
20 |   AccentYellow: '',
21 |   AccentRed: '',
22 |   DiffAdded: '',
23 |   DiffRemoved: '',
24 |   Comment: '',
25 |   Gray: '',
26 | };
27 | 
28 | const noColorSemanticColors: SemanticColors = {
29 |   text: {
30 |     primary: '',
31 |     secondary: '',
32 |     link: '',
33 |     accent: '',
34 |   },
35 |   background: {
36 |     primary: '',
37 |     diff: {
38 |       added: '',
39 |       removed: '',
40 |     },
41 |   },
42 |   border: {
43 |     default: '',
44 |     focused: '',
45 |   },
46 |   ui: {
47 |     comment: '',
48 |     symbol: '',
49 |     gradient: [],
50 |   },
51 |   status: {
52 |     error: '',
53 |     success: '',
54 |     warning: '',
55 |   },
56 | };
57 | 
58 | export const NoColorTheme: Theme = new Theme(
59 |   'NoColor',
60 |   'dark',
61 |   {
62 |     hljs: {
63 |       display: 'block',
64 |       overflowX: 'auto',
65 |       padding: '0.5em',
66 |     },
67 |     'hljs-keyword': {},
68 |     'hljs-literal': {},
69 |     'hljs-symbol': {},
70 |     'hljs-name': {},
71 |     'hljs-link': {
72 |       textDecoration: 'underline',
73 |     },
74 |     'hljs-built_in': {},
75 |     'hljs-type': {},
76 |     'hljs-number': {},
77 |     'hljs-class': {},
78 |     'hljs-string': {},
79 |     'hljs-meta-string': {},
80 |     'hljs-regexp': {},
81 |     'hljs-template-tag': {},
82 |     'hljs-subst': {},
83 |     'hljs-function': {},
84 |     'hljs-title': {},
85 |     'hljs-params': {},
86 |     'hljs-formula': {},
87 |     'hljs-comment': {
88 |       fontStyle: 'italic',
89 |     },
90 |     'hljs-quote': {
91 |       fontStyle: 'italic',
92 |     },
93 |     'hljs-doctag': {},
94 |     'hljs-meta': {},
95 |     'hljs-meta-keyword': {},
96 |     'hljs-tag': {},
97 |     'hljs-variable': {},
98 |     'hljs-template-variable': {},
99 |     'hljs-attr': {},
100 |     'hljs-attribute': {},
101 |     'hljs-builtin-name': {},
102 |     'hljs-section': {},
103 |     'hljs-emphasis': {
104 |       fontStyle: 'italic',
105 |     },
106 |     'hljs-strong': {
107 |       fontWeight: 'bold',
108 |     },
109 |     'hljs-bullet': {},
110 |     'hljs-selector-tag': {},
111 |     'hljs-selector-id': {},
112 |     'hljs-selector-class': {},
113 |     'hljs-selector-attr': {},
114 |     'hljs-selector-pseudo': {},
115 |     'hljs-addition': {
116 |       display: 'inline-block',
117 |       width: '100%',
118 |     },
119 |     'hljs-deletion': {
120 |       display: 'inline-block',
121 |       width: '100%',
122 |     },
123 |   },
124 |   noColorColorsTheme,
125 |   noColorSemanticColors,
126 | );
```

src/ui/themes/shades-of-purple.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | /**
8 |  * Shades of Purple Theme — for Highlight.js.
9 |  * @author Ahmad Awais <https://twitter.com/mrahmadawais/>
10 |  */
11 | import { type ColorsTheme, Theme } from './theme.js';
12 | 
13 | const shadesOfPurpleColors: ColorsTheme = {
14 |   type: 'dark',
15 |   // Required colors for ColorsTheme interface
16 |   Background: '#2d2b57', // Main background
17 |   Foreground: '#e3dfff', // Default text color (hljs, hljs-subst)
18 |   LightBlue: '#847ace', // Light blue/purple accent
19 |   AccentBlue: '#a599e9', // Borders, secondary blue
20 |   AccentPurple: '#ac65ff', // Comments (main purple)
21 |   AccentCyan: '#a1feff', // Names
22 |   AccentGreen: '#A5FF90', // Strings and many others
23 |   AccentYellow: '#fad000', // Title, main yellow
24 |   AccentRed: '#ff628c', // Error/deletion accent
25 |   DiffAdded: '#383E45',
26 |   DiffRemoved: '#572244',
27 |   Comment: '#B362FF', // Comment color (same as AccentPurple)
28 |   Gray: '#726c86', // Gray color
29 |   GradientColors: ['#4d21fc', '#847ace', '#ff628c'],
30 | };
31 | 
32 | // Additional colors from CSS that don't fit in the ColorsTheme interface
33 | const additionalColors = {
34 |   AccentYellowAlt: '#f8d000', // Attr yellow (slightly different)
35 |   AccentOrange: '#fb9e00', // Keywords, built_in, meta
36 |   AccentPink: '#fa658d', // Numbers, literals
37 |   AccentLightPurple: '#c991ff', // For params and properties
38 |   AccentDarkPurple: '#6943ff', // For operators
39 |   AccentTeal: '#2ee2fa', // For special constructs
40 | };
41 | 
42 | export const ShadesOfPurple = new Theme(
43 |   'Shades Of Purple',
44 |   'dark',
45 |   {
46 |     // Base styles
47 |     hljs: {
48 |       display: 'block',
49 |       overflowX: 'auto',
50 |       background: shadesOfPurpleColors.Background,
51 |       color: shadesOfPurpleColors.Foreground,
52 |     },
53 | 
54 |     // Title elements
55 |     'hljs-title': {
56 |       color: shadesOfPurpleColors.AccentYellow,
57 |       fontWeight: 'normal',
58 |     },
59 | 
60 |     // Names
61 |     'hljs-name': {
62 |       color: shadesOfPurpleColors.AccentCyan,
63 |       fontWeight: 'normal',
64 |     },
65 | 
66 |     // Tags
67 |     'hljs-tag': {
68 |       color: shadesOfPurpleColors.Foreground,
69 |     },
70 | 
71 |     // Attributes
72 |     'hljs-attr': {
73 |       color: additionalColors.AccentYellowAlt,
74 |       fontStyle: 'italic',
75 |     },
76 | 
77 |     // Built-ins, selector tags, sections
78 |     'hljs-built_in': {
79 |       color: additionalColors.AccentOrange,
80 |     },
81 |     'hljs-selector-tag': {
82 |       color: additionalColors.AccentOrange,
83 |       fontWeight: 'normal',
84 |     },
85 |     'hljs-section': {
86 |       color: additionalColors.AccentOrange,
87 |     },
88 | 
89 |     // Keywords
90 |     'hljs-keyword': {
91 |       color: additionalColors.AccentOrange,
92 |       fontWeight: 'normal',
93 |     },
94 | 
95 |     // Default text and substitutions
96 |     'hljs-subst': {
97 |       color: shadesOfPurpleColors.Foreground,
98 |     },
99 | 
100 |     // Strings and related elements (all green)
101 |     'hljs-string': {
102 |       color: shadesOfPurpleColors.AccentGreen,
103 |     },
104 |     'hljs-attribute': {
105 |       color: shadesOfPurpleColors.AccentGreen,
106 |     },
107 |     'hljs-symbol': {
108 |       color: shadesOfPurpleColors.AccentGreen,
109 |     },
110 |     'hljs-bullet': {
111 |       color: shadesOfPurpleColors.AccentGreen,
112 |     },
113 |     'hljs-addition': {
114 |       color: shadesOfPurpleColors.AccentGreen,
115 |     },
116 |     'hljs-code': {
117 |       color: shadesOfPurpleColors.AccentGreen,
118 |     },
119 |     'hljs-regexp': {
120 |       color: shadesOfPurpleColors.AccentGreen,
121 |     },
122 |     'hljs-selector-class': {
123 |       color: shadesOfPurpleColors.AccentGreen,
124 |     },
125 |     'hljs-selector-attr': {
126 |       color: shadesOfPurpleColors.AccentGreen,
127 |     },
128 |     'hljs-selector-pseudo': {
129 |       color: shadesOfPurpleColors.AccentGreen,
130 |     },
131 |     'hljs-template-tag': {
132 |       color: shadesOfPurpleColors.AccentGreen,
133 |     },
134 |     'hljs-quote': {
135 |       color: shadesOfPurpleColors.AccentGreen,
136 |     },
137 |     'hljs-deletion': {
138 |       color: shadesOfPurpleColors.AccentRed,
139 |     },
140 | 
141 |     // Meta elements
142 |     'hljs-meta': {
143 |       color: additionalColors.AccentOrange,
144 |     },
145 |     'hljs-meta-string': {
146 |       color: additionalColors.AccentOrange,
147 |     },
148 | 
149 |     // Comments
150 |     'hljs-comment': {
151 |       color: shadesOfPurpleColors.AccentPurple,
152 |     },
153 | 
154 |     // Literals and numbers
155 |     'hljs-literal': {
156 |       color: additionalColors.AccentPink,
157 |       fontWeight: 'normal',
158 |     },
159 |     'hljs-number': {
160 |       color: additionalColors.AccentPink,
161 |     },
162 | 
163 |     // Emphasis and strong
164 |     'hljs-emphasis': {
165 |       fontStyle: 'italic',
166 |     },
167 |     'hljs-strong': {
168 |       fontWeight: 'bold',
169 |     },
170 | 
171 |     // Diff-specific classes
172 |     'hljs-diff': {
173 |       color: shadesOfPurpleColors.Foreground,
174 |     },
175 |     'hljs-meta.hljs-diff': {
176 |       color: shadesOfPurpleColors.AccentBlue,
177 |     },
178 |     'hljs-ln': {
179 |       color: shadesOfPurpleColors.Gray,
180 |     },
181 | 
182 |     // Additional elements that might be needed
183 |     'hljs-type': {
184 |       color: shadesOfPurpleColors.AccentYellow,
185 |       fontWeight: 'normal',
186 |     },
187 |     'hljs-variable': {
188 |       color: shadesOfPurpleColors.AccentYellow,
189 |     },
190 |     'hljs-template-variable': {
191 |       color: shadesOfPurpleColors.AccentGreen,
192 |     },
193 |     'hljs-function .hljs-keyword': {
194 |       color: additionalColors.AccentOrange,
195 |     },
196 |     'hljs-link': {
197 |       color: shadesOfPurpleColors.LightBlue,
198 |     },
199 |     'hljs-doctag': {
200 |       fontWeight: 'bold',
201 |     },
202 | 
203 |     // Function parameters
204 |     'hljs-params': {
205 |       color: additionalColors.AccentLightPurple,
206 |       fontStyle: 'italic',
207 |     },
208 | 
209 |     // Class definitions
210 |     'hljs-class': {
211 |       color: shadesOfPurpleColors.AccentCyan,
212 |       fontWeight: 'bold',
213 |     },
214 | 
215 |     // Function definitions
216 |     'hljs-function': {
217 |       color: shadesOfPurpleColors.AccentCyan,
218 |     },
219 | 
220 |     // Object properties
221 |     'hljs-property': {
222 |       color: shadesOfPurpleColors.AccentBlue,
223 |     },
224 | 
225 |     // Operators
226 |     'hljs-operator': {
227 |       color: additionalColors.AccentDarkPurple,
228 |     },
229 | 
230 |     // Punctuation (if supported by the parser)
231 |     'hljs-punctuation': {
232 |       color: shadesOfPurpleColors.Gray,
233 |     },
234 | 
235 |     // CSS ID selectors
236 |     'hljs-selector-id': {
237 |       color: shadesOfPurpleColors.AccentYellow,
238 |       fontWeight: 'bold',
239 |     },
240 | 
241 |     // Character literals
242 |     'hljs-char': {
243 |       color: shadesOfPurpleColors.AccentGreen,
244 |     },
245 | 
246 |     // Escape sequences
247 |     'hljs-escape': {
248 |       color: additionalColors.AccentPink,
249 |       fontWeight: 'bold',
250 |     },
251 | 
252 |     // Meta keywords
253 |     'hljs-meta-keyword': {
254 |       color: additionalColors.AccentOrange,
255 |       fontWeight: 'bold',
256 |     },
257 | 
258 |     // Built-in names
259 |     'hljs-builtin-name': {
260 |       color: additionalColors.AccentTeal,
261 |     },
262 | 
263 |     // Modules
264 |     'hljs-module': {
265 |       color: shadesOfPurpleColors.AccentCyan,
266 |     },
267 | 
268 |     // Namespaces
269 |     'hljs-namespace': {
270 |       color: shadesOfPurpleColors.LightBlue,
271 |     },
272 | 
273 |     // Important annotations
274 |     'hljs-important': {
275 |       color: shadesOfPurpleColors.AccentRed,
276 |       fontWeight: 'bold',
277 |     },
278 | 
279 |     // Formulas (for LaTeX, etc.)
280 |     'hljs-formula': {
281 |       color: shadesOfPurpleColors.AccentCyan,
282 |       fontStyle: 'italic',
283 |     },
284 | 
285 |     // Language-specific additions
286 |     // Python decorators
287 |     'hljs-decorator': {
288 |       color: additionalColors.AccentTeal,
289 |       fontWeight: 'bold',
290 |     },
291 | 
292 |     // Ruby symbols
293 |     'hljs-symbol.ruby': {
294 |       color: additionalColors.AccentPink,
295 |     },
296 | 
297 |     // SQL keywords
298 |     'hljs-keyword.sql': {
299 |       color: additionalColors.AccentOrange,
300 |       textTransform: 'uppercase',
301 |     },
302 | 
303 |     // Markdown specific
304 |     'hljs-section.markdown': {
305 |       color: shadesOfPurpleColors.AccentYellow,
306 |       fontWeight: 'bold',
307 |     },
308 | 
309 |     // JSON keys
310 |     'hljs-attr.json': {
311 |       color: shadesOfPurpleColors.AccentCyan,
312 |     },
313 | 
314 |     // XML/HTML specific
315 |     'hljs-tag .hljs-name': {
316 |       color: shadesOfPurpleColors.AccentRed,
317 |     },
318 |     'hljs-tag .hljs-attr': {
319 |       color: additionalColors.AccentYellowAlt,
320 |     },
321 | 
322 |     // Line highlighting (if line numbers are enabled)
323 |     'hljs.hljs-line-numbers': {
324 |       borderRight: `1px solid ${shadesOfPurpleColors.Gray}`,
325 |     },
326 |     'hljs.hljs-line-numbers .hljs-ln-numbers': {
327 |       color: shadesOfPurpleColors.Gray,
328 |       paddingRight: '1em',
329 |     },
330 |     'hljs.hljs-line-numbers .hljs-ln-code': {
331 |       paddingLeft: '1em',
332 |     },
333 | 
334 |     // Selection styling
335 |     'hljs::selection': {
336 |       background: shadesOfPurpleColors.AccentBlue + '40', // 40 = 25% opacity
337 |     },
338 |     'hljs ::-moz-selection': {
339 |       background: shadesOfPurpleColors.AccentBlue + '40',
340 |     },
341 | 
342 |     // Highlighted lines (for emphasis)
343 |     'hljs .hljs-highlight': {
344 |       background: shadesOfPurpleColors.AccentPurple + '20', // 20 = 12.5% opacity
345 |       display: 'block',
346 |       width: '100%',
347 |     },
348 |   },
349 |   shadesOfPurpleColors,
350 | );
```

src/ui/themes/theme-manager.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | // Patch: Unset NO_COLOR at the very top before any imports
8 | if (process.env['NO_COLOR'] !== undefined) {
9 |   delete process.env['NO_COLOR'];
10 | }
11 | 
12 | import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
13 | import { themeManager, DEFAULT_THEME } from './theme-manager.js';
14 | import type { CustomTheme } from './theme.js';
15 | import * as fs from 'node:fs';
16 | import * as os from 'node:os';
17 | import type * as osActual from 'node:os';
18 | 
19 | vi.mock('node:fs');
20 | vi.mock('node:os', async (importOriginal) => {
21 |   const actualOs = await importOriginal<typeof osActual>();
22 |   return {
23 |     ...actualOs,
24 |     homedir: vi.fn(),
25 |     platform: vi.fn(() => 'linux'),
26 |   };
27 | });
28 | 
29 | const validCustomTheme: CustomTheme = {
30 |   type: 'custom',
31 |   name: 'MyCustomTheme',
32 |   Background: '#000000',
33 |   Foreground: '#ffffff',
34 |   LightBlue: '#89BDCD',
35 |   AccentBlue: '#3B82F6',
36 |   AccentPurple: '#8B5CF6',
37 |   AccentCyan: '#06B6D4',
38 |   AccentGreen: '#3CA84B',
39 |   AccentYellow: 'yellow',
40 |   AccentRed: 'red',
41 |   DiffAdded: 'green',
42 |   DiffRemoved: 'red',
43 |   Comment: 'gray',
44 |   Gray: 'gray',
45 | };
46 | 
47 | describe('ThemeManager', () => {
48 |   beforeEach(() => {
49 |     // Reset themeManager state
50 |     themeManager.loadCustomThemes({});
51 |     themeManager.setActiveTheme(DEFAULT_THEME.name);
52 |   });
53 | 
54 |   afterEach(() => {
55 |     vi.restoreAllMocks();
56 |   });
57 | 
58 |   it('should load valid custom themes', () => {
59 |     themeManager.loadCustomThemes({ MyCustomTheme: validCustomTheme });
60 |     expect(themeManager.getCustomThemeNames()).toContain('MyCustomTheme');
61 |     expect(themeManager.isCustomTheme('MyCustomTheme')).toBe(true);
62 |   });
63 | 
64 |   it('should set and get the active theme', () => {
65 |     expect(themeManager.getActiveTheme().name).toBe(DEFAULT_THEME.name);
66 |     themeManager.setActiveTheme('Ayu');
67 |     expect(themeManager.getActiveTheme().name).toBe('Ayu');
68 |   });
69 | 
70 |   it('should set and get a custom active theme', () => {
71 |     themeManager.loadCustomThemes({ MyCustomTheme: validCustomTheme });
72 |     themeManager.setActiveTheme('MyCustomTheme');
73 |     expect(themeManager.getActiveTheme().name).toBe('MyCustomTheme');
74 |   });
75 | 
76 |   it('should return false when setting a non-existent theme', () => {
77 |     expect(themeManager.setActiveTheme('NonExistentTheme')).toBe(false);
78 |     expect(themeManager.getActiveTheme().name).toBe(DEFAULT_THEME.name);
79 |   });
80 | 
81 |   it('should list available themes including custom themes', () => {
82 |     themeManager.loadCustomThemes({ MyCustomTheme: validCustomTheme });
83 |     const available = themeManager.getAvailableThemes();
84 |     expect(
85 |       available.some(
86 |         (t: { name: string; isCustom?: boolean }) =>
87 |           t.name === 'MyCustomTheme' && t.isCustom,
88 |       ),
89 |     ).toBe(true);
90 |   });
91 | 
92 |   it('should get a theme by name', () => {
93 |     expect(themeManager.getTheme('Ayu')).toBeDefined();
94 |     themeManager.loadCustomThemes({ MyCustomTheme: validCustomTheme });
95 |     expect(themeManager.getTheme('MyCustomTheme')).toBeDefined();
96 |   });
97 | 
98 |   it('should fall back to default theme if active theme is invalid', () => {
99 |     (themeManager as unknown as { activeTheme: unknown }).activeTheme = {
100 |       name: 'NonExistent',
101 |       type: 'custom',
102 |     };
103 |     expect(themeManager.getActiveTheme().name).toBe(DEFAULT_THEME.name);
104 |   });
105 | 
106 |   it('should return NoColorTheme if NO_COLOR is set', () => {
107 |     const original = process.env['NO_COLOR'];
108 |     process.env['NO_COLOR'] = '1';
109 |     expect(themeManager.getActiveTheme().name).toBe('NoColor');
110 |     if (original === undefined) {
111 |       delete process.env['NO_COLOR'];
112 |     } else {
113 |       process.env['NO_COLOR'] = original;
114 |     }
115 |   });
116 | 
117 |   describe('when loading a theme from a file', () => {
118 |     const mockThemePath = './my-theme.json';
119 |     const mockTheme: CustomTheme = {
120 |       ...validCustomTheme,
121 |       name: 'My File Theme',
122 |     };
123 | 
124 |     beforeEach(() => {
125 |       vi.mocked(os.homedir).mockReturnValue('/home/user');
126 |       vi.spyOn(fs, 'realpathSync').mockImplementation((p) => p as string);
127 |     });
128 | 
129 |     it('should load a theme from a valid file path', () => {
130 |       vi.spyOn(fs, 'existsSync').mockReturnValue(true);
131 |       vi.spyOn(fs, 'readFileSync').mockReturnValue(JSON.stringify(mockTheme));
132 | 
133 |       const result = themeManager.setActiveTheme('/home/user/my-theme.json');
134 | 
135 |       expect(result).toBe(true);
136 |       const activeTheme = themeManager.getActiveTheme();
137 |       expect(activeTheme.name).toBe('My File Theme');
138 |       expect(fs.readFileSync).toHaveBeenCalledWith(
139 |         expect.stringContaining('my-theme.json'),
140 |         'utf-8',
141 |       );
142 |     });
143 | 
144 |     it('should not load a theme if the file does not exist', () => {
145 |       vi.spyOn(fs, 'existsSync').mockReturnValue(false);
146 | 
147 |       const result = themeManager.setActiveTheme(mockThemePath);
148 | 
149 |       expect(result).toBe(false);
150 |       expect(themeManager.getActiveTheme().name).toBe(DEFAULT_THEME.name);
151 |     });
152 | 
153 |     it('should not load a theme from a file with invalid JSON', () => {
154 |       vi.spyOn(fs, 'existsSync').mockReturnValue(true);
155 |       vi.spyOn(fs, 'readFileSync').mockReturnValue('invalid json');
156 | 
157 |       const result = themeManager.setActiveTheme(mockThemePath);
158 | 
159 |       expect(result).toBe(false);
160 |       expect(themeManager.getActiveTheme().name).toBe(DEFAULT_THEME.name);
161 |     });
162 | 
163 |     it('should not load a theme from an untrusted file path and log a message', () => {
164 |       vi.spyOn(fs, 'existsSync').mockReturnValue(true);
165 |       vi.spyOn(fs, 'readFileSync').mockReturnValue(JSON.stringify(mockTheme));
166 |       const consoleWarnSpy = vi
167 |         .spyOn(console, 'warn')
168 |         .mockImplementation(() => {});
169 | 
170 |       const result = themeManager.setActiveTheme('/untrusted/my-theme.json');
171 | 
172 |       expect(result).toBe(false);
173 |       expect(themeManager.getActiveTheme().name).toBe(DEFAULT_THEME.name);
174 |       expect(consoleWarnSpy).toHaveBeenCalledWith(
175 |         expect.stringContaining('is outside your home directory'),
176 |       );
177 | 
178 |       consoleWarnSpy.mockRestore();
179 |     });
180 |   });
181 | });
```

src/ui/themes/theme-manager.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { AyuDark } from './ayu.js';
8 | import { AyuLight } from './ayu-light.js';
9 | import { AtomOneDark } from './atom-one-dark.js';
10 | import { Dracula } from './dracula.js';
11 | import { GitHubDark } from './github-dark.js';
12 | import { GitHubLight } from './github-light.js';
13 | import { GoogleCode } from './googlecode.js';
14 | import { DefaultLight } from './default-light.js';
15 | import { DefaultDark } from './default.js';
16 | import { ShadesOfPurple } from './shades-of-purple.js';
17 | import { XCode } from './xcode.js';
18 | import * as fs from 'node:fs';
19 | import * as path from 'node:path';
20 | import * as os from 'node:os';
21 | import type { Theme, ThemeType, CustomTheme } from './theme.js';
22 | import { createCustomTheme, validateCustomTheme } from './theme.js';
23 | import type { SemanticColors } from './semantic-tokens.js';
24 | import { ANSI } from './ansi.js';
25 | import { ANSILight } from './ansi-light.js';
26 | import { NoColorTheme } from './no-color.js';
27 | import process from 'node:process';
28 | 
29 | export interface ThemeDisplay {
30 |   name: string;
31 |   type: ThemeType;
32 |   isCustom?: boolean;
33 | }
34 | 
35 | export const DEFAULT_THEME: Theme = DefaultDark;
36 | 
37 | class ThemeManager {
38 |   private readonly availableThemes: Theme[];
39 |   private activeTheme: Theme;
40 |   private customThemes: Map<string, Theme> = new Map();
41 | 
42 |   constructor() {
43 |     this.availableThemes = [
44 |       AyuDark,
45 |       AyuLight,
46 |       AtomOneDark,
47 |       Dracula,
48 |       DefaultLight,
49 |       DefaultDark,
50 |       GitHubDark,
51 |       GitHubLight,
52 |       GoogleCode,
53 |       ShadesOfPurple,
54 |       XCode,
55 |       ANSI,
56 |       ANSILight,
57 |     ];
58 |     this.activeTheme = DEFAULT_THEME;
59 |   }
60 | 
61 |   /**
62 |    * Loads custom themes from settings.
63 |    * @param customThemesSettings Custom themes from settings.
64 |    */
65 |   loadCustomThemes(customThemesSettings?: Record<string, CustomTheme>): void {
66 |     this.customThemes.clear();
67 | 
68 |     if (!customThemesSettings) {
69 |       return;
70 |     }
71 | 
72 |     for (const [name, customThemeConfig] of Object.entries(
73 |       customThemesSettings,
74 |     )) {
75 |       const validation = validateCustomTheme(customThemeConfig);
76 |       if (validation.isValid) {
77 |         if (validation.warning) {
78 |           console.warn(`Theme "${name}": ${validation.warning}`);
79 |         }
80 |         const themeWithDefaults: CustomTheme = {
81 |           ...DEFAULT_THEME.colors,
82 |           ...customThemeConfig,
83 |           name: customThemeConfig.name || name,
84 |           type: 'custom',
85 |         };
86 | 
87 |         try {
88 |           const theme = createCustomTheme(themeWithDefaults);
89 |           this.customThemes.set(name, theme);
90 |         } catch (error) {
91 |           console.warn(`Failed to load custom theme "${name}":`, error);
92 |         }
93 |       } else {
94 |         console.warn(`Invalid custom theme "${name}": ${validation.error}`);
95 |       }
96 |     }
97 |     // If the current active theme is a custom theme, keep it if still valid
98 |     if (
99 |       this.activeTheme &&
100 |       this.activeTheme.type === 'custom' &&
101 |       this.customThemes.has(this.activeTheme.name)
102 |     ) {
103 |       this.activeTheme = this.customThemes.get(this.activeTheme.name)!;
104 |     }
105 |   }
106 | 
107 |   /**
108 |    * Sets the active theme.
109 |    * @param themeName The name of the theme to set as active.
110 |    * @returns True if the theme was successfully set, false otherwise.
111 |    */
112 |   setActiveTheme(themeName: string | undefined): boolean {
113 |     const theme = this.findThemeByName(themeName);
114 |     if (!theme) {
115 |       return false;
116 |     }
117 |     this.activeTheme = theme;
118 |     return true;
119 |   }
120 | 
121 |   /**
122 |    * Gets the currently active theme.
123 |    * @returns The active theme.
124 |    */
125 |   getActiveTheme(): Theme {
126 |     if (process.env['NO_COLOR']) {
127 |       return NoColorTheme;
128 |     }
129 | 
130 |     if (this.activeTheme) {
131 |       const isBuiltIn = this.availableThemes.some(
132 |         (t) => t.name === this.activeTheme.name,
133 |       );
134 |       const isCustom = [...this.customThemes.values()].includes(
135 |         this.activeTheme,
136 |       );
137 | 
138 |       if (isBuiltIn || isCustom) {
139 |         return this.activeTheme;
140 |       }
141 |     }
142 | 
143 |     // Fallback to default if no active theme or if it's no longer valid.
144 |     this.activeTheme = DEFAULT_THEME;
145 |     return this.activeTheme;
146 |   }
147 | 
148 |   /**
149 |    * Gets the semantic colors for the active theme.
150 |    * @returns The semantic colors.
151 |    */
152 |   getSemanticColors(): SemanticColors {
153 |     return this.getActiveTheme().semanticColors;
154 |   }
155 | 
156 |   /**
157 |    * Gets a list of custom theme names.
158 |    * @returns Array of custom theme names.
159 |    */
160 |   getCustomThemeNames(): string[] {
161 |     return Array.from(this.customThemes.keys());
162 |   }
163 | 
164 |   /**
165 |    * Checks if a theme name is a custom theme.
166 |    * @param themeName The theme name to check.
167 |    * @returns True if the theme is custom.
168 |    */
169 |   isCustomTheme(themeName: string): boolean {
170 |     return this.customThemes.has(themeName);
171 |   }
172 | 
173 |   /**
174 |    * Returns a list of available theme names.
175 |    */
176 |   getAvailableThemes(): ThemeDisplay[] {
177 |     const builtInThemes = this.availableThemes.map((theme) => ({
178 |       name: theme.name,
179 |       type: theme.type,
180 |       isCustom: false,
181 |     }));
182 | 
183 |     const customThemes = Array.from(this.customThemes.values()).map(
184 |       (theme) => ({
185 |         name: theme.name,
186 |         type: theme.type,
187 |         isCustom: true,
188 |       }),
189 |     );
190 | 
191 |     const allThemes = [...builtInThemes, ...customThemes];
192 | 
193 |     const sortedThemes = allThemes.sort((a, b) => {
194 |       const typeOrder = (type: ThemeType): number => {
195 |         switch (type) {
196 |           case 'dark':
197 |             return 1;
198 |           case 'light':
199 |             return 2;
200 |           case 'ansi':
201 |             return 3;
202 |           case 'custom':
203 |             return 4; // Custom themes at the end
204 |           default:
205 |             return 5;
206 |         }
207 |       };
208 | 
209 |       const typeComparison = typeOrder(a.type) - typeOrder(b.type);
210 |       if (typeComparison !== 0) {
211 |         return typeComparison;
212 |       }
213 |       return a.name.localeCompare(b.name);
214 |     });
215 | 
216 |     return sortedThemes;
217 |   }
218 | 
219 |   /**
220 |    * Gets a theme by name.
221 |    * @param themeName The name of the theme to get.
222 |    * @returns The theme if found, undefined otherwise.
223 |    */
224 |   getTheme(themeName: string): Theme | undefined {
225 |     return this.findThemeByName(themeName);
226 |   }
227 | 
228 |   private isPath(themeName: string): boolean {
229 |     return (
230 |       themeName.endsWith('.json') ||
231 |       themeName.startsWith('.') ||
232 |       path.isAbsolute(themeName)
233 |     );
234 |   }
235 | 
236 |   private loadThemeFromFile(themePath: string): Theme | undefined {
237 |     try {
238 |       // realpathSync resolves the path and throws if it doesn't exist.
239 |       const canonicalPath = fs.realpathSync(path.resolve(themePath));
240 | 
241 |       // 1. Check cache using the canonical path.
242 |       if (this.customThemes.has(canonicalPath)) {
243 |         return this.customThemes.get(canonicalPath);
244 |       }
245 | 
246 |       // 2. Perform security check.
247 |       const homeDir = path.resolve(os.homedir());
248 |       if (!canonicalPath.startsWith(homeDir)) {
249 |         console.warn(
250 |           `Theme file at "${themePath}" is outside your home directory. ` +
251 |             `Only load themes from trusted sources.`,
252 |         );
253 |         return undefined;
254 |       }
255 | 
256 |       // 3. Read, parse, and validate the theme file.
257 |       const themeContent = fs.readFileSync(canonicalPath, 'utf-8');
258 |       const customThemeConfig = JSON.parse(themeContent) as CustomTheme;
259 | 
260 |       const validation = validateCustomTheme(customThemeConfig);
261 |       if (!validation.isValid) {
262 |         console.warn(
263 |           `Invalid custom theme from file "${themePath}": ${validation.error}`,
264 |         );
265 |         return undefined;
266 |       }
267 | 
268 |       if (validation.warning) {
269 |         console.warn(`Theme from "${themePath}": ${validation.warning}`);
270 |       }
271 | 
272 |       // 4. Create and cache the theme.
273 |       const themeWithDefaults: CustomTheme = {
274 |         ...DEFAULT_THEME.colors,
275 |         ...customThemeConfig,
276 |         name: customThemeConfig.name || canonicalPath,
277 |         type: 'custom',
278 |       };
279 | 
280 |       const theme = createCustomTheme(themeWithDefaults);
281 |       this.customThemes.set(canonicalPath, theme); // Cache by canonical path
282 |       return theme;
283 |     } catch (error) {
284 |       // Any error in the process (file not found, bad JSON, etc.) is caught here.
285 |       // We can return undefined silently for file-not-found, and warn for others.
286 |       if (
287 |         !(error instanceof Error && 'code' in error && error.code === 'ENOENT')
288 |       ) {
289 |         console.warn(`Could not load theme from file "${themePath}":`, error);
290 |       }
291 |       return undefined;
292 |     }
293 |   }
294 | 
295 |   findThemeByName(themeName: string | undefined): Theme | undefined {
296 |     if (!themeName) {
297 |       return DEFAULT_THEME;
298 |     }
299 | 
300 |     // First check built-in themes
301 |     const builtInTheme = this.availableThemes.find(
302 |       (theme) => theme.name === themeName,
303 |     );
304 |     if (builtInTheme) {
305 |       return builtInTheme;
306 |     }
307 | 
308 |     // Then check custom themes that have been loaded from settings, or file paths
309 |     if (this.isPath(themeName)) {
310 |       return this.loadThemeFromFile(themeName);
311 |     }
312 | 
313 |     if (this.customThemes.has(themeName)) {
314 |       return this.customThemes.get(themeName);
315 |     }
316 | 
317 |     // If it's not a built-in, not in cache, and not a valid file path,
318 |     // it's not a valid theme.
319 |     return undefined;
320 |   }
321 | }
322 | 
323 | // Export an instance of the ThemeManager
324 | export const themeManager = new ThemeManager();
```

src/ui/themes/theme.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect } from 'vitest';
8 | import * as themeModule from './theme.js';
9 | import { themeManager } from './theme-manager.js';
10 | 
11 | const { validateCustomTheme } = themeModule;
12 | type CustomTheme = themeModule.CustomTheme;
13 | 
14 | describe('validateCustomTheme', () => {
15 |   const validTheme: CustomTheme = {
16 |     type: 'custom',
17 |     name: 'My Custom Theme',
18 |     Background: '#FFFFFF',
19 |     Foreground: '#000000',
20 |     LightBlue: '#ADD8E6',
21 |     AccentBlue: '#0000FF',
22 |     AccentPurple: '#800080',
23 |     AccentCyan: '#00FFFF',
24 |     AccentGreen: '#008000',
25 |     AccentYellow: '#FFFF00',
26 |     AccentRed: '#FF0000',
27 |     DiffAdded: '#00FF00',
28 |     DiffRemoved: '#FF0000',
29 |     Comment: '#808080',
30 |     Gray: '#808080',
31 |   };
32 | 
33 |   it('should return isValid: true for a valid theme', () => {
34 |     const result = validateCustomTheme(validTheme);
35 |     expect(result.isValid).toBe(true);
36 |     expect(result.error).toBeUndefined();
37 |   });
38 | 
39 |   it('should return isValid: false for a theme with an invalid name', () => {
40 |     const invalidTheme = { ...validTheme, name: ' ' };
41 |     const result = validateCustomTheme(invalidTheme);
42 |     expect(result.isValid).toBe(false);
43 |     expect(result.error).toBe('Invalid theme name:  ');
44 |   });
45 | 
46 |   it('should return isValid: true for a theme missing optional DiffAdded and DiffRemoved colors', () => {
47 |     const legacyTheme: Partial<CustomTheme> = { ...validTheme };
48 |     delete legacyTheme.DiffAdded;
49 |     delete legacyTheme.DiffRemoved;
50 |     const result = validateCustomTheme(legacyTheme);
51 |     expect(result.isValid).toBe(true);
52 |     expect(result.error).toBeUndefined();
53 |   });
54 | 
55 |   it('should return isValid: false for a theme with a very long name', () => {
56 |     const invalidTheme = { ...validTheme, name: 'a'.repeat(51) };
57 |     const result = validateCustomTheme(invalidTheme);
58 |     expect(result.isValid).toBe(false);
59 |     expect(result.error).toBe(`Invalid theme name: ${'a'.repeat(51)}`);
60 |   });
61 | });
62 | 
63 | describe('themeManager.loadCustomThemes', () => {
64 |   const baseTheme: Omit<CustomTheme, 'DiffAdded' | 'DiffRemoved'> & {
65 |     DiffAdded?: string;
66 |     DiffRemoved?: string;
67 |   } = {
68 |     type: 'custom',
69 |     name: 'Test Theme',
70 |     Background: '#FFF',
71 |     Foreground: '#000',
72 |     LightBlue: '#ADD8E6',
73 |     AccentBlue: '#00F',
74 |     AccentPurple: '#808',
75 |     AccentCyan: '#0FF',
76 |     AccentGreen: '#080',
77 |     AccentYellow: '#FF0',
78 |     AccentRed: '#F00',
79 |     Comment: '#888',
80 |     Gray: '#888',
81 |   };
82 | 
83 |   it('should use values from DEFAULT_THEME when DiffAdded and DiffRemoved are not provided', () => {
84 |     const { darkTheme } = themeModule;
85 |     const legacyTheme: Partial<CustomTheme> = { ...baseTheme };
86 |     delete legacyTheme.DiffAdded;
87 |     delete legacyTheme.DiffRemoved;
88 | 
89 |     themeManager.loadCustomThemes({ 'Legacy Custom Theme': legacyTheme });
90 |     const result = themeManager.getTheme('Legacy Custom Theme')!;
91 | 
92 |     expect(result.colors.DiffAdded).toBe(darkTheme.DiffAdded);
93 |     expect(result.colors.DiffRemoved).toBe(darkTheme.DiffRemoved);
94 |     expect(result.colors.AccentBlue).toBe(legacyTheme.AccentBlue);
95 |     expect(result.name).toBe(legacyTheme.name);
96 |   });
97 | });
```

src/ui/themes/theme.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type { CSSProperties } from 'react';
8 | import type { SemanticColors } from './semantic-tokens.js';
9 | import { resolveColor } from './color-utils.js';
10 | 
11 | export type ThemeType = 'light' | 'dark' | 'ansi' | 'custom';
12 | 
13 | export interface ColorsTheme {
14 |   type: ThemeType;
15 |   Background: string;
16 |   Foreground: string;
17 |   LightBlue: string;
18 |   AccentBlue: string;
19 |   AccentPurple: string;
20 |   AccentCyan: string;
21 |   AccentGreen: string;
22 |   AccentYellow: string;
23 |   AccentRed: string;
24 |   DiffAdded: string;
25 |   DiffRemoved: string;
26 |   Comment: string;
27 |   Gray: string;
28 |   GradientColors?: string[];
29 | }
30 | 
31 | export interface CustomTheme {
32 |   type: 'custom';
33 |   name: string;
34 | 
35 |   text?: {
36 |     primary?: string;
37 |     secondary?: string;
38 |     link?: string;
39 |     accent?: string;
40 |   };
41 |   background?: {
42 |     primary?: string;
43 |     diff?: {
44 |       added?: string;
45 |       removed?: string;
46 |     };
47 |   };
48 |   border?: {
49 |     default?: string;
50 |     focused?: string;
51 |   };
52 |   ui?: {
53 |     comment?: string;
54 |     symbol?: string;
55 |     gradient?: string[];
56 |   };
57 |   status?: {
58 |     error?: string;
59 |     success?: string;
60 |     warning?: string;
61 |   };
62 | 
63 |   // Legacy properties (all optional)
64 |   Background?: string;
65 |   Foreground?: string;
66 |   LightBlue?: string;
67 |   AccentBlue?: string;
68 |   AccentPurple?: string;
69 |   AccentCyan?: string;
70 |   AccentGreen?: string;
71 |   AccentYellow?: string;
72 |   AccentRed?: string;
73 |   DiffAdded?: string;
74 |   DiffRemoved?: string;
75 |   Comment?: string;
76 |   Gray?: string;
77 |   GradientColors?: string[];
78 | }
79 | 
80 | export const lightTheme: ColorsTheme = {
81 |   type: 'light',
82 |   Background: '#FAFAFA',
83 |   Foreground: '',
84 |   LightBlue: '#89BDCD',
85 |   AccentBlue: '#3B82F6',
86 |   AccentPurple: '#8B5CF6',
87 |   AccentCyan: '#06B6D4',
88 |   AccentGreen: '#3CA84B',
89 |   AccentYellow: '#D5A40A',
90 |   AccentRed: '#DD4C4C',
91 |   DiffAdded: '#C6EAD8',
92 |   DiffRemoved: '#FFCCCC',
93 |   Comment: '#008000',
94 |   Gray: '#97a0b0',
95 |   GradientColors: ['#4796E4', '#847ACE', '#C3677F'],
96 | };
97 | 
98 | export const darkTheme: ColorsTheme = {
99 |   type: 'dark',
100 |   Background: '#1E1E2E',
101 |   Foreground: '',
102 |   LightBlue: '#ADD8E6',
103 |   AccentBlue: '#89B4FA',
104 |   AccentPurple: '#CBA6F7',
105 |   AccentCyan: '#89DCEB',
106 |   AccentGreen: '#A6E3A1',
107 |   AccentYellow: '#F9E2AF',
108 |   AccentRed: '#F38BA8',
109 |   DiffAdded: '#28350B',
110 |   DiffRemoved: '#430000',
111 |   Comment: '#6C7086',
112 |   Gray: '#6C7086',
113 |   GradientColors: ['#4796E4', '#847ACE', '#C3677F'],
114 | };
115 | 
116 | export const ansiTheme: ColorsTheme = {
117 |   type: 'ansi',
118 |   Background: 'black',
119 |   Foreground: 'white',
120 |   LightBlue: 'blue',
121 |   AccentBlue: 'blue',
122 |   AccentPurple: 'magenta',
123 |   AccentCyan: 'cyan',
124 |   AccentGreen: 'green',
125 |   AccentYellow: 'yellow',
126 |   AccentRed: 'red',
127 |   DiffAdded: 'green',
128 |   DiffRemoved: 'red',
129 |   Comment: 'gray',
130 |   Gray: 'gray',
131 | };
132 | 
133 | export class Theme {
134 |   /**
135 |    * The default foreground color for text when no specific highlight rule applies.
136 |    * This is an Ink-compatible color string (hex or name).
137 |    */
138 |   readonly defaultColor: string;
139 |   /**
140 |    * Stores the mapping from highlight.js class names (e.g., 'hljs-keyword')
141 |    * to Ink-compatible color strings (hex or name).
142 |    */
143 |   protected readonly _colorMap: Readonly<Record<string, string>>;
144 |   readonly semanticColors: SemanticColors;
145 | 
146 |   /**
147 |    * Creates a new Theme instance.
148 |    * @param name The name of the theme.
149 |    * @param rawMappings The raw CSSProperties mappings from a react-syntax-highlighter theme object.
150 |    */
151 |   constructor(
152 |     readonly name: string,
153 |     readonly type: ThemeType,
154 |     rawMappings: Record<string, CSSProperties>,
155 |     readonly colors: ColorsTheme,
156 |     semanticColors?: SemanticColors,
157 |   ) {
158 |     this.semanticColors = semanticColors ?? {
159 |       text: {
160 |         primary: this.colors.Foreground,
161 |         secondary: this.colors.Gray,
162 |         link: this.colors.AccentBlue,
163 |         accent: this.colors.AccentPurple,
164 |       },
165 |       background: {
166 |         primary: this.colors.Background,
167 |         diff: {
168 |           added: this.colors.DiffAdded,
169 |           removed: this.colors.DiffRemoved,
170 |         },
171 |       },
172 |       border: {
173 |         default: this.colors.Gray,
174 |         focused: this.colors.AccentBlue,
175 |       },
176 |       ui: {
177 |         comment: this.colors.Gray,
178 |         symbol: this.colors.AccentCyan,
179 |         gradient: this.colors.GradientColors,
180 |       },
181 |       status: {
182 |         error: this.colors.AccentRed,
183 |         success: this.colors.AccentGreen,
184 |         warning: this.colors.AccentYellow,
185 |       },
186 |     };
187 |     this._colorMap = Object.freeze(this._buildColorMap(rawMappings)); // Build and freeze the map
188 | 
189 |     // Determine the default foreground color
190 |     const rawDefaultColor = rawMappings['hljs']?.color;
191 |     this.defaultColor =
192 |       (rawDefaultColor ? Theme._resolveColor(rawDefaultColor) : undefined) ??
193 |       ''; // Default to empty string if not found or resolvable
194 |   }
195 | 
196 |   /**
197 |    * Gets the Ink-compatible color string for a given highlight.js class name.
198 |    * @param hljsClass The highlight.js class name (e.g., 'hljs-keyword', 'hljs-string').
199 |    * @returns The corresponding Ink color string (hex or name) if it exists.
200 |    */
201 |   getInkColor(hljsClass: string): string | undefined {
202 |     return this._colorMap[hljsClass];
203 |   }
204 | 
205 |   /**
206 |    * Resolves a CSS color value (name or hex) into an Ink-compatible color string.
207 |    * @param colorValue The raw color string (e.g., 'blue', '#ff0000', 'darkkhaki').
208 |    * @returns An Ink-compatible color string (hex or name), or undefined if not resolvable.
209 |    */
210 |   private static _resolveColor(colorValue: string): string | undefined {
211 |     return resolveColor(colorValue);
212 |   }
213 | 
214 |   /**
215 |    * Builds the internal map from highlight.js class names to Ink-compatible color strings.
216 |    * This method is protected and primarily intended for use by the constructor.
217 |    * @param hljsTheme The raw CSSProperties mappings from a react-syntax-highlighter theme object.
218 |    * @returns An Ink-compatible theme map (Record<string, string>).
219 |    */
220 |   protected _buildColorMap(
221 |     hljsTheme: Record<string, CSSProperties>,
222 |   ): Record<string, string> {
223 |     const inkTheme: Record<string, string> = {};
224 |     for (const key in hljsTheme) {
225 |       // Ensure the key starts with 'hljs-' or is 'hljs' for the base style
226 |       if (!key.startsWith('hljs-') && key !== 'hljs') {
227 |         continue; // Skip keys not related to highlighting classes
228 |       }
229 | 
230 |       const style = hljsTheme[key];
231 |       if (style?.color) {
232 |         const resolvedColor = Theme._resolveColor(style.color);
233 |         if (resolvedColor !== undefined) {
234 |           // Use the original key from the hljsTheme (e.g., 'hljs-keyword')
235 |           inkTheme[key] = resolvedColor;
236 |         }
237 |         // If color is not resolvable, it's omitted from the map,
238 |         // this enables falling back to the default foreground color.
239 |       }
240 |       // We currently only care about the 'color' property for Ink rendering.
241 |       // Other properties like background, fontStyle, etc., are ignored.
242 |     }
243 |     return inkTheme;
244 |   }
245 | }
246 | 
247 | /**
248 |  * Creates a Theme instance from a custom theme configuration.
249 |  * @param customTheme The custom theme configuration.
250 |  * @returns A new Theme instance.
251 |  */
252 | export function createCustomTheme(customTheme: CustomTheme): Theme {
253 |   const colors: ColorsTheme = {
254 |     type: 'custom',
255 |     Background: customTheme.background?.primary ?? customTheme.Background ?? '',
256 |     Foreground: customTheme.text?.primary ?? customTheme.Foreground ?? '',
257 |     LightBlue: customTheme.text?.link ?? customTheme.LightBlue ?? '',
258 |     AccentBlue: customTheme.text?.link ?? customTheme.AccentBlue ?? '',
259 |     AccentPurple: customTheme.text?.accent ?? customTheme.AccentPurple ?? '',
260 |     AccentCyan: customTheme.text?.link ?? customTheme.AccentCyan ?? '',
261 |     AccentGreen: customTheme.status?.success ?? customTheme.AccentGreen ?? '',
262 |     AccentYellow: customTheme.status?.warning ?? customTheme.AccentYellow ?? '',
263 |     AccentRed: customTheme.status?.error ?? customTheme.AccentRed ?? '',
264 |     DiffAdded:
265 |       customTheme.background?.diff?.added ?? customTheme.DiffAdded ?? '',
266 |     DiffRemoved:
267 |       customTheme.background?.diff?.removed ?? customTheme.DiffRemoved ?? '',
268 |     Comment: customTheme.ui?.comment ?? customTheme.Comment ?? '',
269 |     Gray: customTheme.text?.secondary ?? customTheme.Gray ?? '',
270 |     GradientColors: customTheme.ui?.gradient ?? customTheme.GradientColors,
271 |   };
272 | 
273 |   // Generate CSS properties mappings based on the custom theme colors
274 |   const rawMappings: Record<string, CSSProperties> = {
275 |     hljs: {
276 |       display: 'block',
277 |       overflowX: 'auto',
278 |       padding: '0.5em',
279 |       background: colors.Background,
280 |       color: colors.Foreground,
281 |     },
282 |     'hljs-keyword': {
283 |       color: colors.AccentBlue,
284 |     },
285 |     'hljs-literal': {
286 |       color: colors.AccentBlue,
287 |     },
288 |     'hljs-symbol': {
289 |       color: colors.AccentBlue,
290 |     },
291 |     'hljs-name': {
292 |       color: colors.AccentBlue,
293 |     },
294 |     'hljs-link': {
295 |       color: colors.AccentBlue,
296 |       textDecoration: 'underline',
297 |     },
298 |     'hljs-built_in': {
299 |       color: colors.AccentCyan,
300 |     },
301 |     'hljs-type': {
302 |       color: colors.AccentCyan,
303 |     },
304 |     'hljs-number': {
305 |       color: colors.AccentGreen,
306 |     },
307 |     'hljs-class': {
308 |       color: colors.AccentGreen,
309 |     },
310 |     'hljs-string': {
311 |       color: colors.AccentYellow,
312 |     },
313 |     'hljs-meta-string': {
314 |       color: colors.AccentYellow,
315 |     },
316 |     'hljs-regexp': {
317 |       color: colors.AccentRed,
318 |     },
319 |     'hljs-template-tag': {
320 |       color: colors.AccentRed,
321 |     },
322 |     'hljs-subst': {
323 |       color: colors.Foreground,
324 |     },
325 |     'hljs-function': {
326 |       color: colors.Foreground,
327 |     },
328 |     'hljs-title': {
329 |       color: colors.Foreground,
330 |     },
331 |     'hljs-params': {
332 |       color: colors.Foreground,
333 |     },
334 |     'hljs-formula': {
335 |       color: colors.Foreground,
336 |     },
337 |     'hljs-comment': {
338 |       color: colors.Comment,
339 |       fontStyle: 'italic',
340 |     },
341 |     'hljs-quote': {
342 |       color: colors.Comment,
343 |       fontStyle: 'italic',
344 |     },
345 |     'hljs-doctag': {
346 |       color: colors.Comment,
347 |     },
348 |     'hljs-meta': {
349 |       color: colors.Gray,
350 |     },
351 |     'hljs-meta-keyword': {
352 |       color: colors.Gray,
353 |     },
354 |     'hljs-tag': {
355 |       color: colors.Gray,
356 |     },
357 |     'hljs-variable': {
358 |       color: colors.AccentPurple,
359 |     },
360 |     'hljs-template-variable': {
361 |       color: colors.AccentPurple,
362 |     },
363 |     'hljs-attr': {
364 |       color: colors.LightBlue,
365 |     },
366 |     'hljs-attribute': {
367 |       color: colors.LightBlue,
368 |     },
369 |     'hljs-builtin-name': {
370 |       color: colors.LightBlue,
371 |     },
372 |     'hljs-section': {
373 |       color: colors.AccentYellow,
374 |     },
375 |     'hljs-emphasis': {
376 |       fontStyle: 'italic',
377 |     },
378 |     'hljs-strong': {
379 |       fontWeight: 'bold',
380 |     },
381 |     'hljs-bullet': {
382 |       color: colors.AccentYellow,
383 |     },
384 |     'hljs-selector-tag': {
385 |       color: colors.AccentYellow,
386 |     },
387 |     'hljs-selector-id': {
388 |       color: colors.AccentYellow,
389 |     },
390 |     'hljs-selector-class': {
391 |       color: colors.AccentYellow,
392 |     },
393 |     'hljs-selector-attr': {
394 |       color: colors.AccentYellow,
395 |     },
396 |     'hljs-selector-pseudo': {
397 |       color: colors.AccentYellow,
398 |     },
399 |     'hljs-addition': {
400 |       backgroundColor: colors.AccentGreen,
401 |       display: 'inline-block',
402 |       width: '100%',
403 |     },
404 |     'hljs-deletion': {
405 |       backgroundColor: colors.AccentRed,
406 |       display: 'inline-block',
407 |       width: '100%',
408 |     },
409 |   };
410 | 
[TRUNCATED]
```

src/ui/themes/xcode.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { type ColorsTheme, Theme } from './theme.js';
8 | 
9 | const xcodeColors: ColorsTheme = {
10 |   type: 'light',
11 |   Background: '#fff',
12 |   Foreground: '#444',
13 |   LightBlue: '#0E0EFF',
14 |   AccentBlue: '#1c00cf',
15 |   AccentPurple: '#aa0d91',
16 |   AccentCyan: '#3F6E74',
17 |   AccentGreen: '#007400',
18 |   AccentYellow: '#836C28',
19 |   AccentRed: '#c41a16',
20 |   DiffAdded: '#C6EAD8',
21 |   DiffRemoved: '#FEDEDE',
22 |   Comment: '#007400',
23 |   Gray: '#c0c0c0',
24 |   GradientColors: ['#1c00cf', '#007400'],
25 | };
26 | 
27 | export const XCode: Theme = new Theme(
28 |   'Xcode',
29 |   'light',
30 |   {
31 |     hljs: {
32 |       display: 'block',
33 |       overflowX: 'auto',
34 |       padding: '0.5em',
35 |       background: xcodeColors.Background,
36 |       color: xcodeColors.Foreground,
37 |     },
38 |     'xml .hljs-meta': {
39 |       color: xcodeColors.Gray,
40 |     },
41 |     'hljs-comment': {
42 |       color: xcodeColors.Comment,
43 |     },
44 |     'hljs-quote': {
45 |       color: xcodeColors.Comment,
46 |     },
47 |     'hljs-tag': {
48 |       color: xcodeColors.AccentPurple,
49 |     },
50 |     'hljs-attribute': {
51 |       color: xcodeColors.AccentPurple,
52 |     },
53 |     'hljs-keyword': {
54 |       color: xcodeColors.AccentPurple,
55 |     },
56 |     'hljs-selector-tag': {
57 |       color: xcodeColors.AccentPurple,
58 |     },
59 |     'hljs-literal': {
60 |       color: xcodeColors.AccentPurple,
61 |     },
62 |     'hljs-name': {
63 |       color: xcodeColors.AccentPurple,
64 |     },
65 |     'hljs-variable': {
66 |       color: xcodeColors.AccentCyan,
67 |     },
68 |     'hljs-template-variable': {
69 |       color: xcodeColors.AccentCyan,
70 |     },
71 |     'hljs-code': {
72 |       color: xcodeColors.AccentRed,
73 |     },
74 |     'hljs-string': {
75 |       color: xcodeColors.AccentRed,
76 |     },
77 |     'hljs-meta-string': {
78 |       color: xcodeColors.AccentRed,
79 |     },
80 |     'hljs-regexp': {
81 |       color: xcodeColors.LightBlue,
82 |     },
83 |     'hljs-link': {
84 |       color: xcodeColors.LightBlue,
85 |     },
86 |     'hljs-title': {
87 |       color: xcodeColors.AccentBlue,
88 |     },
89 |     'hljs-symbol': {
90 |       color: xcodeColors.AccentBlue,
91 |     },
92 |     'hljs-bullet': {
93 |       color: xcodeColors.AccentBlue,
94 |     },
95 |     'hljs-number': {
96 |       color: xcodeColors.AccentBlue,
97 |     },
98 |     'hljs-section': {
99 |       color: xcodeColors.AccentYellow,
100 |     },
101 |     'hljs-meta': {
102 |       color: xcodeColors.AccentYellow,
103 |     },
104 |     'hljs-class .hljs-title': {
105 |       color: xcodeColors.AccentPurple,
106 |     },
107 |     'hljs-type': {
108 |       color: xcodeColors.AccentPurple,
109 |     },
110 |     'hljs-built_in': {
111 |       color: xcodeColors.AccentPurple,
112 |     },
113 |     'hljs-builtin-name': {
114 |       color: xcodeColors.AccentPurple,
115 |     },
116 |     'hljs-params': {
117 |       color: xcodeColors.AccentPurple,
118 |     },
119 |     'hljs-attr': {
120 |       color: xcodeColors.AccentYellow,
121 |     },
122 |     'hljs-subst': {
123 |       color: xcodeColors.Foreground,
124 |     },
125 |     'hljs-formula': {
126 |       backgroundColor: '#eee',
127 |       fontStyle: 'italic',
128 |     },
129 |     'hljs-addition': {
130 |       backgroundColor: '#baeeba',
131 |     },
132 |     'hljs-deletion': {
133 |       backgroundColor: '#ffc8bd',
134 |     },
135 |     'hljs-selector-id': {
136 |       color: xcodeColors.AccentYellow,
137 |     },
138 |     'hljs-selector-class': {
139 |       color: xcodeColors.AccentYellow,
140 |     },
141 |     'hljs-doctag': {
142 |       fontWeight: 'bold',
143 |     },
144 |     'hljs-strong': {
145 |       fontWeight: 'bold',
146 |     },
147 |     'hljs-emphasis': {
148 |       fontStyle: 'italic',
149 |     },
150 |   },
151 |   xcodeColors,
152 | );
```

src/ui/state/extensions.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type { ExtensionUpdateInfo } from '../../config/extension.js';
8 | import { checkExhaustive } from '../../utils/checks.js';
9 | 
10 | export enum ExtensionUpdateState {
11 |   CHECKING_FOR_UPDATES = 'checking for updates',
12 |   UPDATED_NEEDS_RESTART = 'updated, needs restart',
13 |   UPDATING = 'updating',
14 |   UPDATE_AVAILABLE = 'update available',
15 |   UP_TO_DATE = 'up to date',
16 |   ERROR = 'error',
17 |   NOT_UPDATABLE = 'not updatable',
18 |   UNKNOWN = 'unknown',
19 | }
20 | 
21 | export interface ExtensionUpdateStatus {
22 |   status: ExtensionUpdateState;
23 |   notified: boolean;
24 | }
25 | 
26 | export interface ExtensionUpdatesState {
27 |   extensionStatuses: Map<string, ExtensionUpdateStatus>;
28 |   batchChecksInProgress: number;
29 |   // Explicitly scheduled updates.
30 |   scheduledUpdate: ScheduledUpdate | null;
31 | }
32 | 
33 | export interface ScheduledUpdate {
34 |   names: string[] | null;
35 |   all: boolean;
36 |   onCompleteCallbacks: OnCompleteUpdate[];
37 | }
38 | 
39 | export interface ScheduleUpdateArgs {
40 |   names: string[] | null;
41 |   all: boolean;
42 |   onComplete: OnCompleteUpdate;
43 | }
44 | 
45 | type OnCompleteUpdate = (updateInfos: ExtensionUpdateInfo[]) => void;
46 | 
47 | export const initialExtensionUpdatesState: ExtensionUpdatesState = {
48 |   extensionStatuses: new Map(),
49 |   batchChecksInProgress: 0,
50 |   scheduledUpdate: null,
51 | };
52 | 
53 | export type ExtensionUpdateAction =
54 |   | {
55 |       type: 'SET_STATE';
56 |       payload: { name: string; state: ExtensionUpdateState };
57 |     }
58 |   | {
59 |       type: 'SET_NOTIFIED';
60 |       payload: { name: string; notified: boolean };
61 |     }
62 |   | { type: 'BATCH_CHECK_START' }
63 |   | { type: 'BATCH_CHECK_END' }
64 |   | { type: 'SCHEDULE_UPDATE'; payload: ScheduleUpdateArgs }
65 |   | { type: 'CLEAR_SCHEDULED_UPDATE' };
66 | 
67 | export function extensionUpdatesReducer(
68 |   state: ExtensionUpdatesState,
69 |   action: ExtensionUpdateAction,
70 | ): ExtensionUpdatesState {
71 |   switch (action.type) {
72 |     case 'SET_STATE': {
73 |       const existing = state.extensionStatuses.get(action.payload.name);
74 |       if (existing?.status === action.payload.state) {
75 |         return state;
76 |       }
77 |       const newStatuses = new Map(state.extensionStatuses);
78 |       newStatuses.set(action.payload.name, {
79 |         status: action.payload.state,
80 |         notified: false,
81 |       });
82 |       return { ...state, extensionStatuses: newStatuses };
83 |     }
84 |     case 'SET_NOTIFIED': {
85 |       const existing = state.extensionStatuses.get(action.payload.name);
86 |       if (!existing || existing.notified === action.payload.notified) {
87 |         return state;
88 |       }
89 |       const newStatuses = new Map(state.extensionStatuses);
90 |       newStatuses.set(action.payload.name, {
91 |         ...existing,
92 |         notified: action.payload.notified,
93 |       });
94 |       return { ...state, extensionStatuses: newStatuses };
95 |     }
96 |     case 'BATCH_CHECK_START':
97 |       return {
98 |         ...state,
99 |         batchChecksInProgress: state.batchChecksInProgress + 1,
100 |       };
101 |     case 'BATCH_CHECK_END':
102 |       return {
103 |         ...state,
104 |         batchChecksInProgress: state.batchChecksInProgress - 1,
105 |       };
106 |     case 'SCHEDULE_UPDATE':
107 |       return {
108 |         ...state,
109 |         // If there is a pre-existing scheduled update, we merge them.
110 |         scheduledUpdate: {
111 |           all: state.scheduledUpdate?.all || action.payload.all,
112 |           names: [
113 |             ...(state.scheduledUpdate?.names ?? []),
114 |             ...(action.payload.names ?? []),
115 |           ],
116 |           onCompleteCallbacks: [
117 |             ...(state.scheduledUpdate?.onCompleteCallbacks ?? []),
118 |             action.payload.onComplete,
119 |           ],
120 |         },
121 |       };
122 |     case 'CLEAR_SCHEDULED_UPDATE':
123 |       return {
124 |         ...state,
125 |         scheduledUpdate: null,
126 |       };
127 |     default:
128 |       checkExhaustive(action);
129 |   }
130 | }
```

src/ui/utils/CodeColorizer.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import React from 'react';
8 | import { Text, Box } from 'ink';
9 | import { common, createLowlight } from 'lowlight';
10 | import type {
11 |   Root,
12 |   Element,
13 |   Text as HastText,
14 |   ElementContent,
15 |   RootContent,
16 | } from 'hast';
17 | import { themeManager } from '../themes/theme-manager.js';
18 | import type { Theme } from '../themes/theme.js';
19 | import {
20 |   MaxSizedBox,
21 |   MINIMUM_MAX_HEIGHT,
22 | } from '../components/shared/MaxSizedBox.js';
23 | import type { LoadedSettings } from '../../config/settings.js';
24 | 
25 | // Configure theming and parsing utilities.
26 | const lowlight = createLowlight(common);
27 | 
28 | function renderHastNode(
29 |   node: Root | Element | HastText | RootContent,
30 |   theme: Theme,
31 |   inheritedColor: string | undefined,
32 | ): React.ReactNode {
33 |   if (node.type === 'text') {
34 |     // Use the color passed down from parent element, or the theme's default.
35 |     const color = inheritedColor || theme.defaultColor;
36 |     return <Text color={color}>{node.value}</Text>;
37 |   }
38 | 
39 |   // Handle Element Nodes: Determine color and pass it down, don't wrap
40 |   if (node.type === 'element') {
41 |     const nodeClasses: string[] =
42 |       (node.properties?.['className'] as string[]) || [];
43 |     let elementColor: string | undefined = undefined;
44 | 
45 |     // Find color defined specifically for this element's class
46 |     for (let i = nodeClasses.length - 1; i >= 0; i--) {
47 |       const color = theme.getInkColor(nodeClasses[i]);
48 |       if (color) {
49 |         elementColor = color;
50 |         break;
51 |       }
52 |     }
53 | 
54 |     // Determine the color to pass down: Use this element's specific color
55 |     // if found; otherwise, continue passing down the already inherited color.
56 |     const colorToPassDown = elementColor || inheritedColor;
57 | 
58 |     // Recursively render children, passing the determined color down
59 |     // Ensure child type matches expected HAST structure (ElementContent is common)
60 |     const children = node.children?.map(
61 |       (child: ElementContent, index: number) => (
62 |         <React.Fragment key={index}>
63 |           {renderHastNode(child, theme, colorToPassDown)}
64 |         </React.Fragment>
65 |       ),
66 |     );
67 | 
68 |     // Element nodes now only group children; color is applied by Text nodes.
69 |     // Use a React Fragment to avoid adding unnecessary elements.
70 |     return <React.Fragment>{children}</React.Fragment>;
71 |   }
72 | 
73 |   // Handle Root Node: Start recursion with initially inherited color
74 |   if (node.type === 'root') {
75 |     // Check if children array is empty - this happens when lowlight can't detect language – fall back to plain text
76 |     if (!node.children || node.children.length === 0) {
77 |       return null;
78 |     }
79 | 
80 |     // Pass down the initial inheritedColor (likely undefined from the top call)
81 |     // Ensure child type matches expected HAST structure (RootContent is common)
82 |     return node.children?.map((child: RootContent, index: number) => (
83 |       <React.Fragment key={index}>
84 |         {renderHastNode(child, theme, inheritedColor)}
85 |       </React.Fragment>
86 |     ));
87 |   }
88 | 
89 |   // Handle unknown or unsupported node types
90 |   return null;
91 | }
92 | 
93 | function highlightAndRenderLine(
94 |   line: string,
95 |   language: string | null,
96 |   theme: Theme,
97 | ): React.ReactNode {
98 |   try {
99 |     const getHighlightedLine = () =>
100 |       !language || !lowlight.registered(language)
101 |         ? lowlight.highlightAuto(line)
102 |         : lowlight.highlight(language, line);
103 | 
104 |     const renderedNode = renderHastNode(getHighlightedLine(), theme, undefined);
105 | 
106 |     return renderedNode !== null ? renderedNode : line;
107 |   } catch (_error) {
108 |     return line;
109 |   }
110 | }
111 | 
112 | export function colorizeLine(
113 |   line: string,
114 |   language: string | null,
115 |   theme?: Theme,
116 | ): React.ReactNode {
117 |   const activeTheme = theme || themeManager.getActiveTheme();
118 |   return highlightAndRenderLine(line, language, activeTheme);
119 | }
120 | 
121 | /**
122 |  * Renders syntax-highlighted code for Ink applications using a selected theme.
123 |  *
124 |  * @param code The code string to highlight.
125 |  * @param language The language identifier (e.g., 'javascript', 'css', 'html')
126 |  * @returns A React.ReactNode containing Ink <Text> elements for the highlighted code.
127 |  */
128 | export function colorizeCode(
129 |   code: string,
130 |   language: string | null,
131 |   availableHeight?: number,
132 |   maxWidth?: number,
133 |   theme?: Theme,
134 |   settings?: LoadedSettings,
135 | ): React.ReactNode {
136 |   const codeToHighlight = code.replace(/\n$/, '');
137 |   const activeTheme = theme || themeManager.getActiveTheme();
138 |   const showLineNumbers = settings?.merged.ui?.showLineNumbers ?? true;
139 | 
140 |   try {
141 |     // Render the HAST tree using the adapted theme
142 |     // Apply the theme's default foreground color to the top-level Text element
143 |     let lines = codeToHighlight.split('\n');
144 |     const padWidth = String(lines.length).length; // Calculate padding width based on number of lines
145 | 
146 |     let hiddenLinesCount = 0;
147 | 
148 |     // Optimization to avoid highlighting lines that cannot possibly be displayed.
149 |     if (availableHeight !== undefined) {
150 |       availableHeight = Math.max(availableHeight, MINIMUM_MAX_HEIGHT);
151 |       if (lines.length > availableHeight) {
152 |         const sliceIndex = lines.length - availableHeight;
153 |         hiddenLinesCount = sliceIndex;
154 |         lines = lines.slice(sliceIndex);
155 |       }
156 |     }
157 | 
158 |     return (
159 |       <MaxSizedBox
160 |         maxHeight={availableHeight}
161 |         maxWidth={maxWidth}
162 |         additionalHiddenLinesCount={hiddenLinesCount}
163 |         overflowDirection="top"
164 |       >
165 |         {lines.map((line, index) => {
166 |           const contentToRender = highlightAndRenderLine(
167 |             line,
168 |             language,
169 |             activeTheme,
170 |           );
171 | 
172 |           return (
173 |             <Box key={index}>
174 |               {showLineNumbers && (
175 |                 <Text color={activeTheme.colors.Gray}>
176 |                   {`${String(index + 1 + hiddenLinesCount).padStart(
177 |                     padWidth,
178 |                     ' ',
179 |                   )} `}
180 |                 </Text>
181 |               )}
182 |               <Text color={activeTheme.defaultColor} wrap="wrap">
183 |                 {contentToRender}
184 |               </Text>
185 |             </Box>
186 |           );
187 |         })}
188 |       </MaxSizedBox>
189 |     );
190 |   } catch (error) {
191 |     console.error(
192 |       `[colorizeCode] Error highlighting code for language "${language}":`,
193 |       error,
194 |     );
195 |     // Fall back to plain text with default color on error
196 |     // Also display line numbers in fallback
197 |     const lines = codeToHighlight.split('\n');
198 |     const padWidth = String(lines.length).length; // Calculate padding width based on number of lines
199 |     return (
200 |       <MaxSizedBox
201 |         maxHeight={availableHeight}
202 |         maxWidth={maxWidth}
203 |         overflowDirection="top"
204 |       >
205 |         {lines.map((line, index) => (
206 |           <Box key={index}>
207 |             {showLineNumbers && (
208 |               <Text color={activeTheme.defaultColor}>
209 |                 {`${String(index + 1).padStart(padWidth, ' ')} `}
210 |               </Text>
211 |             )}
212 |             <Text color={activeTheme.colors.Gray}>{line}</Text>
213 |           </Box>
214 |         ))}
215 |       </MaxSizedBox>
216 |     );
217 |   }
218 | }
```

src/ui/utils/ConsolePatcher.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import util from 'node:util';
8 | import type { ConsoleMessageItem } from '../types.js';
9 | 
10 | interface ConsolePatcherParams {
11 |   onNewMessage?: (message: Omit<ConsoleMessageItem, 'id'>) => void;
12 |   debugMode: boolean;
13 |   stderr?: boolean;
14 | }
15 | 
16 | export class ConsolePatcher {
17 |   private originalConsoleLog = console.log;
18 |   private originalConsoleWarn = console.warn;
19 |   private originalConsoleError = console.error;
20 |   private originalConsoleDebug = console.debug;
21 |   private originalConsoleInfo = console.info;
22 | 
23 |   private params: ConsolePatcherParams;
24 | 
25 |   constructor(params: ConsolePatcherParams) {
26 |     this.params = params;
27 |   }
28 | 
29 |   patch() {
30 |     console.log = this.patchConsoleMethod('log', this.originalConsoleLog);
31 |     console.warn = this.patchConsoleMethod('warn', this.originalConsoleWarn);
32 |     console.error = this.patchConsoleMethod('error', this.originalConsoleError);
33 |     console.debug = this.patchConsoleMethod('debug', this.originalConsoleDebug);
34 |     console.info = this.patchConsoleMethod('info', this.originalConsoleInfo);
35 |   }
36 | 
37 |   cleanup = () => {
38 |     console.log = this.originalConsoleLog;
39 |     console.warn = this.originalConsoleWarn;
40 |     console.error = this.originalConsoleError;
41 |     console.debug = this.originalConsoleDebug;
42 |     console.info = this.originalConsoleInfo;
43 |   };
44 | 
45 |   private formatArgs = (args: unknown[]): string => util.format(...args);
46 | 
47 |   private patchConsoleMethod =
48 |     (
49 |       type: 'log' | 'warn' | 'error' | 'debug' | 'info',
50 |       originalMethod: (...args: unknown[]) => void,
51 |     ) =>
52 |     (...args: unknown[]) => {
53 |       if (this.params.stderr) {
54 |         if (type !== 'debug' || this.params.debugMode) {
55 |           this.originalConsoleError(this.formatArgs(args));
56 |         }
57 |       } else {
58 |         if (this.params.debugMode) {
59 |           originalMethod.apply(console, args);
60 |         }
61 | 
62 |         if (type !== 'debug' || this.params.debugMode) {
63 |           this.params.onNewMessage?.({
64 |             type,
65 |             content: this.formatArgs(args),
66 |             count: 1,
67 |           });
68 |         }
69 |       }
70 |     };
71 | }
```

src/ui/utils/InlineMarkdownRenderer.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import React from 'react';
8 | import { Text } from 'ink';
9 | import { theme } from '../semantic-colors.js';
10 | import stringWidth from 'string-width';
11 | 
12 | // Constants for Markdown parsing
13 | const BOLD_MARKER_LENGTH = 2; // For "**"
14 | const ITALIC_MARKER_LENGTH = 1; // For "*" or "_"
15 | const STRIKETHROUGH_MARKER_LENGTH = 2; // For "~~")
16 | const INLINE_CODE_MARKER_LENGTH = 1; // For "`"
17 | const UNDERLINE_TAG_START_LENGTH = 3; // For "<u>"
18 | const UNDERLINE_TAG_END_LENGTH = 4; // For "</u>"
19 | 
20 | interface RenderInlineProps {
21 |   text: string;
22 | }
23 | 
24 | const RenderInlineInternal: React.FC<RenderInlineProps> = ({ text }) => {
25 |   // Early return for plain text without markdown or URLs
26 |   if (!/[*_~`<[https?:]/.test(text)) {
27 |     return <Text color={theme.text.primary}>{text}</Text>;
28 |   }
29 | 
30 |   const nodes: React.ReactNode[] = [];
31 |   let lastIndex = 0;
32 |   const inlineRegex =
33 |     /(\*\*.*?\*\*|\*.*?\*|_.*?_|~~.*?~~|\[.*?\]\(.*?\)|`+.+?`+|<u>.*?<\/u>|https?:\/\/\S+)/g;
34 |   let match;
35 | 
36 |   while ((match = inlineRegex.exec(text)) !== null) {
37 |     if (match.index > lastIndex) {
38 |       nodes.push(
39 |         <Text key={`t-${lastIndex}`}>
40 |           {text.slice(lastIndex, match.index)}
41 |         </Text>,
42 |       );
43 |     }
44 | 
45 |     const fullMatch = match[0];
46 |     let renderedNode: React.ReactNode = null;
47 |     const key = `m-${match.index}`;
48 | 
49 |     try {
50 |       if (
51 |         fullMatch.startsWith('**') &&
52 |         fullMatch.endsWith('**') &&
53 |         fullMatch.length > BOLD_MARKER_LENGTH * 2
54 |       ) {
55 |         renderedNode = (
56 |           <Text key={key} bold>
57 |             {fullMatch.slice(BOLD_MARKER_LENGTH, -BOLD_MARKER_LENGTH)}
58 |           </Text>
59 |         );
60 |       } else if (
61 |         fullMatch.length > ITALIC_MARKER_LENGTH * 2 &&
62 |         ((fullMatch.startsWith('*') && fullMatch.endsWith('*')) ||
63 |           (fullMatch.startsWith('_') && fullMatch.endsWith('_'))) &&
64 |         !/\w/.test(text.substring(match.index - 1, match.index)) &&
65 |         !/\w/.test(
66 |           text.substring(inlineRegex.lastIndex, inlineRegex.lastIndex + 1),
67 |         ) &&
68 |         !/\S[./\\]/.test(text.substring(match.index - 2, match.index)) &&
69 |         !/[./\\]\S/.test(
70 |           text.substring(inlineRegex.lastIndex, inlineRegex.lastIndex + 2),
71 |         )
72 |       ) {
73 |         renderedNode = (
74 |           <Text key={key} italic>
75 |             {fullMatch.slice(ITALIC_MARKER_LENGTH, -ITALIC_MARKER_LENGTH)}
76 |           </Text>
77 |         );
78 |       } else if (
79 |         fullMatch.startsWith('~~') &&
80 |         fullMatch.endsWith('~~') &&
81 |         fullMatch.length > STRIKETHROUGH_MARKER_LENGTH * 2
82 |       ) {
83 |         renderedNode = (
84 |           <Text key={key} strikethrough>
85 |             {fullMatch.slice(
86 |               STRIKETHROUGH_MARKER_LENGTH,
87 |               -STRIKETHROUGH_MARKER_LENGTH,
88 |             )}
89 |           </Text>
90 |         );
91 |       } else if (
92 |         fullMatch.startsWith('`') &&
93 |         fullMatch.endsWith('`') &&
94 |         fullMatch.length > INLINE_CODE_MARKER_LENGTH
95 |       ) {
96 |         const codeMatch = fullMatch.match(/^(`+)(.+?)\1$/s);
97 |         if (codeMatch && codeMatch[2]) {
98 |           renderedNode = (
99 |             <Text key={key} color={theme.text.accent}>
100 |               {codeMatch[2]}
101 |             </Text>
102 |           );
103 |         }
104 |       } else if (
105 |         fullMatch.startsWith('[') &&
106 |         fullMatch.includes('](') &&
107 |         fullMatch.endsWith(')')
108 |       ) {
109 |         const linkMatch = fullMatch.match(/\[(.*?)\]\((.*?)\)/);
110 |         if (linkMatch) {
111 |           const linkText = linkMatch[1];
112 |           const url = linkMatch[2];
113 |           renderedNode = (
114 |             <Text key={key}>
115 |               {linkText}
116 |               <Text color={theme.text.link}> ({url})</Text>
117 |             </Text>
118 |           );
119 |         }
120 |       } else if (
121 |         fullMatch.startsWith('<u>') &&
122 |         fullMatch.endsWith('</u>') &&
123 |         fullMatch.length >
124 |           UNDERLINE_TAG_START_LENGTH + UNDERLINE_TAG_END_LENGTH - 1 // -1 because length is compared to combined length of start and end tags
125 |       ) {
126 |         renderedNode = (
127 |           <Text key={key} underline>
128 |             {fullMatch.slice(
129 |               UNDERLINE_TAG_START_LENGTH,
130 |               -UNDERLINE_TAG_END_LENGTH,
131 |             )}
132 |           </Text>
133 |         );
134 |       } else if (fullMatch.match(/^https?:\/\//)) {
135 |         renderedNode = (
136 |           <Text key={key} color={theme.text.link}>
137 |             {fullMatch}
138 |           </Text>
139 |         );
140 |       }
141 |     } catch (e) {
142 |       console.error('Error parsing inline markdown part:', fullMatch, e);
143 |       renderedNode = null;
144 |     }
145 | 
146 |     nodes.push(renderedNode ?? <Text key={key}>{fullMatch}</Text>);
147 |     lastIndex = inlineRegex.lastIndex;
148 |   }
149 | 
150 |   if (lastIndex < text.length) {
151 |     nodes.push(<Text key={`t-${lastIndex}`}>{text.slice(lastIndex)}</Text>);
152 |   }
153 | 
154 |   return <>{nodes.filter((node) => node !== null)}</>;
155 | };
156 | 
157 | export const RenderInline = React.memo(RenderInlineInternal);
158 | 
159 | /**
160 |  * Utility function to get the plain text length of a string with markdown formatting
161 |  * This is useful for calculating column widths in tables
162 |  */
163 | export const getPlainTextLength = (text: string): number => {
164 |   const cleanText = text
165 |     .replace(/\*\*(.*?)\*\*/g, '$1')
166 |     .replace(/\*(.*?)\*/g, '$1')
167 |     .replace(/_(.*?)_/g, '$1')
168 |     .replace(/~~(.*?)~~/g, '$1')
169 |     .replace(/`(.*?)`/g, '$1')
170 |     .replace(/<u>(.*?)<\/u>/g, '$1')
171 |     .replace(/.*\[(.*?)\]\(.*\)/g, '$1');
172 |   return stringWidth(cleanText);
173 | };
```

src/ui/utils/MarkdownDisplay.test.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect, vi, beforeEach } from 'vitest';
8 | import { MarkdownDisplay } from './MarkdownDisplay.js';
9 | import { LoadedSettings } from '../../config/settings.js';
10 | import { renderWithProviders } from '../../test-utils/render.js';
11 | 
12 | describe('<MarkdownDisplay />', () => {
13 |   const baseProps = {
14 |     isPending: false,
15 |     terminalWidth: 80,
16 |     availableTerminalHeight: 40,
17 |   };
18 | 
19 |   beforeEach(() => {
20 |     vi.clearAllMocks();
21 |   });
22 | 
23 |   it('renders nothing for empty text', () => {
24 |     const { lastFrame } = renderWithProviders(
25 |       <MarkdownDisplay {...baseProps} text="" />,
26 |     );
27 |     expect(lastFrame()).toMatchSnapshot();
28 |   });
29 | 
30 |   it('renders a simple paragraph', () => {
31 |     const text = 'Hello, world.';
32 |     const { lastFrame } = renderWithProviders(
33 |       <MarkdownDisplay {...baseProps} text={text} />,
34 |     );
35 |     expect(lastFrame()).toMatchSnapshot();
36 |   });
37 | 
38 |   const lineEndings = [
39 |     { name: 'Windows', eol: '\r\n' },
40 |     { name: 'Unix', eol: '\n' },
41 |   ];
42 | 
43 |   describe.each(lineEndings)('with $name line endings', ({ eol }) => {
44 |     it('renders headers with correct levels', () => {
45 |       const text = `
46 | # Header 1
47 | ## Header 2
48 | ### Header 3
49 | #### Header 4
50 | `.replace(/\n/g, eol);
51 |       const { lastFrame } = renderWithProviders(
52 |         <MarkdownDisplay {...baseProps} text={text} />,
53 |       );
54 |       expect(lastFrame()).toMatchSnapshot();
55 |     });
56 | 
57 |     it('renders a fenced code block with a language', () => {
58 |       const text = '```javascript\nconst x = 1;\nconsole.log(x);\n```'.replace(
59 |         /\n/g,
60 |         eol,
61 |       );
62 |       const { lastFrame } = renderWithProviders(
63 |         <MarkdownDisplay {...baseProps} text={text} />,
64 |       );
65 |       expect(lastFrame()).toMatchSnapshot();
66 |     });
67 | 
68 |     it('renders a fenced code block without a language', () => {
69 |       const text = '```\nplain text\n```'.replace(/\n/g, eol);
70 |       const { lastFrame } = renderWithProviders(
71 |         <MarkdownDisplay {...baseProps} text={text} />,
72 |       );
73 |       expect(lastFrame()).toMatchSnapshot();
74 |     });
75 | 
76 |     it('handles unclosed (pending) code blocks', () => {
77 |       const text = '```typescript\nlet y = 2;'.replace(/\n/g, eol);
78 |       const { lastFrame } = renderWithProviders(
79 |         <MarkdownDisplay {...baseProps} text={text} isPending={true} />,
80 |       );
81 |       expect(lastFrame()).toMatchSnapshot();
82 |     });
83 | 
84 |     it('renders unordered lists with different markers', () => {
85 |       const text = `
86 | - item A
87 | * item B
88 | + item C
89 | `.replace(/\n/g, eol);
90 |       const { lastFrame } = renderWithProviders(
91 |         <MarkdownDisplay {...baseProps} text={text} />,
92 |       );
93 |       expect(lastFrame()).toMatchSnapshot();
94 |     });
95 | 
96 |     it('renders nested unordered lists', () => {
97 |       const text = `
98 | * Level 1
99 |   * Level 2
100 |     * Level 3
101 | `.replace(/\n/g, eol);
102 |       const { lastFrame } = renderWithProviders(
103 |         <MarkdownDisplay {...baseProps} text={text} />,
104 |       );
105 |       expect(lastFrame()).toMatchSnapshot();
106 |     });
107 | 
108 |     it('renders ordered lists', () => {
109 |       const text = `
110 | 1. First item
111 | 2. Second item
112 | `.replace(/\n/g, eol);
113 |       const { lastFrame } = renderWithProviders(
114 |         <MarkdownDisplay {...baseProps} text={text} />,
115 |       );
116 |       expect(lastFrame()).toMatchSnapshot();
117 |     });
118 | 
119 |     it('renders horizontal rules', () => {
120 |       const text = `
121 | Hello
122 | ---
123 | World
124 | ***
125 | Test
126 | `.replace(/\n/g, eol);
127 |       const { lastFrame } = renderWithProviders(
128 |         <MarkdownDisplay {...baseProps} text={text} />,
129 |       );
130 |       expect(lastFrame()).toMatchSnapshot();
131 |     });
132 | 
133 |     it('renders tables correctly', () => {
134 |       const text = `
135 | | Header 1 | Header 2 |
136 | |----------|:--------:|
137 | | Cell 1   | Cell 2   |
138 | | Cell 3   | Cell 4   |
139 | `.replace(/\n/g, eol);
140 |       const { lastFrame } = renderWithProviders(
141 |         <MarkdownDisplay {...baseProps} text={text} />,
142 |       );
143 |       expect(lastFrame()).toMatchSnapshot();
144 |     });
145 | 
146 |     it('handles a table at the end of the input', () => {
147 |       const text = `
148 | Some text before.
149 | | A | B |
150 | |---|
151 | | 1 | 2 |`.replace(/\n/g, eol);
152 |       const { lastFrame } = renderWithProviders(
153 |         <MarkdownDisplay {...baseProps} text={text} />,
154 |       );
155 |       expect(lastFrame()).toMatchSnapshot();
156 |     });
157 | 
158 |     it('inserts a single space between paragraphs', () => {
159 |       const text = `Paragraph 1.
160 | 
161 | Paragraph 2.`.replace(/\n/g, eol);
162 |       const { lastFrame } = renderWithProviders(
163 |         <MarkdownDisplay {...baseProps} text={text} />,
164 |       );
165 |       expect(lastFrame()).toMatchSnapshot();
166 |     });
167 | 
168 |     it('correctly parses a mix of markdown elements', () => {
169 |       const text = `
170 | # Main Title
171 | 
172 | Here is a paragraph.
173 | 
174 | - List item 1
175 | - List item 2
176 | 
177 | \`\`\`
178 | some code
179 | \`\`\`
180 | 
181 | Another paragraph.
182 | `.replace(/\n/g, eol);
183 |       const { lastFrame } = renderWithProviders(
184 |         <MarkdownDisplay {...baseProps} text={text} />,
185 |       );
186 |       expect(lastFrame()).toMatchSnapshot();
187 |     });
188 | 
189 |     it('hides line numbers in code blocks when showLineNumbers is false', () => {
190 |       const text = '```javascript\nconst x = 1;\n```'.replace(/\n/g, eol);
191 |       const settings = new LoadedSettings(
192 |         { path: '', settings: {}, originalSettings: {} },
193 |         { path: '', settings: {}, originalSettings: {} },
194 |         {
195 |           path: '',
196 |           settings: { ui: { showLineNumbers: false } },
197 |           originalSettings: { ui: { showLineNumbers: false } },
198 |         },
199 |         { path: '', settings: {}, originalSettings: {} },
200 |         true,
201 |         new Set(),
202 |       );
203 | 
204 |       const { lastFrame } = renderWithProviders(
205 |         <MarkdownDisplay {...baseProps} text={text} />,
206 |         { settings },
207 |       );
208 |       expect(lastFrame()).toMatchSnapshot();
209 |       expect(lastFrame()).not.toContain(' 1 ');
210 |     });
211 | 
212 |     it('shows line numbers in code blocks by default', () => {
213 |       const text = '```javascript\nconst x = 1;\n```'.replace(/\n/g, eol);
214 |       const { lastFrame } = renderWithProviders(
215 |         <MarkdownDisplay {...baseProps} text={text} />,
216 |       );
217 |       expect(lastFrame()).toMatchSnapshot();
218 |       expect(lastFrame()).toContain(' 1 ');
219 |     });
220 |   });
221 | });
```

src/ui/utils/MarkdownDisplay.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import React from 'react';
8 | import { Text, Box } from 'ink';
9 | import { theme } from '../semantic-colors.js';
10 | import { colorizeCode } from './CodeColorizer.js';
11 | import { TableRenderer } from './TableRenderer.js';
12 | import { RenderInline } from './InlineMarkdownRenderer.js';
13 | import { useSettings } from '../contexts/SettingsContext.js';
14 | 
15 | interface MarkdownDisplayProps {
16 |   text: string;
17 |   isPending: boolean;
18 |   availableTerminalHeight?: number;
19 |   terminalWidth: number;
20 | }
21 | 
22 | // Constants for Markdown parsing and rendering
23 | 
24 | const EMPTY_LINE_HEIGHT = 1;
25 | const CODE_BLOCK_PREFIX_PADDING = 1;
26 | const LIST_ITEM_PREFIX_PADDING = 1;
27 | const LIST_ITEM_TEXT_FLEX_GROW = 1;
28 | 
29 | const MarkdownDisplayInternal: React.FC<MarkdownDisplayProps> = ({
30 |   text,
31 |   isPending,
32 |   availableTerminalHeight,
33 |   terminalWidth,
34 | }) => {
35 |   if (!text) return <></>;
36 | 
37 |   const lines = text.split(/\r?\n/);
38 |   const headerRegex = /^ *(#{1,4}) +(.*)/;
39 |   const codeFenceRegex = /^ *(`{3,}|~{3,}) *(\w*?) *$/;
40 |   const ulItemRegex = /^([ \t]*)([-*+]) +(.*)/;
41 |   const olItemRegex = /^([ \t]*)(\d+)\. +(.*)/;
42 |   const hrRegex = /^ *([-*_] *){3,} *$/;
43 |   const tableRowRegex = /^\s*\|(.+)\|\s*$/;
44 |   const tableSeparatorRegex = /^\s*\|?\s*(:?-+:?)\s*(\|\s*(:?-+:?)\s*)+\|?\s*$/;
45 | 
46 |   const contentBlocks: React.ReactNode[] = [];
47 |   let inCodeBlock = false;
48 |   let lastLineEmpty = true;
49 |   let codeBlockContent: string[] = [];
50 |   let codeBlockLang: string | null = null;
51 |   let codeBlockFence = '';
52 |   let inTable = false;
53 |   let tableRows: string[][] = [];
54 |   let tableHeaders: string[] = [];
55 | 
56 |   function addContentBlock(block: React.ReactNode) {
57 |     if (block) {
58 |       contentBlocks.push(block);
59 |       lastLineEmpty = false;
60 |     }
61 |   }
62 | 
63 |   lines.forEach((line, index) => {
64 |     const key = `line-${index}`;
65 | 
66 |     if (inCodeBlock) {
67 |       const fenceMatch = line.match(codeFenceRegex);
68 |       if (
69 |         fenceMatch &&
70 |         fenceMatch[1].startsWith(codeBlockFence[0]) &&
71 |         fenceMatch[1].length >= codeBlockFence.length
72 |       ) {
73 |         addContentBlock(
74 |           <RenderCodeBlock
75 |             key={key}
76 |             content={codeBlockContent}
77 |             lang={codeBlockLang}
78 |             isPending={isPending}
79 |             availableTerminalHeight={availableTerminalHeight}
80 |             terminalWidth={terminalWidth}
81 |           />,
82 |         );
83 |         inCodeBlock = false;
84 |         codeBlockContent = [];
85 |         codeBlockLang = null;
86 |         codeBlockFence = '';
87 |       } else {
88 |         codeBlockContent.push(line);
89 |       }
90 |       return;
91 |     }
92 | 
93 |     const codeFenceMatch = line.match(codeFenceRegex);
94 |     const headerMatch = line.match(headerRegex);
95 |     const ulMatch = line.match(ulItemRegex);
96 |     const olMatch = line.match(olItemRegex);
97 |     const hrMatch = line.match(hrRegex);
98 |     const tableRowMatch = line.match(tableRowRegex);
99 |     const tableSeparatorMatch = line.match(tableSeparatorRegex);
100 | 
101 |     if (codeFenceMatch) {
102 |       inCodeBlock = true;
103 |       codeBlockFence = codeFenceMatch[1];
104 |       codeBlockLang = codeFenceMatch[2] || null;
105 |     } else if (tableRowMatch && !inTable) {
106 |       // Potential table start - check if next line is separator
107 |       if (
108 |         index + 1 < lines.length &&
109 |         lines[index + 1].match(tableSeparatorRegex)
110 |       ) {
111 |         inTable = true;
112 |         tableHeaders = tableRowMatch[1].split('|').map((cell) => cell.trim());
113 |         tableRows = [];
114 |       } else {
115 |         // Not a table, treat as regular text
116 |         addContentBlock(
117 |           <Box key={key}>
118 |             <Text wrap="wrap">
119 |               <RenderInline text={line} />
120 |             </Text>
121 |           </Box>,
122 |         );
123 |       }
124 |     } else if (inTable && tableSeparatorMatch) {
125 |       // Skip separator line - already handled
126 |     } else if (inTable && tableRowMatch) {
127 |       // Add table row
128 |       const cells = tableRowMatch[1].split('|').map((cell) => cell.trim());
129 |       // Ensure row has same column count as headers
130 |       while (cells.length < tableHeaders.length) {
131 |         cells.push('');
132 |       }
133 |       if (cells.length > tableHeaders.length) {
134 |         cells.length = tableHeaders.length;
135 |       }
136 |       tableRows.push(cells);
137 |     } else if (inTable && !tableRowMatch) {
138 |       // End of table
139 |       if (tableHeaders.length > 0 && tableRows.length > 0) {
140 |         addContentBlock(
141 |           <RenderTable
142 |             key={`table-${contentBlocks.length}`}
143 |             headers={tableHeaders}
144 |             rows={tableRows}
145 |             terminalWidth={terminalWidth}
146 |           />,
147 |         );
148 |       }
149 |       inTable = false;
150 |       tableRows = [];
151 |       tableHeaders = [];
152 | 
153 |       // Process current line as normal
154 |       if (line.trim().length > 0) {
155 |         addContentBlock(
156 |           <Box key={key}>
157 |             <Text wrap="wrap">
158 |               <RenderInline text={line} />
159 |             </Text>
160 |           </Box>,
161 |         );
162 |       }
163 |     } else if (hrMatch) {
164 |       addContentBlock(
165 |         <Box key={key}>
166 |           <Text dimColor>---</Text>
167 |         </Box>,
168 |       );
169 |     } else if (headerMatch) {
170 |       const level = headerMatch[1].length;
171 |       const headerText = headerMatch[2];
172 |       let headerNode: React.ReactNode = null;
173 |       switch (level) {
174 |         case 1:
175 |           headerNode = (
176 |             <Text bold color={theme.text.link}>
177 |               <RenderInline text={headerText} />
178 |             </Text>
179 |           );
180 |           break;
181 |         case 2:
182 |           headerNode = (
183 |             <Text bold color={theme.text.link}>
184 |               <RenderInline text={headerText} />
185 |             </Text>
186 |           );
187 |           break;
188 |         case 3:
189 |           headerNode = (
190 |             <Text bold color={theme.text.primary}>
191 |               <RenderInline text={headerText} />
192 |             </Text>
193 |           );
194 |           break;
195 |         case 4:
196 |           headerNode = (
197 |             <Text italic color={theme.text.secondary}>
198 |               <RenderInline text={headerText} />
199 |             </Text>
200 |           );
201 |           break;
202 |         default:
203 |           headerNode = (
204 |             <Text color={theme.text.primary}>
205 |               <RenderInline text={headerText} />
206 |             </Text>
207 |           );
208 |           break;
209 |       }
210 |       if (headerNode) addContentBlock(<Box key={key}>{headerNode}</Box>);
211 |     } else if (ulMatch) {
212 |       const leadingWhitespace = ulMatch[1];
213 |       const marker = ulMatch[2];
214 |       const itemText = ulMatch[3];
215 |       addContentBlock(
216 |         <RenderListItem
217 |           key={key}
218 |           itemText={itemText}
219 |           type="ul"
220 |           marker={marker}
221 |           leadingWhitespace={leadingWhitespace}
222 |         />,
223 |       );
224 |     } else if (olMatch) {
225 |       const leadingWhitespace = olMatch[1];
226 |       const marker = olMatch[2];
227 |       const itemText = olMatch[3];
228 |       addContentBlock(
229 |         <RenderListItem
230 |           key={key}
231 |           itemText={itemText}
232 |           type="ol"
233 |           marker={marker}
234 |           leadingWhitespace={leadingWhitespace}
235 |         />,
236 |       );
237 |     } else {
238 |       if (line.trim().length === 0 && !inCodeBlock) {
239 |         if (!lastLineEmpty) {
240 |           contentBlocks.push(
241 |             <Box key={`spacer-${index}`} height={EMPTY_LINE_HEIGHT} />,
242 |           );
243 |           lastLineEmpty = true;
244 |         }
245 |       } else {
246 |         addContentBlock(
247 |           <Box key={key}>
248 |             <Text wrap="wrap" color={theme.text.primary}>
249 |               <RenderInline text={line} />
250 |             </Text>
251 |           </Box>,
252 |         );
253 |       }
254 |     }
255 |   });
256 | 
257 |   if (inCodeBlock) {
258 |     addContentBlock(
259 |       <RenderCodeBlock
260 |         key="line-eof"
261 |         content={codeBlockContent}
262 |         lang={codeBlockLang}
263 |         isPending={isPending}
264 |         availableTerminalHeight={availableTerminalHeight}
265 |         terminalWidth={terminalWidth}
266 |       />,
267 |     );
268 |   }
269 | 
270 |   // Handle table at end of content
271 |   if (inTable && tableHeaders.length > 0 && tableRows.length > 0) {
272 |     addContentBlock(
273 |       <RenderTable
274 |         key={`table-${contentBlocks.length}`}
275 |         headers={tableHeaders}
276 |         rows={tableRows}
277 |         terminalWidth={terminalWidth}
278 |       />,
279 |     );
280 |   }
281 | 
282 |   return <>{contentBlocks}</>;
283 | };
284 | 
285 | // Helper functions (adapted from static methods of MarkdownRenderer)
286 | 
287 | interface RenderCodeBlockProps {
288 |   content: string[];
289 |   lang: string | null;
290 |   isPending: boolean;
291 |   availableTerminalHeight?: number;
292 |   terminalWidth: number;
293 | }
294 | 
295 | const RenderCodeBlockInternal: React.FC<RenderCodeBlockProps> = ({
296 |   content,
297 |   lang,
298 |   isPending,
299 |   availableTerminalHeight,
300 |   terminalWidth,
301 | }) => {
302 |   const settings = useSettings();
303 |   const MIN_LINES_FOR_MESSAGE = 1; // Minimum lines to show before the "generating more" message
304 |   const RESERVED_LINES = 2; // Lines reserved for the message itself and potential padding
305 | 
306 |   if (isPending && availableTerminalHeight !== undefined) {
307 |     const MAX_CODE_LINES_WHEN_PENDING = Math.max(
308 |       0,
309 |       availableTerminalHeight - RESERVED_LINES,
310 |     );
311 | 
312 |     if (content.length > MAX_CODE_LINES_WHEN_PENDING) {
313 |       if (MAX_CODE_LINES_WHEN_PENDING < MIN_LINES_FOR_MESSAGE) {
314 |         // Not enough space to even show the message meaningfully
315 |         return (
316 |           <Box paddingLeft={CODE_BLOCK_PREFIX_PADDING}>
317 |             <Text color={theme.text.secondary}>
318 |               ... code is being written ...
319 |             </Text>
320 |           </Box>
321 |         );
322 |       }
323 |       const truncatedContent = content.slice(0, MAX_CODE_LINES_WHEN_PENDING);
324 |       const colorizedTruncatedCode = colorizeCode(
325 |         truncatedContent.join('\n'),
326 |         lang,
327 |         availableTerminalHeight,
328 |         terminalWidth - CODE_BLOCK_PREFIX_PADDING,
329 |         undefined,
330 |         settings,
331 |       );
332 |       return (
333 |         <Box paddingLeft={CODE_BLOCK_PREFIX_PADDING} flexDirection="column">
334 |           {colorizedTruncatedCode}
335 |           <Text color={theme.text.secondary}>... generating more ...</Text>
336 |         </Box>
337 |       );
338 |     }
339 |   }
340 | 
341 |   const fullContent = content.join('\n');
342 |   const colorizedCode = colorizeCode(
343 |     fullContent,
344 |     lang,
345 |     availableTerminalHeight,
346 |     terminalWidth - CODE_BLOCK_PREFIX_PADDING,
347 |     undefined,
348 |     settings,
349 |   );
350 | 
351 |   return (
352 |     <Box
353 |       paddingLeft={CODE_BLOCK_PREFIX_PADDING}
354 |       flexDirection="column"
355 |       width={terminalWidth}
356 |       flexShrink={0}
357 |     >
358 |       {colorizedCode}
359 |     </Box>
360 |   );
361 | };
362 | 
363 | const RenderCodeBlock = React.memo(RenderCodeBlockInternal);
364 | 
365 | interface RenderListItemProps {
366 |   itemText: string;
367 |   type: 'ul' | 'ol';
368 |   marker: string;
369 |   leadingWhitespace?: string;
370 | }
371 | 
372 | const RenderListItemInternal: React.FC<RenderListItemProps> = ({
373 |   itemText,
374 |   type,
375 |   marker,
376 |   leadingWhitespace = '',
377 | }) => {
378 |   const prefix = type === 'ol' ? `${marker}. ` : `${marker} `;
379 |   const prefixWidth = prefix.length;
380 |   const indentation = leadingWhitespace.length;
381 | 
382 |   return (
383 |     <Box
384 |       paddingLeft={indentation + LIST_ITEM_PREFIX_PADDING}
385 |       flexDirection="row"
386 |     >
387 |       <Box width={prefixWidth}>
388 |         <Text color={theme.text.primary}>{prefix}</Text>
389 |       </Box>
[TRUNCATED]
```

src/ui/utils/TableRenderer.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import React from 'react';
8 | import { Text, Box } from 'ink';
9 | import { theme } from '../semantic-colors.js';
10 | import { RenderInline, getPlainTextLength } from './InlineMarkdownRenderer.js';
11 | 
12 | interface TableRendererProps {
13 |   headers: string[];
14 |   rows: string[][];
15 |   terminalWidth: number;
16 | }
17 | 
18 | /**
19 |  * Custom table renderer for markdown tables
20 |  * We implement our own instead of using ink-table due to module compatibility issues
21 |  */
22 | export const TableRenderer: React.FC<TableRendererProps> = ({
23 |   headers,
24 |   rows,
25 |   terminalWidth,
26 | }) => {
27 |   // Calculate column widths using actual display width after markdown processing
28 |   const columnWidths = headers.map((header, index) => {
29 |     const headerWidth = getPlainTextLength(header);
30 |     const maxRowWidth = Math.max(
31 |       ...rows.map((row) => getPlainTextLength(row[index] || '')),
32 |     );
33 |     return Math.max(headerWidth, maxRowWidth) + 2; // Add padding
34 |   });
35 | 
36 |   // Ensure table fits within terminal width
37 |   const totalWidth = columnWidths.reduce((sum, width) => sum + width + 1, 1);
38 |   const scaleFactor =
39 |     totalWidth > terminalWidth ? terminalWidth / totalWidth : 1;
40 |   const adjustedWidths = columnWidths.map((width) =>
41 |     Math.floor(width * scaleFactor),
42 |   );
43 | 
44 |   // Helper function to render a cell with proper width
45 |   const renderCell = (
46 |     content: string,
47 |     width: number,
48 |     isHeader = false,
49 |   ): React.ReactNode => {
50 |     const contentWidth = Math.max(0, width - 2);
51 |     const displayWidth = getPlainTextLength(content);
52 | 
53 |     let cellContent = content;
54 |     if (displayWidth > contentWidth) {
55 |       if (contentWidth <= 3) {
56 |         // Just truncate by character count
57 |         cellContent = content.substring(
58 |           0,
59 |           Math.min(content.length, contentWidth),
60 |         );
61 |       } else {
62 |         // Truncate preserving markdown formatting using binary search
63 |         let left = 0;
64 |         let right = content.length;
65 |         let bestTruncated = content;
66 | 
67 |         // Binary search to find the optimal truncation point
68 |         while (left <= right) {
69 |           const mid = Math.floor((left + right) / 2);
70 |           const candidate = content.substring(0, mid);
71 |           const candidateWidth = getPlainTextLength(candidate);
72 | 
73 |           if (candidateWidth <= contentWidth - 3) {
74 |             bestTruncated = candidate;
75 |             left = mid + 1;
76 |           } else {
77 |             right = mid - 1;
78 |           }
79 |         }
80 | 
81 |         cellContent = bestTruncated + '...';
82 |       }
83 |     }
84 | 
85 |     // Calculate exact padding needed
86 |     const actualDisplayWidth = getPlainTextLength(cellContent);
87 |     const paddingNeeded = Math.max(0, contentWidth - actualDisplayWidth);
88 | 
89 |     return (
90 |       <Text>
91 |         {isHeader ? (
92 |           <Text bold color={theme.text.link}>
93 |             <RenderInline text={cellContent} />
94 |           </Text>
95 |         ) : (
96 |           <RenderInline text={cellContent} />
97 |         )}
98 |         {' '.repeat(paddingNeeded)}
99 |       </Text>
100 |     );
101 |   };
102 | 
103 |   // Helper function to render border
104 |   const renderBorder = (type: 'top' | 'middle' | 'bottom'): React.ReactNode => {
105 |     const chars = {
106 |       top: { left: '┌', middle: '┬', right: '┐', horizontal: '─' },
107 |       middle: { left: '├', middle: '┼', right: '┤', horizontal: '─' },
108 |       bottom: { left: '└', middle: '┴', right: '┘', horizontal: '─' },
109 |     };
110 | 
111 |     const char = chars[type];
112 |     const borderParts = adjustedWidths.map((w) => char.horizontal.repeat(w));
113 |     const border = char.left + borderParts.join(char.middle) + char.right;
114 | 
115 |     return <Text color={theme.border.default}>{border}</Text>;
116 |   };
117 | 
118 |   // Helper function to render a table row
119 |   const renderRow = (cells: string[], isHeader = false): React.ReactNode => {
120 |     const renderedCells = cells.map((cell, index) => {
121 |       const width = adjustedWidths[index] || 0;
122 |       return renderCell(cell || '', width, isHeader);
123 |     });
124 | 
125 |     return (
126 |       <Text color={theme.text.primary}>
127 |         │{' '}
128 |         {renderedCells.map((cell, index) => (
129 |           <React.Fragment key={index}>
130 |             {cell}
131 |             {index < renderedCells.length - 1 ? ' │ ' : ''}
132 |           </React.Fragment>
133 |         ))}{' '}
134 |         │
135 |       </Text>
136 |     );
137 |   };
138 | 
139 |   return (
140 |     <Box flexDirection="column" marginY={1}>
141 |       {/* Top border */}
142 |       {renderBorder('top')}
143 | 
144 |       {/* Header row */}
145 |       {renderRow(headers, true)}
146 | 
147 |       {/* Middle border */}
148 |       {renderBorder('middle')}
149 | 
150 |       {/* Data rows */}
151 |       {rows.map((row, index) => (
152 |         <React.Fragment key={index}>{renderRow(row)}</React.Fragment>
153 |       ))}
154 | 
155 |       {/* Bottom border */}
156 |       {renderBorder('bottom')}
157 |     </Box>
158 |   );
159 | };
```

src/ui/utils/clipboardUtils.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect } from 'vitest';
8 | import {
9 |   clipboardHasImage,
10 |   saveClipboardImage,
11 |   cleanupOldClipboardImages,
12 | } from './clipboardUtils.js';
13 | 
14 | describe('clipboardUtils', () => {
15 |   describe('clipboardHasImage', () => {
16 |     it('should return false on non-macOS platforms', async () => {
17 |       if (process.platform !== 'darwin') {
18 |         const result = await clipboardHasImage();
19 |         expect(result).toBe(false);
20 |       } else {
21 |         // Skip on macOS as it would require actual clipboard state
22 |         expect(true).toBe(true);
23 |       }
24 |     });
25 | 
26 |     it('should return boolean on macOS', async () => {
27 |       if (process.platform === 'darwin') {
28 |         const result = await clipboardHasImage();
29 |         expect(typeof result).toBe('boolean');
30 |       } else {
31 |         // Skip on non-macOS
32 |         expect(true).toBe(true);
33 |       }
34 |     });
35 |   });
36 | 
37 |   describe('saveClipboardImage', () => {
38 |     it('should return null on non-macOS platforms', async () => {
39 |       if (process.platform !== 'darwin') {
40 |         const result = await saveClipboardImage();
41 |         expect(result).toBe(null);
42 |       } else {
43 |         // Skip on macOS
44 |         expect(true).toBe(true);
45 |       }
46 |     });
47 | 
48 |     it('should handle errors gracefully', async () => {
49 |       // Test with invalid directory (should not throw)
50 |       const result = await saveClipboardImage(
51 |         '/invalid/path/that/does/not/exist',
52 |       );
53 | 
54 |       if (process.platform === 'darwin') {
55 |         // On macOS, might return null due to various errors
56 |         expect(result === null || typeof result === 'string').toBe(true);
57 |       } else {
58 |         // On other platforms, should always return null
59 |         expect(result).toBe(null);
60 |       }
61 |     });
62 |   });
63 | 
64 |   describe('cleanupOldClipboardImages', () => {
65 |     it('should not throw errors', async () => {
66 |       // Should handle missing directories gracefully
67 |       await expect(
68 |         cleanupOldClipboardImages('/path/that/does/not/exist'),
69 |       ).resolves.not.toThrow();
70 |     });
71 | 
72 |     it('should complete without errors on valid directory', async () => {
73 |       await expect(cleanupOldClipboardImages('.')).resolves.not.toThrow();
74 |     });
75 |   });
76 | });
```

src/ui/utils/clipboardUtils.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import * as fs from 'node:fs/promises';
8 | import * as path from 'node:path';
9 | import { spawnAsync } from '@google/gemini-cli-core';
10 | 
11 | /**
12 |  * Checks if the system clipboard contains an image (macOS only for now)
13 |  * @returns true if clipboard contains an image
14 |  */
15 | export async function clipboardHasImage(): Promise<boolean> {
16 |   if (process.platform !== 'darwin') {
17 |     return false;
18 |   }
19 | 
20 |   try {
21 |     // Use osascript to check clipboard type
22 |     const { stdout } = await spawnAsync('osascript', ['-e', 'clipboard info']);
23 |     const imageRegex =
24 |       /«class PNGf»|TIFF picture|JPEG picture|GIF picture|«class JPEG»|«class TIFF»/;
25 |     return imageRegex.test(stdout);
26 |   } catch {
27 |     return false;
28 |   }
29 | }
30 | 
31 | /**
32 |  * Saves the image from clipboard to a temporary file (macOS only for now)
33 |  * @param targetDir The target directory to create temp files within
34 |  * @returns The path to the saved image file, or null if no image or error
35 |  */
36 | export async function saveClipboardImage(
37 |   targetDir?: string,
38 | ): Promise<string | null> {
39 |   if (process.platform !== 'darwin') {
40 |     return null;
41 |   }
42 | 
43 |   try {
44 |     // Create a temporary directory for clipboard images within the target directory
45 |     // This avoids security restrictions on paths outside the target directory
46 |     const baseDir = targetDir || process.cwd();
47 |     const tempDir = path.join(baseDir, '.gemini-clipboard');
48 |     await fs.mkdir(tempDir, { recursive: true });
49 | 
50 |     // Generate a unique filename with timestamp
51 |     const timestamp = new Date().getTime();
52 | 
53 |     // Try different image formats in order of preference
54 |     const formats = [
55 |       { class: 'PNGf', extension: 'png' },
56 |       { class: 'JPEG', extension: 'jpg' },
57 |       { class: 'TIFF', extension: 'tiff' },
58 |       { class: 'GIFf', extension: 'gif' },
59 |     ];
60 | 
61 |     for (const format of formats) {
62 |       const tempFilePath = path.join(
63 |         tempDir,
64 |         `clipboard-${timestamp}.${format.extension}`,
65 |       );
66 | 
67 |       // Try to save clipboard as this format
68 |       const script = `
69 |         try
70 |           set imageData to the clipboard as «class ${format.class}»
71 |           set fileRef to open for access POSIX file "${tempFilePath}" with write permission
72 |           write imageData to fileRef
73 |           close access fileRef
74 |           return "success"
75 |         on error errMsg
76 |           try
77 |             close access POSIX file "${tempFilePath}"
78 |           end try
79 |           return "error"
80 |         end try
81 |       `;
82 | 
83 |       const { stdout } = await spawnAsync('osascript', ['-e', script]);
84 | 
85 |       if (stdout.trim() === 'success') {
86 |         // Verify the file was created and has content
87 |         try {
88 |           const stats = await fs.stat(tempFilePath);
89 |           if (stats.size > 0) {
90 |             return tempFilePath;
91 |           }
92 |         } catch {
93 |           // File doesn't exist, continue to next format
94 |         }
95 |       }
96 | 
97 |       // Clean up failed attempt
98 |       try {
99 |         await fs.unlink(tempFilePath);
100 |       } catch {
101 |         // Ignore cleanup errors
102 |       }
103 |     }
104 | 
105 |     // No format worked
106 |     return null;
107 |   } catch (error) {
108 |     console.error('Error saving clipboard image:', error);
109 |     return null;
110 |   }
111 | }
112 | 
113 | /**
114 |  * Cleans up old temporary clipboard image files
115 |  * Removes files older than 1 hour
116 |  * @param targetDir The target directory where temp files are stored
117 |  */
118 | export async function cleanupOldClipboardImages(
119 |   targetDir?: string,
120 | ): Promise<void> {
121 |   try {
122 |     const baseDir = targetDir || process.cwd();
123 |     const tempDir = path.join(baseDir, '.gemini-clipboard');
124 |     const files = await fs.readdir(tempDir);
125 |     const oneHourAgo = Date.now() - 60 * 60 * 1000;
126 | 
127 |     for (const file of files) {
128 |       if (
129 |         file.startsWith('clipboard-') &&
130 |         (file.endsWith('.png') ||
131 |           file.endsWith('.jpg') ||
132 |           file.endsWith('.tiff') ||
133 |           file.endsWith('.gif'))
134 |       ) {
135 |         const filePath = path.join(tempDir, file);
136 |         const stats = await fs.stat(filePath);
137 |         if (stats.mtimeMs < oneHourAgo) {
138 |           await fs.unlink(filePath);
139 |         }
140 |       }
141 |     }
142 |   } catch {
143 |     // Ignore errors in cleanup
144 |   }
145 | }
```

src/ui/utils/commandUtils.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type { Mock } from 'vitest';
8 | import { vi, describe, it, expect, beforeEach } from 'vitest';
9 | import type { spawn, SpawnOptions } from 'node:child_process';
10 | import { EventEmitter } from 'node:events';
11 | import {
12 |   isAtCommand,
13 |   isSlashCommand,
14 |   copyToClipboard,
15 |   getUrlOpenCommand,
16 | } from './commandUtils.js';
17 | 
18 | // Mock child_process
19 | vi.mock('child_process');
20 | 
21 | // Mock process.platform for platform-specific tests
22 | const mockProcess = vi.hoisted(() => ({
23 |   platform: 'darwin',
24 | }));
25 | 
26 | vi.stubGlobal('process', {
27 |   ...process,
28 |   get platform() {
29 |     return mockProcess.platform;
30 |   },
31 | });
32 | 
33 | interface MockChildProcess extends EventEmitter {
34 |   stdin: EventEmitter & {
35 |     write: Mock;
36 |     end: Mock;
37 |   };
38 |   stderr: EventEmitter;
39 | }
40 | 
41 | describe('commandUtils', () => {
42 |   let mockSpawn: Mock;
43 |   let mockChild: MockChildProcess;
44 | 
45 |   beforeEach(async () => {
46 |     vi.clearAllMocks();
47 |     // Dynamically import and set up spawn mock
48 |     const { spawn } = await import('node:child_process');
49 |     mockSpawn = spawn as Mock;
50 | 
51 |     // Create mock child process with stdout/stderr emitters
52 |     mockChild = Object.assign(new EventEmitter(), {
53 |       stdin: Object.assign(new EventEmitter(), {
54 |         write: vi.fn(),
55 |         end: vi.fn(),
56 |       }),
57 |       stderr: new EventEmitter(),
58 |     }) as MockChildProcess;
59 | 
60 |     mockSpawn.mockReturnValue(mockChild as unknown as ReturnType<typeof spawn>);
61 |   });
62 | 
63 |   describe('isAtCommand', () => {
64 |     it('should return true when query starts with @', () => {
65 |       expect(isAtCommand('@file')).toBe(true);
66 |       expect(isAtCommand('@path/to/file')).toBe(true);
67 |       expect(isAtCommand('@')).toBe(true);
68 |     });
69 | 
70 |     it('should return true when query contains @ preceded by whitespace', () => {
71 |       expect(isAtCommand('hello @file')).toBe(true);
72 |       expect(isAtCommand('some text @path/to/file')).toBe(true);
73 |       expect(isAtCommand('   @file')).toBe(true);
74 |     });
75 | 
76 |     it('should return false when query does not start with @ and has no spaced @', () => {
77 |       expect(isAtCommand('file')).toBe(false);
78 |       expect(isAtCommand('hello')).toBe(false);
79 |       expect(isAtCommand('')).toBe(false);
80 |       expect(isAtCommand('email@domain.com')).toBe(false);
81 |       expect(isAtCommand('user@host')).toBe(false);
82 |     });
83 | 
84 |     it('should return false when @ is not preceded by whitespace', () => {
85 |       expect(isAtCommand('hello@file')).toBe(false);
86 |       expect(isAtCommand('text@path')).toBe(false);
87 |     });
88 |   });
89 | 
90 |   describe('isSlashCommand', () => {
91 |     it('should return true when query starts with /', () => {
92 |       expect(isSlashCommand('/help')).toBe(true);
93 |       expect(isSlashCommand('/memory show')).toBe(true);
94 |       expect(isSlashCommand('/clear')).toBe(true);
95 |       expect(isSlashCommand('/')).toBe(true);
96 |     });
97 | 
98 |     it('should return false when query does not start with /', () => {
99 |       expect(isSlashCommand('help')).toBe(false);
100 |       expect(isSlashCommand('memory show')).toBe(false);
101 |       expect(isSlashCommand('')).toBe(false);
102 |       expect(isSlashCommand('path/to/file')).toBe(false);
103 |       expect(isSlashCommand(' /help')).toBe(false);
104 |     });
105 | 
106 |     it('should return false for line comments starting with //', () => {
107 |       expect(isSlashCommand('// This is a comment')).toBe(false);
108 |       expect(isSlashCommand('// check if variants base info all filled.')).toBe(
109 |         false,
110 |       );
111 |       expect(isSlashCommand('//comment without space')).toBe(false);
112 |     });
113 | 
114 |     it('should return false for block comments starting with /*', () => {
115 |       expect(isSlashCommand('/* This is a block comment */')).toBe(false);
116 |       expect(isSlashCommand('/*\n * Multi-line comment\n */')).toBe(false);
117 |       expect(isSlashCommand('/*comment without space*/')).toBe(false);
118 |     });
119 |   });
120 | 
121 |   describe('copyToClipboard', () => {
122 |     describe('on macOS (darwin)', () => {
123 |       beforeEach(() => {
124 |         mockProcess.platform = 'darwin';
125 |       });
126 | 
127 |       it('should successfully copy text to clipboard using pbcopy', async () => {
128 |         const testText = 'Hello, world!';
129 | 
130 |         // Simulate successful execution
131 |         setTimeout(() => {
132 |           mockChild.emit('close', 0);
133 |         }, 0);
134 | 
135 |         await copyToClipboard(testText);
136 | 
137 |         expect(mockSpawn).toHaveBeenCalledWith('pbcopy', []);
138 |         expect(mockChild.stdin.write).toHaveBeenCalledWith(testText);
139 |         expect(mockChild.stdin.end).toHaveBeenCalled();
140 |       });
141 | 
142 |       it('should handle pbcopy command failure', async () => {
143 |         const testText = 'Hello, world!';
144 | 
145 |         // Simulate command failure
146 |         setTimeout(() => {
147 |           mockChild.stderr.emit('data', 'Command not found');
148 |           mockChild.emit('close', 1);
149 |         }, 0);
150 | 
151 |         await expect(copyToClipboard(testText)).rejects.toThrow(
152 |           "'pbcopy' exited with code 1: Command not found",
153 |         );
154 |       });
155 | 
156 |       it('should handle spawn error', async () => {
157 |         const testText = 'Hello, world!';
158 | 
159 |         setTimeout(() => {
160 |           mockChild.emit('error', new Error('spawn error'));
161 |         }, 0);
162 | 
163 |         await expect(copyToClipboard(testText)).rejects.toThrow('spawn error');
164 |       });
165 | 
166 |       it('should handle stdin write error', async () => {
167 |         const testText = 'Hello, world!';
168 | 
169 |         setTimeout(() => {
170 |           mockChild.stdin.emit('error', new Error('stdin error'));
171 |         }, 0);
172 | 
173 |         await expect(copyToClipboard(testText)).rejects.toThrow('stdin error');
174 |       });
175 |     });
176 | 
177 |     describe('on Windows (win32)', () => {
178 |       beforeEach(() => {
179 |         mockProcess.platform = 'win32';
180 |       });
181 | 
182 |       it('should successfully copy text to clipboard using clip', async () => {
183 |         const testText = 'Hello, world!';
184 | 
185 |         setTimeout(() => {
186 |           mockChild.emit('close', 0);
187 |         }, 0);
188 | 
189 |         await copyToClipboard(testText);
190 | 
191 |         expect(mockSpawn).toHaveBeenCalledWith('clip', []);
192 |         expect(mockChild.stdin.write).toHaveBeenCalledWith(testText);
193 |         expect(mockChild.stdin.end).toHaveBeenCalled();
194 |       });
195 |     });
196 | 
197 |     describe('on Linux', () => {
198 |       beforeEach(() => {
199 |         mockProcess.platform = 'linux';
200 |       });
201 | 
202 |       it('should successfully copy text to clipboard using xclip', async () => {
203 |         const testText = 'Hello, world!';
204 |         const linuxOptions: SpawnOptions = {
205 |           stdio: ['pipe', 'inherit', 'pipe'],
206 |         };
207 | 
208 |         setTimeout(() => {
209 |           mockChild.emit('close', 0);
210 |         }, 0);
211 | 
212 |         await copyToClipboard(testText);
213 | 
214 |         expect(mockSpawn).toHaveBeenCalledWith(
215 |           'xclip',
216 |           ['-selection', 'clipboard'],
217 |           linuxOptions,
218 |         );
219 |         expect(mockChild.stdin.write).toHaveBeenCalledWith(testText);
220 |         expect(mockChild.stdin.end).toHaveBeenCalled();
221 |       });
222 | 
223 |       it('should fall back to xsel when xclip fails', async () => {
224 |         const testText = 'Hello, world!';
225 |         let callCount = 0;
226 |         const linuxOptions: SpawnOptions = {
227 |           stdio: ['pipe', 'inherit', 'pipe'],
228 |         };
229 | 
230 |         mockSpawn.mockImplementation(() => {
231 |           const child = Object.assign(new EventEmitter(), {
232 |             stdin: Object.assign(new EventEmitter(), {
233 |               write: vi.fn(),
234 |               end: vi.fn(),
235 |             }),
236 |             stderr: new EventEmitter(),
237 |           }) as MockChildProcess;
238 | 
239 |           setTimeout(() => {
240 |             if (callCount === 0) {
241 |               // First call (xclip) fails
242 |               const error = new Error('spawn xclip ENOENT');
243 |               (error as NodeJS.ErrnoException).code = 'ENOENT';
244 |               child.emit('error', error);
245 |               child.emit('close', 1);
246 |               callCount++;
247 |             } else {
248 |               // Second call (xsel) succeeds
249 |               child.emit('close', 0);
250 |             }
251 |           }, 0);
252 | 
253 |           return child as unknown as ReturnType<typeof spawn>;
254 |         });
255 | 
256 |         await copyToClipboard(testText);
257 | 
258 |         expect(mockSpawn).toHaveBeenCalledTimes(2);
259 |         expect(mockSpawn).toHaveBeenNthCalledWith(
260 |           1,
261 |           'xclip',
262 |           ['-selection', 'clipboard'],
263 |           linuxOptions,
264 |         );
265 |         expect(mockSpawn).toHaveBeenNthCalledWith(
266 |           2,
267 |           'xsel',
268 |           ['--clipboard', '--input'],
269 |           linuxOptions,
270 |         );
271 |       });
272 | 
273 |       it('should throw error when both xclip and xsel are not found', async () => {
274 |         const testText = 'Hello, world!';
275 |         let callCount = 0;
276 |         const linuxOptions: SpawnOptions = {
277 |           stdio: ['pipe', 'inherit', 'pipe'],
278 |         };
279 | 
280 |         mockSpawn.mockImplementation(() => {
281 |           const child = Object.assign(new EventEmitter(), {
282 |             stdin: Object.assign(new EventEmitter(), {
283 |               write: vi.fn(),
284 |               end: vi.fn(),
285 |             }),
286 |             stderr: new EventEmitter(),
287 |           }) as MockChildProcess;
288 | 
289 |           setTimeout(() => {
290 |             if (callCount === 0) {
291 |               // First call (xclip) fails with ENOENT
292 |               const error = new Error('spawn xclip ENOENT');
293 |               (error as NodeJS.ErrnoException).code = 'ENOENT';
294 |               child.emit('error', error);
295 |               child.emit('close', 1);
296 |               callCount++;
297 |             } else {
298 |               // Second call (xsel) fails with ENOENT
299 |               const error = new Error('spawn xsel ENOENT');
300 |               (error as NodeJS.ErrnoException).code = 'ENOENT';
301 |               child.emit('error', error);
302 |               child.emit('close', 1);
303 |             }
304 |           }, 0);
305 | 
306 |           return child as unknown as ReturnType<typeof spawn>;
307 |         });
308 |         await expect(copyToClipboard(testText)).rejects.toThrow(
309 |           'Please ensure xclip or xsel is installed and configured.',
310 |         );
311 | 
312 |         expect(mockSpawn).toHaveBeenCalledTimes(2);
313 |         expect(mockSpawn).toHaveBeenNthCalledWith(
314 |           1,
315 |           'xclip',
316 |           ['-selection', 'clipboard'],
317 |           linuxOptions,
318 |         );
319 |         expect(mockSpawn).toHaveBeenNthCalledWith(
320 |           2,
321 |           'xsel',
322 |           ['--clipboard', '--input'],
323 |           linuxOptions,
324 |         );
325 |       });
326 | 
327 |       it('should emit error when xclip or xsel fail with stderr output (command installed)', async () => {
328 |         const testText = 'Hello, world!';
329 |         let callCount = 0;
330 |         const linuxOptions: SpawnOptions = {
331 |           stdio: ['pipe', 'inherit', 'pipe'],
332 |         };
333 |         const errorMsg = "Error: Can't open display:";
334 |         const exitCode = 1;
335 | 
336 |         mockSpawn.mockImplementation(() => {
337 |           const child = Object.assign(new EventEmitter(), {
338 |             stdin: Object.assign(new EventEmitter(), {
339 |               write: vi.fn(),
340 |               end: vi.fn(),
341 |             }),
342 |             stderr: new EventEmitter(),
343 |           }) as MockChildProcess;
344 | 
345 |           setTimeout(() => {
346 |             // e.g., cannot connect to X server
347 |             if (callCount === 0) {
348 |               child.stderr.emit('data', errorMsg);
349 |               child.emit('close', exitCode);
350 |               callCount++;
351 |             } else {
352 |               child.stderr.emit('data', errorMsg);
353 |               child.emit('close', exitCode);
354 |             }
355 |           }, 0);
356 | 
357 |           return child as unknown as ReturnType<typeof spawn>;
358 |         });
359 | 
360 |         const xclipErrorMsg = `'xclip' exited with code ${exitCode}${errorMsg ? `: ${errorMsg}` : ''}`;
361 |         const xselErrorMsg = `'xsel' exited with code ${exitCode}${errorMsg ? `: ${errorMsg}` : ''}`;
362 | 
363 |         await expect(copyToClipboard(testText)).rejects.toThrow(
364 |           `All copy commands failed. "${xclipErrorMsg}", "${xselErrorMsg}". `,
365 |         );
366 | 
367 |         expect(mockSpawn).toHaveBeenCalledTimes(2);
368 |         expect(mockSpawn).toHaveBeenNthCalledWith(
369 |           1,
370 |           'xclip',
371 |           ['-selection', 'clipboard'],
372 |           linuxOptions,
373 |         );
[TRUNCATED]
```

src/ui/utils/commandUtils.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type { SpawnOptions } from 'node:child_process';
8 | import { spawn } from 'node:child_process';
9 | 
10 | /**
11 |  * Checks if a query string potentially represents an '@' command.
12 |  * It triggers if the query starts with '@' or contains '@' preceded by whitespace
13 |  * and followed by a non-whitespace character.
14 |  *
15 |  * @param query The input query string.
16 |  * @returns True if the query looks like an '@' command, false otherwise.
17 |  */
18 | export const isAtCommand = (query: string): boolean =>
19 |   // Check if starts with @ OR has a space, then @
20 |   query.startsWith('@') || /\s@/.test(query);
21 | 
22 | /**
23 |  * Checks if a query string potentially represents an '/' command.
24 |  * It triggers if the query starts with '/' but excludes code comments like '//' and '/*'.
25 |  *
26 |  * @param query The input query string.
27 |  * @returns True if the query looks like an '/' command, false otherwise.
28 |  */
29 | export const isSlashCommand = (query: string): boolean => {
30 |   if (!query.startsWith('/')) {
31 |     return false;
32 |   }
33 | 
34 |   // Exclude line comments that start with '//'
35 |   if (query.startsWith('//')) {
36 |     return false;
37 |   }
38 | 
39 |   // Exclude block comments that start with '/*'
40 |   if (query.startsWith('/*')) {
41 |     return false;
42 |   }
43 | 
44 |   return true;
45 | };
46 | 
47 | // Copies a string snippet to the clipboard for different platforms
48 | export const copyToClipboard = async (text: string): Promise<void> => {
49 |   const run = (cmd: string, args: string[], options?: SpawnOptions) =>
50 |     new Promise<void>((resolve, reject) => {
51 |       const child = options ? spawn(cmd, args, options) : spawn(cmd, args);
52 |       let stderr = '';
53 |       if (child.stderr) {
54 |         child.stderr.on('data', (chunk) => (stderr += chunk.toString()));
55 |       }
56 |       child.on('error', reject);
57 |       child.on('close', (code) => {
58 |         if (code === 0) return resolve();
59 |         const errorMsg = stderr.trim();
60 |         reject(
61 |           new Error(
62 |             `'${cmd}' exited with code ${code}${errorMsg ? `: ${errorMsg}` : ''}`,
63 |           ),
64 |         );
65 |       });
66 |       if (child.stdin) {
67 |         child.stdin.on('error', reject);
68 |         child.stdin.write(text);
69 |         child.stdin.end();
70 |       } else {
71 |         reject(new Error('Child process has no stdin stream to write to.'));
72 |       }
73 |     });
74 | 
75 |   // Configure stdio for Linux clipboard commands.
76 |   // - stdin: 'pipe' to write the text that needs to be copied.
77 |   // - stdout: 'inherit' since we don't need to capture the command's output on success.
78 |   // - stderr: 'pipe' to capture error messages (e.g., "command not found") for better error handling.
79 |   const linuxOptions: SpawnOptions = { stdio: ['pipe', 'inherit', 'pipe'] };
80 | 
81 |   switch (process.platform) {
82 |     case 'win32':
83 |       return run('clip', []);
84 |     case 'darwin':
85 |       return run('pbcopy', []);
86 |     case 'linux':
87 |       try {
88 |         await run('xclip', ['-selection', 'clipboard'], linuxOptions);
89 |       } catch (primaryError) {
90 |         try {
91 |           // If xclip fails for any reason, try xsel as a fallback.
92 |           await run('xsel', ['--clipboard', '--input'], linuxOptions);
93 |         } catch (fallbackError) {
94 |           const xclipNotFound =
95 |             primaryError instanceof Error &&
96 |             (primaryError as NodeJS.ErrnoException).code === 'ENOENT';
97 |           const xselNotFound =
98 |             fallbackError instanceof Error &&
99 |             (fallbackError as NodeJS.ErrnoException).code === 'ENOENT';
100 |           if (xclipNotFound && xselNotFound) {
101 |             throw new Error(
102 |               'Please ensure xclip or xsel is installed and configured.',
103 |             );
104 |           }
105 | 
106 |           let primaryMsg =
107 |             primaryError instanceof Error
108 |               ? primaryError.message
109 |               : String(primaryError);
110 |           if (xclipNotFound) {
111 |             primaryMsg = `xclip not found`;
112 |           }
113 |           let fallbackMsg =
114 |             fallbackError instanceof Error
115 |               ? fallbackError.message
116 |               : String(fallbackError);
117 |           if (xselNotFound) {
118 |             fallbackMsg = `xsel not found`;
119 |           }
120 | 
121 |           throw new Error(
122 |             `All copy commands failed. "${primaryMsg}", "${fallbackMsg}". `,
123 |           );
124 |         }
125 |       }
126 |       return;
127 |     default:
128 |       throw new Error(`Unsupported platform: ${process.platform}`);
129 |   }
130 | };
131 | 
132 | export const getUrlOpenCommand = (): string => {
133 |   // --- Determine the OS-specific command to open URLs ---
134 |   let openCmd: string;
135 |   switch (process.platform) {
136 |     case 'darwin':
137 |       openCmd = 'open';
138 |       break;
139 |     case 'win32':
140 |       openCmd = 'start';
141 |       break;
142 |     case 'linux':
143 |       openCmd = 'xdg-open';
144 |       break;
145 |     default:
146 |       // Default to xdg-open, which appears to be supported for the less popular operating systems.
147 |       openCmd = 'xdg-open';
148 |       console.warn(
149 |         `Unknown platform: ${process.platform}. Attempting to open URLs with: ${openCmd}.`,
150 |       );
151 |       break;
152 |   }
153 |   return openCmd;
154 | };
```

src/ui/utils/computeStats.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect } from 'vitest';
8 | import {
9 |   calculateAverageLatency,
10 |   calculateCacheHitRate,
11 |   calculateErrorRate,
12 |   computeSessionStats,
13 | } from './computeStats.js';
14 | import type {
15 |   ModelMetrics,
16 |   SessionMetrics,
17 | } from '../contexts/SessionContext.js';
18 | 
19 | describe('calculateErrorRate', () => {
20 |   it('should return 0 if totalRequests is 0', () => {
21 |     const metrics: ModelMetrics = {
22 |       api: { totalRequests: 0, totalErrors: 0, totalLatencyMs: 0 },
23 |       tokens: {
24 |         prompt: 0,
25 |         candidates: 0,
26 |         total: 0,
27 |         cached: 0,
28 |         thoughts: 0,
29 |         tool: 0,
30 |       },
31 |     };
32 |     expect(calculateErrorRate(metrics)).toBe(0);
33 |   });
34 | 
35 |   it('should calculate the error rate correctly', () => {
36 |     const metrics: ModelMetrics = {
37 |       api: { totalRequests: 10, totalErrors: 2, totalLatencyMs: 0 },
38 |       tokens: {
39 |         prompt: 0,
40 |         candidates: 0,
41 |         total: 0,
42 |         cached: 0,
43 |         thoughts: 0,
44 |         tool: 0,
45 |       },
46 |     };
47 |     expect(calculateErrorRate(metrics)).toBe(20);
48 |   });
49 | });
50 | 
51 | describe('calculateAverageLatency', () => {
52 |   it('should return 0 if totalRequests is 0', () => {
53 |     const metrics: ModelMetrics = {
54 |       api: { totalRequests: 0, totalErrors: 0, totalLatencyMs: 1000 },
55 |       tokens: {
56 |         prompt: 0,
57 |         candidates: 0,
58 |         total: 0,
59 |         cached: 0,
60 |         thoughts: 0,
61 |         tool: 0,
62 |       },
63 |     };
64 |     expect(calculateAverageLatency(metrics)).toBe(0);
65 |   });
66 | 
67 |   it('should calculate the average latency correctly', () => {
68 |     const metrics: ModelMetrics = {
69 |       api: { totalRequests: 10, totalErrors: 0, totalLatencyMs: 1500 },
70 |       tokens: {
71 |         prompt: 0,
72 |         candidates: 0,
73 |         total: 0,
74 |         cached: 0,
75 |         thoughts: 0,
76 |         tool: 0,
77 |       },
78 |     };
79 |     expect(calculateAverageLatency(metrics)).toBe(150);
80 |   });
81 | });
82 | 
83 | describe('calculateCacheHitRate', () => {
84 |   it('should return 0 if prompt tokens is 0', () => {
85 |     const metrics: ModelMetrics = {
86 |       api: { totalRequests: 0, totalErrors: 0, totalLatencyMs: 0 },
87 |       tokens: {
88 |         prompt: 0,
89 |         candidates: 0,
90 |         total: 0,
91 |         cached: 100,
92 |         thoughts: 0,
93 |         tool: 0,
94 |       },
95 |     };
96 |     expect(calculateCacheHitRate(metrics)).toBe(0);
97 |   });
98 | 
99 |   it('should calculate the cache hit rate correctly', () => {
100 |     const metrics: ModelMetrics = {
101 |       api: { totalRequests: 0, totalErrors: 0, totalLatencyMs: 0 },
102 |       tokens: {
103 |         prompt: 200,
104 |         candidates: 0,
105 |         total: 0,
106 |         cached: 50,
107 |         thoughts: 0,
108 |         tool: 0,
109 |       },
110 |     };
111 |     expect(calculateCacheHitRate(metrics)).toBe(25);
112 |   });
113 | });
114 | 
115 | describe('computeSessionStats', () => {
116 |   it('should return all zeros for initial empty metrics', () => {
117 |     const metrics: SessionMetrics = {
118 |       models: {},
119 |       tools: {
120 |         totalCalls: 0,
121 |         totalSuccess: 0,
122 |         totalFail: 0,
123 |         totalDurationMs: 0,
124 |         totalDecisions: { accept: 0, reject: 0, modify: 0 },
125 |         byName: {},
126 |       },
127 |       files: {
128 |         totalLinesAdded: 0,
129 |         totalLinesRemoved: 0,
130 |       },
131 |     };
132 | 
133 |     const result = computeSessionStats(metrics);
134 | 
135 |     expect(result).toEqual({
136 |       totalApiTime: 0,
137 |       totalToolTime: 0,
138 |       agentActiveTime: 0,
139 |       apiTimePercent: 0,
140 |       toolTimePercent: 0,
141 |       cacheEfficiency: 0,
142 |       totalDecisions: 0,
143 |       successRate: 0,
144 |       agreementRate: 0,
145 |       totalPromptTokens: 0,
146 |       totalCachedTokens: 0,
147 |       totalLinesAdded: 0,
148 |       totalLinesRemoved: 0,
149 |     });
150 |   });
151 | 
152 |   it('should correctly calculate API and tool time percentages', () => {
153 |     const metrics: SessionMetrics = {
154 |       models: {
155 |         'gemini-pro': {
156 |           api: { totalRequests: 1, totalErrors: 0, totalLatencyMs: 750 },
157 |           tokens: {
158 |             prompt: 10,
159 |             candidates: 10,
160 |             total: 20,
161 |             cached: 0,
162 |             thoughts: 0,
163 |             tool: 0,
164 |           },
165 |         },
166 |       },
167 |       tools: {
168 |         totalCalls: 1,
169 |         totalSuccess: 1,
170 |         totalFail: 0,
171 |         totalDurationMs: 250,
172 |         totalDecisions: { accept: 0, reject: 0, modify: 0 },
173 |         byName: {},
174 |       },
175 |       files: {
176 |         totalLinesAdded: 0,
177 |         totalLinesRemoved: 0,
178 |       },
179 |     };
180 | 
181 |     const result = computeSessionStats(metrics);
182 | 
183 |     expect(result.totalApiTime).toBe(750);
184 |     expect(result.totalToolTime).toBe(250);
185 |     expect(result.agentActiveTime).toBe(1000);
186 |     expect(result.apiTimePercent).toBe(75);
187 |     expect(result.toolTimePercent).toBe(25);
188 |   });
189 | 
190 |   it('should correctly calculate cache efficiency', () => {
191 |     const metrics: SessionMetrics = {
192 |       models: {
193 |         'gemini-pro': {
194 |           api: { totalRequests: 2, totalErrors: 0, totalLatencyMs: 1000 },
195 |           tokens: {
196 |             prompt: 150,
197 |             candidates: 10,
198 |             total: 160,
199 |             cached: 50,
200 |             thoughts: 0,
201 |             tool: 0,
202 |           },
203 |         },
204 |       },
205 |       tools: {
206 |         totalCalls: 0,
207 |         totalSuccess: 0,
208 |         totalFail: 0,
209 |         totalDurationMs: 0,
210 |         totalDecisions: { accept: 0, reject: 0, modify: 0 },
211 |         byName: {},
212 |       },
213 |       files: {
214 |         totalLinesAdded: 0,
215 |         totalLinesRemoved: 0,
216 |       },
217 |     };
218 | 
219 |     const result = computeSessionStats(metrics);
220 | 
221 |     expect(result.cacheEfficiency).toBeCloseTo(33.33); // 50 / 150
222 |   });
223 | 
224 |   it('should correctly calculate success and agreement rates', () => {
225 |     const metrics: SessionMetrics = {
226 |       models: {},
227 |       tools: {
228 |         totalCalls: 10,
229 |         totalSuccess: 8,
230 |         totalFail: 2,
231 |         totalDurationMs: 1000,
232 |         totalDecisions: { accept: 6, reject: 2, modify: 2 },
233 |         byName: {},
234 |       },
235 |       files: {
236 |         totalLinesAdded: 0,
237 |         totalLinesRemoved: 0,
238 |       },
239 |     };
240 | 
241 |     const result = computeSessionStats(metrics);
242 | 
243 |     expect(result.successRate).toBe(80); // 8 / 10
244 |     expect(result.agreementRate).toBe(60); // 6 / 10
245 |   });
246 | 
247 |   it('should handle division by zero gracefully', () => {
248 |     const metrics: SessionMetrics = {
249 |       models: {},
250 |       tools: {
251 |         totalCalls: 0,
252 |         totalSuccess: 0,
253 |         totalFail: 0,
254 |         totalDurationMs: 0,
255 |         totalDecisions: { accept: 0, reject: 0, modify: 0 },
256 |         byName: {},
257 |       },
258 |       files: {
259 |         totalLinesAdded: 0,
260 |         totalLinesRemoved: 0,
261 |       },
262 |     };
263 | 
264 |     const result = computeSessionStats(metrics);
265 | 
266 |     expect(result.apiTimePercent).toBe(0);
267 |     expect(result.toolTimePercent).toBe(0);
268 |     expect(result.cacheEfficiency).toBe(0);
269 |     expect(result.successRate).toBe(0);
270 |     expect(result.agreementRate).toBe(0);
271 |   });
272 | 
273 |   it('should correctly include line counts', () => {
274 |     const metrics: SessionMetrics = {
275 |       models: {},
276 |       tools: {
277 |         totalCalls: 0,
278 |         totalSuccess: 0,
279 |         totalFail: 0,
280 |         totalDurationMs: 0,
281 |         totalDecisions: { accept: 0, reject: 0, modify: 0 },
282 |         byName: {},
283 |       },
284 |       files: {
285 |         totalLinesAdded: 42,
286 |         totalLinesRemoved: 18,
287 |       },
288 |     };
289 | 
290 |     const result = computeSessionStats(metrics);
291 | 
292 |     expect(result.totalLinesAdded).toBe(42);
293 |     expect(result.totalLinesRemoved).toBe(18);
294 |   });
295 | });
```

src/ui/utils/computeStats.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type {
8 |   SessionMetrics,
9 |   ComputedSessionStats,
10 |   ModelMetrics,
11 | } from '../contexts/SessionContext.js';
12 | 
13 | export function calculateErrorRate(metrics: ModelMetrics): number {
14 |   if (metrics.api.totalRequests === 0) {
15 |     return 0;
16 |   }
17 |   return (metrics.api.totalErrors / metrics.api.totalRequests) * 100;
18 | }
19 | 
20 | export function calculateAverageLatency(metrics: ModelMetrics): number {
21 |   if (metrics.api.totalRequests === 0) {
22 |     return 0;
23 |   }
24 |   return metrics.api.totalLatencyMs / metrics.api.totalRequests;
25 | }
26 | 
27 | export function calculateCacheHitRate(metrics: ModelMetrics): number {
28 |   if (metrics.tokens.prompt === 0) {
29 |     return 0;
30 |   }
31 |   return (metrics.tokens.cached / metrics.tokens.prompt) * 100;
32 | }
33 | 
34 | export const computeSessionStats = (
35 |   metrics: SessionMetrics,
36 | ): ComputedSessionStats => {
37 |   const { models, tools, files } = metrics;
38 |   const totalApiTime = Object.values(models).reduce(
39 |     (acc, model) => acc + model.api.totalLatencyMs,
40 |     0,
41 |   );
42 |   const totalToolTime = tools.totalDurationMs;
43 |   const agentActiveTime = totalApiTime + totalToolTime;
44 |   const apiTimePercent =
45 |     agentActiveTime > 0 ? (totalApiTime / agentActiveTime) * 100 : 0;
46 |   const toolTimePercent =
47 |     agentActiveTime > 0 ? (totalToolTime / agentActiveTime) * 100 : 0;
48 | 
49 |   const totalCachedTokens = Object.values(models).reduce(
50 |     (acc, model) => acc + model.tokens.cached,
51 |     0,
52 |   );
53 |   const totalPromptTokens = Object.values(models).reduce(
54 |     (acc, model) => acc + model.tokens.prompt,
55 |     0,
56 |   );
57 |   const cacheEfficiency =
58 |     totalPromptTokens > 0 ? (totalCachedTokens / totalPromptTokens) * 100 : 0;
59 | 
60 |   const totalDecisions =
61 |     tools.totalDecisions.accept +
62 |     tools.totalDecisions.reject +
63 |     tools.totalDecisions.modify;
64 |   const successRate =
65 |     tools.totalCalls > 0 ? (tools.totalSuccess / tools.totalCalls) * 100 : 0;
66 |   const agreementRate =
67 |     totalDecisions > 0
68 |       ? (tools.totalDecisions.accept / totalDecisions) * 100
69 |       : 0;
70 | 
71 |   return {
72 |     totalApiTime,
73 |     totalToolTime,
74 |     agentActiveTime,
75 |     apiTimePercent,
76 |     toolTimePercent,
77 |     cacheEfficiency,
78 |     totalDecisions,
79 |     successRate,
80 |     agreementRate,
81 |     totalCachedTokens,
82 |     totalPromptTokens,
83 |     totalLinesAdded: files.totalLinesAdded,
84 |     totalLinesRemoved: files.totalLinesRemoved,
85 |   };
86 | };
```

src/ui/utils/displayUtils.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect } from 'vitest';
8 | import {
9 |   getStatusColor,
10 |   TOOL_SUCCESS_RATE_HIGH,
11 |   TOOL_SUCCESS_RATE_MEDIUM,
12 |   USER_AGREEMENT_RATE_HIGH,
13 |   USER_AGREEMENT_RATE_MEDIUM,
14 |   CACHE_EFFICIENCY_HIGH,
15 |   CACHE_EFFICIENCY_MEDIUM,
16 | } from './displayUtils.js';
17 | import { Colors } from '../colors.js';
18 | 
19 | describe('displayUtils', () => {
20 |   describe('getStatusColor', () => {
21 |     describe('with red threshold', () => {
22 |       const thresholds = {
23 |         green: 80,
24 |         yellow: 50,
25 |         red: 20,
26 |       };
27 | 
28 |       it('should return green for values >= green threshold', () => {
29 |         expect(getStatusColor(90, thresholds)).toBe(Colors.AccentGreen);
30 |         expect(getStatusColor(80, thresholds)).toBe(Colors.AccentGreen);
31 |       });
32 | 
33 |       it('should return yellow for values < green and >= yellow threshold', () => {
34 |         expect(getStatusColor(79, thresholds)).toBe(Colors.AccentYellow);
35 |         expect(getStatusColor(50, thresholds)).toBe(Colors.AccentYellow);
36 |       });
37 | 
38 |       it('should return red for values < yellow and >= red threshold', () => {
39 |         expect(getStatusColor(49, thresholds)).toBe(Colors.AccentRed);
40 |         expect(getStatusColor(20, thresholds)).toBe(Colors.AccentRed);
41 |       });
42 | 
43 |       it('should return error for values < red threshold', () => {
44 |         expect(getStatusColor(19, thresholds)).toBe(Colors.AccentRed);
45 |         expect(getStatusColor(0, thresholds)).toBe(Colors.AccentRed);
46 |       });
47 | 
48 |       it('should return defaultColor for values < red threshold when provided', () => {
49 |         expect(
50 |           getStatusColor(19, thresholds, { defaultColor: Colors.Foreground }),
51 |         ).toBe(Colors.Foreground);
52 |       });
53 |     });
54 | 
55 |     describe('when red threshold is not provided', () => {
56 |       const thresholds = {
57 |         green: 80,
58 |         yellow: 50,
59 |       };
60 | 
61 |       it('should return error color for values < yellow threshold', () => {
62 |         expect(getStatusColor(49, thresholds)).toBe(Colors.AccentRed);
63 |       });
64 | 
65 |       it('should return defaultColor for values < yellow threshold when provided', () => {
66 |         expect(
67 |           getStatusColor(49, thresholds, { defaultColor: Colors.Foreground }),
68 |         ).toBe(Colors.Foreground);
69 |       });
70 |     });
71 |   });
72 | 
73 |   describe('Threshold Constants', () => {
74 |     it('should have the correct values', () => {
75 |       expect(TOOL_SUCCESS_RATE_HIGH).toBe(95);
76 |       expect(TOOL_SUCCESS_RATE_MEDIUM).toBe(85);
77 |       expect(USER_AGREEMENT_RATE_HIGH).toBe(75);
78 |       expect(USER_AGREEMENT_RATE_MEDIUM).toBe(45);
79 |       expect(CACHE_EFFICIENCY_HIGH).toBe(40);
80 |       expect(CACHE_EFFICIENCY_MEDIUM).toBe(15);
81 |     });
82 |   });
83 | });
```

src/ui/utils/displayUtils.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { theme } from '../semantic-colors.js';
8 | 
9 | // --- Thresholds ---
10 | export const TOOL_SUCCESS_RATE_HIGH = 95;
11 | export const TOOL_SUCCESS_RATE_MEDIUM = 85;
12 | 
13 | export const USER_AGREEMENT_RATE_HIGH = 75;
14 | export const USER_AGREEMENT_RATE_MEDIUM = 45;
15 | 
16 | export const CACHE_EFFICIENCY_HIGH = 40;
17 | export const CACHE_EFFICIENCY_MEDIUM = 15;
18 | 
19 | // --- Color Logic ---
20 | export const getStatusColor = (
21 |   value: number,
22 |   thresholds: { green: number; yellow: number; red?: number },
23 |   options: { defaultColor?: string } = {},
24 | ) => {
25 |   if (value >= thresholds.green) {
26 |     return theme.status.success;
27 |   }
28 |   if (value >= thresholds.yellow) {
29 |     return theme.status.warning;
30 |   }
31 |   if (thresholds.red != null && value >= thresholds.red) {
32 |     return theme.status.error;
33 |   }
34 |   return options.defaultColor ?? theme.status.error;
35 | };
```

src/ui/utils/formatters.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect } from 'vitest';
8 | import { formatDuration, formatMemoryUsage } from './formatters.js';
9 | 
10 | describe('formatters', () => {
11 |   describe('formatMemoryUsage', () => {
12 |     it('should format bytes into KB', () => {
13 |       expect(formatMemoryUsage(12345)).toBe('12.1 KB');
14 |     });
15 | 
16 |     it('should format bytes into MB', () => {
17 |       expect(formatMemoryUsage(12345678)).toBe('11.8 MB');
18 |     });
19 | 
20 |     it('should format bytes into GB', () => {
21 |       expect(formatMemoryUsage(12345678901)).toBe('11.50 GB');
22 |     });
23 |   });
24 | 
25 |   describe('formatDuration', () => {
26 |     it('should format milliseconds less than a second', () => {
27 |       expect(formatDuration(500)).toBe('500ms');
28 |     });
29 | 
30 |     it('should format a duration of 0', () => {
31 |       expect(formatDuration(0)).toBe('0s');
32 |     });
33 | 
34 |     it('should format an exact number of seconds', () => {
35 |       expect(formatDuration(5000)).toBe('5.0s');
36 |     });
37 | 
38 |     it('should format a duration in seconds with one decimal place', () => {
39 |       expect(formatDuration(12345)).toBe('12.3s');
40 |     });
41 | 
42 |     it('should format an exact number of minutes', () => {
43 |       expect(formatDuration(120000)).toBe('2m');
44 |     });
45 | 
46 |     it('should format a duration in minutes and seconds', () => {
47 |       expect(formatDuration(123000)).toBe('2m 3s');
48 |     });
49 | 
50 |     it('should format an exact number of hours', () => {
51 |       expect(formatDuration(3600000)).toBe('1h');
52 |     });
53 | 
54 |     it('should format a duration in hours and seconds', () => {
55 |       expect(formatDuration(3605000)).toBe('1h 5s');
56 |     });
57 | 
58 |     it('should format a duration in hours, minutes, and seconds', () => {
59 |       expect(formatDuration(3723000)).toBe('1h 2m 3s');
60 |     });
61 | 
62 |     it('should handle large durations', () => {
63 |       expect(formatDuration(86400000 + 3600000 + 120000 + 1000)).toBe(
64 |         '25h 2m 1s',
65 |       );
66 |     });
67 | 
68 |     it('should handle negative durations', () => {
69 |       expect(formatDuration(-100)).toBe('0s');
70 |     });
71 |   });
72 | });
```

src/ui/utils/formatters.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | export const formatMemoryUsage = (bytes: number): string => {
8 |   const gb = bytes / (1024 * 1024 * 1024);
9 |   if (bytes < 1024 * 1024) {
10 |     return `${(bytes / 1024).toFixed(1)} KB`;
11 |   }
12 |   if (bytes < 1024 * 1024 * 1024) {
13 |     return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
14 |   }
15 |   return `${gb.toFixed(2)} GB`;
16 | };
17 | 
18 | /**
19 |  * Formats a duration in milliseconds into a concise, human-readable string (e.g., "1h 5s").
20 |  * It omits any time units that are zero.
21 |  * @param milliseconds The duration in milliseconds.
22 |  * @returns A formatted string representing the duration.
23 |  */
24 | export const formatDuration = (milliseconds: number): string => {
25 |   if (milliseconds <= 0) {
26 |     return '0s';
27 |   }
28 | 
29 |   if (milliseconds < 1000) {
30 |     return `${Math.round(milliseconds)}ms`;
31 |   }
32 | 
33 |   const totalSeconds = milliseconds / 1000;
34 | 
35 |   if (totalSeconds < 60) {
36 |     return `${totalSeconds.toFixed(1)}s`;
37 |   }
38 | 
39 |   const hours = Math.floor(totalSeconds / 3600);
40 |   const minutes = Math.floor((totalSeconds % 3600) / 60);
41 |   const seconds = Math.floor(totalSeconds % 60);
42 | 
43 |   const parts: string[] = [];
44 | 
45 |   if (hours > 0) {
46 |     parts.push(`${hours}h`);
47 |   }
48 |   if (minutes > 0) {
49 |     parts.push(`${minutes}m`);
50 |   }
51 |   if (seconds > 0) {
52 |     parts.push(`${seconds}s`);
53 |   }
54 | 
55 |   // If all parts are zero (e.g., exactly 1 hour), return the largest unit.
56 |   if (parts.length === 0) {
57 |     if (hours > 0) return `${hours}h`;
58 |     if (minutes > 0) return `${minutes}m`;
59 |     return `${seconds}s`;
60 |   }
61 | 
62 |   return parts.join(' ');
63 | };
```

src/ui/utils/highlight.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect } from 'vitest';
8 | import { parseInputForHighlighting } from './highlight.js';
9 | 
10 | describe('parseInputForHighlighting', () => {
11 |   it('should handle an empty string', () => {
12 |     expect(parseInputForHighlighting('', 0)).toEqual([
13 |       { text: '', type: 'default' },
14 |     ]);
15 |   });
16 | 
17 |   it('should handle text with no commands or files', () => {
18 |     const text = 'this is a normal sentence';
19 |     expect(parseInputForHighlighting(text, 0)).toEqual([
20 |       { text, type: 'default' },
21 |     ]);
22 |   });
23 | 
24 |   it('should highlight a single command at the beginning when index is 0', () => {
25 |     const text = '/help me';
26 |     expect(parseInputForHighlighting(text, 0)).toEqual([
27 |       { text: '/help', type: 'command' },
28 |       { text: ' me', type: 'default' },
29 |     ]);
30 |   });
31 | 
32 |   it('should NOT highlight a command at the beginning when index is not 0', () => {
33 |     const text = '/help me';
34 |     expect(parseInputForHighlighting(text, 1)).toEqual([
35 |       { text: '/help', type: 'default' },
36 |       { text: ' me', type: 'default' },
37 |     ]);
38 |   });
39 | 
40 |   it('should highlight a single file path at the beginning', () => {
41 |     const text = '@path/to/file.txt please';
42 |     expect(parseInputForHighlighting(text, 0)).toEqual([
43 |       { text: '@path/to/file.txt', type: 'file' },
44 |       { text: ' please', type: 'default' },
45 |     ]);
46 |   });
47 | 
48 |   it('should not highlight a command in the middle', () => {
49 |     const text = 'I need /help with this';
50 |     expect(parseInputForHighlighting(text, 0)).toEqual([
51 |       { text: 'I need /help with this', type: 'default' },
52 |     ]);
53 |   });
54 | 
55 |   it('should highlight a file path in the middle', () => {
56 |     const text = 'Please check @path/to/file.txt for details';
57 |     expect(parseInputForHighlighting(text, 0)).toEqual([
58 |       { text: 'Please check ', type: 'default' },
59 |       { text: '@path/to/file.txt', type: 'file' },
60 |       { text: ' for details', type: 'default' },
61 |     ]);
62 |   });
63 | 
64 |   it('should highlight files but not commands not at the start', () => {
65 |     const text = 'Use /run with @file.js and also /format @another/file.ts';
66 |     expect(parseInputForHighlighting(text, 0)).toEqual([
67 |       { text: 'Use /run with ', type: 'default' },
68 |       { text: '@file.js', type: 'file' },
69 |       { text: ' and also /format ', type: 'default' },
70 |       { text: '@another/file.ts', type: 'file' },
71 |     ]);
72 |   });
73 | 
74 |   it('should handle adjacent highlights at start', () => {
75 |     const text = '/run@file.js';
76 |     expect(parseInputForHighlighting(text, 0)).toEqual([
77 |       { text: '/run', type: 'command' },
78 |       { text: '@file.js', type: 'file' },
79 |     ]);
80 |   });
81 | 
82 |   it('should not highlight command at the end of the string', () => {
83 |     const text = 'Get help with /help';
84 |     expect(parseInputForHighlighting(text, 0)).toEqual([
85 |       { text: 'Get help with /help', type: 'default' },
86 |     ]);
87 |   });
88 | 
89 |   it('should handle file paths with dots and dashes', () => {
90 |     const text = 'Check @./path-to/file-name.v2.txt';
91 |     expect(parseInputForHighlighting(text, 0)).toEqual([
92 |       { text: 'Check ', type: 'default' },
93 |       { text: '@./path-to/file-name.v2.txt', type: 'file' },
94 |     ]);
95 |   });
96 | 
97 |   it('should not highlight command with dashes and numbers not at start', () => {
98 |     const text = 'Run /command-123 now';
99 |     expect(parseInputForHighlighting(text, 0)).toEqual([
100 |       { text: 'Run /command-123 now', type: 'default' },
101 |     ]);
102 |   });
103 | 
104 |   it('should highlight command with dashes and numbers at start', () => {
105 |     const text = '/command-123 now';
106 |     expect(parseInputForHighlighting(text, 0)).toEqual([
107 |       { text: '/command-123', type: 'command' },
108 |       { text: ' now', type: 'default' },
109 |     ]);
110 |   });
111 | 
112 |   it('should still highlight a file path on a non-zero line', () => {
113 |     const text = 'some text @path/to/file.txt';
114 |     expect(parseInputForHighlighting(text, 1)).toEqual([
115 |       { text: 'some text ', type: 'default' },
116 |       { text: '@path/to/file.txt', type: 'file' },
117 |     ]);
118 |   });
119 | 
120 |   it('should not highlight command but highlight file on a non-zero line', () => {
121 |     const text = '/cmd @file.txt';
122 |     expect(parseInputForHighlighting(text, 2)).toEqual([
123 |       { text: '/cmd', type: 'default' },
124 |       { text: ' ', type: 'default' },
125 |       { text: '@file.txt', type: 'file' },
126 |     ]);
127 |   });
128 | 
129 |   it('should highlight a file path with escaped spaces', () => {
130 |     const text = 'cat @/my\\ path/file.txt';
131 |     expect(parseInputForHighlighting(text, 0)).toEqual([
132 |       { text: 'cat ', type: 'default' },
133 |       { text: '@/my\\ path/file.txt', type: 'file' },
134 |     ]);
135 |   });
136 | });
```

src/ui/utils/highlight.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { cpLen, cpSlice } from './textUtils.js';
8 | 
9 | export type HighlightToken = {
10 |   text: string;
11 |   type: 'default' | 'command' | 'file';
12 | };
13 | 
14 | const HIGHLIGHT_REGEX = /(^\/[a-zA-Z0-9_-]+|@(?:\\ |[a-zA-Z0-9_./-])+)/g;
15 | 
16 | export function parseInputForHighlighting(
17 |   text: string,
18 |   index: number,
19 | ): readonly HighlightToken[] {
20 |   if (!text) {
21 |     return [{ text: '', type: 'default' }];
22 |   }
23 | 
24 |   const tokens: HighlightToken[] = [];
25 |   let lastIndex = 0;
26 |   let match;
27 | 
28 |   while ((match = HIGHLIGHT_REGEX.exec(text)) !== null) {
29 |     const [fullMatch] = match;
30 |     const matchIndex = match.index;
31 | 
32 |     // Add the text before the match as a default token
33 |     if (matchIndex > lastIndex) {
34 |       tokens.push({
35 |         text: text.slice(lastIndex, matchIndex),
36 |         type: 'default',
37 |       });
38 |     }
39 | 
40 |     // Add the matched token
41 |     const type = fullMatch.startsWith('/') ? 'command' : 'file';
42 |     // Only highlight slash commands if the index is 0.
43 |     if (type === 'command' && index !== 0) {
44 |       tokens.push({
45 |         text: fullMatch,
46 |         type: 'default',
47 |       });
48 |     } else {
49 |       tokens.push({
50 |         text: fullMatch,
51 |         type,
52 |       });
53 |     }
54 | 
55 |     lastIndex = matchIndex + fullMatch.length;
56 |   }
57 | 
58 |   // Add any remaining text after the last match
59 |   if (lastIndex < text.length) {
60 |     tokens.push({
61 |       text: text.slice(lastIndex),
62 |       type: 'default',
63 |     });
64 |   }
65 | 
66 |   return tokens;
67 | }
68 | 
69 | export function buildSegmentsForVisualSlice(
70 |   tokens: readonly HighlightToken[],
71 |   sliceStart: number,
72 |   sliceEnd: number,
73 | ): readonly HighlightToken[] {
74 |   if (sliceStart >= sliceEnd) return [];
75 | 
76 |   const segments: HighlightToken[] = [];
77 |   let tokenCpStart = 0;
78 | 
79 |   for (const token of tokens) {
80 |     const tokenLen = cpLen(token.text);
81 |     const tokenStart = tokenCpStart;
82 |     const tokenEnd = tokenStart + tokenLen;
83 | 
84 |     const overlapStart = Math.max(tokenStart, sliceStart);
85 |     const overlapEnd = Math.min(tokenEnd, sliceEnd);
86 |     if (overlapStart < overlapEnd) {
87 |       const sliceStartInToken = overlapStart - tokenStart;
88 |       const sliceEndInToken = overlapEnd - tokenStart;
89 |       const rawSlice = cpSlice(token.text, sliceStartInToken, sliceEndInToken);
90 | 
91 |       const last = segments[segments.length - 1];
92 |       if (last && last.type === token.type) {
93 |         last.text += rawSlice;
94 |       } else {
95 |         segments.push({ type: token.type, text: rawSlice });
96 |       }
97 |     }
98 | 
99 |     tokenCpStart += tokenLen;
100 |   }
101 | 
102 |   return segments;
103 | }
```

src/ui/utils/isNarrowWidth.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | export function isNarrowWidth(width: number): boolean {
8 |   return width < 80;
9 | }
```

src/ui/utils/kittyProtocolDetector.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | let detectionComplete = false;
8 | let protocolSupported = false;
9 | let protocolEnabled = false;
10 | 
11 | /**
12 |  * Detects Kitty keyboard protocol support.
13 |  * Definitive document about this protocol lives at https://sw.kovidgoyal.net/kitty/keyboard-protocol/
14 |  * This function should be called once at app startup.
15 |  */
16 | export async function detectAndEnableKittyProtocol(): Promise<boolean> {
17 |   if (detectionComplete) {
18 |     return protocolSupported;
19 |   }
20 | 
21 |   return new Promise((resolve) => {
22 |     if (!process.stdin.isTTY || !process.stdout.isTTY) {
23 |       detectionComplete = true;
24 |       resolve(false);
25 |       return;
26 |     }
27 | 
28 |     const originalRawMode = process.stdin.isRaw;
29 |     if (!originalRawMode) {
30 |       process.stdin.setRawMode(true);
31 |     }
32 | 
33 |     let responseBuffer = '';
34 |     let progressiveEnhancementReceived = false;
35 |     let timeoutId: NodeJS.Timeout | undefined;
36 | 
37 |     const onTimeout = () => {
38 |       timeoutId = undefined;
39 |       process.stdin.removeListener('data', handleData);
40 |       if (!originalRawMode) {
41 |         process.stdin.setRawMode(false);
42 |       }
43 |       detectionComplete = true;
44 |       resolve(false);
45 |     };
46 | 
47 |     const handleData = (data: Buffer) => {
48 |       if (timeoutId === undefined) {
49 |         // Race condition. We have already timed out.
50 |         return;
51 |       }
52 |       responseBuffer += data.toString();
53 | 
54 |       // Check for progressive enhancement response (CSI ? <flags> u)
55 |       if (responseBuffer.includes('\x1b[?') && responseBuffer.includes('u')) {
56 |         progressiveEnhancementReceived = true;
57 |         // Give more time to get the full set of kitty responses if we have an
58 |         // indication the terminal probably supports kitty and we just need to
59 |         // wait a bit longer for a response.
60 |         clearTimeout(timeoutId);
61 |         timeoutId = setTimeout(onTimeout, 1000);
62 |       }
63 | 
64 |       // Check for device attributes response (CSI ? <attrs> c)
65 |       if (responseBuffer.includes('\x1b[?') && responseBuffer.includes('c')) {
66 |         clearTimeout(timeoutId);
67 |         timeoutId = undefined;
68 |         process.stdin.removeListener('data', handleData);
69 | 
70 |         if (!originalRawMode) {
71 |           process.stdin.setRawMode(false);
72 |         }
73 | 
74 |         if (progressiveEnhancementReceived) {
75 |           // Enable the protocol
76 |           process.stdout.write('\x1b[>1u');
77 |           protocolSupported = true;
78 |           protocolEnabled = true;
79 | 
80 |           // Set up cleanup on exit
81 |           process.on('exit', disableProtocol);
82 |           process.on('SIGTERM', disableProtocol);
83 |         }
84 | 
85 |         detectionComplete = true;
86 |         resolve(protocolSupported);
87 |       }
88 |     };
89 | 
90 |     process.stdin.on('data', handleData);
91 | 
92 |     // Send queries
93 |     process.stdout.write('\x1b[?u'); // Query progressive enhancement
94 |     process.stdout.write('\x1b[c'); // Query device attributes
95 | 
96 |     // Timeout after 200ms
97 |     // When a iterm2 terminal does not have focus this can take over 90s on a
98 |     // fast macbook so we need a somewhat longer threshold than would be ideal.
99 |     timeoutId = setTimeout(onTimeout, 200);
100 |   });
101 | }
102 | 
103 | function disableProtocol() {
104 |   if (protocolEnabled) {
105 |     process.stdout.write('\x1b[<u');
106 |     protocolEnabled = false;
107 |   }
108 | }
109 | 
110 | export function isKittyProtocolEnabled(): boolean {
111 |   return protocolEnabled;
112 | }
113 | 
114 | export function isKittyProtocolSupported(): boolean {
115 |   return protocolSupported;
116 | }
```

src/ui/utils/markdownUtilities.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect } from 'vitest';
8 | import { findLastSafeSplitPoint } from './markdownUtilities.js';
9 | 
10 | describe('markdownUtilities', () => {
11 |   describe('findLastSafeSplitPoint', () => {
12 |     it('should split at the last double newline if not in a code block', () => {
13 |       const content = 'paragraph1\n\nparagraph2\n\nparagraph3';
14 |       expect(findLastSafeSplitPoint(content)).toBe(24); // After the second \n\n
15 |     });
16 | 
17 |     it('should return content.length if no safe split point is found', () => {
18 |       const content = 'longstringwithoutanysafesplitpoint';
19 |       expect(findLastSafeSplitPoint(content)).toBe(content.length);
20 |     });
21 | 
22 |     it('should prioritize splitting at \n\n over being at the very end of the string if the end is not in a code block', () => {
23 |       const content = 'Some text here.\n\nAnd more text here.';
24 |       expect(findLastSafeSplitPoint(content)).toBe(17); // after the \n\n
25 |     });
26 | 
27 |     it('should return content.length if the only \n\n is inside a code block and the end of content is not', () => {
28 |       const content = '```\nignore this\n\nnewline\n```KeepThis';
29 |       expect(findLastSafeSplitPoint(content)).toBe(content.length);
30 |     });
31 | 
32 |     it('should correctly identify the last \n\n even if it is followed by text not in a code block', () => {
33 |       const content =
34 |         'First part.\n\nSecond part.\n\nThird part, then some more text.';
35 |       // Split should be after "Second part.\n\n"
36 |       // "First part.\n\n" is 13 chars. "Second part.\n\n" is 14 chars. Total 27.
37 |       expect(findLastSafeSplitPoint(content)).toBe(27);
38 |     });
39 | 
40 |     it('should return content.length if content is empty', () => {
41 |       const content = '';
42 |       expect(findLastSafeSplitPoint(content)).toBe(0);
43 |     });
44 | 
45 |     it('should return content.length if content has no newlines and no code blocks', () => {
46 |       const content = 'Single line of text';
47 |       expect(findLastSafeSplitPoint(content)).toBe(content.length);
48 |     });
49 |   });
50 | });
```

src/ui/utils/markdownUtilities.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | /*
8 | **Background & Purpose:**
9 | 
10 | The `findSafeSplitPoint` function is designed to address the challenge of displaying or processing large, potentially streaming, pieces of Markdown text. When content (e.g., from an LLM like Gemini) arrives in chunks or grows too large for a single display unit (like a message bubble), it needs to be split. A naive split (e.g., just at a character limit) can break Markdown formatting, especially critical for multi-line elements like code blocks, lists, or blockquotes, leading to incorrect rendering.
11 | 
12 | This function aims to find an *intelligent* or "safe" index within the provided `content` string at which to make such a split, prioritizing the preservation of Markdown integrity.
13 | 
14 | **Key Expectations & Behavior (Prioritized):**
15 | 
16 | 1.  **No Split if Short Enough:**
17 |     * If `content.length` is less than or equal to `idealMaxLength`, the function should return `content.length` (indicating no split is necessary for length reasons).
18 | 
19 | 2.  **Code Block Integrity (Highest Priority for Safety):**
20 |     * The function must try to avoid splitting *inside* a fenced code block (i.e., between ` ``` ` and ` ``` `).
21 |     * If `idealMaxLength` falls within a code block:
22 |         * The function will attempt to return an index that splits the content *before* the start of that code block.
23 |         * If a code block starts at the very beginning of the `content` and `idealMaxLength` falls within it (meaning the block itself is too long for the first chunk), the function might return `0`. This effectively makes the first chunk empty, pushing the entire oversized code block to the second part of the split.
24 |     * When considering splits near code blocks, the function prefers to keep the entire code block intact in one of the resulting chunks.
25 | 
26 | 3.  **Markdown-Aware Newline Splitting (If Not Governed by Code Block Logic):**
27 |     * If `idealMaxLength` does not fall within a code block (or after code block considerations have been made), the function will look for natural break points by scanning backwards from `idealMaxLength`:
28 |         * **Paragraph Breaks:** It prioritizes splitting after a double newline (`\n\n`), as this typically signifies the end of a paragraph or a block-level element.
29 |         * **Single Line Breaks:** If no double newline is found in a suitable range, it will look for a single newline (`\n`).
30 |     * Any newline chosen as a split point must also not be inside a code block.
31 | 
32 | 4.  **Fall back to `idealMaxLength`:**
33 |     * If no "safer" split point (respecting code blocks or finding suitable newlines) is identified before or at `idealMaxLength`, and `idealMaxLength` itself is not determined to be an unsafe split point (e.g., inside a code block), the function may return a length larger than `idealMaxLength`, again it CANNOT break markdown formatting. This could happen with very long lines of text without Markdown block structures or newlines.
34 | 
35 | **In essence, `findSafeSplitPoint` tries to be a good Markdown citizen when forced to divide content, preferring structural boundaries over arbitrary character limits, with a strong emphasis on not corrupting code blocks.**
36 | */
37 | 
38 | /**
39 |  * Checks if a given character index within a string is inside a fenced (```) code block.
40 |  * @param content The full string content.
41 |  * @param indexToTest The character index to test.
42 |  * @returns True if the index is inside a code block's content, false otherwise.
43 |  */
44 | const isIndexInsideCodeBlock = (
45 |   content: string,
46 |   indexToTest: number,
47 | ): boolean => {
48 |   let fenceCount = 0;
49 |   let searchPos = 0;
50 |   while (searchPos < content.length) {
51 |     const nextFence = content.indexOf('```', searchPos);
52 |     if (nextFence === -1 || nextFence >= indexToTest) {
53 |       break;
54 |     }
55 |     fenceCount++;
56 |     searchPos = nextFence + 3;
57 |   }
58 |   return fenceCount % 2 === 1;
59 | };
60 | 
61 | /**
62 |  * Finds the starting index of the code block that encloses the given index.
63 |  * Returns -1 if the index is not inside a code block.
64 |  * @param content The markdown content.
65 |  * @param index The index to check.
66 |  * @returns Start index of the enclosing code block or -1.
67 |  */
68 | const findEnclosingCodeBlockStart = (
69 |   content: string,
70 |   index: number,
71 | ): number => {
72 |   if (!isIndexInsideCodeBlock(content, index)) {
73 |     return -1;
74 |   }
75 |   let currentSearchPos = 0;
76 |   while (currentSearchPos < index) {
77 |     const blockStartIndex = content.indexOf('```', currentSearchPos);
78 |     if (blockStartIndex === -1 || blockStartIndex >= index) {
79 |       break;
80 |     }
81 |     const blockEndIndex = content.indexOf('```', blockStartIndex + 3);
82 |     if (blockStartIndex < index) {
83 |       if (blockEndIndex === -1 || index < blockEndIndex + 3) {
84 |         return blockStartIndex;
85 |       }
86 |     }
87 |     if (blockEndIndex === -1) break;
88 |     currentSearchPos = blockEndIndex + 3;
89 |   }
90 |   return -1;
91 | };
92 | 
93 | export const findLastSafeSplitPoint = (content: string) => {
94 |   const enclosingBlockStart = findEnclosingCodeBlockStart(
95 |     content,
96 |     content.length,
97 |   );
98 |   if (enclosingBlockStart !== -1) {
99 |     // The end of the content is contained in a code block. Split right before.
100 |     return enclosingBlockStart;
101 |   }
102 | 
103 |   // Search for the last double newline (\n\n) not in a code block.
104 |   let searchStartIndex = content.length;
105 |   while (searchStartIndex >= 0) {
106 |     const dnlIndex = content.lastIndexOf('\n\n', searchStartIndex);
107 |     if (dnlIndex === -1) {
108 |       // No more double newlines found.
109 |       break;
110 |     }
111 | 
112 |     const potentialSplitPoint = dnlIndex + 2;
113 |     if (!isIndexInsideCodeBlock(content, potentialSplitPoint)) {
114 |       return potentialSplitPoint;
115 |     }
116 | 
117 |     // If potentialSplitPoint was inside a code block,
118 |     // the next search should start *before* the \n\n we just found to ensure progress.
119 |     searchStartIndex = dnlIndex - 1;
120 |   }
121 | 
122 |   // If no safe double newline is found, return content.length
123 |   // to keep the entire content as one piece.
124 |   return content.length;
125 | };
```

src/ui/utils/platformConstants.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | /**
8 |  * Terminal Platform Constants
9 |  *
10 |  * This file contains terminal-related constants used throughout the application,
11 |  * specifically for handling keyboard inputs and terminal protocols.
12 |  */
13 | 
14 | /**
15 |  * Kitty keyboard protocol sequences for enhanced keyboard input.
16 |  * @see https://sw.kovidgoyal.net/kitty/keyboard-protocol/
17 |  */
18 | export const KITTY_CTRL_C = '[99;5u';
19 | 
20 | /**
21 |  * Kitty keyboard protocol keycodes
22 |  */
23 | export const KITTY_KEYCODE_ENTER = 13;
24 | export const KITTY_KEYCODE_NUMPAD_ENTER = 57414;
25 | export const KITTY_KEYCODE_TAB = 9;
26 | export const KITTY_KEYCODE_BACKSPACE = 127;
27 | 
28 | /**
29 |  * Kitty modifier decoding constants
30 |  *
31 |  * In Kitty/Ghostty, the modifier parameter is encoded as (1 + bitmask).
32 |  * Some terminals also set bit 7 (i.e., add 128) when reporting event types.
33 |  */
34 | export const KITTY_MODIFIER_BASE = 1; // Base value per spec before bitmask decode
35 | export const KITTY_MODIFIER_EVENT_TYPES_OFFSET = 128; // Added when event types are included
36 | 
37 | /**
38 |  * Modifier bit flags for Kitty/Xterm-style parameters.
39 |  *
40 |  * Per spec, the modifiers parameter encodes (1 + bitmask) where:
41 |  * - 1: no modifiers
42 |  * - bit 0 (1): Shift
43 |  * - bit 1 (2): Alt/Option (reported as "alt" in spec; we map to meta)
44 |  * - bit 2 (4): Ctrl
45 |  *
46 |  * Some terminals add 128 to the entire modifiers field when reporting event types.
47 |  * See: https://sw.kovidgoyal.net/kitty/keyboard-protocol/#modifiers
48 |  */
49 | export const MODIFIER_SHIFT_BIT = 1;
50 | export const MODIFIER_ALT_BIT = 2;
51 | export const MODIFIER_CTRL_BIT = 4;
52 | 
53 | /**
54 |  * Timing constants for terminal interactions
55 |  */
56 | export const CTRL_EXIT_PROMPT_DURATION_MS = 1000;
57 | 
58 | /**
59 |  * VS Code terminal integration constants
60 |  */
61 | export const VSCODE_SHIFT_ENTER_SEQUENCE = '\\\r\n';
62 | 
63 | /**
64 |  * Backslash + Enter detection window in milliseconds.
65 |  * Used to detect Shift+Enter pattern where backslash
66 |  * is followed by Enter within this timeframe.
67 |  */
68 | export const BACKSLASH_ENTER_DETECTION_WINDOW_MS = 5;
69 | 
70 | /**
71 |  * Maximum expected length of a Kitty keyboard protocol sequence.
72 |  * Format: ESC [ <keycode> ; <modifiers> u/~
73 |  * Example: \x1b[13;2u (Shift+Enter) = 8 chars
74 |  * Longest reasonable: \x1b[127;15~ = 11 chars (Del with all modifiers)
75 |  * We use 12 to provide a small buffer.
76 |  */
77 | // Increased to accommodate parameterized forms and occasional colon subfields
78 | // while still being small enough to avoid pathological buffering.
79 | export const MAX_KITTY_SEQUENCE_LENGTH = 32;
80 | 
81 | /**
82 |  * Character codes for common escape sequences
83 |  */
84 | export const CHAR_CODE_ESC = 27;
85 | export const CHAR_CODE_LEFT_BRACKET = 91;
86 | export const CHAR_CODE_1 = 49;
87 | export const CHAR_CODE_2 = 50;
```

src/ui/utils/terminalSetup.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | /**
8 |  * Terminal setup utility for configuring Shift+Enter and Ctrl+Enter support.
9 |  *
10 |  * This module provides automatic detection and configuration of various terminal
11 |  * emulators to support multiline input through modified Enter keys.
12 |  *
13 |  * Supported terminals:
14 |  * - VS Code: Configures keybindings.json to send \\\r\n
15 |  * - Cursor: Configures keybindings.json to send \\\r\n (VS Code fork)
16 |  * - Windsurf: Configures keybindings.json to send \\\r\n (VS Code fork)
17 |  *
18 |  * For VS Code and its forks:
19 |  * - Shift+Enter: Sends \\\r\n (backslash followed by CRLF)
20 |  * - Ctrl+Enter: Sends \\\r\n (backslash followed by CRLF)
21 |  *
22 |  * The module will not modify existing shift+enter or ctrl+enter keybindings
23 |  * to avoid conflicts with user customizations.
24 |  */
25 | 
26 | import { promises as fs } from 'node:fs';
27 | import * as os from 'node:os';
28 | import * as path from 'node:path';
29 | import { exec } from 'node:child_process';
30 | import { promisify } from 'node:util';
31 | import { isKittyProtocolEnabled } from './kittyProtocolDetector.js';
32 | import { VSCODE_SHIFT_ENTER_SEQUENCE } from './platformConstants.js';
33 | 
34 | const execAsync = promisify(exec);
35 | 
36 | /**
37 |  * Removes single-line JSON comments (// ...) from a string to allow parsing
38 |  * VS Code style JSON files that may contain comments.
39 |  */
40 | function stripJsonComments(content: string): string {
41 |   // Remove single-line comments (// ...)
42 |   return content.replace(/^\s*\/\/.*$/gm, '');
43 | }
44 | 
45 | export interface TerminalSetupResult {
46 |   success: boolean;
47 |   message: string;
48 |   requiresRestart?: boolean;
49 | }
50 | 
51 | type SupportedTerminal = 'vscode' | 'cursor' | 'windsurf';
52 | 
53 | // Terminal detection
54 | async function detectTerminal(): Promise<SupportedTerminal | null> {
55 |   const termProgram = process.env['TERM_PROGRAM'];
56 | 
57 |   // Check VS Code and its forks - check forks first to avoid false positives
58 |   // Check for Cursor-specific indicators
59 |   if (
60 |     process.env['CURSOR_TRACE_ID'] ||
61 |     process.env['VSCODE_GIT_ASKPASS_MAIN']?.toLowerCase().includes('cursor')
62 |   ) {
63 |     return 'cursor';
64 |   }
65 |   // Check for Windsurf-specific indicators
66 |   if (
67 |     process.env['VSCODE_GIT_ASKPASS_MAIN']?.toLowerCase().includes('windsurf')
68 |   ) {
69 |     return 'windsurf';
70 |   }
71 |   // Check VS Code last since forks may also set VSCODE env vars
72 |   if (termProgram === 'vscode' || process.env['VSCODE_GIT_IPC_HANDLE']) {
73 |     return 'vscode';
74 |   }
75 | 
76 |   // Check parent process name
77 |   if (os.platform() !== 'win32') {
78 |     try {
79 |       const { stdout } = await execAsync('ps -o comm= -p $PPID');
80 |       const parentName = stdout.trim();
81 | 
82 |       // Check forks before VS Code to avoid false positives
83 |       if (parentName.includes('windsurf') || parentName.includes('Windsurf'))
84 |         return 'windsurf';
85 |       if (parentName.includes('cursor') || parentName.includes('Cursor'))
86 |         return 'cursor';
87 |       if (parentName.includes('code') || parentName.includes('Code'))
88 |         return 'vscode';
89 |     } catch (error) {
90 |       // Continue detection even if process check fails
91 |       console.debug('Parent process detection failed:', error);
92 |     }
93 |   }
94 | 
95 |   return null;
96 | }
97 | 
98 | // Backup file helper
99 | async function backupFile(filePath: string): Promise<void> {
100 |   try {
101 |     const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
102 |     const backupPath = `${filePath}.backup.${timestamp}`;
103 |     await fs.copyFile(filePath, backupPath);
104 |   } catch (error) {
105 |     // Log backup errors but continue with operation
106 |     console.warn(`Failed to create backup of ${filePath}:`, error);
107 |   }
108 | }
109 | 
110 | // Helper function to get VS Code-style config directory
111 | function getVSCodeStyleConfigDir(appName: string): string | null {
112 |   const platform = os.platform();
113 | 
114 |   if (platform === 'darwin') {
115 |     return path.join(
116 |       os.homedir(),
117 |       'Library',
118 |       'Application Support',
119 |       appName,
120 |       'User',
121 |     );
122 |   } else if (platform === 'win32') {
123 |     if (!process.env['APPDATA']) {
124 |       return null;
125 |     }
126 |     return path.join(process.env['APPDATA'], appName, 'User');
127 |   } else {
128 |     return path.join(os.homedir(), '.config', appName, 'User');
129 |   }
130 | }
131 | 
132 | // Generic VS Code-style terminal configuration
133 | async function configureVSCodeStyle(
134 |   terminalName: string,
135 |   appName: string,
136 | ): Promise<TerminalSetupResult> {
137 |   const configDir = getVSCodeStyleConfigDir(appName);
138 | 
139 |   if (!configDir) {
140 |     return {
141 |       success: false,
142 |       message: `Could not determine ${terminalName} config path on Windows: APPDATA environment variable is not set.`,
143 |     };
144 |   }
145 | 
146 |   const keybindingsFile = path.join(configDir, 'keybindings.json');
147 | 
148 |   try {
149 |     await fs.mkdir(configDir, { recursive: true });
150 | 
151 |     let keybindings: unknown[] = [];
152 |     try {
153 |       const content = await fs.readFile(keybindingsFile, 'utf8');
154 |       await backupFile(keybindingsFile);
155 |       try {
156 |         const cleanContent = stripJsonComments(content);
157 |         const parsedContent = JSON.parse(cleanContent);
158 |         if (!Array.isArray(parsedContent)) {
159 |           return {
160 |             success: false,
161 |             message:
162 |               `${terminalName} keybindings.json exists but is not a valid JSON array. ` +
163 |               `Please fix the file manually or delete it to allow automatic configuration.\n` +
164 |               `File: ${keybindingsFile}`,
165 |           };
166 |         }
167 |         keybindings = parsedContent;
168 |       } catch (parseError) {
169 |         return {
170 |           success: false,
171 |           message:
172 |             `Failed to parse ${terminalName} keybindings.json. The file contains invalid JSON.\n` +
173 |             `Please fix the file manually or delete it to allow automatic configuration.\n` +
174 |             `File: ${keybindingsFile}\n` +
175 |             `Error: ${parseError}`,
176 |         };
177 |       }
178 |     } catch {
179 |       // File doesn't exist, will create new one
180 |     }
181 | 
182 |     const shiftEnterBinding = {
183 |       key: 'shift+enter',
184 |       command: 'workbench.action.terminal.sendSequence',
185 |       when: 'terminalFocus',
186 |       args: { text: VSCODE_SHIFT_ENTER_SEQUENCE },
187 |     };
188 | 
189 |     const ctrlEnterBinding = {
190 |       key: 'ctrl+enter',
191 |       command: 'workbench.action.terminal.sendSequence',
192 |       when: 'terminalFocus',
193 |       args: { text: VSCODE_SHIFT_ENTER_SEQUENCE },
194 |     };
195 | 
196 |     // Check if ANY shift+enter or ctrl+enter bindings already exist
197 |     const existingShiftEnter = keybindings.find((kb) => {
198 |       const binding = kb as { key?: string };
199 |       return binding.key === 'shift+enter';
200 |     });
201 | 
202 |     const existingCtrlEnter = keybindings.find((kb) => {
203 |       const binding = kb as { key?: string };
204 |       return binding.key === 'ctrl+enter';
205 |     });
206 | 
207 |     if (existingShiftEnter || existingCtrlEnter) {
208 |       const messages: string[] = [];
209 |       if (existingShiftEnter) {
210 |         messages.push(`- Shift+Enter binding already exists`);
211 |       }
212 |       if (existingCtrlEnter) {
213 |         messages.push(`- Ctrl+Enter binding already exists`);
214 |       }
215 |       return {
216 |         success: false,
217 |         message:
218 |           `Existing keybindings detected. Will not modify to avoid conflicts.\n` +
219 |           messages.join('\n') +
220 |           '\n' +
221 |           `Please check and modify manually if needed: ${keybindingsFile}`,
222 |       };
223 |     }
224 | 
225 |     // Check if our specific bindings already exist
226 |     const hasOurShiftEnter = keybindings.some((kb) => {
227 |       const binding = kb as {
228 |         command?: string;
229 |         args?: { text?: string };
230 |         key?: string;
231 |       };
232 |       return (
233 |         binding.key === 'shift+enter' &&
234 |         binding.command === 'workbench.action.terminal.sendSequence' &&
235 |         binding.args?.text === '\\\r\n'
236 |       );
237 |     });
238 | 
239 |     const hasOurCtrlEnter = keybindings.some((kb) => {
240 |       const binding = kb as {
241 |         command?: string;
242 |         args?: { text?: string };
243 |         key?: string;
244 |       };
245 |       return (
246 |         binding.key === 'ctrl+enter' &&
247 |         binding.command === 'workbench.action.terminal.sendSequence' &&
248 |         binding.args?.text === '\\\r\n'
249 |       );
250 |     });
251 | 
252 |     if (!hasOurShiftEnter || !hasOurCtrlEnter) {
253 |       if (!hasOurShiftEnter) keybindings.unshift(shiftEnterBinding);
254 |       if (!hasOurCtrlEnter) keybindings.unshift(ctrlEnterBinding);
255 | 
256 |       await fs.writeFile(keybindingsFile, JSON.stringify(keybindings, null, 4));
257 |       return {
258 |         success: true,
259 |         message: `Added Shift+Enter and Ctrl+Enter keybindings to ${terminalName}.\nModified: ${keybindingsFile}`,
260 |         requiresRestart: true,
261 |       };
262 |     } else {
263 |       return {
264 |         success: true,
265 |         message: `${terminalName} keybindings already configured.`,
266 |       };
267 |     }
268 |   } catch (error) {
269 |     return {
270 |       success: false,
271 |       message: `Failed to configure ${terminalName}.\nFile: ${keybindingsFile}\nError: ${error}`,
272 |     };
273 |   }
274 | }
275 | 
276 | // Terminal-specific configuration functions
277 | 
278 | async function configureVSCode(): Promise<TerminalSetupResult> {
279 |   return configureVSCodeStyle('VS Code', 'Code');
280 | }
281 | 
282 | async function configureCursor(): Promise<TerminalSetupResult> {
283 |   return configureVSCodeStyle('Cursor', 'Cursor');
284 | }
285 | 
286 | async function configureWindsurf(): Promise<TerminalSetupResult> {
287 |   return configureVSCodeStyle('Windsurf', 'Windsurf');
288 | }
289 | 
290 | /**
291 |  * Main terminal setup function that detects and configures the current terminal.
292 |  *
293 |  * This function:
294 |  * 1. Detects the current terminal emulator
295 |  * 2. Applies appropriate configuration for Shift+Enter and Ctrl+Enter support
296 |  * 3. Creates backups of configuration files before modifying them
297 |  *
298 |  * @returns Promise<TerminalSetupResult> Result object with success status and message
299 |  *
300 |  * @example
301 |  * const result = await terminalSetup();
302 |  * if (result.success) {
303 |  *   console.log(result.message);
304 |  *   if (result.requiresRestart) {
305 |  *     console.log('Please restart your terminal');
306 |  *   }
307 |  * }
308 |  */
309 | export async function terminalSetup(): Promise<TerminalSetupResult> {
310 |   // Check if terminal already has optimal keyboard support
311 |   if (isKittyProtocolEnabled()) {
312 |     return {
313 |       success: true,
314 |       message:
315 |         'Your terminal is already configured for an optimal experience with multiline input (Shift+Enter and Ctrl+Enter).',
316 |     };
317 |   }
318 | 
319 |   const terminal = await detectTerminal();
320 | 
321 |   if (!terminal) {
322 |     return {
323 |       success: false,
324 |       message:
325 |         'Could not detect terminal type. Supported terminals: VS Code, Cursor, and Windsurf.',
326 |     };
327 |   }
328 | 
329 |   switch (terminal) {
330 |     case 'vscode':
331 |       return configureVSCode();
332 |     case 'cursor':
333 |       return configureCursor();
334 |     case 'windsurf':
335 |       return configureWindsurf();
336 |     default:
337 |       return {
338 |         success: false,
339 |         message: `Terminal "${terminal}" is not supported yet.`,
340 |       };
341 |   }
342 | }
```

src/ui/utils/textUtils.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect } from 'vitest';
8 | import type {
9 |   ToolCallConfirmationDetails,
10 |   ToolEditConfirmationDetails,
11 | } from '@google/gemini-cli-core';
12 | import { escapeAnsiCtrlCodes } from './textUtils.js';
13 | 
14 | describe('textUtils', () => {
15 |   describe('escapeAnsiCtrlCodes', () => {
16 |     describe('escapeAnsiCtrlCodes string case study', () => {
17 |       it('should replace ANSI escape codes with a visible representation', () => {
18 |         const text = '\u001b[31mHello\u001b[0m';
19 |         const expected = '\\u001b[31mHello\\u001b[0m';
20 |         expect(escapeAnsiCtrlCodes(text)).toBe(expected);
21 | 
22 |         const text2 = "sh -e 'good && bad# \u001b[9D\u001b[K && good";
23 |         const expected2 = "sh -e 'good && bad# \\u001b[9D\\u001b[K && good";
24 |         expect(escapeAnsiCtrlCodes(text2)).toBe(expected2);
25 |       });
26 | 
27 |       it('should not change a string with no ANSI codes', () => {
28 |         const text = 'Hello, world!';
29 |         expect(escapeAnsiCtrlCodes(text)).toBe(text);
30 |       });
31 | 
32 |       it('should handle an empty string', () => {
33 |         expect(escapeAnsiCtrlCodes('')).toBe('');
34 |       });
35 | 
36 |       describe('toolConfirmationDetails case study', () => {
37 |         it('should sanitize command and rootCommand for exec type', () => {
38 |           const details: ToolCallConfirmationDetails = {
39 |             title: '\u001b[34mfake-title\u001b[0m',
40 |             type: 'exec',
41 |             command: '\u001b[31mmls -l\u001b[0m',
42 |             rootCommand: '\u001b[32msudo apt-get update\u001b[0m',
43 |             onConfirm: async () => {},
44 |           };
45 | 
46 |           const sanitized = escapeAnsiCtrlCodes(details);
47 | 
48 |           if (sanitized.type === 'exec') {
49 |             expect(sanitized.title).toBe('\\u001b[34mfake-title\\u001b[0m');
50 |             expect(sanitized.command).toBe('\\u001b[31mmls -l\\u001b[0m');
51 |             expect(sanitized.rootCommand).toBe(
52 |               '\\u001b[32msudo apt-get update\\u001b[0m',
53 |             );
54 |           }
55 |         });
56 | 
57 |         it('should sanitize properties for edit type', () => {
58 |           const details: ToolCallConfirmationDetails = {
59 |             type: 'edit',
60 |             title: '\u001b[34mEdit File\u001b[0m',
61 |             fileName: '\u001b[31mfile.txt\u001b[0m',
62 |             filePath: '/path/to/\u001b[32mfile.txt\u001b[0m',
63 |             fileDiff:
64 |               'diff --git a/file.txt b/file.txt\n--- a/\u001b[33mfile.txt\u001b[0m\n+++ b/file.txt',
65 |             onConfirm: async () => {},
66 |           } as unknown as ToolEditConfirmationDetails;
67 | 
68 |           const sanitized = escapeAnsiCtrlCodes(details);
69 | 
70 |           if (sanitized.type === 'edit') {
71 |             expect(sanitized.title).toBe('\\u001b[34mEdit File\\u001b[0m');
72 |             expect(sanitized.fileName).toBe('\\u001b[31mfile.txt\\u001b[0m');
73 |             expect(sanitized.filePath).toBe(
74 |               '/path/to/\\u001b[32mfile.txt\\u001b[0m',
75 |             );
76 |             expect(sanitized.fileDiff).toBe(
77 |               'diff --git a/file.txt b/file.txt\n--- a/\\u001b[33mfile.txt\\u001b[0m\n+++ b/file.txt',
78 |             );
79 |           }
80 |         });
81 | 
82 |         it('should sanitize properties for mcp type', () => {
83 |           const details: ToolCallConfirmationDetails = {
84 |             type: 'mcp',
85 |             title: '\u001b[34mCloud Run\u001b[0m',
86 |             serverName: '\u001b[31mmy-server\u001b[0m',
87 |             toolName: '\u001b[32mdeploy\u001b[0m',
88 |             toolDisplayName: '\u001b[33mDeploy Service\u001b[0m',
89 |             onConfirm: async () => {},
90 |           };
91 | 
92 |           const sanitized = escapeAnsiCtrlCodes(details);
93 | 
94 |           if (sanitized.type === 'mcp') {
95 |             expect(sanitized.title).toBe('\\u001b[34mCloud Run\\u001b[0m');
96 |             expect(sanitized.serverName).toBe('\\u001b[31mmy-server\\u001b[0m');
97 |             expect(sanitized.toolName).toBe('\\u001b[32mdeploy\\u001b[0m');
98 |             expect(sanitized.toolDisplayName).toBe(
99 |               '\\u001b[33mDeploy Service\\u001b[0m',
100 |             );
101 |           }
102 |         });
103 | 
104 |         it('should sanitize properties for info type', () => {
105 |           const details: ToolCallConfirmationDetails = {
106 |             type: 'info',
107 |             title: '\u001b[34mWeb Search\u001b[0m',
108 |             prompt: '\u001b[31mSearch for cats\u001b[0m',
109 |             urls: ['https://\u001b[32mgoogle.com\u001b[0m'],
110 |             onConfirm: async () => {},
111 |           };
112 | 
113 |           const sanitized = escapeAnsiCtrlCodes(details);
114 | 
115 |           if (sanitized.type === 'info') {
116 |             expect(sanitized.title).toBe('\\u001b[34mWeb Search\\u001b[0m');
117 |             expect(sanitized.prompt).toBe(
118 |               '\\u001b[31mSearch for cats\\u001b[0m',
119 |             );
120 |             expect(sanitized.urls?.[0]).toBe(
121 |               'https://\\u001b[32mgoogle.com\\u001b[0m',
122 |             );
123 |           }
124 |         });
125 |       });
126 | 
127 |       it('should not change the object if no sanitization is needed', () => {
128 |         const details: ToolCallConfirmationDetails = {
129 |           type: 'info',
130 |           title: 'Web Search',
131 |           prompt: 'Search for cats',
132 |           urls: ['https://google.com'],
133 |           onConfirm: async () => {},
134 |         };
135 | 
136 |         const sanitized = escapeAnsiCtrlCodes(details);
137 |         expect(sanitized).toBe(details);
138 |       });
139 | 
140 |       it('should handle nested objects and arrays', () => {
141 |         const details = {
142 |           a: '\u001b[31mred\u001b[0m',
143 |           b: {
144 |             c: '\u001b[32mgreen\u001b[0m',
145 |             d: ['\u001b[33myellow\u001b[0m', { e: '\u001b[34mblue\u001b[0m' }],
146 |           },
147 |           f: 123,
148 |           g: null,
149 |           h: () => '\u001b[35mpurple\u001b[0m',
150 |         };
151 | 
152 |         const sanitized = escapeAnsiCtrlCodes(details);
153 | 
154 |         expect(sanitized.a).toBe('\\u001b[31mred\\u001b[0m');
155 |         if (typeof sanitized.b === 'object' && sanitized.b !== null) {
156 |           const b = sanitized.b as { c: string; d: Array<string | object> };
157 |           expect(b.c).toBe('\\u001b[32mgreen\\u001b[0m');
158 |           expect(b.d[0]).toBe('\\u001b[33myellow\\u001b[0m');
159 |           if (typeof b.d[1] === 'object' && b.d[1] !== null) {
160 |             const e = b.d[1] as { e: string };
161 |             expect(e.e).toBe('\\u001b[34mblue\\u001b[0m');
162 |           }
163 |         }
164 |         expect(sanitized.f).toBe(123);
165 |         expect(sanitized.g).toBe(null);
166 |         expect(sanitized.h()).toBe('\u001b[35mpurple\u001b[0m');
167 |       });
168 |     });
169 |   });
170 | });
```

src/ui/utils/textUtils.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import stripAnsi from 'strip-ansi';
8 | import ansiRegex from 'ansi-regex';
9 | import { stripVTControlCharacters } from 'node:util';
10 | import stringWidth from 'string-width';
11 | 
12 | /**
13 |  * Calculates the maximum width of a multi-line ASCII art string.
14 |  * @param asciiArt The ASCII art string.
15 |  * @returns The length of the longest line in the ASCII art.
16 |  */
17 | export const getAsciiArtWidth = (asciiArt: string): number => {
18 |   if (!asciiArt) {
19 |     return 0;
20 |   }
21 |   const lines = asciiArt.split('\n');
22 |   return Math.max(...lines.map((line) => line.length));
23 | };
24 | 
25 | /*
26 |  * -------------------------------------------------------------------------
27 |  *  Unicode‑aware helpers (work at the code‑point level rather than UTF‑16
28 |  *  code units so that surrogate‑pair emoji count as one "column".)
29 |  * ---------------------------------------------------------------------- */
30 | 
31 | // Cache for code points to reduce GC pressure
32 | const codePointsCache = new Map<string, string[]>();
33 | const MAX_STRING_LENGTH_TO_CACHE = 1000;
34 | 
35 | export function toCodePoints(str: string): string[] {
36 |   // ASCII fast path - check if all chars are ASCII (0-127)
37 |   let isAscii = true;
38 |   for (let i = 0; i < str.length; i++) {
39 |     if (str.charCodeAt(i) > 127) {
40 |       isAscii = false;
41 |       break;
42 |     }
43 |   }
44 |   if (isAscii) {
45 |     return str.split('');
46 |   }
47 | 
48 |   // Cache short strings
49 |   if (str.length <= MAX_STRING_LENGTH_TO_CACHE) {
50 |     const cached = codePointsCache.get(str);
51 |     if (cached) {
52 |       return cached;
53 |     }
54 |   }
55 | 
56 |   const result = Array.from(str);
57 | 
58 |   // Cache result (unlimited like Ink)
59 |   if (str.length <= MAX_STRING_LENGTH_TO_CACHE) {
60 |     codePointsCache.set(str, result);
61 |   }
62 | 
63 |   return result;
64 | }
65 | 
66 | export function cpLen(str: string): number {
67 |   return toCodePoints(str).length;
68 | }
69 | 
70 | export function cpSlice(str: string, start: number, end?: number): string {
71 |   // Slice by code‑point indices and re‑join.
72 |   const arr = toCodePoints(str).slice(start, end);
73 |   return arr.join('');
74 | }
75 | 
76 | /**
77 |  * Strip characters that can break terminal rendering.
78 |  *
79 |  * Uses Node.js built-in stripVTControlCharacters to handle VT sequences,
80 |  * then filters remaining control characters that can disrupt display.
81 |  *
82 |  * Characters stripped:
83 |  * - ANSI escape sequences (via strip-ansi)
84 |  * - VT control sequences (via Node.js util.stripVTControlCharacters)
85 |  * - C0 control chars (0x00-0x1F) except CR/LF which are handled elsewhere
86 |  * - C1 control chars (0x80-0x9F) that can cause display issues
87 |  *
88 |  * Characters preserved:
89 |  * - All printable Unicode including emojis
90 |  * - DEL (0x7F) - handled functionally by applyOperations, not a display issue
91 |  * - CR/LF (0x0D/0x0A) - needed for line breaks
92 |  */
93 | export function stripUnsafeCharacters(str: string): string {
94 |   const strippedAnsi = stripAnsi(str);
95 |   const strippedVT = stripVTControlCharacters(strippedAnsi);
96 | 
97 |   return toCodePoints(strippedVT)
98 |     .filter((char) => {
99 |       const code = char.codePointAt(0);
100 |       if (code === undefined) return false;
101 | 
102 |       // Preserve CR/LF for line handling
103 |       if (code === 0x0a || code === 0x0d) return true;
104 | 
105 |       // Remove C0 control chars (except CR/LF) that can break display
106 |       // Examples: BELL(0x07) makes noise, BS(0x08) moves cursor, VT(0x0B), FF(0x0C)
107 |       if (code >= 0x00 && code <= 0x1f) return false;
108 | 
109 |       // Remove C1 control chars (0x80-0x9f) - legacy 8-bit control codes
110 |       if (code >= 0x80 && code <= 0x9f) return false;
111 | 
112 |       // Preserve DEL (0x7f) - it's handled functionally by applyOperations as backspace
113 |       // and doesn't cause rendering issues when displayed
114 | 
115 |       // Preserve all other characters including Unicode/emojis
116 |       return true;
117 |     })
118 |     .join('');
119 | }
120 | 
121 | // String width caching for performance optimization
122 | const stringWidthCache = new Map<string, number>();
123 | 
124 | /**
125 |  * Cached version of stringWidth function for better performance
126 |  * Follows Ink's approach with unlimited cache (no eviction)
127 |  */
128 | export const getCachedStringWidth = (str: string): number => {
129 |   // ASCII printable chars have width 1
130 |   if (/^[\x20-\x7E]*$/.test(str)) {
131 |     return str.length;
132 |   }
133 | 
134 |   if (stringWidthCache.has(str)) {
135 |     return stringWidthCache.get(str)!;
136 |   }
137 | 
138 |   const width = stringWidth(str);
139 |   stringWidthCache.set(str, width);
140 | 
141 |   return width;
142 | };
143 | 
144 | /**
145 |  * Clear the string width cache
146 |  */
147 | export const clearStringWidthCache = (): void => {
148 |   stringWidthCache.clear();
149 | };
150 | 
151 | const regex = ansiRegex();
152 | 
153 | /* Recursively traverses a JSON-like structure (objects, arrays, primitives)
154 |  * and escapes all ANSI control characters found in any string values.
155 |  *
156 |  * This function is designed to be robust, handling deeply nested objects and
157 |  * arrays. It applies a regex-based replacement to all string values to
158 |  * safely escape control characters.
159 |  *
160 |  * To optimize performance, this function uses a "copy-on-write" strategy.
161 |  * It avoids allocating new objects or arrays if no nested string values
162 |  * required escaping, returning the original object reference in such cases.
163 |  *
164 |  * @param obj The JSON-like value (object, array, string, etc.) to traverse.
165 |  * @returns A new value with all nested string fields escaped, or the
166 |  * original `obj` reference if no changes were necessary.
167 |  */
168 | export function escapeAnsiCtrlCodes<T>(obj: T): T {
169 |   if (typeof obj === 'string') {
170 |     if (obj.search(regex) === -1) {
171 |       return obj; // No changes return original string
172 |     }
173 | 
174 |     regex.lastIndex = 0; // needed for global regex
175 |     return obj.replace(regex, (match) =>
176 |       JSON.stringify(match).slice(1, -1),
177 |     ) as T;
178 |   }
179 | 
180 |   if (obj === null || typeof obj !== 'object') {
181 |     return obj;
182 |   }
183 | 
184 |   if (Array.isArray(obj)) {
185 |     let newArr: unknown[] | null = null;
186 | 
187 |     for (let i = 0; i < obj.length; i++) {
188 |       const value = obj[i];
189 |       const escapedValue = escapeAnsiCtrlCodes(value);
190 |       if (escapedValue !== value) {
191 |         if (newArr === null) {
192 |           newArr = [...obj];
193 |         }
194 |         newArr[i] = escapedValue;
195 |       }
196 |     }
197 |     return (newArr !== null ? newArr : obj) as T;
198 |   }
199 | 
200 |   let newObj: T | null = null;
201 |   const keys = Object.keys(obj);
202 | 
203 |   for (const key of keys) {
204 |     const value = (obj as Record<string, unknown>)[key];
205 |     const escapedValue = escapeAnsiCtrlCodes(value);
206 | 
207 |     if (escapedValue !== value) {
208 |       if (newObj === null) {
209 |         newObj = { ...obj };
210 |       }
211 |       (newObj as Record<string, unknown>)[key] = escapedValue;
212 |     }
213 |   }
214 | 
215 |   return newObj !== null ? newObj : obj;
216 | }
```

src/ui/utils/ui-sizing.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { lerp } from '../../utils/math.js';
8 | import { type LoadedSettings } from '../../config/settings.js';
9 | 
10 | const getMainAreaWidthInternal = (terminalWidth: number): number => {
11 |   if (terminalWidth <= 80) {
12 |     return Math.round(0.98 * terminalWidth);
13 |   }
14 |   if (terminalWidth >= 132) {
15 |     return Math.round(0.9 * terminalWidth);
16 |   }
17 | 
18 |   // Linearly interpolate between 80 columns (98%) and 132 columns (90%).
19 |   const t = (terminalWidth - 80) / (132 - 80);
20 |   const percentage = lerp(98, 90, t);
21 | 
22 |   return Math.round(percentage * terminalWidth * 0.01);
23 | };
24 | 
25 | export const calculateMainAreaWidth = (
26 |   terminalWidth: number,
27 |   settings: LoadedSettings,
28 | ): number =>
29 |   settings.merged.ui?.useFullWidth
30 |     ? terminalWidth
31 |     : getMainAreaWidthInternal(terminalWidth);
```

src/ui/utils/updateCheck.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { vi, describe, it, expect, beforeEach } from 'vitest';
8 | import { checkForUpdates } from './updateCheck.js';
9 | 
10 | const getPackageJson = vi.hoisted(() => vi.fn());
11 | vi.mock('../../utils/package.js', () => ({
12 |   getPackageJson,
13 | }));
14 | 
15 | const updateNotifier = vi.hoisted(() => vi.fn());
16 | vi.mock('update-notifier', () => ({
17 |   default: updateNotifier,
18 | }));
19 | 
20 | describe('checkForUpdates', () => {
21 |   beforeEach(() => {
22 |     vi.useFakeTimers();
23 |     vi.resetAllMocks();
24 |     // Clear DEV environment variable before each test
25 |     delete process.env['DEV'];
26 |   });
27 | 
28 |   afterEach(() => {
29 |     vi.useRealTimers();
30 |     vi.restoreAllMocks();
31 |   });
32 | 
33 |   it('should return null when running from source (DEV=true)', async () => {
34 |     process.env['DEV'] = 'true';
35 |     getPackageJson.mockResolvedValue({
36 |       name: 'test-package',
37 |       version: '1.0.0',
38 |     });
39 |     updateNotifier.mockReturnValue({
40 |       fetchInfo: vi
41 |         .fn()
42 |         .mockResolvedValue({ current: '1.0.0', latest: '1.1.0' }),
43 |     });
44 |     const result = await checkForUpdates();
45 |     expect(result).toBeNull();
46 |     expect(getPackageJson).not.toHaveBeenCalled();
47 |     expect(updateNotifier).not.toHaveBeenCalled();
48 |   });
49 | 
50 |   it('should return null if package.json is missing', async () => {
51 |     getPackageJson.mockResolvedValue(null);
52 |     const result = await checkForUpdates();
53 |     expect(result).toBeNull();
54 |   });
55 | 
56 |   it('should return null if there is no update', async () => {
57 |     getPackageJson.mockResolvedValue({
58 |       name: 'test-package',
59 |       version: '1.0.0',
60 |     });
61 |     updateNotifier.mockReturnValue({
62 |       fetchInfo: vi.fn().mockResolvedValue(null),
63 |     });
64 |     const result = await checkForUpdates();
65 |     expect(result).toBeNull();
66 |   });
67 | 
68 |   it('should return a message if a newer version is available', async () => {
69 |     getPackageJson.mockResolvedValue({
70 |       name: 'test-package',
71 |       version: '1.0.0',
72 |     });
73 |     updateNotifier.mockReturnValue({
74 |       fetchInfo: vi
75 |         .fn()
76 |         .mockResolvedValue({ current: '1.0.0', latest: '1.1.0' }),
77 |     });
78 | 
79 |     const result = await checkForUpdates();
80 |     expect(result?.message).toContain('1.0.0 → 1.1.0');
81 |     expect(result?.update).toEqual({ current: '1.0.0', latest: '1.1.0' });
82 |   });
83 | 
84 |   it('should return null if the latest version is the same as the current version', async () => {
85 |     getPackageJson.mockResolvedValue({
86 |       name: 'test-package',
87 |       version: '1.0.0',
88 |     });
89 |     updateNotifier.mockReturnValue({
90 |       fetchInfo: vi
91 |         .fn()
92 |         .mockResolvedValue({ current: '1.0.0', latest: '1.0.0' }),
93 |     });
94 |     const result = await checkForUpdates();
95 |     expect(result).toBeNull();
96 |   });
97 | 
98 |   it('should return null if the latest version is older than the current version', async () => {
99 |     getPackageJson.mockResolvedValue({
100 |       name: 'test-package',
101 |       version: '1.1.0',
102 |     });
103 |     updateNotifier.mockReturnValue({
104 |       fetchInfo: vi
105 |         .fn()
106 |         .mockResolvedValue({ current: '1.1.0', latest: '1.0.0' }),
107 |     });
108 |     const result = await checkForUpdates();
109 |     expect(result).toBeNull();
110 |   });
111 | 
112 |   it('should return null if fetchInfo rejects', async () => {
113 |     getPackageJson.mockResolvedValue({
114 |       name: 'test-package',
115 |       version: '1.0.0',
116 |     });
117 |     updateNotifier.mockReturnValue({
118 |       fetchInfo: vi.fn().mockRejectedValue(new Error('Timeout')),
119 |     });
120 | 
121 |     const result = await checkForUpdates();
122 |     expect(result).toBeNull();
123 |   });
124 | 
125 |   it('should handle errors gracefully', async () => {
126 |     getPackageJson.mockRejectedValue(new Error('test error'));
127 |     const result = await checkForUpdates();
128 |     expect(result).toBeNull();
129 |   });
130 | 
131 |   describe('nightly updates', () => {
132 |     it('should notify for a newer nightly version when current is nightly', async () => {
133 |       getPackageJson.mockResolvedValue({
134 |         name: 'test-package',
135 |         version: '1.2.3-nightly.1',
136 |       });
137 | 
138 |       const fetchInfoMock = vi.fn().mockImplementation(({ distTag }) => {
139 |         if (distTag === 'nightly') {
140 |           return Promise.resolve({
141 |             latest: '1.2.3-nightly.2',
142 |             current: '1.2.3-nightly.1',
143 |           });
144 |         }
145 |         if (distTag === 'latest') {
146 |           return Promise.resolve({
147 |             latest: '1.2.3',
148 |             current: '1.2.3-nightly.1',
149 |           });
150 |         }
151 |         return Promise.resolve(null);
152 |       });
153 | 
154 |       updateNotifier.mockImplementation(({ pkg, distTag }) => ({
155 |         fetchInfo: () => fetchInfoMock({ pkg, distTag }),
156 |       }));
157 | 
158 |       const result = await checkForUpdates();
159 |       expect(result?.message).toContain('1.2.3-nightly.1 → 1.2.3-nightly.2');
160 |       expect(result?.update.latest).toBe('1.2.3-nightly.2');
161 |     });
162 |   });
163 | });
```

src/ui/utils/updateCheck.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type { UpdateInfo } from 'update-notifier';
8 | import updateNotifier from 'update-notifier';
9 | import semver from 'semver';
10 | import { getPackageJson } from '../../utils/package.js';
11 | 
12 | export const FETCH_TIMEOUT_MS = 2000;
13 | 
14 | export interface UpdateObject {
15 |   message: string;
16 |   update: UpdateInfo;
17 | }
18 | 
19 | /**
20 |  * From a nightly and stable update, determines which is the "best" one to offer.
21 |  * The rule is to always prefer nightly if the base versions are the same.
22 |  */
23 | function getBestAvailableUpdate(
24 |   nightly?: UpdateInfo,
25 |   stable?: UpdateInfo,
26 | ): UpdateInfo | null {
27 |   if (!nightly) return stable || null;
28 |   if (!stable) return nightly || null;
29 | 
30 |   const nightlyVer = nightly.latest;
31 |   const stableVer = stable.latest;
32 | 
33 |   if (
34 |     semver.coerce(stableVer)?.version === semver.coerce(nightlyVer)?.version
35 |   ) {
36 |     return nightly;
37 |   }
38 | 
39 |   return semver.gt(stableVer, nightlyVer) ? stable : nightly;
40 | }
41 | 
42 | export async function checkForUpdates(): Promise<UpdateObject | null> {
43 |   try {
44 |     // Skip update check when running from source (development mode)
45 |     if (process.env['DEV'] === 'true') {
46 |       return null;
47 |     }
48 |     const packageJson = await getPackageJson();
49 |     if (!packageJson || !packageJson.name || !packageJson.version) {
50 |       return null;
51 |     }
52 | 
53 |     const { name, version: currentVersion } = packageJson;
54 |     const isNightly = currentVersion.includes('nightly');
55 |     const createNotifier = (distTag: 'latest' | 'nightly') =>
56 |       updateNotifier({
57 |         pkg: {
58 |           name,
59 |           version: currentVersion,
60 |         },
61 |         updateCheckInterval: 0,
62 |         shouldNotifyInNpmScript: true,
63 |         distTag,
64 |       });
65 | 
66 |     if (isNightly) {
67 |       const [nightlyUpdateInfo, latestUpdateInfo] = await Promise.all([
68 |         createNotifier('nightly').fetchInfo(),
69 |         createNotifier('latest').fetchInfo(),
70 |       ]);
71 | 
72 |       const bestUpdate = getBestAvailableUpdate(
73 |         nightlyUpdateInfo,
74 |         latestUpdateInfo,
75 |       );
76 | 
77 |       if (bestUpdate && semver.gt(bestUpdate.latest, currentVersion)) {
78 |         const message = `A new version of Gemini CLI is available! ${currentVersion} → ${bestUpdate.latest}`;
79 |         return {
80 |           message,
81 |           update: { ...bestUpdate, current: currentVersion },
82 |         };
83 |       }
84 |     } else {
85 |       const updateInfo = await createNotifier('latest').fetchInfo();
86 | 
87 |       if (updateInfo && semver.gt(updateInfo.latest, currentVersion)) {
88 |         const message = `Gemini CLI update available! ${currentVersion} → ${updateInfo.latest}`;
89 |         return {
90 |           message,
91 |           update: { ...updateInfo, current: currentVersion },
92 |         };
93 |       }
94 |     }
95 | 
96 |     return null;
97 |   } catch (e) {
98 |     console.warn('Failed to check for updates: ' + e);
99 |     return null;
100 |   }
101 | }
```

src/ui/components/messages/CompressionMessage.test.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { render } from 'ink-testing-library';
8 | import type { CompressionDisplayProps } from './CompressionMessage.js';
9 | import { CompressionMessage } from './CompressionMessage.js';
10 | import { CompressionStatus } from '@google/gemini-cli-core';
11 | import type { CompressionProps } from '../../types.js';
12 | import { describe, it, expect } from 'vitest';
13 | 
14 | describe('<CompressionMessage />', () => {
15 |   const createCompressionProps = (
16 |     overrides: Partial<CompressionProps> = {},
17 |   ): CompressionDisplayProps => ({
18 |     compression: {
19 |       isPending: false,
20 |       originalTokenCount: null,
21 |       newTokenCount: null,
22 |       compressionStatus: CompressionStatus.COMPRESSED,
23 |       ...overrides,
24 |     },
25 |   });
26 | 
27 |   describe('pending state', () => {
28 |     it('renders pending message when compression is in progress', () => {
29 |       const props = createCompressionProps({ isPending: true });
30 |       const { lastFrame } = render(<CompressionMessage {...props} />);
31 |       const output = lastFrame();
32 | 
33 |       expect(output).toContain('Compressing chat history');
34 |     });
35 |   });
36 | 
37 |   describe('normal compression (successful token reduction)', () => {
38 |     it('renders success message when tokens are reduced', () => {
39 |       const props = createCompressionProps({
40 |         isPending: false,
41 |         originalTokenCount: 100,
42 |         newTokenCount: 50,
43 |         compressionStatus: CompressionStatus.COMPRESSED,
44 |       });
45 |       const { lastFrame } = render(<CompressionMessage {...props} />);
46 |       const output = lastFrame();
47 | 
48 |       expect(output).toContain('✦');
49 |       expect(output).toContain(
50 |         'Chat history compressed from 100 to 50 tokens.',
51 |       );
52 |     });
53 | 
54 |     it('renders success message for large successful compressions', () => {
55 |       const testCases = [
56 |         { original: 50000, new: 25000 }, // Large compression
57 |         { original: 700000, new: 350000 }, // Very large compression
58 |       ];
59 | 
60 |       testCases.forEach(({ original, new: newTokens }) => {
61 |         const props = createCompressionProps({
62 |           isPending: false,
63 |           originalTokenCount: original,
64 |           newTokenCount: newTokens,
65 |           compressionStatus: CompressionStatus.COMPRESSED,
66 |         });
67 |         const { lastFrame } = render(<CompressionMessage {...props} />);
68 |         const output = lastFrame();
69 | 
70 |         expect(output).toContain('✦');
71 |         expect(output).toContain(
72 |           `compressed from ${original} to ${newTokens} tokens`,
73 |         );
74 |         expect(output).not.toContain('Skipping compression');
75 |         expect(output).not.toContain('did not reduce size');
76 |       });
77 |     });
78 |   });
79 | 
80 |   describe('skipped compression (tokens increased or same)', () => {
81 |     it('renders skip message when compression would increase token count', () => {
82 |       const props = createCompressionProps({
83 |         isPending: false,
84 |         originalTokenCount: 50,
85 |         newTokenCount: 75,
86 |         compressionStatus:
87 |           CompressionStatus.COMPRESSION_FAILED_INFLATED_TOKEN_COUNT,
88 |       });
89 |       const { lastFrame } = render(<CompressionMessage {...props} />);
90 |       const output = lastFrame();
91 | 
92 |       expect(output).toContain('✦');
93 |       expect(output).toContain(
94 |         'Compression was not beneficial for this history size.',
95 |       );
96 |     });
97 | 
98 |     it('renders skip message when token counts are equal', () => {
99 |       const props = createCompressionProps({
100 |         isPending: false,
101 |         originalTokenCount: 50,
102 |         newTokenCount: 50,
103 |         compressionStatus:
104 |           CompressionStatus.COMPRESSION_FAILED_INFLATED_TOKEN_COUNT,
105 |       });
106 |       const { lastFrame } = render(<CompressionMessage {...props} />);
107 |       const output = lastFrame();
108 | 
109 |       expect(output).toContain(
110 |         'Compression was not beneficial for this history size.',
111 |       );
112 |     });
113 |   });
114 | 
115 |   describe('message content validation', () => {
116 |     it('displays correct compression statistics', () => {
117 |       const testCases = [
118 |         {
119 |           original: 200,
120 |           new: 80,
121 |           expected: 'compressed from 200 to 80 tokens',
122 |         },
123 |         {
124 |           original: 500,
125 |           new: 150,
126 |           expected: 'compressed from 500 to 150 tokens',
127 |         },
128 |         {
129 |           original: 1500,
130 |           new: 400,
131 |           expected: 'compressed from 1500 to 400 tokens',
132 |         },
133 |       ];
134 | 
135 |       testCases.forEach(({ original, new: newTokens, expected }) => {
136 |         const props = createCompressionProps({
137 |           isPending: false,
138 |           originalTokenCount: original,
139 |           newTokenCount: newTokens,
140 |           compressionStatus: CompressionStatus.COMPRESSED,
141 |         });
142 |         const { lastFrame } = render(<CompressionMessage {...props} />);
143 |         const output = lastFrame();
144 | 
145 |         expect(output).toContain(expected);
146 |       });
147 |     });
148 | 
149 |     it('shows skip message for small histories when new tokens >= original tokens', () => {
150 |       const testCases = [
151 |         { original: 50, new: 60 }, // Increased
152 |         { original: 100, new: 100 }, // Same
153 |         { original: 49999, new: 50000 }, // Just under 50k threshold
154 |       ];
155 | 
156 |       testCases.forEach(({ original, new: newTokens }) => {
157 |         const props = createCompressionProps({
158 |           isPending: false,
159 |           originalTokenCount: original,
160 |           newTokenCount: newTokens,
161 |           compressionStatus:
162 |             CompressionStatus.COMPRESSION_FAILED_INFLATED_TOKEN_COUNT,
163 |         });
164 |         const { lastFrame } = render(<CompressionMessage {...props} />);
165 |         const output = lastFrame();
166 | 
167 |         expect(output).toContain(
168 |           'Compression was not beneficial for this history size.',
169 |         );
170 |         expect(output).not.toContain('compressed from');
171 |       });
172 |     });
173 | 
174 |     it('shows compression failure message for large histories when new tokens >= original tokens', () => {
175 |       const testCases = [
176 |         { original: 50000, new: 50100 }, // At 50k threshold
177 |         { original: 700000, new: 710000 }, // Large history case
178 |         { original: 100000, new: 100000 }, // Large history, same count
179 |       ];
180 | 
181 |       testCases.forEach(({ original, new: newTokens }) => {
182 |         const props = createCompressionProps({
183 |           isPending: false,
184 |           originalTokenCount: original,
185 |           newTokenCount: newTokens,
186 |           compressionStatus:
187 |             CompressionStatus.COMPRESSION_FAILED_INFLATED_TOKEN_COUNT,
188 |         });
189 |         const { lastFrame } = render(<CompressionMessage {...props} />);
190 |         const output = lastFrame();
191 | 
192 |         expect(output).toContain('compression did not reduce size');
193 |         expect(output).not.toContain('compressed from');
194 |         expect(output).not.toContain('Compression was not beneficial');
195 |       });
196 |     });
197 |   });
198 | });
```

src/ui/components/messages/CompressionMessage.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { Box, Text } from 'ink';
8 | import type { CompressionProps } from '../../types.js';
9 | import { CliSpinner } from '../CliSpinner.js';
10 | import { theme } from '../../semantic-colors.js';
11 | import { SCREEN_READER_MODEL_PREFIX } from '../../textConstants.js';
12 | import { CompressionStatus } from '@google/gemini-cli-core';
13 | 
14 | export interface CompressionDisplayProps {
15 |   compression: CompressionProps;
16 | }
17 | 
18 | /*
19 |  * Compression messages appear when the /compress command is run, and show a loading spinner
20 |  * while compression is in progress, followed up by some compression stats.
21 |  */
22 | export function CompressionMessage({
23 |   compression,
24 | }: CompressionDisplayProps): React.JSX.Element {
25 |   const { isPending, originalTokenCount, newTokenCount, compressionStatus } =
26 |     compression;
27 | 
28 |   const originalTokens = originalTokenCount ?? 0;
29 |   const newTokens = newTokenCount ?? 0;
30 | 
31 |   const getCompressionText = () => {
32 |     if (isPending) {
33 |       return 'Compressing chat history';
34 |     }
35 | 
36 |     switch (compressionStatus) {
37 |       case CompressionStatus.COMPRESSED:
38 |         return `Chat history compressed from ${originalTokens} to ${newTokens} tokens.`;
39 |       case CompressionStatus.COMPRESSION_FAILED_INFLATED_TOKEN_COUNT:
40 |         // For smaller histories (< 50k tokens), compression overhead likely exceeds benefits
41 |         if (originalTokens < 50000) {
42 |           return 'Compression was not beneficial for this history size.';
43 |         }
44 |         // For larger histories where compression should work but didn't,
45 |         // this suggests an issue with the compression process itself
46 |         return 'Chat history compression did not reduce size. This may indicate issues with the compression prompt.';
47 |       case CompressionStatus.COMPRESSION_FAILED_TOKEN_COUNT_ERROR:
48 |         return 'Could not compress chat history due to a token counting error.';
49 |       case CompressionStatus.NOOP:
50 |         return 'Chat history is already compressed.';
51 |       default:
52 |         return '';
53 |     }
54 |   };
55 | 
56 |   const text = getCompressionText();
57 | 
58 |   return (
59 |     <Box flexDirection="row">
60 |       <Box marginRight={1}>
61 |         {isPending ? (
62 |           <CliSpinner type="dots" />
63 |         ) : (
64 |           <Text color={theme.text.accent}>✦</Text>
65 |         )}
66 |       </Box>
67 |       <Box>
68 |         <Text
69 |           color={
70 |             compression.isPending ? theme.text.accent : theme.status.success
71 |           }
72 |           aria-label={SCREEN_READER_MODEL_PREFIX}
73 |         >
74 |           {text}
75 |         </Text>
76 |       </Box>
77 |     </Box>
78 |   );
79 | }
```

src/ui/components/messages/DiffRenderer.test.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { OverflowProvider } from '../../contexts/OverflowContext.js';
8 | import { render } from 'ink-testing-library';
9 | import { DiffRenderer } from './DiffRenderer.js';
10 | import * as CodeColorizer from '../../utils/CodeColorizer.js';
11 | import { vi } from 'vitest';
12 | 
13 | describe('<OverflowProvider><DiffRenderer /></OverflowProvider>', () => {
14 |   const mockColorizeCode = vi.spyOn(CodeColorizer, 'colorizeCode');
15 | 
16 |   beforeEach(() => {
17 |     mockColorizeCode.mockClear();
18 |   });
19 | 
20 |   const sanitizeOutput = (output: string | undefined, terminalWidth: number) =>
21 |     output?.replace(/GAP_INDICATOR/g, '═'.repeat(terminalWidth));
22 | 
23 |   it('should call colorizeCode with correct language for new file with known extension', () => {
24 |     const newFileDiffContent = `
25 | diff --git a/test.py b/test.py
26 | new file mode 100644
27 | index 0000000..e69de29
28 | --- /dev/null
29 | +++ b/test.py
30 | @@ -0,0 +1 @@
31 | +print("hello world")
32 | `;
33 |     render(
34 |       <OverflowProvider>
35 |         <DiffRenderer
36 |           diffContent={newFileDiffContent}
37 |           filename="test.py"
38 |           terminalWidth={80}
39 |         />
40 |       </OverflowProvider>,
41 |     );
42 |     expect(mockColorizeCode).toHaveBeenCalledWith(
43 |       'print("hello world")',
44 |       'python',
45 |       undefined,
46 |       80,
47 |       undefined,
48 |     );
49 |   });
50 | 
51 |   it('should call colorizeCode with null language for new file with unknown extension', () => {
52 |     const newFileDiffContent = `
53 | diff --git a/test.unknown b/test.unknown
54 | new file mode 100644
55 | index 0000000..e69de29
56 | --- /dev/null
57 | +++ b/test.unknown
58 | @@ -0,0 +1 @@
59 | +some content
60 | `;
61 |     render(
62 |       <OverflowProvider>
63 |         <DiffRenderer
64 |           diffContent={newFileDiffContent}
65 |           filename="test.unknown"
66 |           terminalWidth={80}
67 |         />
68 |       </OverflowProvider>,
69 |     );
70 |     expect(mockColorizeCode).toHaveBeenCalledWith(
71 |       'some content',
72 |       null,
73 |       undefined,
74 |       80,
75 |       undefined,
76 |     );
77 |   });
78 | 
79 |   it('should call colorizeCode with null language for new file if no filename is provided', () => {
80 |     const newFileDiffContent = `
81 | diff --git a/test.txt b/test.txt
82 | new file mode 100644
83 | index 0000000..e69de29
84 | --- /dev/null
85 | +++ b/test.txt
86 | @@ -0,0 +1 @@
87 | +some text content
88 | `;
89 |     render(
90 |       <OverflowProvider>
91 |         <DiffRenderer diffContent={newFileDiffContent} terminalWidth={80} />
92 |       </OverflowProvider>,
93 |     );
94 |     expect(mockColorizeCode).toHaveBeenCalledWith(
95 |       'some text content',
96 |       null,
97 |       undefined,
98 |       80,
99 |       undefined,
100 |     );
101 |   });
102 | 
103 |   it('should render diff content for existing file (not calling colorizeCode directly for the whole block)', () => {
104 |     const existingFileDiffContent = `
105 | diff --git a/test.txt b/test.txt
106 | index 0000001..0000002 100644
107 | --- a/test.txt
108 | +++ b/test.txt
109 | @@ -1 +1 @@
110 | -old line
111 | +new line
112 | `;
113 |     const { lastFrame } = render(
114 |       <OverflowProvider>
115 |         <DiffRenderer
116 |           diffContent={existingFileDiffContent}
117 |           filename="test.txt"
118 |           terminalWidth={80}
119 |         />
120 |       </OverflowProvider>,
121 |     );
122 |     // colorizeCode is used internally by the line-by-line rendering, not for the whole block
123 |     expect(mockColorizeCode).not.toHaveBeenCalledWith(
124 |       expect.stringContaining('old line'),
125 |       expect.anything(),
126 |     );
127 |     expect(mockColorizeCode).not.toHaveBeenCalledWith(
128 |       expect.stringContaining('new line'),
129 |       expect.anything(),
130 |     );
131 |     const output = lastFrame();
132 |     const lines = output!.split('\n');
133 |     expect(lines[0]).toBe('1 - old line');
134 |     expect(lines[1]).toBe('1 + new line');
135 |   });
136 | 
137 |   it('should handle diff with only header and no changes', () => {
138 |     const noChangeDiff = `diff --git a/file.txt b/file.txt
139 | index 1234567..1234567 100644
140 | --- a/file.txt
141 | +++ b/file.txt
142 | `;
143 |     const { lastFrame } = render(
144 |       <OverflowProvider>
145 |         <DiffRenderer
146 |           diffContent={noChangeDiff}
147 |           filename="file.txt"
148 |           terminalWidth={80}
149 |         />
150 |       </OverflowProvider>,
151 |     );
152 |     expect(lastFrame()).toContain('No changes detected');
153 |     expect(mockColorizeCode).not.toHaveBeenCalled();
154 |   });
155 | 
156 |   it('should handle empty diff content', () => {
157 |     const { lastFrame } = render(
158 |       <OverflowProvider>
159 |         <DiffRenderer diffContent="" terminalWidth={80} />
160 |       </OverflowProvider>,
161 |     );
162 |     expect(lastFrame()).toContain('No diff content');
163 |     expect(mockColorizeCode).not.toHaveBeenCalled();
164 |   });
165 | 
166 |   it('should render a gap indicator for skipped lines', () => {
167 |     const diffWithGap = `
168 | diff --git a/file.txt b/file.txt
169 | index 123..456 100644
170 | --- a/file.txt
171 | +++ b/file.txt
172 | @@ -1,2 +1,2 @@
173 |  context line 1
174 | -deleted line
175 | +added line
176 | @@ -10,2 +10,2 @@
177 |  context line 10
178 |  context line 11
179 | `;
180 |     const { lastFrame } = render(
181 |       <OverflowProvider>
182 |         <DiffRenderer
183 |           diffContent={diffWithGap}
184 |           filename="file.txt"
185 |           terminalWidth={80}
186 |         />
187 |       </OverflowProvider>,
188 |     );
189 |     const output = lastFrame();
190 |     expect(output).toContain('═'); // Check for the border character used in the gap
191 | 
192 |     // Verify that lines before and after the gap are rendered
193 |     expect(output).toContain('context line 1');
194 |     expect(output).toContain('added line');
195 |     expect(output).toContain('context line 10');
196 |   });
197 | 
198 |   it('should not render a gap indicator for small gaps (<= MAX_CONTEXT_LINES_WITHOUT_GAP)', () => {
199 |     const diffWithSmallGap = `
200 | diff --git a/file.txt b/file.txt
201 | index abc..def 100644
202 | --- a/file.txt
203 | +++ b/file.txt
204 | @@ -1,5 +1,5 @@
205 |  context line 1
206 |  context line 2
207 |  context line 3
208 |  context line 4
209 |  context line 5
210 | @@ -11,5 +11,5 @@
211 |  context line 11
212 |  context line 12
213 |  context line 13
214 |  context line 14
215 |  context line 15
216 | `;
217 |     const { lastFrame } = render(
218 |       <OverflowProvider>
219 |         <DiffRenderer
220 |           diffContent={diffWithSmallGap}
221 |           filename="file.txt"
222 |           terminalWidth={80}
223 |         />
224 |       </OverflowProvider>,
225 |     );
226 |     const output = lastFrame();
227 |     expect(output).not.toContain('═'); // Ensure no separator is rendered
228 | 
229 |     // Verify that lines before and after the gap are rendered
230 |     expect(output).toContain('context line 5');
231 |     expect(output).toContain('context line 11');
232 |   });
233 | 
234 |   describe('should correctly render a diff with multiple hunks and a gap indicator', () => {
235 |     const diffWithMultipleHunks = `
236 | diff --git a/multi.js b/multi.js
237 | index 123..789 100644
238 | --- a/multi.js
239 | +++ b/multi.js
240 | @@ -1,3 +1,3 @@
241 |  console.log('first hunk');
242 | -const oldVar = 1;
243 | +const newVar = 1;
244 |  console.log('end of first hunk');
245 | @@ -20,3 +20,3 @@
246 |  console.log('second hunk');
247 | -const anotherOld = 'test';
248 | +const anotherNew = 'test';
249 |  console.log('end of second hunk');
250 | `;
251 | 
252 |     it.each([
253 |       {
254 |         terminalWidth: 80,
255 |         height: undefined,
256 |         expected: ` 1   console.log('first hunk');
257 |  2 - const oldVar = 1;
258 |  2 + const newVar = 1;
259 |  3   console.log('end of first hunk');
260 | ════════════════════════════════════════════════════════════════════════════════
261 | 20   console.log('second hunk');
262 | 21 - const anotherOld = 'test';
263 | 21 + const anotherNew = 'test';
264 | 22   console.log('end of second hunk');`,
265 |       },
266 |       {
267 |         terminalWidth: 80,
268 |         height: 6,
269 |         expected: `... first 4 lines hidden ...
270 | ════════════════════════════════════════════════════════════════════════════════
271 | 20   console.log('second hunk');
272 | 21 - const anotherOld = 'test';
273 | 21 + const anotherNew = 'test';
274 | 22   console.log('end of second hunk');`,
275 |       },
276 |       {
277 |         terminalWidth: 30,
278 |         height: 6,
279 |         expected: `... first 10 lines hidden ...
280 |    ;
281 | 21 + const anotherNew = 'test'
282 |    ;
283 | 22   console.log('end of
284 |      second hunk');`,
285 |       },
286 |     ])(
287 |       'with terminalWidth $terminalWidth and height $height',
288 |       ({ terminalWidth, height, expected }) => {
289 |         const { lastFrame } = render(
290 |           <OverflowProvider>
291 |             <DiffRenderer
292 |               diffContent={diffWithMultipleHunks}
293 |               filename="multi.js"
294 |               terminalWidth={terminalWidth}
295 |               availableTerminalHeight={height}
296 |             />
297 |           </OverflowProvider>,
298 |         );
299 |         const output = lastFrame();
300 |         expect(sanitizeOutput(output, terminalWidth)).toEqual(expected);
301 |       },
302 |     );
303 |   });
304 | 
305 |   it('should correctly render a diff with a SVN diff format', () => {
306 |     const newFileDiff = `
307 | fileDiff Index: file.txt
308 | ===================================================================
309 | --- a/file.txt   Current
310 | +++ b/file.txt   Proposed
311 | --- a/multi.js
312 | +++ b/multi.js
313 | @@ -1,1 +1,1 @@
314 | -const oldVar = 1;
315 | +const newVar = 1;
316 | @@ -20,1 +20,1 @@
317 | -const anotherOld = 'test';
318 | +const anotherNew = 'test';
319 | \\ No newline at end of file  
320 | `;
321 |     const { lastFrame } = render(
322 |       <OverflowProvider>
323 |         <DiffRenderer
324 |           diffContent={newFileDiff}
325 |           filename="TEST"
326 |           terminalWidth={80}
327 |         />
328 |       </OverflowProvider>,
329 |     );
330 |     const output = lastFrame();
331 | 
332 |     expect(output).toEqual(` 1 - const oldVar = 1;
333 |  1 + const newVar = 1;
334 | ════════════════════════════════════════════════════════════════════════════════
335 | 20 - const anotherOld = 'test';
336 | 20 + const anotherNew = 'test';`);
337 |   });
338 | 
339 |   it('should correctly render a new file with no file extension correctly', () => {
340 |     const newFileDiff = `
341 | fileDiff Index: Dockerfile
342 | ===================================================================
343 | --- Dockerfile   Current
344 | +++ Dockerfile   Proposed
345 | @@ -0,0 +1,3 @@
346 | +FROM node:14
347 | +RUN npm install
348 | +RUN npm run build
349 | \\ No newline at end of file  
350 | `;
351 |     const { lastFrame } = render(
352 |       <OverflowProvider>
353 |         <DiffRenderer
354 |           diffContent={newFileDiff}
355 |           filename="Dockerfile"
356 |           terminalWidth={80}
357 |         />
358 |       </OverflowProvider>,
359 |     );
360 |     const output = lastFrame();
361 |     expect(output).toEqual(`1 FROM node:14
362 | 2 RUN npm install
363 | 3 RUN npm run build`);
364 |   });
365 | });
```

src/ui/components/messages/DiffRenderer.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type React from 'react';
8 | import { Box, Text, useIsScreenReaderEnabled } from 'ink';
9 | import crypto from 'node:crypto';
10 | import { colorizeCode, colorizeLine } from '../../utils/CodeColorizer.js';
11 | import { MaxSizedBox } from '../shared/MaxSizedBox.js';
12 | import { theme as semanticTheme } from '../../semantic-colors.js';
13 | import type { Theme } from '../../themes/theme.js';
14 | 
15 | interface DiffLine {
16 |   type: 'add' | 'del' | 'context' | 'hunk' | 'other';
17 |   oldLine?: number;
18 |   newLine?: number;
19 |   content: string;
20 | }
21 | 
22 | function parseDiffWithLineNumbers(diffContent: string): DiffLine[] {
23 |   const lines = diffContent.split('\n');
24 |   const result: DiffLine[] = [];
25 |   let currentOldLine = 0;
26 |   let currentNewLine = 0;
27 |   let inHunk = false;
28 |   const hunkHeaderRegex = /^@@ -(\d+),?\d* \+(\d+),?\d* @@/;
29 | 
30 |   for (const line of lines) {
31 |     const hunkMatch = line.match(hunkHeaderRegex);
32 |     if (hunkMatch) {
33 |       currentOldLine = parseInt(hunkMatch[1], 10);
34 |       currentNewLine = parseInt(hunkMatch[2], 10);
35 |       inHunk = true;
36 |       result.push({ type: 'hunk', content: line });
37 |       // We need to adjust the starting point because the first line number applies to the *first* actual line change/context,
38 |       // but we increment *before* pushing that line. So decrement here.
39 |       currentOldLine--;
40 |       currentNewLine--;
41 |       continue;
42 |     }
43 |     if (!inHunk) {
44 |       // Skip standard Git header lines more robustly
45 |       if (line.startsWith('--- ')) {
46 |         continue;
47 |       }
48 |       // If it's not a hunk or header, skip (or handle as 'other' if needed)
49 |       continue;
50 |     }
51 |     if (line.startsWith('+')) {
52 |       currentNewLine++; // Increment before pushing
53 |       result.push({
54 |         type: 'add',
55 |         newLine: currentNewLine,
56 |         content: line.substring(1),
57 |       });
58 |     } else if (line.startsWith('-')) {
59 |       currentOldLine++; // Increment before pushing
60 |       result.push({
61 |         type: 'del',
62 |         oldLine: currentOldLine,
63 |         content: line.substring(1),
64 |       });
65 |     } else if (line.startsWith(' ')) {
66 |       currentOldLine++; // Increment before pushing
67 |       currentNewLine++;
68 |       result.push({
69 |         type: 'context',
70 |         oldLine: currentOldLine,
71 |         newLine: currentNewLine,
72 |         content: line.substring(1),
73 |       });
74 |     } else if (line.startsWith('\\')) {
75 |       // Handle "\ No newline at end of file"
76 |       result.push({ type: 'other', content: line });
77 |     }
78 |   }
79 |   return result;
80 | }
81 | 
82 | interface DiffRendererProps {
83 |   diffContent: string;
84 |   filename?: string;
85 |   tabWidth?: number;
86 |   availableTerminalHeight?: number;
87 |   terminalWidth: number;
88 |   theme?: Theme;
89 | }
90 | 
91 | const DEFAULT_TAB_WIDTH = 4; // Spaces per tab for normalization
92 | 
93 | export const DiffRenderer: React.FC<DiffRendererProps> = ({
94 |   diffContent,
95 |   filename,
96 |   tabWidth = DEFAULT_TAB_WIDTH,
97 |   availableTerminalHeight,
98 |   terminalWidth,
99 |   theme,
100 | }) => {
101 |   const screenReaderEnabled = useIsScreenReaderEnabled();
102 |   if (!diffContent || typeof diffContent !== 'string') {
103 |     return <Text color={semanticTheme.status.warning}>No diff content.</Text>;
104 |   }
105 | 
106 |   const parsedLines = parseDiffWithLineNumbers(diffContent);
107 | 
108 |   if (parsedLines.length === 0) {
109 |     return (
110 |       <Box
111 |         borderStyle="round"
112 |         borderColor={semanticTheme.border.default}
113 |         padding={1}
114 |       >
115 |         <Text dimColor>No changes detected.</Text>
116 |       </Box>
117 |     );
118 |   }
119 |   if (screenReaderEnabled) {
120 |     return (
121 |       <Box flexDirection="column">
122 |         {parsedLines.map((line, index) => (
123 |           <Text key={index}>
124 |             {line.type}: {line.content}
125 |           </Text>
126 |         ))}
127 |       </Box>
128 |     );
129 |   }
130 | 
131 |   // Check if the diff represents a new file (only additions and header lines)
132 |   const isNewFile = parsedLines.every(
133 |     (line) =>
134 |       line.type === 'add' ||
135 |       line.type === 'hunk' ||
136 |       line.type === 'other' ||
137 |       line.content.startsWith('diff --git') ||
138 |       line.content.startsWith('new file mode'),
139 |   );
140 | 
141 |   let renderedOutput;
142 | 
143 |   if (isNewFile) {
144 |     // Extract only the added lines' content
145 |     const addedContent = parsedLines
146 |       .filter((line) => line.type === 'add')
147 |       .map((line) => line.content)
148 |       .join('\n');
149 |     // Attempt to infer language from filename, default to plain text if no filename
150 |     const fileExtension = filename?.split('.').pop() || null;
151 |     const language = fileExtension
152 |       ? getLanguageFromExtension(fileExtension)
153 |       : null;
154 |     renderedOutput = colorizeCode(
155 |       addedContent,
156 |       language,
157 |       availableTerminalHeight,
158 |       terminalWidth,
159 |       theme,
160 |     );
161 |   } else {
162 |     renderedOutput = renderDiffContent(
163 |       parsedLines,
164 |       filename,
165 |       tabWidth,
166 |       availableTerminalHeight,
167 |       terminalWidth,
168 |     );
169 |   }
170 | 
171 |   return renderedOutput;
172 | };
173 | 
174 | const renderDiffContent = (
175 |   parsedLines: DiffLine[],
176 |   filename: string | undefined,
177 |   tabWidth = DEFAULT_TAB_WIDTH,
178 |   availableTerminalHeight: number | undefined,
179 |   terminalWidth: number,
180 | ) => {
181 |   // 1. Normalize whitespace (replace tabs with spaces) *before* further processing
182 |   const normalizedLines = parsedLines.map((line) => ({
183 |     ...line,
184 |     content: line.content.replace(/\t/g, ' '.repeat(tabWidth)),
185 |   }));
186 | 
187 |   // Filter out non-displayable lines (hunks, potentially 'other') using the normalized list
188 |   const displayableLines = normalizedLines.filter(
189 |     (l) => l.type !== 'hunk' && l.type !== 'other',
190 |   );
191 | 
192 |   if (displayableLines.length === 0) {
193 |     return (
194 |       <Box
195 |         borderStyle="round"
196 |         borderColor={semanticTheme.border.default}
197 |         padding={1}
198 |       >
199 |         <Text dimColor>No changes detected.</Text>
200 |       </Box>
201 |     );
202 |   }
203 | 
204 |   const maxLineNumber = Math.max(
205 |     0,
206 |     ...displayableLines.map((l) => l.oldLine ?? 0),
207 |     ...displayableLines.map((l) => l.newLine ?? 0),
208 |   );
209 |   const gutterWidth = Math.max(1, maxLineNumber.toString().length);
210 | 
211 |   const fileExtension = filename?.split('.').pop() || null;
212 |   const language = fileExtension
213 |     ? getLanguageFromExtension(fileExtension)
214 |     : null;
215 | 
216 |   // Calculate the minimum indentation across all displayable lines
217 |   let baseIndentation = Infinity; // Start high to find the minimum
218 |   for (const line of displayableLines) {
219 |     // Only consider lines with actual content for indentation calculation
220 |     if (line.content.trim() === '') continue;
221 | 
222 |     const firstCharIndex = line.content.search(/\S/); // Find index of first non-whitespace char
223 |     const currentIndent = firstCharIndex === -1 ? 0 : firstCharIndex; // Indent is 0 if no non-whitespace found
224 |     baseIndentation = Math.min(baseIndentation, currentIndent);
225 |   }
226 |   // If baseIndentation remained Infinity (e.g., no displayable lines with content), default to 0
227 |   if (!isFinite(baseIndentation)) {
228 |     baseIndentation = 0;
229 |   }
230 | 
231 |   const key = filename
232 |     ? `diff-box-${filename}`
233 |     : `diff-box-${crypto.createHash('sha1').update(JSON.stringify(parsedLines)).digest('hex')}`;
234 | 
235 |   let lastLineNumber: number | null = null;
236 |   const MAX_CONTEXT_LINES_WITHOUT_GAP = 5;
237 | 
238 |   return (
239 |     <MaxSizedBox
240 |       maxHeight={availableTerminalHeight}
241 |       maxWidth={terminalWidth}
242 |       key={key}
243 |     >
244 |       {displayableLines.reduce<React.ReactNode[]>((acc, line, index) => {
245 |         // Determine the relevant line number for gap calculation based on type
246 |         let relevantLineNumberForGapCalc: number | null = null;
247 |         if (line.type === 'add' || line.type === 'context') {
248 |           relevantLineNumberForGapCalc = line.newLine ?? null;
249 |         } else if (line.type === 'del') {
250 |           // For deletions, the gap is typically in relation to the original file's line numbering
251 |           relevantLineNumberForGapCalc = line.oldLine ?? null;
252 |         }
253 | 
254 |         if (
255 |           lastLineNumber !== null &&
256 |           relevantLineNumberForGapCalc !== null &&
257 |           relevantLineNumberForGapCalc >
258 |             lastLineNumber + MAX_CONTEXT_LINES_WITHOUT_GAP + 1
259 |         ) {
260 |           acc.push(
261 |             <Box key={`gap-${index}`}>
262 |               <Text wrap="truncate" color={semanticTheme.text.secondary}>
263 |                 {'═'.repeat(terminalWidth)}
264 |               </Text>
265 |             </Box>,
266 |           );
267 |         }
268 | 
269 |         const lineKey = `diff-line-${index}`;
270 |         let gutterNumStr = '';
271 |         let prefixSymbol = ' ';
272 | 
273 |         switch (line.type) {
274 |           case 'add':
275 |             gutterNumStr = (line.newLine ?? '').toString();
276 |             prefixSymbol = '+';
277 |             lastLineNumber = line.newLine ?? null;
278 |             break;
279 |           case 'del':
280 |             gutterNumStr = (line.oldLine ?? '').toString();
281 |             prefixSymbol = '-';
282 |             // For deletions, update lastLineNumber based on oldLine if it's advancing.
283 |             // This helps manage gaps correctly if there are multiple consecutive deletions
284 |             // or if a deletion is followed by a context line far away in the original file.
285 |             if (line.oldLine !== undefined) {
286 |               lastLineNumber = line.oldLine;
287 |             }
288 |             break;
289 |           case 'context':
290 |             gutterNumStr = (line.newLine ?? '').toString();
291 |             prefixSymbol = ' ';
292 |             lastLineNumber = line.newLine ?? null;
293 |             break;
294 |           default:
295 |             return acc;
296 |         }
297 | 
298 |         const displayContent = line.content.substring(baseIndentation);
299 | 
300 |         acc.push(
301 |           <Box key={lineKey} flexDirection="row">
302 |             <Text
303 |               color={semanticTheme.text.secondary}
304 |               backgroundColor={
305 |                 line.type === 'add'
306 |                   ? semanticTheme.background.diff.added
307 |                   : line.type === 'del'
308 |                     ? semanticTheme.background.diff.removed
309 |                     : undefined
310 |               }
311 |             >
312 |               {gutterNumStr.padStart(gutterWidth)}{' '}
313 |             </Text>
314 |             {line.type === 'context' ? (
315 |               <>
316 |                 <Text>{prefixSymbol} </Text>
317 |                 <Text wrap="wrap">
318 |                   {colorizeLine(displayContent, language)}
319 |                 </Text>
320 |               </>
321 |             ) : (
322 |               <Text
323 |                 backgroundColor={
324 |                   line.type === 'add'
325 |                     ? semanticTheme.background.diff.added
326 |                     : semanticTheme.background.diff.removed
327 |                 }
328 |                 wrap="wrap"
329 |               >
330 |                 <Text
331 |                   color={
332 |                     line.type === 'add'
333 |                       ? semanticTheme.status.success
334 |                       : semanticTheme.status.error
335 |                   }
336 |                 >
337 |                   {prefixSymbol}
338 |                 </Text>{' '}
339 |                 {colorizeLine(displayContent, language)}
340 |               </Text>
341 |             )}
342 |           </Box>,
343 |         );
344 |         return acc;
345 |       }, [])}
346 |     </MaxSizedBox>
347 |   );
348 | };
349 | 
350 | const getLanguageFromExtension = (extension: string): string | null => {
351 |   const languageMap: { [key: string]: string } = {
352 |     js: 'javascript',
353 |     ts: 'typescript',
354 |     py: 'python',
355 |     json: 'json',
356 |     css: 'css',
357 |     html: 'html',
358 |     sh: 'bash',
359 |     md: 'markdown',
360 |     yaml: 'yaml',
361 |     yml: 'yaml',
362 |     txt: 'plaintext',
363 |     java: 'java',
364 |     c: 'c',
365 |     cpp: 'cpp',
366 |     rb: 'ruby',
367 |   };
[TRUNCATED]
```

src/ui/components/messages/ErrorMessage.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type React from 'react';
8 | import { Text, Box } from 'ink';
9 | import { theme } from '../../semantic-colors.js';
10 | 
11 | interface ErrorMessageProps {
12 |   text: string;
13 | }
14 | 
15 | export const ErrorMessage: React.FC<ErrorMessageProps> = ({ text }) => {
16 |   const prefix = '✕ ';
17 |   const prefixWidth = prefix.length;
18 | 
19 |   return (
20 |     <Box flexDirection="row" marginBottom={1}>
21 |       <Box width={prefixWidth}>
22 |         <Text color={theme.status.error}>{prefix}</Text>
23 |       </Box>
24 |       <Box flexGrow={1}>
25 |         <Text wrap="wrap" color={theme.status.error}>
26 |           {text}
27 |         </Text>
28 |       </Box>
29 |     </Box>
30 |   );
31 | };
```

src/ui/components/messages/GeminiMessage.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type React from 'react';
8 | import { Text, Box } from 'ink';
9 | import { MarkdownDisplay } from '../../utils/MarkdownDisplay.js';
10 | import { theme } from '../../semantic-colors.js';
11 | import { SCREEN_READER_MODEL_PREFIX } from '../../textConstants.js';
12 | 
13 | interface GeminiMessageProps {
14 |   text: string;
15 |   isPending: boolean;
16 |   availableTerminalHeight?: number;
17 |   terminalWidth: number;
18 | }
19 | 
20 | export const GeminiMessage: React.FC<GeminiMessageProps> = ({
21 |   text,
22 |   isPending,
23 |   availableTerminalHeight,
24 |   terminalWidth,
25 | }) => {
26 |   const prefix = '✦ ';
27 |   const prefixWidth = prefix.length;
28 | 
29 |   return (
30 |     <Box flexDirection="row">
31 |       <Box width={prefixWidth}>
32 |         <Text color={theme.text.accent} aria-label={SCREEN_READER_MODEL_PREFIX}>
33 |           {prefix}
34 |         </Text>
35 |       </Box>
36 |       <Box flexGrow={1} flexDirection="column">
37 |         <MarkdownDisplay
38 |           text={text}
39 |           isPending={isPending}
40 |           availableTerminalHeight={availableTerminalHeight}
41 |           terminalWidth={terminalWidth}
42 |         />
43 |       </Box>
44 |     </Box>
45 |   );
46 | };
```

src/ui/components/messages/GeminiMessageContent.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type React from 'react';
8 | import { Box } from 'ink';
9 | import { MarkdownDisplay } from '../../utils/MarkdownDisplay.js';
10 | 
11 | interface GeminiMessageContentProps {
12 |   text: string;
13 |   isPending: boolean;
14 |   availableTerminalHeight?: number;
15 |   terminalWidth: number;
16 | }
17 | 
18 | /*
19 |  * Gemini message content is a semi-hacked component. The intention is to represent a partial
20 |  * of GeminiMessage and is only used when a response gets too long. In that instance messages
21 |  * are split into multiple GeminiMessageContent's to enable the root <Static> component in
22 |  * App.tsx to be as performant as humanly possible.
23 |  */
24 | export const GeminiMessageContent: React.FC<GeminiMessageContentProps> = ({
25 |   text,
26 |   isPending,
27 |   availableTerminalHeight,
28 |   terminalWidth,
29 | }) => {
30 |   const originalPrefix = '✦ ';
31 |   const prefixWidth = originalPrefix.length;
32 | 
33 |   return (
34 |     <Box flexDirection="column" paddingLeft={prefixWidth}>
35 |       <MarkdownDisplay
36 |         text={text}
37 |         isPending={isPending}
38 |         availableTerminalHeight={availableTerminalHeight}
39 |         terminalWidth={terminalWidth}
40 |       />
41 |     </Box>
42 |   );
43 | };
```

src/ui/components/messages/InfoMessage.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type React from 'react';
8 | import { Text, Box } from 'ink';
9 | import { theme } from '../../semantic-colors.js';
10 | import { RenderInline } from '../../utils/InlineMarkdownRenderer.js';
11 | 
12 | interface InfoMessageProps {
13 |   text: string;
14 | }
15 | 
16 | export const InfoMessage: React.FC<InfoMessageProps> = ({ text }) => {
17 |   const prefix = 'ℹ ';
18 |   const prefixWidth = prefix.length;
19 | 
20 |   return (
21 |     <Box flexDirection="row" marginTop={1}>
22 |       <Box width={prefixWidth}>
23 |         <Text color={theme.status.warning}>{prefix}</Text>
24 |       </Box>
25 |       <Box flexGrow={1}>
26 |         <Text wrap="wrap" color={theme.status.warning}>
27 |           <RenderInline text={text} />
28 |         </Text>
29 |       </Box>
30 |     </Box>
31 |   );
32 | };
```

src/ui/components/messages/ToolConfirmationMessage.test.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect, vi } from 'vitest';
8 | import { ToolConfirmationMessage } from './ToolConfirmationMessage.js';
9 | import type {
10 |   ToolCallConfirmationDetails,
11 |   Config,
12 | } from '@google/gemini-cli-core';
13 | import { renderWithProviders } from '../../../test-utils/render.js';
14 | 
15 | describe('ToolConfirmationMessage', () => {
16 |   const mockConfig = {
17 |     isTrustedFolder: () => true,
18 |     getIdeMode: () => false,
19 |   } as unknown as Config;
20 | 
21 |   it('should not display urls if prompt and url are the same', () => {
22 |     const confirmationDetails: ToolCallConfirmationDetails = {
23 |       type: 'info',
24 |       title: 'Confirm Web Fetch',
25 |       prompt: 'https://example.com',
26 |       urls: ['https://example.com'],
27 |       onConfirm: vi.fn(),
28 |     };
29 | 
30 |     const { lastFrame } = renderWithProviders(
31 |       <ToolConfirmationMessage
32 |         confirmationDetails={confirmationDetails}
33 |         config={mockConfig}
34 |         availableTerminalHeight={30}
35 |         terminalWidth={80}
36 |       />,
37 |     );
38 | 
39 |     expect(lastFrame()).not.toContain('URLs to fetch:');
40 |   });
41 | 
42 |   it('should display urls if prompt and url are different', () => {
43 |     const confirmationDetails: ToolCallConfirmationDetails = {
44 |       type: 'info',
45 |       title: 'Confirm Web Fetch',
46 |       prompt:
47 |         'fetch https://github.com/google/gemini-react/blob/main/README.md',
48 |       urls: [
49 |         'https://raw.githubusercontent.com/google/gemini-react/main/README.md',
50 |       ],
51 |       onConfirm: vi.fn(),
52 |     };
53 | 
54 |     const { lastFrame } = renderWithProviders(
55 |       <ToolConfirmationMessage
56 |         confirmationDetails={confirmationDetails}
57 |         config={mockConfig}
58 |         availableTerminalHeight={30}
59 |         terminalWidth={80}
60 |       />,
61 |     );
62 | 
63 |     expect(lastFrame()).toContain('URLs to fetch:');
64 |     expect(lastFrame()).toContain(
65 |       '- https://raw.githubusercontent.com/google/gemini-react/main/README.md',
66 |     );
67 |   });
68 | 
69 |   describe('with folder trust', () => {
70 |     const editConfirmationDetails: ToolCallConfirmationDetails = {
71 |       type: 'edit',
72 |       title: 'Confirm Edit',
73 |       fileName: 'test.txt',
74 |       filePath: '/test.txt',
75 |       fileDiff: '...diff...',
76 |       originalContent: 'a',
77 |       newContent: 'b',
78 |       onConfirm: vi.fn(),
79 |     };
80 | 
81 |     const execConfirmationDetails: ToolCallConfirmationDetails = {
82 |       type: 'exec',
83 |       title: 'Confirm Execution',
84 |       command: 'echo "hello"',
85 |       rootCommand: 'echo',
86 |       onConfirm: vi.fn(),
87 |     };
88 | 
89 |     const infoConfirmationDetails: ToolCallConfirmationDetails = {
90 |       type: 'info',
91 |       title: 'Confirm Web Fetch',
92 |       prompt: 'https://example.com',
93 |       urls: ['https://example.com'],
94 |       onConfirm: vi.fn(),
95 |     };
96 | 
97 |     const mcpConfirmationDetails: ToolCallConfirmationDetails = {
98 |       type: 'mcp',
99 |       title: 'Confirm MCP Tool',
100 |       serverName: 'test-server',
101 |       toolName: 'test-tool',
102 |       toolDisplayName: 'Test Tool',
103 |       onConfirm: vi.fn(),
104 |     };
105 | 
106 |     describe.each([
107 |       {
108 |         description: 'for edit confirmations',
109 |         details: editConfirmationDetails,
110 |         alwaysAllowText: 'Yes, allow always',
111 |       },
112 |       {
113 |         description: 'for exec confirmations',
114 |         details: execConfirmationDetails,
115 |         alwaysAllowText: 'Yes, allow always',
116 |       },
117 |       {
118 |         description: 'for info confirmations',
119 |         details: infoConfirmationDetails,
120 |         alwaysAllowText: 'Yes, allow always',
121 |       },
122 |       {
123 |         description: 'for mcp confirmations',
124 |         details: mcpConfirmationDetails,
125 |         alwaysAllowText: 'always allow',
126 |       },
127 |     ])('$description', ({ details, alwaysAllowText }) => {
128 |       it('should show "allow always" when folder is trusted', () => {
129 |         const mockConfig = {
130 |           isTrustedFolder: () => true,
131 |           getIdeMode: () => false,
132 |         } as unknown as Config;
133 | 
134 |         const { lastFrame } = renderWithProviders(
135 |           <ToolConfirmationMessage
136 |             confirmationDetails={details}
137 |             config={mockConfig}
138 |             availableTerminalHeight={30}
139 |             terminalWidth={80}
140 |           />,
141 |         );
142 | 
143 |         expect(lastFrame()).toContain(alwaysAllowText);
144 |       });
145 | 
146 |       it('should NOT show "allow always" when folder is untrusted', () => {
147 |         const mockConfig = {
148 |           isTrustedFolder: () => false,
149 |           getIdeMode: () => false,
150 |         } as unknown as Config;
151 | 
152 |         const { lastFrame } = renderWithProviders(
153 |           <ToolConfirmationMessage
154 |             confirmationDetails={details}
155 |             config={mockConfig}
156 |             availableTerminalHeight={30}
157 |             terminalWidth={80}
158 |           />,
159 |         );
160 | 
161 |         expect(lastFrame()).not.toContain(alwaysAllowText);
162 |       });
163 |     });
164 |   });
165 | });
```

src/ui/components/messages/ToolConfirmationMessage.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type React from 'react';
8 | import { useEffect, useState } from 'react';
9 | import { Box, Text } from 'ink';
10 | import { DiffRenderer } from './DiffRenderer.js';
11 | import { RenderInline } from '../../utils/InlineMarkdownRenderer.js';
12 | import type {
13 |   ToolCallConfirmationDetails,
14 |   ToolExecuteConfirmationDetails,
15 |   ToolMcpConfirmationDetails,
16 |   Config,
17 | } from '@google/gemini-cli-core';
18 | import { IdeClient, ToolConfirmationOutcome } from '@google/gemini-cli-core';
19 | import type { RadioSelectItem } from '../shared/RadioButtonSelect.js';
20 | import { RadioButtonSelect } from '../shared/RadioButtonSelect.js';
21 | import { MaxSizedBox } from '../shared/MaxSizedBox.js';
22 | import { useKeypress } from '../../hooks/useKeypress.js';
23 | import { theme } from '../../semantic-colors.js';
24 | 
25 | export interface ToolConfirmationMessageProps {
26 |   confirmationDetails: ToolCallConfirmationDetails;
27 |   config: Config;
28 |   isFocused?: boolean;
29 |   availableTerminalHeight?: number;
30 |   terminalWidth: number;
31 | }
32 | 
33 | export const ToolConfirmationMessage: React.FC<
34 |   ToolConfirmationMessageProps
35 | > = ({
36 |   confirmationDetails,
37 |   config,
38 |   isFocused = true,
39 |   availableTerminalHeight,
40 |   terminalWidth,
41 | }) => {
42 |   const { onConfirm } = confirmationDetails;
43 |   const childWidth = terminalWidth - 2; // 2 for padding
44 | 
45 |   const [ideClient, setIdeClient] = useState<IdeClient | null>(null);
46 |   const [isDiffingEnabled, setIsDiffingEnabled] = useState(false);
47 | 
48 |   useEffect(() => {
49 |     let isMounted = true;
50 |     if (config.getIdeMode()) {
51 |       const getIdeClient = async () => {
52 |         const client = await IdeClient.getInstance();
53 |         if (isMounted) {
54 |           setIdeClient(client);
55 |           setIsDiffingEnabled(client?.isDiffingEnabled() ?? false);
56 |         }
57 |       };
58 |       getIdeClient();
59 |     }
60 |     return () => {
61 |       isMounted = false;
62 |     };
63 |   }, [config]);
64 | 
65 |   const handleConfirm = async (outcome: ToolConfirmationOutcome) => {
66 |     if (confirmationDetails.type === 'edit') {
67 |       if (config.getIdeMode() && isDiffingEnabled) {
68 |         const cliOutcome =
69 |           outcome === ToolConfirmationOutcome.Cancel ? 'rejected' : 'accepted';
70 |         await ideClient?.resolveDiffFromCli(
71 |           confirmationDetails.filePath,
72 |           cliOutcome,
73 |         );
74 |       }
75 |     }
76 |     onConfirm(outcome);
77 |   };
78 | 
79 |   const isTrustedFolder = config.isTrustedFolder();
80 | 
81 |   useKeypress(
82 |     (key) => {
83 |       if (!isFocused) return;
84 |       if (key.name === 'escape' || (key.ctrl && key.name === 'c')) {
85 |         handleConfirm(ToolConfirmationOutcome.Cancel);
86 |       }
87 |     },
88 |     { isActive: isFocused },
89 |   );
90 | 
91 |   const handleSelect = (item: ToolConfirmationOutcome) => handleConfirm(item);
92 | 
93 |   let bodyContent: React.ReactNode | null = null; // Removed contextDisplay here
94 |   let question: string;
95 | 
96 |   const options: Array<RadioSelectItem<ToolConfirmationOutcome>> = new Array<
97 |     RadioSelectItem<ToolConfirmationOutcome>
98 |   >();
99 | 
100 |   // Body content is now the DiffRenderer, passing filename to it
101 |   // The bordered box is removed from here and handled within DiffRenderer
102 | 
103 |   function availableBodyContentHeight() {
104 |     if (options.length === 0) {
105 |       // This should not happen in practice as options are always added before this is called.
106 |       throw new Error('Options not provided for confirmation message');
107 |     }
108 | 
109 |     if (availableTerminalHeight === undefined) {
110 |       return undefined;
111 |     }
112 | 
113 |     // Calculate the vertical space (in lines) consumed by UI elements
114 |     // surrounding the main body content.
115 |     const PADDING_OUTER_Y = 2; // Main container has `padding={1}` (top & bottom).
116 |     const MARGIN_BODY_BOTTOM = 1; // margin on the body container.
117 |     const HEIGHT_QUESTION = 1; // The question text is one line.
118 |     const MARGIN_QUESTION_BOTTOM = 1; // Margin on the question container.
119 |     const HEIGHT_OPTIONS = options.length; // Each option in the radio select takes one line.
120 | 
121 |     const surroundingElementsHeight =
122 |       PADDING_OUTER_Y +
123 |       MARGIN_BODY_BOTTOM +
124 |       HEIGHT_QUESTION +
125 |       MARGIN_QUESTION_BOTTOM +
126 |       HEIGHT_OPTIONS;
127 |     return Math.max(availableTerminalHeight - surroundingElementsHeight, 1);
128 |   }
129 | 
130 |   if (confirmationDetails.type === 'edit') {
131 |     if (confirmationDetails.isModifying) {
132 |       return (
133 |         <Box
134 |           width={terminalWidth}
135 |           borderStyle="round"
136 |           borderColor={theme.border.default}
137 |           justifyContent="space-around"
138 |           padding={1}
139 |           overflow="hidden"
140 |         >
141 |           <Text color={theme.text.primary}>Modify in progress: </Text>
142 |           <Text color={theme.status.success}>
143 |             Save and close external editor to continue
144 |           </Text>
145 |         </Box>
146 |       );
147 |     }
148 | 
149 |     question = `Apply this change?`;
150 |     options.push({
151 |       label: 'Yes, allow once',
152 |       value: ToolConfirmationOutcome.ProceedOnce,
153 |       key: 'Yes, allow once',
154 |     });
155 |     if (isTrustedFolder) {
156 |       options.push({
157 |         label: 'Yes, allow always',
158 |         value: ToolConfirmationOutcome.ProceedAlways,
159 |         key: 'Yes, allow always',
160 |       });
161 |     }
162 |     if (!config.getIdeMode() || !isDiffingEnabled) {
163 |       options.push({
164 |         label: 'Modify with external editor',
165 |         value: ToolConfirmationOutcome.ModifyWithEditor,
166 |         key: 'Modify with external editor',
167 |       });
168 |     }
169 | 
170 |     options.push({
171 |       label: 'No, suggest changes (esc)',
172 |       value: ToolConfirmationOutcome.Cancel,
173 |       key: 'No, suggest changes (esc)',
174 |     });
175 | 
176 |     bodyContent = (
177 |       <DiffRenderer
178 |         diffContent={confirmationDetails.fileDiff}
179 |         filename={confirmationDetails.fileName}
180 |         availableTerminalHeight={availableBodyContentHeight()}
181 |         terminalWidth={childWidth}
182 |       />
183 |     );
184 |   } else if (confirmationDetails.type === 'exec') {
185 |     const executionProps =
186 |       confirmationDetails as ToolExecuteConfirmationDetails;
187 | 
188 |     question = `Allow execution of: '${executionProps.rootCommand}'?`;
189 |     options.push({
190 |       label: 'Yes, allow once',
191 |       value: ToolConfirmationOutcome.ProceedOnce,
192 |       key: 'Yes, allow once',
193 |     });
194 |     if (isTrustedFolder) {
195 |       options.push({
196 |         label: `Yes, allow always ...`,
197 |         value: ToolConfirmationOutcome.ProceedAlways,
198 |         key: `Yes, allow always ...`,
199 |       });
200 |     }
201 |     options.push({
202 |       label: 'No, suggest changes (esc)',
203 |       value: ToolConfirmationOutcome.Cancel,
204 |       key: 'No, suggest changes (esc)',
205 |     });
206 | 
207 |     let bodyContentHeight = availableBodyContentHeight();
208 |     if (bodyContentHeight !== undefined) {
209 |       bodyContentHeight -= 2; // Account for padding;
210 |     }
211 |     bodyContent = (
212 |       <Box flexDirection="column">
213 |         <Box paddingX={1} marginLeft={1}>
214 |           <MaxSizedBox
215 |             maxHeight={bodyContentHeight}
216 |             maxWidth={Math.max(childWidth - 4, 1)}
217 |           >
218 |             <Box>
219 |               <Text color={theme.text.link}>{executionProps.command}</Text>
220 |             </Box>
221 |           </MaxSizedBox>
222 |         </Box>
223 |       </Box>
224 |     );
225 |   } else if (confirmationDetails.type === 'info') {
226 |     const infoProps = confirmationDetails;
227 |     const displayUrls =
228 |       infoProps.urls &&
229 |       !(infoProps.urls.length === 1 && infoProps.urls[0] === infoProps.prompt);
230 | 
231 |     question = `Do you want to proceed?`;
232 |     options.push({
233 |       label: 'Yes, allow once',
234 |       value: ToolConfirmationOutcome.ProceedOnce,
235 |       key: 'Yes, allow once',
236 |     });
237 |     if (isTrustedFolder) {
238 |       options.push({
239 |         label: 'Yes, allow always',
240 |         value: ToolConfirmationOutcome.ProceedAlways,
241 |         key: 'Yes, allow always',
242 |       });
243 |     }
244 |     options.push({
245 |       label: 'No, suggest changes (esc)',
246 |       value: ToolConfirmationOutcome.Cancel,
247 |       key: 'No, suggest changes (esc)',
248 |     });
249 | 
250 |     bodyContent = (
251 |       <Box flexDirection="column" paddingX={1} marginLeft={1}>
252 |         <Text color={theme.text.link}>
253 |           <RenderInline text={infoProps.prompt} />
254 |         </Text>
255 |         {displayUrls && infoProps.urls && infoProps.urls.length > 0 && (
256 |           <Box flexDirection="column" marginTop={1}>
257 |             <Text color={theme.text.primary}>URLs to fetch:</Text>
258 |             {infoProps.urls.map((url) => (
259 |               <Text key={url}>
260 |                 {' '}
261 |                 - <RenderInline text={url} />
262 |               </Text>
263 |             ))}
264 |           </Box>
265 |         )}
266 |       </Box>
267 |     );
268 |   } else {
269 |     // mcp tool confirmation
270 |     const mcpProps = confirmationDetails as ToolMcpConfirmationDetails;
271 | 
272 |     bodyContent = (
273 |       <Box flexDirection="column" paddingX={1} marginLeft={1}>
274 |         <Text color={theme.text.link}>MCP Server: {mcpProps.serverName}</Text>
275 |         <Text color={theme.text.link}>Tool: {mcpProps.toolName}</Text>
276 |       </Box>
277 |     );
278 | 
279 |     question = `Allow execution of MCP tool "${mcpProps.toolName}" from server "${mcpProps.serverName}"?`;
280 |     options.push({
281 |       label: 'Yes, allow once',
282 |       value: ToolConfirmationOutcome.ProceedOnce,
283 |       key: 'Yes, allow once',
284 |     });
285 |     if (isTrustedFolder) {
286 |       options.push({
287 |         label: `Yes, always allow tool "${mcpProps.toolName}" from server "${mcpProps.serverName}"`,
288 |         value: ToolConfirmationOutcome.ProceedAlwaysTool, // Cast until types are updated
289 |         key: `Yes, always allow tool "${mcpProps.toolName}" from server "${mcpProps.serverName}"`,
290 |       });
291 |       options.push({
292 |         label: `Yes, always allow all tools from server "${mcpProps.serverName}"`,
293 |         value: ToolConfirmationOutcome.ProceedAlwaysServer,
294 |         key: `Yes, always allow all tools from server "${mcpProps.serverName}"`,
295 |       });
296 |     }
297 |     options.push({
298 |       label: 'No, suggest changes (esc)',
299 |       value: ToolConfirmationOutcome.Cancel,
300 |       key: 'No, suggest changes (esc)',
301 |     });
302 |   }
303 | 
304 |   return (
305 |     <Box flexDirection="column" padding={1} width={childWidth}>
306 |       {/* Body Content (Diff Renderer or Command Info) */}
307 |       {/* No separate context display here anymore for edits */}
308 |       <Box flexGrow={1} flexShrink={1} overflow="hidden" marginBottom={1}>
309 |         {bodyContent}
310 |       </Box>
311 | 
312 |       {/* Confirmation Question */}
313 |       <Box marginBottom={1} flexShrink={0}>
314 |         <Text color={theme.text.primary} wrap="truncate">
315 |           {question}
316 |         </Text>
317 |       </Box>
318 | 
319 |       {/* Select Input for Options */}
320 |       <Box flexShrink={0}>
321 |         <RadioButtonSelect
322 |           items={options}
323 |           onSelect={handleSelect}
324 |           isFocused={isFocused}
325 |         />
326 |       </Box>
327 |     </Box>
328 |   );
329 | };
```

src/ui/components/messages/ToolGroupMessage.test.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { render } from 'ink-testing-library';
8 | import { describe, it, expect, vi } from 'vitest';
9 | import { Text } from 'ink';
10 | import type React from 'react';
11 | import { ToolGroupMessage } from './ToolGroupMessage.js';
12 | import type { IndividualToolCallDisplay } from '../../types.js';
13 | import { ToolCallStatus } from '../../types.js';
14 | import type {
15 |   Config,
16 |   ToolCallConfirmationDetails,
17 | } from '@google/gemini-cli-core';
18 | import { TOOL_STATUS } from '../../constants.js';
19 | import { ConfigContext } from '../../contexts/ConfigContext.js';
20 | 
21 | // Mock child components to isolate ToolGroupMessage behavior
22 | vi.mock('./ToolMessage.js', () => ({
23 |   ToolMessage: function MockToolMessage({
24 |     callId,
25 |     name,
26 |     description,
27 |     status,
28 |     emphasis,
29 |   }: {
30 |     callId: string;
31 |     name: string;
32 |     description: string;
33 |     status: ToolCallStatus;
34 |     emphasis: string;
35 |   }) {
36 |     // Use the same constants as the real component
37 |     const statusSymbolMap: Record<ToolCallStatus, string> = {
38 |       [ToolCallStatus.Success]: TOOL_STATUS.SUCCESS,
39 |       [ToolCallStatus.Pending]: TOOL_STATUS.PENDING,
40 |       [ToolCallStatus.Executing]: TOOL_STATUS.EXECUTING,
41 |       [ToolCallStatus.Confirming]: TOOL_STATUS.CONFIRMING,
42 |       [ToolCallStatus.Canceled]: TOOL_STATUS.CANCELED,
43 |       [ToolCallStatus.Error]: TOOL_STATUS.ERROR,
44 |     };
45 |     const statusSymbol = statusSymbolMap[status] || '?';
46 |     return (
47 |       <Text>
48 |         MockTool[{callId}]: {statusSymbol} {name} - {description} ({emphasis})
49 |       </Text>
50 |     );
51 |   },
52 | }));
53 | 
54 | vi.mock('./ToolConfirmationMessage.js', () => ({
55 |   ToolConfirmationMessage: function MockToolConfirmationMessage({
56 |     confirmationDetails,
57 |   }: {
58 |     confirmationDetails: ToolCallConfirmationDetails;
59 |   }) {
60 |     const displayText =
61 |       confirmationDetails?.type === 'info'
62 |         ? (confirmationDetails as { prompt: string }).prompt
63 |         : confirmationDetails?.title || 'confirm';
64 |     return <Text>MockConfirmation: {displayText}</Text>;
65 |   },
66 | }));
67 | 
68 | describe('<ToolGroupMessage />', () => {
69 |   const mockConfig: Config = {} as Config;
70 | 
71 |   const createToolCall = (
72 |     overrides: Partial<IndividualToolCallDisplay> = {},
73 |   ): IndividualToolCallDisplay => ({
74 |     callId: 'tool-123',
75 |     name: 'test-tool',
76 |     description: 'A tool for testing',
77 |     resultDisplay: 'Test result',
78 |     status: ToolCallStatus.Success,
79 |     confirmationDetails: undefined,
80 |     renderOutputAsMarkdown: false,
81 |     ...overrides,
82 |   });
83 | 
84 |   const baseProps = {
85 |     groupId: 1,
86 |     terminalWidth: 80,
87 |     isFocused: true,
88 |   };
89 | 
90 |   // Helper to wrap component with required providers
91 |   const renderWithProviders = (component: React.ReactElement) =>
92 |     render(
93 |       <ConfigContext.Provider value={mockConfig}>
94 |         {component}
95 |       </ConfigContext.Provider>,
96 |     );
97 | 
98 |   describe('Golden Snapshots', () => {
99 |     it('renders single successful tool call', () => {
100 |       const toolCalls = [createToolCall()];
101 |       const { lastFrame } = renderWithProviders(
102 |         <ToolGroupMessage {...baseProps} toolCalls={toolCalls} />,
103 |       );
104 |       expect(lastFrame()).toMatchSnapshot();
105 |     });
106 | 
107 |     it('renders multiple tool calls with different statuses', () => {
108 |       const toolCalls = [
109 |         createToolCall({
110 |           callId: 'tool-1',
111 |           name: 'successful-tool',
112 |           description: 'This tool succeeded',
113 |           status: ToolCallStatus.Success,
114 |         }),
115 |         createToolCall({
116 |           callId: 'tool-2',
117 |           name: 'pending-tool',
118 |           description: 'This tool is pending',
119 |           status: ToolCallStatus.Pending,
120 |         }),
121 |         createToolCall({
122 |           callId: 'tool-3',
123 |           name: 'error-tool',
124 |           description: 'This tool failed',
125 |           status: ToolCallStatus.Error,
126 |         }),
127 |       ];
128 |       const { lastFrame } = renderWithProviders(
129 |         <ToolGroupMessage {...baseProps} toolCalls={toolCalls} />,
130 |       );
131 |       expect(lastFrame()).toMatchSnapshot();
132 |     });
133 | 
134 |     it('renders tool call awaiting confirmation', () => {
135 |       const toolCalls = [
136 |         createToolCall({
137 |           callId: 'tool-confirm',
138 |           name: 'confirmation-tool',
139 |           description: 'This tool needs confirmation',
140 |           status: ToolCallStatus.Confirming,
141 |           confirmationDetails: {
142 |             type: 'info',
143 |             title: 'Confirm Tool Execution',
144 |             prompt: 'Are you sure you want to proceed?',
145 |             onConfirm: vi.fn(),
146 |           },
147 |         }),
148 |       ];
149 |       const { lastFrame } = renderWithProviders(
150 |         <ToolGroupMessage {...baseProps} toolCalls={toolCalls} />,
151 |       );
152 |       expect(lastFrame()).toMatchSnapshot();
153 |     });
154 | 
155 |     it('renders shell command with yellow border', () => {
156 |       const toolCalls = [
157 |         createToolCall({
158 |           callId: 'shell-1',
159 |           name: 'run_shell_command',
160 |           description: 'Execute shell command',
161 |           status: ToolCallStatus.Success,
162 |         }),
163 |       ];
164 |       const { lastFrame } = renderWithProviders(
165 |         <ToolGroupMessage {...baseProps} toolCalls={toolCalls} />,
166 |       );
167 |       expect(lastFrame()).toMatchSnapshot();
168 |     });
169 | 
170 |     it('renders mixed tool calls including shell command', () => {
171 |       const toolCalls = [
172 |         createToolCall({
173 |           callId: 'tool-1',
174 |           name: 'read_file',
175 |           description: 'Read a file',
176 |           status: ToolCallStatus.Success,
177 |         }),
178 |         createToolCall({
179 |           callId: 'tool-2',
180 |           name: 'run_shell_command',
181 |           description: 'Run command',
182 |           status: ToolCallStatus.Executing,
183 |         }),
184 |         createToolCall({
185 |           callId: 'tool-3',
186 |           name: 'write_file',
187 |           description: 'Write to file',
188 |           status: ToolCallStatus.Pending,
189 |         }),
190 |       ];
191 |       const { lastFrame } = renderWithProviders(
192 |         <ToolGroupMessage {...baseProps} toolCalls={toolCalls} />,
193 |       );
194 |       expect(lastFrame()).toMatchSnapshot();
195 |     });
196 | 
197 |     it('renders with limited terminal height', () => {
198 |       const toolCalls = [
199 |         createToolCall({
200 |           callId: 'tool-1',
201 |           name: 'tool-with-result',
202 |           description: 'Tool with output',
203 |           resultDisplay:
204 |             'This is a long result that might need height constraints',
205 |         }),
206 |         createToolCall({
207 |           callId: 'tool-2',
208 |           name: 'another-tool',
209 |           description: 'Another tool',
210 |           resultDisplay: 'More output here',
211 |         }),
212 |       ];
213 |       const { lastFrame } = renderWithProviders(
214 |         <ToolGroupMessage
215 |           {...baseProps}
216 |           toolCalls={toolCalls}
217 |           availableTerminalHeight={10}
218 |         />,
219 |       );
220 |       expect(lastFrame()).toMatchSnapshot();
221 |     });
222 | 
223 |     it('renders when not focused', () => {
224 |       const toolCalls = [createToolCall()];
225 |       const { lastFrame } = renderWithProviders(
226 |         <ToolGroupMessage
227 |           {...baseProps}
228 |           toolCalls={toolCalls}
229 |           isFocused={false}
230 |         />,
231 |       );
232 |       expect(lastFrame()).toMatchSnapshot();
233 |     });
234 | 
235 |     it('renders with narrow terminal width', () => {
236 |       const toolCalls = [
237 |         createToolCall({
238 |           name: 'very-long-tool-name-that-might-wrap',
239 |           description:
240 |             'This is a very long description that might cause wrapping issues',
241 |         }),
242 |       ];
243 |       const { lastFrame } = renderWithProviders(
244 |         <ToolGroupMessage
245 |           {...baseProps}
246 |           toolCalls={toolCalls}
247 |           terminalWidth={40}
248 |         />,
249 |       );
250 |       expect(lastFrame()).toMatchSnapshot();
251 |     });
252 | 
253 |     it('renders empty tool calls array', () => {
254 |       const { lastFrame } = renderWithProviders(
255 |         <ToolGroupMessage {...baseProps} toolCalls={[]} />,
256 |       );
257 |       expect(lastFrame()).toMatchSnapshot();
258 |     });
259 |   });
260 | 
261 |   describe('Border Color Logic', () => {
262 |     it('uses yellow border when tools are pending', () => {
263 |       const toolCalls = [createToolCall({ status: ToolCallStatus.Pending })];
264 |       const { lastFrame } = renderWithProviders(
265 |         <ToolGroupMessage {...baseProps} toolCalls={toolCalls} />,
266 |       );
267 |       // The snapshot will capture the visual appearance including border color
268 |       expect(lastFrame()).toMatchSnapshot();
269 |     });
270 | 
271 |     it('uses yellow border for shell commands even when successful', () => {
272 |       const toolCalls = [
273 |         createToolCall({
274 |           name: 'run_shell_command',
275 |           status: ToolCallStatus.Success,
276 |         }),
277 |       ];
278 |       const { lastFrame } = renderWithProviders(
279 |         <ToolGroupMessage {...baseProps} toolCalls={toolCalls} />,
280 |       );
281 |       expect(lastFrame()).toMatchSnapshot();
282 |     });
283 | 
284 |     it('uses gray border when all tools are successful and no shell commands', () => {
285 |       const toolCalls = [
286 |         createToolCall({ status: ToolCallStatus.Success }),
287 |         createToolCall({
288 |           callId: 'tool-2',
289 |           name: 'another-tool',
290 |           status: ToolCallStatus.Success,
291 |         }),
292 |       ];
293 |       const { lastFrame } = renderWithProviders(
294 |         <ToolGroupMessage {...baseProps} toolCalls={toolCalls} />,
295 |       );
296 |       expect(lastFrame()).toMatchSnapshot();
297 |     });
298 |   });
299 | 
300 |   describe('Height Calculation', () => {
301 |     it('calculates available height correctly with multiple tools with results', () => {
302 |       const toolCalls = [
303 |         createToolCall({
304 |           callId: 'tool-1',
305 |           resultDisplay: 'Result 1',
306 |         }),
307 |         createToolCall({
308 |           callId: 'tool-2',
309 |           resultDisplay: 'Result 2',
310 |         }),
311 |         createToolCall({
312 |           callId: 'tool-3',
313 |           resultDisplay: '', // No result
314 |         }),
315 |       ];
316 |       const { lastFrame } = renderWithProviders(
317 |         <ToolGroupMessage
318 |           {...baseProps}
319 |           toolCalls={toolCalls}
320 |           availableTerminalHeight={20}
321 |         />,
322 |       );
323 |       expect(lastFrame()).toMatchSnapshot();
324 |     });
325 |   });
326 | 
327 |   describe('Confirmation Handling', () => {
328 |     it('shows confirmation dialog for first confirming tool only', () => {
329 |       const toolCalls = [
330 |         createToolCall({
331 |           callId: 'tool-1',
332 |           name: 'first-confirm',
333 |           status: ToolCallStatus.Confirming,
334 |           confirmationDetails: {
335 |             type: 'info',
336 |             title: 'Confirm First Tool',
337 |             prompt: 'Confirm first tool',
338 |             onConfirm: vi.fn(),
339 |           },
340 |         }),
341 |         createToolCall({
342 |           callId: 'tool-2',
343 |           name: 'second-confirm',
344 |           status: ToolCallStatus.Confirming,
345 |           confirmationDetails: {
346 |             type: 'info',
347 |             title: 'Confirm Second Tool',
348 |             prompt: 'Confirm second tool',
349 |             onConfirm: vi.fn(),
350 |           },
351 |         }),
352 |       ];
353 |       const { lastFrame } = renderWithProviders(
354 |         <ToolGroupMessage {...baseProps} toolCalls={toolCalls} />,
355 |       );
356 |       // Should only show confirmation for the first tool
357 |       expect(lastFrame()).toMatchSnapshot();
358 |     });
359 |   });
360 | });
```

src/ui/components/messages/ToolGroupMessage.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type React from 'react';
8 | import { useMemo } from 'react';
9 | import { Box, Text } from 'ink';
10 | import type { IndividualToolCallDisplay } from '../../types.js';
11 | import { ToolCallStatus } from '../../types.js';
12 | import { ToolMessage } from './ToolMessage.js';
13 | import { ToolConfirmationMessage } from './ToolConfirmationMessage.js';
14 | import { theme } from '../../semantic-colors.js';
15 | import { SHELL_COMMAND_NAME, SHELL_NAME } from '../../constants.js';
16 | import { useConfig } from '../../contexts/ConfigContext.js';
17 | 
18 | interface ToolGroupMessageProps {
19 |   groupId: number;
20 |   toolCalls: IndividualToolCallDisplay[];
21 |   availableTerminalHeight?: number;
22 |   terminalWidth: number;
23 |   isFocused?: boolean;
24 |   activeShellPtyId?: number | null;
25 |   embeddedShellFocused?: boolean;
26 |   onShellInputSubmit?: (input: string) => void;
27 | }
28 | 
29 | // Main component renders the border and maps the tools using ToolMessage
30 | export const ToolGroupMessage: React.FC<ToolGroupMessageProps> = ({
31 |   toolCalls,
32 |   availableTerminalHeight,
33 |   terminalWidth,
34 |   isFocused = true,
35 |   activeShellPtyId,
36 |   embeddedShellFocused,
37 | }) => {
38 |   const isEmbeddedShellFocused =
39 |     embeddedShellFocused &&
40 |     toolCalls.some(
41 |       (t) =>
42 |         t.ptyId === activeShellPtyId && t.status === ToolCallStatus.Executing,
43 |     );
44 | 
45 |   const hasPending = !toolCalls.every(
46 |     (t) => t.status === ToolCallStatus.Success,
47 |   );
48 | 
49 |   const config = useConfig();
50 |   const isShellCommand = toolCalls.some(
51 |     (t) => t.name === SHELL_COMMAND_NAME || t.name === SHELL_NAME,
52 |   );
53 |   const borderColor =
54 |     isShellCommand || isEmbeddedShellFocused
55 |       ? theme.ui.symbol
56 |       : hasPending
57 |         ? theme.status.warning
58 |         : theme.border.default;
59 | 
60 |   const staticHeight = /* border */ 2 + /* marginBottom */ 1;
61 |   // This is a bit of a magic number, but it accounts for the border and
62 |   // marginLeft.
63 |   const innerWidth = terminalWidth - 4;
64 | 
65 |   // only prompt for tool approval on the first 'confirming' tool in the list
66 |   // note, after the CTA, this automatically moves over to the next 'confirming' tool
67 |   const toolAwaitingApproval = useMemo(
68 |     () => toolCalls.find((tc) => tc.status === ToolCallStatus.Confirming),
69 |     [toolCalls],
70 |   );
71 | 
72 |   let countToolCallsWithResults = 0;
73 |   for (const tool of toolCalls) {
74 |     if (tool.resultDisplay !== undefined && tool.resultDisplay !== '') {
75 |       countToolCallsWithResults++;
76 |     }
77 |   }
78 |   const countOneLineToolCalls = toolCalls.length - countToolCallsWithResults;
79 |   const availableTerminalHeightPerToolMessage = availableTerminalHeight
80 |     ? Math.max(
81 |         Math.floor(
82 |           (availableTerminalHeight - staticHeight - countOneLineToolCalls) /
83 |             Math.max(1, countToolCallsWithResults),
84 |         ),
85 |         1,
86 |       )
87 |     : undefined;
88 | 
89 |   return (
90 |     <Box
91 |       flexDirection="column"
92 |       borderStyle="round"
93 |       /*
94 |         This width constraint is highly important and protects us from an Ink rendering bug.
95 |         Since the ToolGroup can typically change rendering states frequently, it can cause
96 |         Ink to render the border of the box incorrectly and span multiple lines and even
97 |         cause tearing.
98 |       */
99 |       width={terminalWidth}
100 |       borderDimColor={
101 |         hasPending && (!isShellCommand || !isEmbeddedShellFocused)
102 |       }
103 |       borderColor={borderColor}
104 |       gap={1}
105 |     >
106 |       {toolCalls.map((tool) => {
107 |         const isConfirming = toolAwaitingApproval?.callId === tool.callId;
108 |         return (
109 |           <Box key={tool.callId} flexDirection="column" minHeight={1}>
110 |             <Box flexDirection="row" alignItems="center">
111 |               <ToolMessage
112 |                 {...tool}
113 |                 availableTerminalHeight={availableTerminalHeightPerToolMessage}
114 |                 terminalWidth={innerWidth}
115 |                 emphasis={
116 |                   isConfirming
117 |                     ? 'high'
118 |                     : toolAwaitingApproval
119 |                       ? 'low'
120 |                       : 'medium'
121 |                 }
122 |                 activeShellPtyId={activeShellPtyId}
123 |                 embeddedShellFocused={embeddedShellFocused}
124 |                 config={config}
125 |               />
126 |             </Box>
127 |             {tool.status === ToolCallStatus.Confirming &&
128 |               isConfirming &&
129 |               tool.confirmationDetails && (
130 |                 <ToolConfirmationMessage
131 |                   confirmationDetails={tool.confirmationDetails}
132 |                   config={config}
133 |                   isFocused={isFocused}
134 |                   availableTerminalHeight={
135 |                     availableTerminalHeightPerToolMessage
136 |                   }
137 |                   terminalWidth={innerWidth}
138 |                 />
139 |               )}
140 |             {tool.outputFile && (
141 |               <Box marginX={1}>
142 |                 <Text color={theme.text.primary}>
143 |                   Output too long and was saved to: {tool.outputFile}
144 |                 </Text>
145 |               </Box>
146 |             )}
147 |           </Box>
148 |         );
149 |       })}
150 |     </Box>
151 |   );
152 | };
```

src/ui/components/messages/ToolMessage.test.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import React from 'react';
8 | import { render } from 'ink-testing-library';
9 | import type { ToolMessageProps } from './ToolMessage.js';
10 | import { ToolMessage } from './ToolMessage.js';
11 | import { StreamingState, ToolCallStatus } from '../../types.js';
12 | import { Text } from 'ink';
13 | import { StreamingContext } from '../../contexts/StreamingContext.js';
14 | import type { AnsiOutput } from '@google/gemini-cli-core';
15 | 
16 | vi.mock('../TerminalOutput.js', () => ({
17 |   TerminalOutput: function MockTerminalOutput({
18 |     cursor,
19 |   }: {
20 |     cursor: { x: number; y: number } | null;
21 |   }) {
22 |     return (
23 |       <Text>
24 |         MockCursor:({cursor?.x},{cursor?.y})
25 |       </Text>
26 |     );
27 |   },
28 | }));
29 | 
30 | vi.mock('../AnsiOutput.js', () => ({
31 |   AnsiOutputText: function MockAnsiOutputText({ data }: { data: AnsiOutput }) {
32 |     // Simple serialization for snapshot stability
33 |     const serialized = data
34 |       .map((line) => line.map((token) => token.text || '').join(''))
35 |       .join('\n');
36 |     return <Text>MockAnsiOutput:{serialized}</Text>;
37 |   },
38 | }));
39 | 
40 | // Mock child components or utilities if they are complex or have side effects
41 | vi.mock('../GeminiRespondingSpinner.js', () => ({
42 |   GeminiRespondingSpinner: ({
43 |     nonRespondingDisplay,
44 |   }: {
45 |     nonRespondingDisplay?: string;
46 |   }) => {
47 |     const streamingState = React.useContext(StreamingContext)!;
48 |     if (streamingState === StreamingState.Responding) {
49 |       return <Text>MockRespondingSpinner</Text>;
50 |     }
51 |     return nonRespondingDisplay ? <Text>{nonRespondingDisplay}</Text> : null;
52 |   },
53 | }));
54 | vi.mock('./DiffRenderer.js', () => ({
55 |   DiffRenderer: function MockDiffRenderer({
56 |     diffContent,
57 |   }: {
58 |     diffContent: string;
59 |   }) {
60 |     return <Text>MockDiff:{diffContent}</Text>;
61 |   },
62 | }));
63 | vi.mock('../../utils/MarkdownDisplay.js', () => ({
64 |   MarkdownDisplay: function MockMarkdownDisplay({ text }: { text: string }) {
65 |     return <Text>MockMarkdown:{text}</Text>;
66 |   },
67 | }));
68 | 
69 | // Helper to render with context
70 | const renderWithContext = (
71 |   ui: React.ReactElement,
72 |   streamingState: StreamingState,
73 | ) => {
74 |   const contextValue: StreamingState = streamingState;
75 |   return render(
76 |     <StreamingContext.Provider value={contextValue}>
77 |       {ui}
78 |     </StreamingContext.Provider>,
79 |   );
80 | };
81 | 
82 | describe('<ToolMessage />', () => {
83 |   const baseProps: ToolMessageProps = {
84 |     callId: 'tool-123',
85 |     name: 'test-tool',
86 |     description: 'A tool for testing',
87 |     resultDisplay: 'Test result',
88 |     status: ToolCallStatus.Success,
89 |     terminalWidth: 80,
90 |     confirmationDetails: undefined,
91 |     emphasis: 'medium',
92 |   };
93 | 
94 |   it('renders basic tool information', () => {
95 |     const { lastFrame } = renderWithContext(
96 |       <ToolMessage {...baseProps} />,
97 |       StreamingState.Idle,
98 |     );
99 |     const output = lastFrame();
100 |     expect(output).toContain('✓'); // Success indicator
101 |     expect(output).toContain('test-tool');
102 |     expect(output).toContain('A tool for testing');
103 |     expect(output).toContain('MockMarkdown:Test result');
104 |   });
105 | 
106 |   describe('ToolStatusIndicator rendering', () => {
107 |     it('shows ✓ for Success status', () => {
108 |       const { lastFrame } = renderWithContext(
109 |         <ToolMessage {...baseProps} status={ToolCallStatus.Success} />,
110 |         StreamingState.Idle,
111 |       );
112 |       expect(lastFrame()).toContain('✓');
113 |     });
114 | 
115 |     it('shows o for Pending status', () => {
116 |       const { lastFrame } = renderWithContext(
117 |         <ToolMessage {...baseProps} status={ToolCallStatus.Pending} />,
118 |         StreamingState.Idle,
119 |       );
120 |       expect(lastFrame()).toContain('o');
121 |     });
122 | 
123 |     it('shows ? for Confirming status', () => {
124 |       const { lastFrame } = renderWithContext(
125 |         <ToolMessage {...baseProps} status={ToolCallStatus.Confirming} />,
126 |         StreamingState.Idle,
127 |       );
128 |       expect(lastFrame()).toContain('?');
129 |     });
130 | 
131 |     it('shows - for Canceled status', () => {
132 |       const { lastFrame } = renderWithContext(
133 |         <ToolMessage {...baseProps} status={ToolCallStatus.Canceled} />,
134 |         StreamingState.Idle,
135 |       );
136 |       expect(lastFrame()).toContain('-');
137 |     });
138 | 
139 |     it('shows x for Error status', () => {
140 |       const { lastFrame } = renderWithContext(
141 |         <ToolMessage {...baseProps} status={ToolCallStatus.Error} />,
142 |         StreamingState.Idle,
143 |       );
144 |       expect(lastFrame()).toContain('x');
145 |     });
146 | 
147 |     it('shows paused spinner for Executing status when streamingState is Idle', () => {
148 |       const { lastFrame } = renderWithContext(
149 |         <ToolMessage {...baseProps} status={ToolCallStatus.Executing} />,
150 |         StreamingState.Idle,
151 |       );
152 |       expect(lastFrame()).toContain('⊷');
153 |       expect(lastFrame()).not.toContain('MockRespondingSpinner');
154 |       expect(lastFrame()).not.toContain('✓');
155 |     });
156 | 
157 |     it('shows paused spinner for Executing status when streamingState is WaitingForConfirmation', () => {
158 |       const { lastFrame } = renderWithContext(
159 |         <ToolMessage {...baseProps} status={ToolCallStatus.Executing} />,
160 |         StreamingState.WaitingForConfirmation,
161 |       );
162 |       expect(lastFrame()).toContain('⊷');
163 |       expect(lastFrame()).not.toContain('MockRespondingSpinner');
164 |       expect(lastFrame()).not.toContain('✓');
165 |     });
166 | 
167 |     it('shows MockRespondingSpinner for Executing status when streamingState is Responding', () => {
168 |       const { lastFrame } = renderWithContext(
169 |         <ToolMessage {...baseProps} status={ToolCallStatus.Executing} />,
170 |         StreamingState.Responding, // Simulate app still responding
171 |       );
172 |       expect(lastFrame()).toContain('MockRespondingSpinner');
173 |       expect(lastFrame()).not.toContain('✓');
174 |     });
175 |   });
176 | 
177 |   it('renders DiffRenderer for diff results', () => {
178 |     const diffResult = {
179 |       fileDiff: '--- a/file.txt\n+++ b/file.txt\n@@ -1 +1 @@\n-old\n+new',
180 |       fileName: 'file.txt',
181 |       originalContent: 'old',
182 |       newContent: 'new',
183 |     };
184 |     const { lastFrame } = renderWithContext(
185 |       <ToolMessage {...baseProps} resultDisplay={diffResult} />,
186 |       StreamingState.Idle,
187 |     );
188 |     // Check that the output contains the MockDiff content as part of the whole message
189 |     expect(lastFrame()).toMatch(/MockDiff:--- a\/file\.txt/);
190 |   });
191 | 
192 |   it('renders emphasis correctly', () => {
193 |     const { lastFrame: highEmphasisFrame } = renderWithContext(
194 |       <ToolMessage {...baseProps} emphasis="high" />,
195 |       StreamingState.Idle,
196 |     );
197 |     // Check for trailing indicator or specific color if applicable (Colors are not easily testable here)
198 |     expect(highEmphasisFrame()).toContain('←'); // Trailing indicator for high emphasis
199 | 
200 |     const { lastFrame: lowEmphasisFrame } = renderWithContext(
201 |       <ToolMessage {...baseProps} emphasis="low" />,
202 |       StreamingState.Idle,
203 |     );
204 |     // For low emphasis, the name and description might be dimmed (check for dimColor if possible)
205 |     // This is harder to assert directly in text output without color checks.
206 |     // We can at least ensure it doesn't have the high emphasis indicator.
207 |     expect(lowEmphasisFrame()).not.toContain('←');
208 |   });
209 | 
210 |   it('renders AnsiOutputText for AnsiOutput results', () => {
211 |     const ansiResult: AnsiOutput = [
212 |       [
213 |         {
214 |           text: 'hello',
215 |           fg: '#ffffff',
216 |           bg: '#000000',
217 |           bold: false,
218 |           italic: false,
219 |           underline: false,
220 |           dim: false,
221 |           inverse: false,
222 |         },
223 |       ],
224 |     ];
225 |     const { lastFrame } = renderWithContext(
226 |       <ToolMessage {...baseProps} resultDisplay={ansiResult} />,
227 |       StreamingState.Idle,
228 |     );
229 |     expect(lastFrame()).toContain('MockAnsiOutput:hello');
230 |   });
231 | });
```

src/ui/components/messages/ToolMessage.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import React from 'react';
8 | import { Box, Text } from 'ink';
9 | import type { IndividualToolCallDisplay } from '../../types.js';
10 | import { ToolCallStatus } from '../../types.js';
11 | import { DiffRenderer } from './DiffRenderer.js';
12 | import { MarkdownDisplay } from '../../utils/MarkdownDisplay.js';
13 | import { AnsiOutputText } from '../AnsiOutput.js';
14 | import { GeminiRespondingSpinner } from '../GeminiRespondingSpinner.js';
15 | import { MaxSizedBox } from '../shared/MaxSizedBox.js';
16 | import { ShellInputPrompt } from '../ShellInputPrompt.js';
17 | import {
18 |   SHELL_COMMAND_NAME,
19 |   SHELL_NAME,
20 |   TOOL_STATUS,
21 | } from '../../constants.js';
22 | import { theme } from '../../semantic-colors.js';
23 | import type { AnsiOutput, Config } from '@google/gemini-cli-core';
24 | 
25 | const STATIC_HEIGHT = 1;
26 | const RESERVED_LINE_COUNT = 5; // for tool name, status, padding etc.
27 | const STATUS_INDICATOR_WIDTH = 3;
28 | const MIN_LINES_SHOWN = 2; // show at least this many lines
29 | 
30 | // Large threshold to ensure we don't cause performance issues for very large
31 | // outputs that will get truncated further MaxSizedBox anyway.
32 | const MAXIMUM_RESULT_DISPLAY_CHARACTERS = 1000000;
33 | export type TextEmphasis = 'high' | 'medium' | 'low';
34 | 
35 | export interface ToolMessageProps extends IndividualToolCallDisplay {
36 |   availableTerminalHeight?: number;
37 |   terminalWidth: number;
38 |   emphasis?: TextEmphasis;
39 |   renderOutputAsMarkdown?: boolean;
40 |   activeShellPtyId?: number | null;
41 |   embeddedShellFocused?: boolean;
42 |   config?: Config;
43 | }
44 | 
45 | export const ToolMessage: React.FC<ToolMessageProps> = ({
46 |   name,
47 |   description,
48 |   resultDisplay,
49 |   status,
50 |   availableTerminalHeight,
51 |   terminalWidth,
52 |   emphasis = 'medium',
53 |   renderOutputAsMarkdown = true,
54 |   activeShellPtyId,
55 |   embeddedShellFocused,
56 |   ptyId,
57 |   config,
58 | }) => {
59 |   const isThisShellFocused =
60 |     (name === SHELL_COMMAND_NAME || name === 'Shell') &&
61 |     status === ToolCallStatus.Executing &&
62 |     ptyId === activeShellPtyId &&
63 |     embeddedShellFocused;
64 | 
65 |   const [lastUpdateTime, setLastUpdateTime] = React.useState<Date | null>(null);
66 |   const [userHasFocused, setUserHasFocused] = React.useState(false);
67 |   const [showFocusHint, setShowFocusHint] = React.useState(false);
68 | 
69 |   React.useEffect(() => {
70 |     if (resultDisplay) {
71 |       setLastUpdateTime(new Date());
72 |     }
73 |   }, [resultDisplay]);
74 | 
75 |   React.useEffect(() => {
76 |     if (!lastUpdateTime) {
77 |       return;
78 |     }
79 | 
80 |     const timer = setTimeout(() => {
81 |       setShowFocusHint(true);
82 |     }, 5000);
83 | 
84 |     return () => clearTimeout(timer);
85 |   }, [lastUpdateTime]);
86 | 
87 |   React.useEffect(() => {
88 |     if (isThisShellFocused) {
89 |       setUserHasFocused(true);
90 |     }
91 |   }, [isThisShellFocused]);
92 | 
93 |   const isThisShellFocusable =
94 |     (name === SHELL_COMMAND_NAME || name === 'Shell') &&
95 |     status === ToolCallStatus.Executing &&
96 |     config?.getEnableInteractiveShell();
97 | 
98 |   const shouldShowFocusHint =
99 |     isThisShellFocusable && (showFocusHint || userHasFocused);
100 | 
101 |   const availableHeight = availableTerminalHeight
102 |     ? Math.max(
103 |         availableTerminalHeight - STATIC_HEIGHT - RESERVED_LINE_COUNT,
104 |         MIN_LINES_SHOWN + 1, // enforce minimum lines shown
105 |       )
106 |     : undefined;
107 | 
108 |   // Long tool call response in MarkdownDisplay doesn't respect availableTerminalHeight properly,
109 |   // we're forcing it to not render as markdown when the response is too long, it will fallback
110 |   // to render as plain text, which is contained within the terminal using MaxSizedBox
111 |   if (availableHeight) {
112 |     renderOutputAsMarkdown = false;
113 |   }
114 | 
115 |   const childWidth = terminalWidth - 3; // account for padding.
116 |   if (typeof resultDisplay === 'string') {
117 |     if (resultDisplay.length > MAXIMUM_RESULT_DISPLAY_CHARACTERS) {
118 |       // Truncate the result display to fit within the available width.
119 |       resultDisplay =
120 |         '...' + resultDisplay.slice(-MAXIMUM_RESULT_DISPLAY_CHARACTERS);
121 |     }
122 |   }
123 |   return (
124 |     <Box paddingX={1} paddingY={0} flexDirection="column">
125 |       <Box minHeight={1}>
126 |         <ToolStatusIndicator status={status} name={name} />
127 |         <ToolInfo
128 |           name={name}
129 |           status={status}
130 |           description={description}
131 |           emphasis={emphasis}
132 |         />
133 |         {shouldShowFocusHint && (
134 |           <Box marginLeft={1} flexShrink={0}>
135 |             <Text color={theme.text.accent}>
136 |               {isThisShellFocused ? '(Focused)' : '(ctrl+f to focus)'}
137 |             </Text>
138 |           </Box>
139 |         )}
140 |         {emphasis === 'high' && <TrailingIndicator />}
141 |       </Box>
142 |       {resultDisplay && (
143 |         <Box paddingLeft={STATUS_INDICATOR_WIDTH} width="100%" marginTop={1}>
144 |           <Box flexDirection="column">
145 |             {typeof resultDisplay === 'string' && renderOutputAsMarkdown ? (
146 |               <Box flexDirection="column">
147 |                 <MarkdownDisplay
148 |                   text={resultDisplay}
149 |                   isPending={false}
150 |                   availableTerminalHeight={availableHeight}
151 |                   terminalWidth={childWidth}
152 |                 />
153 |               </Box>
154 |             ) : typeof resultDisplay === 'string' && !renderOutputAsMarkdown ? (
155 |               <MaxSizedBox maxHeight={availableHeight} maxWidth={childWidth}>
156 |                 <Box>
157 |                   <Text wrap="wrap" color={theme.text.primary}>
158 |                     {resultDisplay}
159 |                   </Text>
160 |                 </Box>
161 |               </MaxSizedBox>
162 |             ) : typeof resultDisplay === 'object' &&
163 |               'fileDiff' in resultDisplay ? (
164 |               <DiffRenderer
165 |                 diffContent={resultDisplay.fileDiff}
166 |                 filename={resultDisplay.fileName}
167 |                 availableTerminalHeight={availableHeight}
168 |                 terminalWidth={childWidth}
169 |               />
170 |             ) : (
171 |               <AnsiOutputText
172 |                 data={resultDisplay as AnsiOutput}
173 |                 availableTerminalHeight={availableHeight}
174 |                 width={childWidth}
175 |               />
176 |             )}
177 |           </Box>
178 |         </Box>
179 |       )}
180 |       {isThisShellFocused && config && (
181 |         <Box paddingLeft={STATUS_INDICATOR_WIDTH} marginTop={1}>
182 |           <ShellInputPrompt
183 |             activeShellPtyId={activeShellPtyId ?? null}
184 |             focus={embeddedShellFocused}
185 |           />
186 |         </Box>
187 |       )}
188 |     </Box>
189 |   );
190 | };
191 | 
192 | type ToolStatusIndicatorProps = {
193 |   status: ToolCallStatus;
194 |   name: string;
195 | };
196 | 
197 | const ToolStatusIndicator: React.FC<ToolStatusIndicatorProps> = ({
198 |   status,
199 |   name,
200 | }) => {
201 |   const isShell = name === SHELL_COMMAND_NAME || name === SHELL_NAME;
202 |   const statusColor = isShell ? theme.ui.symbol : theme.status.warning;
203 | 
204 |   return (
205 |     <Box minWidth={STATUS_INDICATOR_WIDTH}>
206 |       {status === ToolCallStatus.Pending && (
207 |         <Text color={theme.status.success}>{TOOL_STATUS.PENDING}</Text>
208 |       )}
209 |       {status === ToolCallStatus.Executing && (
210 |         <GeminiRespondingSpinner
211 |           spinnerType="toggle"
212 |           nonRespondingDisplay={TOOL_STATUS.EXECUTING}
213 |         />
214 |       )}
215 |       {status === ToolCallStatus.Success && (
216 |         <Text color={theme.status.success} aria-label={'Success:'}>
217 |           {TOOL_STATUS.SUCCESS}
218 |         </Text>
219 |       )}
220 |       {status === ToolCallStatus.Confirming && (
221 |         <Text color={statusColor} aria-label={'Confirming:'}>
222 |           {TOOL_STATUS.CONFIRMING}
223 |         </Text>
224 |       )}
225 |       {status === ToolCallStatus.Canceled && (
226 |         <Text color={statusColor} aria-label={'Canceled:'} bold>
227 |           {TOOL_STATUS.CANCELED}
228 |         </Text>
229 |       )}
230 |       {status === ToolCallStatus.Error && (
231 |         <Text color={theme.status.error} aria-label={'Error:'} bold>
232 |           {TOOL_STATUS.ERROR}
233 |         </Text>
234 |       )}
235 |     </Box>
236 |   );
237 | };
238 | 
239 | type ToolInfo = {
240 |   name: string;
241 |   description: string;
242 |   status: ToolCallStatus;
243 |   emphasis: TextEmphasis;
244 | };
245 | const ToolInfo: React.FC<ToolInfo> = ({
246 |   name,
247 |   description,
248 |   status,
249 |   emphasis,
250 | }) => {
251 |   const nameColor = React.useMemo<string>(() => {
252 |     switch (emphasis) {
253 |       case 'high':
254 |         return theme.text.primary;
255 |       case 'medium':
256 |         return theme.text.primary;
257 |       case 'low':
258 |         return theme.text.secondary;
259 |       default: {
260 |         const exhaustiveCheck: never = emphasis;
261 |         return exhaustiveCheck;
262 |       }
263 |     }
264 |   }, [emphasis]);
265 |   return (
266 |     <Box>
267 |       <Text
268 |         wrap="truncate-end"
269 |         strikethrough={status === ToolCallStatus.Canceled}
270 |       >
271 |         <Text color={nameColor} bold>
272 |           {name}
273 |         </Text>{' '}
274 |         <Text color={theme.text.secondary}>{description}</Text>
275 |       </Text>
276 |     </Box>
277 |   );
278 | };
279 | 
280 | const TrailingIndicator: React.FC = () => (
281 |   <Text color={theme.text.primary} wrap="truncate">
282 |     {' '}
283 |     ←
284 |   </Text>
285 | );
```

src/ui/components/messages/UserMessage.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type React from 'react';
8 | import { Text, Box } from 'ink';
9 | import { theme } from '../../semantic-colors.js';
10 | import { SCREEN_READER_USER_PREFIX } from '../../textConstants.js';
11 | import { isSlashCommand as checkIsSlashCommand } from '../../utils/commandUtils.js';
12 | 
13 | interface UserMessageProps {
14 |   text: string;
15 | }
16 | 
17 | export const UserMessage: React.FC<UserMessageProps> = ({ text }) => {
18 |   const prefix = '> ';
19 |   const prefixWidth = prefix.length;
20 |   const isSlashCommand = checkIsSlashCommand(text);
21 | 
22 |   const textColor = isSlashCommand ? theme.text.accent : theme.text.secondary;
23 | 
24 |   return (
25 |     <Box flexDirection="row" paddingY={0} marginY={1} alignSelf="flex-start">
26 |       <Box width={prefixWidth}>
27 |         <Text color={theme.text.accent} aria-label={SCREEN_READER_USER_PREFIX}>
28 |           {prefix}
29 |         </Text>
30 |       </Box>
31 |       <Box flexGrow={1}>
32 |         <Text wrap="wrap" color={textColor}>
33 |           {text}
34 |         </Text>
35 |       </Box>
36 |     </Box>
37 |   );
38 | };
```

src/ui/components/messages/UserShellMessage.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type React from 'react';
8 | import { Box, Text } from 'ink';
9 | import { theme } from '../../semantic-colors.js';
10 | 
11 | interface UserShellMessageProps {
12 |   text: string;
13 | }
14 | 
15 | export const UserShellMessage: React.FC<UserShellMessageProps> = ({ text }) => {
16 |   // Remove leading '!' if present, as App.tsx adds it for the processor.
17 |   const commandToDisplay = text.startsWith('!') ? text.substring(1) : text;
18 | 
19 |   return (
20 |     <Box>
21 |       <Text color={theme.text.link}>$ </Text>
22 |       <Text color={theme.text.primary}>{commandToDisplay}</Text>
23 |     </Box>
24 |   );
25 | };
```

src/ui/components/messages/WarningMessage.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type React from 'react';
8 | import { Box, Text } from 'ink';
9 | import { Colors } from '../../colors.js';
10 | import { RenderInline } from '../../utils/InlineMarkdownRenderer.js';
11 | 
12 | interface WarningMessageProps {
13 |   text: string;
14 | }
15 | 
16 | export const WarningMessage: React.FC<WarningMessageProps> = ({ text }) => {
17 |   const prefix = '⚠ ';
18 |   const prefixWidth = 3;
19 | 
20 |   return (
21 |     <Box flexDirection="row" marginTop={1}>
22 |       <Box width={prefixWidth}>
23 |         <Text color={Colors.AccentYellow}>{prefix}</Text>
24 |       </Box>
25 |       <Box flexGrow={1}>
26 |         <Text wrap="wrap" color={Colors.AccentYellow}>
27 |           <RenderInline text={text} />
28 |         </Text>
29 |       </Box>
30 |     </Box>
31 |   );
32 | };
```

src/ui/components/__snapshots__/Footer.test.tsx.snap
```
1 | // Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html
2 | 
3 | exports[`<Footer /> > footer configuration filtering (golden snapshots) > renders complete footer in narrow terminal (baseline narrow) > complete-footer-narrow 1`] = `" ...s/to/make/it/long              no sandbox              gemini-pro (100%)"`;
4 | 
5 | exports[`<Footer /> > footer configuration filtering (golden snapshots) > renders complete footer with all sections visible (baseline) > complete-footer-wide 1`] = `" ...ectories/to/make/it/long              no sandbox (see /docs)               gemini-pro (100% context left)"`;
6 | 
7 | exports[`<Footer /> > footer configuration filtering (golden snapshots) > renders footer with CWD and model info hidden to test alignment (only sandbox visible) > footer-only-sandbox 1`] = `"                                            no sandbox (see /docs)"`;
8 | 
9 | exports[`<Footer /> > footer configuration filtering (golden snapshots) > renders footer with all optional sections hidden (minimal footer) > footer-minimal 1`] = `""`;
10 | 
11 | exports[`<Footer /> > footer configuration filtering (golden snapshots) > renders footer with only model info hidden (partial filtering) > footer-no-model 1`] = `" ...ectories/to/make/it/long                             no sandbox (see /docs)"`;
```

src/ui/components/__snapshots__/HistoryItemDisplay.test.tsx.snap
```
1 | // Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html
2 | 
3 | exports[`<HistoryItemDisplay /> > should render a full gemini item when using availableTerminalHeightGemini 1`] = `
4 | "✦ Example code block:
5 |     1 Line 1
6 |     2 Line 2
7 |     3 Line 3
8 |     4 Line 4
9 |     5 Line 5
10 |     6 Line 6
11 |     7 Line 7
12 |     8 Line 8
13 |     9 Line 9
14 |    10 Line 10
15 |    11 Line 11
16 |    12 Line 12
17 |    13 Line 13
18 |    14 Line 14
19 |    15 Line 15
20 |    16 Line 16
21 |    17 Line 17
22 |    18 Line 18
23 |    19 Line 19
24 |    20 Line 20
25 |    21 Line 21
26 |    22 Line 22
27 |    23 Line 23
28 |    24 Line 24
29 |    25 Line 25
30 |    26 Line 26
31 |    27 Line 27
32 |    28 Line 28
33 |    29 Line 29
34 |    30 Line 30
35 |    31 Line 31
36 |    32 Line 32
37 |    33 Line 33
38 |    34 Line 34
39 |    35 Line 35
40 |    36 Line 36
41 |    37 Line 37
42 |    38 Line 38
43 |    39 Line 39
44 |    40 Line 40
45 |    41 Line 41
46 |    42 Line 42
47 |    43 Line 43
48 |    44 Line 44
49 |    45 Line 45
50 |    46 Line 46
51 |    47 Line 47
52 |    48 Line 48
53 |    49 Line 49
54 |    50 Line 50"
55 | `;
56 | 
57 | exports[`<HistoryItemDisplay /> > should render a full gemini_content item when using availableTerminalHeightGemini 1`] = `
58 | "  Example code block:
59 |     1 Line 1
60 |     2 Line 2
61 |     3 Line 3
62 |     4 Line 4
63 |     5 Line 5
64 |     6 Line 6
65 |     7 Line 7
66 |     8 Line 8
67 |     9 Line 9
68 |    10 Line 10
69 |    11 Line 11
70 |    12 Line 12
71 |    13 Line 13
72 |    14 Line 14
73 |    15 Line 15
74 |    16 Line 16
75 |    17 Line 17
76 |    18 Line 18
77 |    19 Line 19
78 |    20 Line 20
79 |    21 Line 21
80 |    22 Line 22
81 |    23 Line 23
82 |    24 Line 24
83 |    25 Line 25
84 |    26 Line 26
85 |    27 Line 27
86 |    28 Line 28
87 |    29 Line 29
88 |    30 Line 30
89 |    31 Line 31
90 |    32 Line 32
91 |    33 Line 33
92 |    34 Line 34
93 |    35 Line 35
94 |    36 Line 36
95 |    37 Line 37
96 |    38 Line 38
97 |    39 Line 39
98 |    40 Line 40
99 |    41 Line 41
100 |    42 Line 42
101 |    43 Line 43
102 |    44 Line 44
103 |    45 Line 45
104 |    46 Line 46
105 |    47 Line 47
106 |    48 Line 48
107 |    49 Line 49
108 |    50 Line 50"
109 | `;
110 | 
111 | exports[`<HistoryItemDisplay /> > should render a truncated gemini item 1`] = `
112 | "✦ Example code block:
113 |    ... first 41 lines hidden ...
114 |    42 Line 42
115 |    43 Line 43
116 |    44 Line 44
117 |    45 Line 45
118 |    46 Line 46
119 |    47 Line 47
120 |    48 Line 48
121 |    49 Line 49
122 |    50 Line 50"
123 | `;
124 | 
125 | exports[`<HistoryItemDisplay /> > should render a truncated gemini_content item 1`] = `
126 | "  Example code block:
127 |    ... first 41 lines hidden ...
128 |    42 Line 42
129 |    43 Line 43
130 |    44 Line 44
131 |    45 Line 45
132 |    46 Line 46
133 |    47 Line 47
134 |    48 Line 48
135 |    49 Line 49
136 |    50 Line 50"
137 | `;
```

src/ui/components/__snapshots__/IDEContextDetailDisplay.test.tsx.snap
```
1 | // Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html
2 | 
3 | exports[`IDEContextDetailDisplay > handles duplicate basenames by showing path hints 1`] = `
4 | "
5 | ╭──────────────────────────────────────────────────────────────────────────────────────────────────╮
6 | │ VS Code Context (ctrl+g to toggle)                                                               │
7 | │                                                                                                  │
8 | │ Open files:                                                                                      │
9 | │ - bar.txt (/foo) (active)                                                                        │
10 | │ - bar.txt (/qux)                                                                                 │
11 | │ - unique.txt                                                                                     │
12 | ╰──────────────────────────────────────────────────────────────────────────────────────────────────╯"
13 | `;
14 | 
15 | exports[`IDEContextDetailDisplay > renders a list of open files with active status 1`] = `
16 | "
17 | ╭──────────────────────────────────────────────────────────────────────────────────────────────────╮
18 | │ VS Code Context (ctrl+g to toggle)                                                               │
19 | │                                                                                                  │
20 | │ Open files:                                                                                      │
21 | │ - bar.txt (active)                                                                               │
22 | │ - baz.txt                                                                                        │
23 | ╰──────────────────────────────────────────────────────────────────────────────────────────────────╯"
24 | `;
```

src/ui/components/__snapshots__/InputPrompt.test.tsx.snap
```
1 | // Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html
2 | 
3 | exports[`InputPrompt > command search (Ctrl+R when not in shell) > expands and collapses long suggestion via Right/Left arrows > command-search-collapsed-match 1`] = `
4 | "╭────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
5 | │ (r:)    Type your message or @path/to/file                                                        │
6 | ╰────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
7 |  lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll →
8 |  lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll
9 |  ..."
10 | `;
11 | 
12 | exports[`InputPrompt > command search (Ctrl+R when not in shell) > expands and collapses long suggestion via Right/Left arrows > command-search-expanded-match 1`] = `
13 | "╭────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
14 | │ (r:)    Type your message or @path/to/file                                                        │
15 | ╰────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
16 |  lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll ←
17 |  lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll
18 |  llllllllllllllllllllllllllllllllllllllllllllllllll"
19 | `;
20 | 
21 | exports[`InputPrompt > command search (Ctrl+R when not in shell) > renders match window and expanded view (snapshots) > command-search-collapsed-match 1`] = `
22 | "╭────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
23 | │ (r:)  commit                                                                                      │
24 | ╰────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
25 |  git commit -m "feat: add search" in src/app"
26 | `;
27 | 
28 | exports[`InputPrompt > command search (Ctrl+R when not in shell) > renders match window and expanded view (snapshots) > command-search-expanded-match 1`] = `
29 | "╭────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
30 | │ (r:)  commit                                                                                      │
31 | ╰────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
32 |  git commit -m "feat: add search" in src/app"
33 | `;
34 | 
35 | exports[`InputPrompt > snapshots > should not show inverted cursor when shell is focused 1`] = `
36 | "╭────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
37 | │ >   Type your message or @path/to/file                                                            │
38 | ╰────────────────────────────────────────────────────────────────────────────────────────────────────────────╯"
39 | `;
40 | 
41 | exports[`InputPrompt > snapshots > should render correctly in shell mode 1`] = `
42 | "╭────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
43 | │ !   Type your message or @path/to/file                                                            │
44 | ╰────────────────────────────────────────────────────────────────────────────────────────────────────────────╯"
45 | `;
46 | 
47 | exports[`InputPrompt > snapshots > should render correctly in yolo mode 1`] = `
48 | "╭────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
49 | │ *   Type your message or @path/to/file                                                            │
50 | ╰────────────────────────────────────────────────────────────────────────────────────────────────────────────╯"
51 | `;
52 | 
53 | exports[`InputPrompt > snapshots > should render correctly when accepting edits 1`] = `
54 | "╭────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
55 | │ >   Type your message or @path/to/file                                                            │
56 | ╰────────────────────────────────────────────────────────────────────────────────────────────────────────────╯"
57 | `;
```

src/ui/components/__snapshots__/LoadingIndicator.test.tsx.snap
```
1 | // Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html
2 | 
3 | exports[`<LoadingIndicator /> > should truncate long primary text instead of wrapping 1`] = `
4 | "MockResponding This is an extremely long loading phrase that should be truncated in t (esc to
5 | Spinner                                                                              cancel, 5s)"
6 | `;
```

src/ui/components/__snapshots__/LoopDetectionConfirmation.test.tsx.snap
```
1 | // Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html
2 | 
3 | exports[`LoopDetectionConfirmation > renders correctly 1`] = `
4 | " ╭──────────────────────────────────────────────────────────────────────────────────────────────────╮
5 |  │ ?  A potential loop was detected                                                                 │
6 |  │                                                                                                  │
7 |  │ This can happen due to repetitive tool calls or other model behavior. Do you want to keep loop   │
8 |  │ detection enabled or disable it for this session?                                                │
9 |  │                                                                                                  │
10 |  │ ● 1. Keep loop detection enabled (esc)                                                           │
11 |  │   2. Disable loop detection for this session                                                     │
12 |  ╰──────────────────────────────────────────────────────────────────────────────────────────────────╯"
13 | `;
```

src/ui/components/__snapshots__/ModelStatsDisplay.test.tsx.snap
```
1 | // Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html
2 | 
3 | exports[`<ModelStatsDisplay /> > should display a single model correctly 1`] = `
4 | "╭──────────────────────────────────────────────────────────────────────────────────────────────────╮
5 | │                                                                                                  │
6 | │  Model Stats For Nerds                                                                           │
7 | │                                                                                                  │
8 | │  Metric                      gemini-2.5-pro                                                      │
9 | │  ──────────────────────────────────────────────────────────────────────────────────────────────  │
10 | │  API                                                                                             │
11 | │  Requests                    1                                                                   │
12 | │  Errors                      0 (0.0%)                                                            │
13 | │  Avg Latency                 100ms                                                               │
14 | │                                                                                                  │
15 | │  Tokens                                                                                          │
16 | │  Total                       30                                                                  │
17 | │    ↳ Prompt                  10                                                                  │
18 | │    ↳ Cached                  5 (50.0%)                                                           │
19 | │    ↳ Thoughts                2                                                                   │
20 | │    ↳ Tool                    1                                                                   │
21 | │    ↳ Output                  20                                                                  │
22 | │                                                                                                  │
23 | ╰──────────────────────────────────────────────────────────────────────────────────────────────────╯"
24 | `;
25 | 
26 | exports[`<ModelStatsDisplay /> > should display conditional rows if at least one model has data 1`] = `
27 | "╭──────────────────────────────────────────────────────────────────────────────────────────────────╮
28 | │                                                                                                  │
29 | │  Model Stats For Nerds                                                                           │
30 | │                                                                                                  │
31 | │  Metric                      gemini-2.5-pro        gemini-2.5-flash                              │
32 | │  ──────────────────────────────────────────────────────────────────────────────────────────────  │
33 | │  API                                                                                             │
34 | │  Requests                    1                     1                                             │
35 | │  Errors                      0 (0.0%)              0 (0.0%)                                      │
36 | │  Avg Latency                 100ms                 50ms                                          │
37 | │                                                                                                  │
38 | │  Tokens                                                                                          │
39 | │  Total                       30                    15                                            │
40 | │    ↳ Prompt                  10                    5                                             │
41 | │    ↳ Cached                  5 (50.0%)             0 (0.0%)                                      │
42 | │    ↳ Thoughts                2                     0                                             │
43 | │    ↳ Tool                    0                     3                                             │
44 | │    ↳ Output                  20                    10                                            │
45 | │                                                                                                  │
46 | ╰──────────────────────────────────────────────────────────────────────────────────────────────────╯"
47 | `;
48 | 
49 | exports[`<ModelStatsDisplay /> > should display stats for multiple models correctly 1`] = `
50 | "╭──────────────────────────────────────────────────────────────────────────────────────────────────╮
51 | │                                                                                                  │
52 | │  Model Stats For Nerds                                                                           │
53 | │                                                                                                  │
54 | │  Metric                      gemini-2.5-pro        gemini-2.5-flash                              │
55 | │  ──────────────────────────────────────────────────────────────────────────────────────────────  │
56 | │  API                                                                                             │
57 | │  Requests                    10                    20                                            │
58 | │  Errors                      1 (10.0%)             2 (10.0%)                                     │
59 | │  Avg Latency                 100ms                 25ms                                          │
60 | │                                                                                                  │
61 | │  Tokens                                                                                          │
62 | │  Total                       300                   600                                           │
63 | │    ↳ Prompt                  100                   200                                           │
64 | │    ↳ Cached                  50 (50.0%)            100 (50.0%)                                   │
65 | │    ↳ Thoughts                10                    20                                            │
66 | │    ↳ Tool                    5                     10                                            │
67 | │    ↳ Output                  200                   400                                           │
68 | │                                                                                                  │
69 | ╰──────────────────────────────────────────────────────────────────────────────────────────────────╯"
70 | `;
71 | 
72 | exports[`<ModelStatsDisplay /> > should handle large values without wrapping or overlapping 1`] = `
73 | "╭──────────────────────────────────────────────────────────────────────────────────────────────────╮
74 | │                                                                                                  │
75 | │  Model Stats For Nerds                                                                           │
76 | │                                                                                                  │
77 | │  Metric                      gemini-2.5-pro                                                      │
78 | │  ──────────────────────────────────────────────────────────────────────────────────────────────  │
79 | │  API                                                                                             │
80 | │  Requests                    999,999,999                                                         │
81 | │  Errors                      123,456,789 (12.3%)                                                 │
82 | │  Avg Latency                 0ms                                                                 │
83 | │                                                                                                  │
84 | │  Tokens                                                                                          │
85 | │  Total                       999,999,999                                                         │
86 | │    ↳ Prompt                  987,654,321                                                         │
87 | │    ↳ Cached                  123,456,789 (12.5%)                                                 │
88 | │    ↳ Thoughts                111,111,111                                                         │
89 | │    ↳ Tool                    222,222,222                                                         │
90 | │    ↳ Output                  123,456,789                                                         │
91 | │                                                                                                  │
92 | ╰──────────────────────────────────────────────────────────────────────────────────────────────────╯"
93 | `;
94 | 
95 | exports[`<ModelStatsDisplay /> > should not display conditional rows if no model has data for them 1`] = `
96 | "╭──────────────────────────────────────────────────────────────────────────────────────────────────╮
97 | │                                                                                                  │
98 | │  Model Stats For Nerds                                                                           │
99 | │                                                                                                  │
100 | │  Metric                      gemini-2.5-pro                                                      │
101 | │  ──────────────────────────────────────────────────────────────────────────────────────────────  │
102 | │  API                                                                                             │
103 | │  Requests                    1                                                                   │
104 | │  Errors                      0 (0.0%)                                                            │
105 | │  Avg Latency                 100ms                                                               │
106 | │                                                                                                  │
107 | │  Tokens                                                                                          │
108 | │  Total                       30                                                                  │
109 | │    ↳ Prompt                  10                                                                  │
110 | │    ↳ Output                  20                                                                  │
111 | │                                                                                                  │
112 | ╰──────────────────────────────────────────────────────────────────────────────────────────────────╯"
113 | `;
114 | 
115 | exports[`<ModelStatsDisplay /> > should render "no API calls" message when there are no active models 1`] = `
116 | "╭──────────────────────────────────────────────────────────────────────────────────────────────────╮
117 | │                                                                                                  │
118 | │  No API calls have been made in this session.                                                    │
119 | │                                                                                                  │
120 | ╰──────────────────────────────────────────────────────────────────────────────────────────────────╯"
121 | `;
```

src/ui/components/__snapshots__/PrepareLabel.test.tsx.snap
```
1 | // Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html
2 | 
3 | exports[`PrepareLabel > creates centered window around match when collapsed 1`] = `
4 | "...ry/long/path/that/keeps/going/cd /very/long/path/that/keeps/going/search-here/and/then/some/more/
5 | components//and/then/some/more/components//and/..."
6 | `;
7 | 
8 | exports[`PrepareLabel > highlights matched substring when expanded (text only visible) 1`] = `"run: git commit -m "feat: add search""`;
9 | 
10 | exports[`PrepareLabel > renders plain label when no match (short label) 1`] = `"simple command"`;
11 | 
12 | exports[`PrepareLabel > shows full long label when expanded and no match 1`] = `
13 | "yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy
14 | yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy"
15 | `;
16 | 
17 | exports[`PrepareLabel > truncates long label when collapsed and no match 1`] = `
18 | "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
19 | xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx..."
20 | `;
21 | 
22 | exports[`PrepareLabel > truncates match itself when match is very long 1`] = `
23 | "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
24 | xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx..."
25 | `;
```

src/ui/components/__snapshots__/SessionSummaryDisplay.test.tsx.snap
```
1 | // Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html
2 | 
3 | exports[`<SessionSummaryDisplay /> > renders the summary display with a title 1`] = `
4 | "╭──────────────────────────────────────────────────────────────────────────────────────────────────╮
5 | │                                                                                                  │
6 | │  Agent powering down. Goodbye!                                                                   │
7 | │                                                                                                  │
8 | │  Interaction Summary                                                                             │
9 | │  Session ID:                                                                                     │
10 | │  Tool Calls:                 0 ( ✓ 0 x 0 )                                                       │
11 | │  Success Rate:               0.0%                                                                │
12 | │  Code Changes:               +42 -15                                                             │
13 | │                                                                                                  │
14 | │  Performance                                                                                     │
15 | │  Wall Time:                  1h 23m 45s                                                          │
16 | │  Agent Active:               50.2s                                                               │
17 | │    » API Time:               50.2s (100.0%)                                                      │
18 | │    » Tool Time:              0s (0.0%)                                                           │
19 | │                                                                                                  │
20 | │                                                                                                  │
21 | │  Model Usage                  Reqs   Input Tokens  Output Tokens                                 │
22 | │  ───────────────────────────────────────────────────────────────                                 │
23 | │  gemini-2.5-pro                 10          1,000          2,000                                 │
24 | │                                                                                                  │
25 | │  Savings Highlight: 500 (50.0%) of input tokens were served from the cache, reducing costs.      │
26 | │                                                                                                  │
27 | │  » Tip: For a full token breakdown, run \`/stats model\`.                                          │
28 | │                                                                                                  │
29 | ╰──────────────────────────────────────────────────────────────────────────────────────────────────╯"
30 | `;
```

src/ui/components/__snapshots__/SettingsDialog.test.tsx.snap
```
1 | // Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html
2 | 
3 | exports[`SettingsDialog > Snapshot Tests > should render default state correctly 1`] = `
4 | "╭──────────────────────────────────────────────────────────────────────────────────────────────────╮
5 | │                                                                                                  │
6 | │ > Settings                                                                                       │
7 | │                                                                                                  │
8 | │ ▲                                                                                                │
9 | │ ● Vim Mode                                             false                                     │
10 | │                                                                                                  │
11 | │   Disable Auto Update                                  false                                     │
12 | │                                                                                                  │
13 | │   Enable Prompt Completion                             false                                     │
14 | │                                                                                                  │
15 | │   Debug Keystroke Logging                              false                                     │
16 | │                                                                                                  │
17 | │   Session Retention                                    undefined                                 │
18 | │                                                                                                  │
19 | │   Enable Session Cleanup                               false                                     │
20 | │                                                                                                  │
21 | │   Output Format                                        Text                                      │
22 | │                                                                                                  │
23 | │   Hide Window Title                                    false                                     │
24 | │                                                                                                  │
25 | │ ▼                                                                                                │
26 | │                                                                                                  │
27 | │                                                                                                  │
28 | │   Apply To                                                                                       │
29 | │ ● User Settings                                                                                  │
30 | │   Workspace Settings                                                                             │
31 | │   System Settings                                                                                │
32 | │                                                                                                  │
33 | │ (Use Enter to select, Tab to change focus)                                                       │
34 | │                                                                                                  │
35 | ╰──────────────────────────────────────────────────────────────────────────────────────────────────╯"
36 | `;
37 | 
38 | exports[`SettingsDialog > Snapshot Tests > should render focused on scope selector 1`] = `
39 | "╭──────────────────────────────────────────────────────────────────────────────────────────────────╮
40 | │                                                                                                  │
41 | │ > Settings                                                                                       │
42 | │                                                                                                  │
43 | │ ▲                                                                                                │
44 | │ ● Vim Mode                                             false                                     │
45 | │                                                                                                  │
46 | │   Disable Auto Update                                  false                                     │
47 | │                                                                                                  │
48 | │   Enable Prompt Completion                             false                                     │
49 | │                                                                                                  │
50 | │   Debug Keystroke Logging                              false                                     │
51 | │                                                                                                  │
52 | │   Session Retention                                    undefined                                 │
53 | │                                                                                                  │
54 | │   Enable Session Cleanup                               false                                     │
55 | │                                                                                                  │
56 | │   Output Format                                        Text                                      │
57 | │                                                                                                  │
58 | │   Hide Window Title                                    false                                     │
59 | │                                                                                                  │
60 | │ ▼                                                                                                │
61 | │                                                                                                  │
62 | │                                                                                                  │
63 | │   Apply To                                                                                       │
64 | │ ● User Settings                                                                                  │
65 | │   Workspace Settings                                                                             │
66 | │   System Settings                                                                                │
67 | │                                                                                                  │
68 | │ (Use Enter to select, Tab to change focus)                                                       │
69 | │                                                                                                  │
70 | ╰──────────────────────────────────────────────────────────────────────────────────────────────────╯"
71 | `;
72 | 
73 | exports[`SettingsDialog > Snapshot Tests > should render with accessibility settings enabled 1`] = `
74 | "╭──────────────────────────────────────────────────────────────────────────────────────────────────╮
75 | │                                                                                                  │
76 | │ > Settings                                                                                       │
77 | │                                                                                                  │
78 | │ ▲                                                                                                │
79 | │ ● Vim Mode                                             true*                                     │
80 | │                                                                                                  │
81 | │   Disable Auto Update                                  false                                     │
82 | │                                                                                                  │
83 | │   Enable Prompt Completion                             false                                     │
84 | │                                                                                                  │
85 | │   Debug Keystroke Logging                              false                                     │
86 | │                                                                                                  │
87 | │   Session Retention                                    undefined                                 │
88 | │                                                                                                  │
89 | │   Enable Session Cleanup                               false                                     │
90 | │                                                                                                  │
91 | │   Output Format                                        Text                                      │
92 | │                                                                                                  │
93 | │   Hide Window Title                                    false                                     │
94 | │                                                                                                  │
95 | │ ▼                                                                                                │
96 | │                                                                                                  │
97 | │                                                                                                  │
98 | │   Apply To                                                                                       │
99 | │ ● User Settings                                                                                  │
100 | │   Workspace Settings                                                                             │
101 | │   System Settings                                                                                │
102 | │                                                                                                  │
103 | │ (Use Enter to select, Tab to change focus)                                                       │
104 | │                                                                                                  │
105 | ╰──────────────────────────────────────────────────────────────────────────────────────────────────╯"
106 | `;
107 | 
108 | exports[`SettingsDialog > Snapshot Tests > should render with all boolean settings disabled 1`] = `
109 | "╭──────────────────────────────────────────────────────────────────────────────────────────────────╮
110 | │                                                                                                  │
111 | │ > Settings                                                                                       │
112 | │                                                                                                  │
113 | │ ▲                                                                                                │
114 | │ ● Vim Mode                                             false*                                    │
115 | │                                                                                                  │
116 | │   Disable Auto Update                                  false*                                    │
117 | │                                                                                                  │
118 | │   Enable Prompt Completion                             false*                                    │
119 | │                                                                                                  │
120 | │   Debug Keystroke Logging                              false*                                    │
121 | │                                                                                                  │
122 | │   Session Retention                                    undefined                                 │
123 | │                                                                                                  │
124 | │   Enable Session Cleanup                               false                                     │
125 | │                                                                                                  │
126 | │   Output Format                                        Text                                      │
127 | │                                                                                                  │
128 | │   Hide Window Title                                    false*                                    │
129 | │                                                                                                  │
130 | │ ▼                                                                                                │
131 | │                                                                                                  │
132 | │                                                                                                  │
133 | │   Apply To                                                                                       │
134 | │ ● User Settings                                                                                  │
135 | │   Workspace Settings                                                                             │
136 | │   System Settings                                                                                │
137 | │                                                                                                  │
138 | │ (Use Enter to select, Tab to change focus)                                                       │
139 | │                                                                                                  │
140 | ╰──────────────────────────────────────────────────────────────────────────────────────────────────╯"
141 | `;
142 | 
143 | exports[`SettingsDialog > Snapshot Tests > should render with different scope selected (System) 1`] = `
144 | "╭──────────────────────────────────────────────────────────────────────────────────────────────────╮
145 | │                                                                                                  │
146 | │ > Settings                                                                                       │
147 | │                                                                                                  │
148 | │ ▲                                                                                                │
149 | │ ● Vim Mode (Modified in System)                        false                                     │
150 | │                                                                                                  │
151 | │   Disable Auto Update (Modified in System)             false                                     │
152 | │                                                                                                  │
153 | │   Enable Prompt Completion                             false                                     │
154 | │                                                                                                  │
155 | │   Debug Keystroke Logging                              false                                     │
156 | │                                                                                                  │
157 | │   Session Retention                                    undefined                                 │
158 | │                                                                                                  │
159 | │   Enable Session Cleanup                               false                                     │
160 | │                                                                                                  │
161 | │   Output Format                                        Text                                      │
162 | │                                                                                                  │
163 | │   Hide Window Title                                    false                                     │
164 | │                                                                                                  │
165 | │ ▼                                                                                                │
166 | │                                                                                                  │
167 | │                                                                                                  │
168 | │   Apply To                                                                                       │
169 | │ ● User Settings                                                                                  │
170 | │   Workspace Settings                                                                             │
171 | │   System Settings                                                                                │
172 | │                                                                                                  │
173 | │ (Use Enter to select, Tab to change focus)                                                       │
174 | │                                                                                                  │
175 | ╰──────────────────────────────────────────────────────────────────────────────────────────────────╯"
176 | `;
177 | 
178 | exports[`SettingsDialog > Snapshot Tests > should render with different scope selected (Workspace) 1`] = `
179 | "╭──────────────────────────────────────────────────────────────────────────────────────────────────╮
180 | │                                                                                                  │
181 | │ > Settings                                                                                       │
182 | │                                                                                                  │
183 | │ ▲                                                                                                │
184 | │ ● Vim Mode (Modified in Workspace)                     false                                     │
185 | │                                                                                                  │
186 | │   Disable Auto Update                                  false                                     │
187 | │                                                                                                  │
188 | │   Enable Prompt Completion                             false                                     │
189 | │                                                                                                  │
190 | │   Debug Keystroke Logging (Modified in Workspace)      false                                     │
191 | │                                                                                                  │
192 | │   Session Retention                                    undefined                                 │
193 | │                                                                                                  │
194 | │   Enable Session Cleanup                               false                                     │
195 | │                                                                                                  │
196 | │   Output Format                                        Text                                      │
197 | │                                                                                                  │
198 | │   Hide Window Title                                    false                                     │
199 | │                                                                                                  │
200 | │ ▼                                                                                                │
201 | │                                                                                                  │
202 | │                                                                                                  │
203 | │   Apply To                                                                                       │
204 | │ ● User Settings                                                                                  │
205 | │   Workspace Settings                                                                             │
206 | │   System Settings                                                                                │
207 | │                                                                                                  │
208 | │ (Use Enter to select, Tab to change focus)                                                       │
209 | │                                                                                                  │
210 | ╰──────────────────────────────────────────────────────────────────────────────────────────────────╯"
211 | `;
212 | 
213 | exports[`SettingsDialog > Snapshot Tests > should render with file filtering settings configured 1`] = `
214 | "╭──────────────────────────────────────────────────────────────────────────────────────────────────╮
215 | │                                                                                                  │
216 | │ > Settings                                                                                       │
217 | │                                                                                                  │
218 | │ ▲                                                                                                │
219 | │ ● Vim Mode                                             false                                     │
220 | │                                                                                                  │
221 | │   Disable Auto Update                                  false                                     │
222 | │                                                                                                  │
223 | │   Enable Prompt Completion                             false                                     │
224 | │                                                                                                  │
225 | │   Debug Keystroke Logging                              false                                     │
226 | │                                                                                                  │
227 | │   Session Retention                                    undefined                                 │
228 | │                                                                                                  │
229 | │   Enable Session Cleanup                               false                                     │
230 | │                                                                                                  │
231 | │   Output Format                                        Text                                      │
232 | │                                                                                                  │
233 | │   Hide Window Title                                    false                                     │
234 | │                                                                                                  │
235 | │ ▼                                                                                                │
236 | │                                                                                                  │
237 | │                                                                                                  │
238 | │   Apply To                                                                                       │
239 | │ ● User Settings                                                                                  │
240 | │   Workspace Settings                                                                             │
241 | │   System Settings                                                                                │
242 | │                                                                                                  │
243 | │ (Use Enter to select, Tab to change focus)                                                       │
244 | │                                                                                                  │
245 | ╰──────────────────────────────────────────────────────────────────────────────────────────────────╯"
246 | `;
247 | 
248 | exports[`SettingsDialog > Snapshot Tests > should render with mixed boolean and number settings 1`] = `
249 | "╭──────────────────────────────────────────────────────────────────────────────────────────────────╮
250 | │                                                                                                  │
251 | │ > Settings                                                                                       │
252 | │                                                                                                  │
253 | │ ▲                                                                                                │
254 | │ ● Vim Mode                                             false*                                    │
255 | │                                                                                                  │
256 | │   Disable Auto Update                                  true*                                     │
257 | │                                                                                                  │
258 | │   Enable Prompt Completion                             false                                     │
259 | │                                                                                                  │
260 | │   Debug Keystroke Logging                              false                                     │
261 | │                                                                                                  │
262 | │   Session Retention                                    undefined                                 │
263 | │                                                                                                  │
264 | │   Enable Session Cleanup                               false                                     │
265 | │                                                                                                  │
266 | │   Output Format                                        Text                                      │
267 | │                                                                                                  │
268 | │   Hide Window Title                                    false*                                    │
269 | │                                                                                                  │
270 | │ ▼                                                                                                │
271 | │                                                                                                  │
272 | │                                                                                                  │
273 | │   Apply To                                                                                       │
274 | │ ● User Settings                                                                                  │
275 | │   Workspace Settings                                                                             │
276 | │   System Settings                                                                                │
277 | │                                                                                                  │
278 | │ (Use Enter to select, Tab to change focus)                                                       │
279 | │                                                                                                  │
280 | ╰──────────────────────────────────────────────────────────────────────────────────────────────────╯"
281 | `;
282 | 
283 | exports[`SettingsDialog > Snapshot Tests > should render with tools and security settings 1`] = `
284 | "╭──────────────────────────────────────────────────────────────────────────────────────────────────╮
285 | │                                                                                                  │
286 | │ > Settings                                                                                       │
287 | │                                                                                                  │
288 | │ ▲                                                                                                │
289 | │ ● Vim Mode                                             false                                     │
290 | │                                                                                                  │
291 | │   Disable Auto Update                                  false                                     │
292 | │                                                                                                  │
293 | │   Enable Prompt Completion                             false                                     │
294 | │                                                                                                  │
295 | │   Debug Keystroke Logging                              false                                     │
296 | │                                                                                                  │
297 | │   Session Retention                                    undefined                                 │
298 | │                                                                                                  │
299 | │   Enable Session Cleanup                               false                                     │
300 | │                                                                                                  │
301 | │   Output Format                                        Text                                      │
302 | │                                                                                                  │
303 | │   Hide Window Title                                    false                                     │
304 | │                                                                                                  │
305 | │ ▼                                                                                                │
306 | │                                                                                                  │
307 | │                                                                                                  │
308 | │   Apply To                                                                                       │
309 | │ ● User Settings                                                                                  │
310 | │   Workspace Settings                                                                             │
311 | │   System Settings                                                                                │
312 | │                                                                                                  │
313 | │ (Use Enter to select, Tab to change focus)                                                       │
314 | │                                                                                                  │
315 | ╰──────────────────────────────────────────────────────────────────────────────────────────────────╯"
316 | `;
317 | 
318 | exports[`SettingsDialog > Snapshot Tests > should render with various boolean settings enabled 1`] = `
319 | "╭──────────────────────────────────────────────────────────────────────────────────────────────────╮
320 | │                                                                                                  │
321 | │ > Settings                                                                                       │
322 | │                                                                                                  │
323 | │ ▲                                                                                                │
324 | │ ● Vim Mode                                             true*                                     │
325 | │                                                                                                  │
326 | │   Disable Auto Update                                  true*                                     │
327 | │                                                                                                  │
328 | │   Enable Prompt Completion                             true*                                     │
329 | │                                                                                                  │
330 | │   Debug Keystroke Logging                              true*                                     │
331 | │                                                                                                  │
[TRUNCATED]
```

src/ui/components/__snapshots__/ShellConfirmationDialog.test.tsx.snap
```
1 | // Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html
2 | 
3 | exports[`ShellConfirmationDialog > renders correctly 1`] = `
4 | " ╭──────────────────────────────────────────────────────────────────────────────────────────────────╮
5 |  │                                                                                                  │
6 |  │ Shell Command Execution                                                                          │
7 |  │ A custom command wants to run the following shell commands:                                      │
8 |  │                                                                                                  │
9 |  │ ╭──────────────────────────────────────────────────────────────────────────────────────────────╮ │
10 |  │ │ ls -la                                                                                       │ │
11 |  │ │ echo "hello"                                                                                 │ │
12 |  │ ╰──────────────────────────────────────────────────────────────────────────────────────────────╯ │
13 |  │                                                                                                  │
14 |  │ Do you want to proceed?                                                                          │
15 |  │                                                                                                  │
16 |  │ ● 1. Yes, allow once                                                                             │
17 |  │   2. Yes, allow always for this session                                                          │
18 |  │   3. No (esc)                                                                                    │
19 |  │                                                                                                  │
20 |  ╰──────────────────────────────────────────────────────────────────────────────────────────────────╯"
21 | `;
```

src/ui/components/__snapshots__/StatsDisplay.test.tsx.snap
```
1 | // Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html
2 | 
3 | exports[`<StatsDisplay /> > Code Changes Display > displays Code Changes when line counts are present 1`] = `
4 | "╭──────────────────────────────────────────────────────────────────────────────────────────────────╮
5 | │                                                                                                  │
6 | │  Session Stats                                                                                   │
7 | │                                                                                                  │
8 | │  Interaction Summary                                                                             │
9 | │  Session ID:                 test-session-id                                                     │
10 | │  Tool Calls:                 1 ( ✓ 1 x 0 )                                                       │
11 | │  Success Rate:               100.0%                                                              │
12 | │  Code Changes:               +42 -18                                                             │
13 | │                                                                                                  │
14 | │  Performance                                                                                     │
15 | │  Wall Time:                  1s                                                                  │
16 | │  Agent Active:               100ms                                                               │
17 | │    » API Time:               0s (0.0%)                                                           │
18 | │    » Tool Time:              100ms (100.0%)                                                      │
19 | │                                                                                                  │
20 | │                                                                                                  │
21 | ╰──────────────────────────────────────────────────────────────────────────────────────────────────╯"
22 | `;
23 | 
24 | exports[`<StatsDisplay /> > Code Changes Display > hides Code Changes when no lines are added or removed 1`] = `
25 | "╭──────────────────────────────────────────────────────────────────────────────────────────────────╮
26 | │                                                                                                  │
27 | │  Session Stats                                                                                   │
28 | │                                                                                                  │
29 | │  Interaction Summary                                                                             │
30 | │  Session ID:                 test-session-id                                                     │
31 | │  Tool Calls:                 1 ( ✓ 1 x 0 )                                                       │
32 | │  Success Rate:               100.0%                                                              │
33 | │                                                                                                  │
34 | │  Performance                                                                                     │
35 | │  Wall Time:                  1s                                                                  │
36 | │  Agent Active:               100ms                                                               │
37 | │    » API Time:               0s (0.0%)                                                           │
38 | │    » Tool Time:              100ms (100.0%)                                                      │
39 | │                                                                                                  │
40 | │                                                                                                  │
41 | ╰──────────────────────────────────────────────────────────────────────────────────────────────────╯"
42 | `;
43 | 
44 | exports[`<StatsDisplay /> > Conditional Color Tests > renders success rate in green for high values 1`] = `
45 | "╭──────────────────────────────────────────────────────────────────────────────────────────────────╮
46 | │                                                                                                  │
47 | │  Session Stats                                                                                   │
48 | │                                                                                                  │
49 | │  Interaction Summary                                                                             │
50 | │  Session ID:                 test-session-id                                                     │
51 | │  Tool Calls:                 10 ( ✓ 10 x 0 )                                                     │
52 | │  Success Rate:               100.0%                                                              │
53 | │                                                                                                  │
54 | │  Performance                                                                                     │
55 | │  Wall Time:                  1s                                                                  │
56 | │  Agent Active:               0s                                                                  │
57 | │    » API Time:               0s (0.0%)                                                           │
58 | │    » Tool Time:              0s (0.0%)                                                           │
59 | │                                                                                                  │
60 | │                                                                                                  │
61 | ╰──────────────────────────────────────────────────────────────────────────────────────────────────╯"
62 | `;
63 | 
64 | exports[`<StatsDisplay /> > Conditional Color Tests > renders success rate in red for low values 1`] = `
65 | "╭──────────────────────────────────────────────────────────────────────────────────────────────────╮
66 | │                                                                                                  │
67 | │  Session Stats                                                                                   │
68 | │                                                                                                  │
69 | │  Interaction Summary                                                                             │
70 | │  Session ID:                 test-session-id                                                     │
71 | │  Tool Calls:                 10 ( ✓ 5 x 5 )                                                      │
72 | │  Success Rate:               50.0%                                                               │
73 | │                                                                                                  │
74 | │  Performance                                                                                     │
75 | │  Wall Time:                  1s                                                                  │
76 | │  Agent Active:               0s                                                                  │
77 | │    » API Time:               0s (0.0%)                                                           │
78 | │    » Tool Time:              0s (0.0%)                                                           │
79 | │                                                                                                  │
80 | │                                                                                                  │
81 | ╰──────────────────────────────────────────────────────────────────────────────────────────────────╯"
82 | `;
83 | 
84 | exports[`<StatsDisplay /> > Conditional Color Tests > renders success rate in yellow for medium values 1`] = `
85 | "╭──────────────────────────────────────────────────────────────────────────────────────────────────╮
86 | │                                                                                                  │
87 | │  Session Stats                                                                                   │
88 | │                                                                                                  │
89 | │  Interaction Summary                                                                             │
90 | │  Session ID:                 test-session-id                                                     │
91 | │  Tool Calls:                 10 ( ✓ 9 x 1 )                                                      │
92 | │  Success Rate:               90.0%                                                               │
93 | │                                                                                                  │
94 | │  Performance                                                                                     │
95 | │  Wall Time:                  1s                                                                  │
96 | │  Agent Active:               0s                                                                  │
97 | │    » API Time:               0s (0.0%)                                                           │
98 | │    » Tool Time:              0s (0.0%)                                                           │
99 | │                                                                                                  │
100 | │                                                                                                  │
101 | ╰──────────────────────────────────────────────────────────────────────────────────────────────────╯"
102 | `;
103 | 
104 | exports[`<StatsDisplay /> > Conditional Rendering Tests > hides Efficiency section when cache is not used 1`] = `
105 | "╭──────────────────────────────────────────────────────────────────────────────────────────────────╮
106 | │                                                                                                  │
107 | │  Session Stats                                                                                   │
108 | │                                                                                                  │
109 | │  Interaction Summary                                                                             │
110 | │  Session ID:                 test-session-id                                                     │
111 | │  Tool Calls:                 0 ( ✓ 0 x 0 )                                                       │
112 | │  Success Rate:               0.0%                                                                │
113 | │                                                                                                  │
114 | │  Performance                                                                                     │
115 | │  Wall Time:                  1s                                                                  │
116 | │  Agent Active:               100ms                                                               │
117 | │    » API Time:               100ms (100.0%)                                                      │
118 | │    » Tool Time:              0s (0.0%)                                                           │
119 | │                                                                                                  │
120 | │                                                                                                  │
121 | │  Model Usage                  Reqs   Input Tokens  Output Tokens                                 │
122 | │  ───────────────────────────────────────────────────────────────                                 │
123 | │  gemini-2.5-pro                  1            100            100                                 │
124 | │                                                                                                  │
125 | ╰──────────────────────────────────────────────────────────────────────────────────────────────────╯"
126 | `;
127 | 
128 | exports[`<StatsDisplay /> > Conditional Rendering Tests > hides User Agreement when no decisions are made 1`] = `
129 | "╭──────────────────────────────────────────────────────────────────────────────────────────────────╮
130 | │                                                                                                  │
131 | │  Session Stats                                                                                   │
132 | │                                                                                                  │
133 | │  Interaction Summary                                                                             │
134 | │  Session ID:                 test-session-id                                                     │
135 | │  Tool Calls:                 2 ( ✓ 1 x 1 )                                                       │
136 | │  Success Rate:               50.0%                                                               │
137 | │                                                                                                  │
138 | │  Performance                                                                                     │
139 | │  Wall Time:                  1s                                                                  │
140 | │  Agent Active:               123ms                                                               │
141 | │    » API Time:               0s (0.0%)                                                           │
142 | │    » Tool Time:              123ms (100.0%)                                                      │
143 | │                                                                                                  │
144 | │                                                                                                  │
145 | ╰──────────────────────────────────────────────────────────────────────────────────────────────────╯"
146 | `;
147 | 
148 | exports[`<StatsDisplay /> > Title Rendering > renders the custom title when a title prop is provided 1`] = `
149 | "╭──────────────────────────────────────────────────────────────────────────────────────────────────╮
150 | │                                                                                                  │
151 | │  Agent powering down. Goodbye!                                                                   │
152 | │                                                                                                  │
153 | │  Interaction Summary                                                                             │
154 | │  Session ID:                 test-session-id                                                     │
155 | │  Tool Calls:                 0 ( ✓ 0 x 0 )                                                       │
156 | │  Success Rate:               0.0%                                                                │
157 | │                                                                                                  │
158 | │  Performance                                                                                     │
159 | │  Wall Time:                  1s                                                                  │
160 | │  Agent Active:               0s                                                                  │
161 | │    » API Time:               0s (0.0%)                                                           │
162 | │    » Tool Time:              0s (0.0%)                                                           │
163 | │                                                                                                  │
164 | │                                                                                                  │
165 | ╰──────────────────────────────────────────────────────────────────────────────────────────────────╯"
166 | `;
167 | 
168 | exports[`<StatsDisplay /> > Title Rendering > renders the default title when no title prop is provided 1`] = `
169 | "╭──────────────────────────────────────────────────────────────────────────────────────────────────╮
170 | │                                                                                                  │
171 | │  Session Stats                                                                                   │
172 | │                                                                                                  │
173 | │  Interaction Summary                                                                             │
174 | │  Session ID:                 test-session-id                                                     │
175 | │  Tool Calls:                 0 ( ✓ 0 x 0 )                                                       │
176 | │  Success Rate:               0.0%                                                                │
177 | │                                                                                                  │
178 | │  Performance                                                                                     │
179 | │  Wall Time:                  1s                                                                  │
180 | │  Agent Active:               0s                                                                  │
181 | │    » API Time:               0s (0.0%)                                                           │
182 | │    » Tool Time:              0s (0.0%)                                                           │
183 | │                                                                                                  │
184 | │                                                                                                  │
185 | ╰──────────────────────────────────────────────────────────────────────────────────────────────────╯"
186 | `;
187 | 
188 | exports[`<StatsDisplay /> > renders a table with two models correctly 1`] = `
189 | "╭──────────────────────────────────────────────────────────────────────────────────────────────────╮
190 | │                                                                                                  │
191 | │  Session Stats                                                                                   │
192 | │                                                                                                  │
193 | │  Interaction Summary                                                                             │
194 | │  Session ID:                 test-session-id                                                     │
195 | │  Tool Calls:                 0 ( ✓ 0 x 0 )                                                       │
196 | │  Success Rate:               0.0%                                                                │
197 | │                                                                                                  │
198 | │  Performance                                                                                     │
199 | │  Wall Time:                  1s                                                                  │
200 | │  Agent Active:               19.5s                                                               │
201 | │    » API Time:               19.5s (100.0%)                                                      │
202 | │    » Tool Time:              0s (0.0%)                                                           │
203 | │                                                                                                  │
204 | │                                                                                                  │
205 | │  Model Usage                  Reqs   Input Tokens  Output Tokens                                 │
206 | │  ───────────────────────────────────────────────────────────────                                 │
207 | │  gemini-2.5-pro                  3          1,000          2,000                                 │
208 | │  gemini-2.5-flash                5         25,000         15,000                                 │
209 | │                                                                                                  │
210 | │  Savings Highlight: 10,500 (40.4%) of input tokens were served from the cache, reducing costs.   │
211 | │                                                                                                  │
212 | │  » Tip: For a full token breakdown, run \`/stats model\`.                                          │
213 | │                                                                                                  │
214 | ╰──────────────────────────────────────────────────────────────────────────────────────────────────╯"
215 | `;
216 | 
217 | exports[`<StatsDisplay /> > renders all sections when all data is present 1`] = `
218 | "╭──────────────────────────────────────────────────────────────────────────────────────────────────╮
219 | │                                                                                                  │
220 | │  Session Stats                                                                                   │
221 | │                                                                                                  │
222 | │  Interaction Summary                                                                             │
223 | │  Session ID:                 test-session-id                                                     │
224 | │  Tool Calls:                 2 ( ✓ 1 x 1 )                                                       │
225 | │  Success Rate:               50.0%                                                               │
226 | │  User Agreement:             100.0% (1 reviewed)                                                 │
227 | │                                                                                                  │
228 | │  Performance                                                                                     │
229 | │  Wall Time:                  1s                                                                  │
230 | │  Agent Active:               223ms                                                               │
231 | │    » API Time:               100ms (44.8%)                                                       │
232 | │    » Tool Time:              123ms (55.2%)                                                       │
233 | │                                                                                                  │
234 | │                                                                                                  │
235 | │  Model Usage                  Reqs   Input Tokens  Output Tokens                                 │
236 | │  ───────────────────────────────────────────────────────────────                                 │
237 | │  gemini-2.5-pro                  1            100            100                                 │
238 | │                                                                                                  │
239 | │  Savings Highlight: 50 (50.0%) of input tokens were served from the cache, reducing costs.       │
240 | │                                                                                                  │
241 | │  » Tip: For a full token breakdown, run \`/stats model\`.                                          │
242 | │                                                                                                  │
243 | ╰──────────────────────────────────────────────────────────────────────────────────────────────────╯"
244 | `;
245 | 
246 | exports[`<StatsDisplay /> > renders only the Performance section in its zero state 1`] = `
247 | "╭──────────────────────────────────────────────────────────────────────────────────────────────────╮
248 | │                                                                                                  │
249 | │  Session Stats                                                                                   │
250 | │                                                                                                  │
251 | │  Interaction Summary                                                                             │
252 | │  Session ID:                 test-session-id                                                     │
253 | │  Tool Calls:                 0 ( ✓ 0 x 0 )                                                       │
254 | │  Success Rate:               0.0%                                                                │
255 | │                                                                                                  │
256 | │  Performance                                                                                     │
257 | │  Wall Time:                  1s                                                                  │
258 | │  Agent Active:               0s                                                                  │
259 | │    » API Time:               0s (0.0%)                                                           │
260 | │    » Tool Time:              0s (0.0%)                                                           │
261 | │                                                                                                  │
262 | │                                                                                                  │
263 | ╰──────────────────────────────────────────────────────────────────────────────────────────────────╯"
264 | `;
```

src/ui/components/__snapshots__/ThemeDialog.test.tsx.snap
```
1 | // Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html
2 | 
3 | exports[`ThemeDialog Snapshots > should render correctly in scope selector mode 1`] = `
4 | "╭──────────────────────────────────────────────────────────────────────────────────────────────────╮
5 | │                                                                                                  │
6 | │ > Apply To                                                                                       │
7 | │ ● 1. User Settings                                                                               │
8 | │   2. Workspace Settings                                                                          │
9 | │   3. System Settings                                                                             │
10 | │                                                                                                  │
11 | │ (Use Enter to apply scope, Tab to select theme)                                                  │
12 | │                                                                                                  │
13 | ╰──────────────────────────────────────────────────────────────────────────────────────────────────╯"
14 | `;
15 | 
16 | exports[`ThemeDialog Snapshots > should render correctly in theme selection mode 1`] = `
17 | "╭──────────────────────────────────────────────────────────────────────────────────────────────────╮
18 | │                                                                                                  │
19 | │ > Select Theme                               Preview                                             │
20 | │ ▲                                            ┌─────────────────────────────────────────────────┐ │
21 | │    1. ANSI Dark                              │                                                 │ │
22 | │    2. Atom One Dark                          │ 1 # function                                    │ │
23 | │    3. Ayu Dark                               │ 2 def fibonacci(n):                             │ │
24 | │ ●  4. Default Dark                           │ 3     a, b = 0, 1                               │ │
25 | │    5. Dracula Dark                           │ 4     for _ in range(n):                        │ │
26 | │    6. GitHub Dark                            │ 5         a, b = b, a + b                       │ │
27 | │    7. Shades Of Purple Dark                  │ 6     return a                                  │ │
28 | │    8. ANSI Light Light                       │                                                 │ │
29 | │    9. Ayu Light Light                        │ 1 - print("Hello, " + name)                     │ │
30 | │   10. Default Light Light                    │ 1 + print(f"Hello, {name}!")                    │ │
31 | │   11. GitHub Light Light                     │                                                 │ │
32 | │   12. Google Code Light                      └─────────────────────────────────────────────────┘ │
33 | │ ▼                                                                                                │
34 | │                                                                                                  │
35 | │ (Use Enter to select, Tab to configure scope)                                                    │
36 | │                                                                                                  │
37 | ╰──────────────────────────────────────────────────────────────────────────────────────────────────╯"
38 | `;
```

src/ui/components/__snapshots__/ToolStatsDisplay.test.tsx.snap
```
1 | // Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html
2 | 
3 | exports[`<ToolStatsDisplay /> > should display stats for a single tool correctly 1`] = `
4 | "╭────────────────────────────────────────────────────────────────────╮
5 | │                                                                    │
6 | │  Tool Stats For Nerds                                              │
7 | │                                                                    │
8 | │  Tool Name                   Calls   Success Rate   Avg Duration   │
9 | │  ────────────────────────────────────────────────────────────────  │
10 | │  test-tool                       1         100.0%          100ms   │
11 | │                                                                    │
12 | │  User Decision Summary                                             │
13 | │  Total Reviewed Suggestions:                                   1   │
14 | │   » Accepted:                                                  1   │
15 | │   » Rejected:                                                  0   │
16 | │   » Modified:                                                  0   │
17 | │  ────────────────────────────────────────────────────────────────  │
18 | │   Overall Agreement Rate:                                 100.0%   │
19 | │                                                                    │
20 | ╰────────────────────────────────────────────────────────────────────╯"
21 | `;
22 | 
23 | exports[`<ToolStatsDisplay /> > should display stats for multiple tools correctly 1`] = `
24 | "╭────────────────────────────────────────────────────────────────────╮
25 | │                                                                    │
26 | │  Tool Stats For Nerds                                              │
27 | │                                                                    │
28 | │  Tool Name                   Calls   Success Rate   Avg Duration   │
29 | │  ────────────────────────────────────────────────────────────────  │
30 | │  tool-a                          2          50.0%          100ms   │
31 | │  tool-b                          1         100.0%          100ms   │
32 | │                                                                    │
33 | │  User Decision Summary                                             │
34 | │  Total Reviewed Suggestions:                                   3   │
35 | │   » Accepted:                                                  1   │
36 | │   » Rejected:                                                  1   │
37 | │   » Modified:                                                  1   │
38 | │  ────────────────────────────────────────────────────────────────  │
39 | │   Overall Agreement Rate:                                  33.3%   │
40 | │                                                                    │
41 | ╰────────────────────────────────────────────────────────────────────╯"
42 | `;
43 | 
44 | exports[`<ToolStatsDisplay /> > should handle large values without wrapping or overlapping 1`] = `
45 | "╭────────────────────────────────────────────────────────────────────╮
46 | │                                                                    │
47 | │  Tool Stats For Nerds                                              │
48 | │                                                                    │
49 | │  Tool Name                   Calls   Success Rate   Avg Duration   │
50 | │  ────────────────────────────────────────────────────────────────  │
51 | │  long-named-tool-for-testi99999999          88.9%            1ms   │
52 | │  ng-wrapping-and-such     9                                        │
53 | │                                                                    │
54 | │  User Decision Summary                                             │
55 | │  Total Reviewed Suggestions:                           222234566   │
56 | │   » Accepted:                                          123456789   │
57 | │   » Rejected:                                           98765432   │
58 | │   » Modified:                                              12345   │
59 | │  ────────────────────────────────────────────────────────────────  │
60 | │   Overall Agreement Rate:                                  55.6%   │
61 | │                                                                    │
62 | ╰────────────────────────────────────────────────────────────────────╯"
63 | `;
64 | 
65 | exports[`<ToolStatsDisplay /> > should handle zero decisions gracefully 1`] = `
66 | "╭────────────────────────────────────────────────────────────────────╮
67 | │                                                                    │
68 | │  Tool Stats For Nerds                                              │
69 | │                                                                    │
70 | │  Tool Name                   Calls   Success Rate   Avg Duration   │
71 | │  ────────────────────────────────────────────────────────────────  │
72 | │  test-tool                       1         100.0%          100ms   │
73 | │                                                                    │
74 | │  User Decision Summary                                             │
75 | │  Total Reviewed Suggestions:                                   0   │
76 | │   » Accepted:                                                  0   │
77 | │   » Rejected:                                                  0   │
78 | │   » Modified:                                                  0   │
79 | │  ────────────────────────────────────────────────────────────────  │
80 | │   Overall Agreement Rate:                                     --   │
81 | │                                                                    │
82 | ╰────────────────────────────────────────────────────────────────────╯"
83 | `;
84 | 
85 | exports[`<ToolStatsDisplay /> > should render "no tool calls" message when there are no active tools 1`] = `
86 | "╭──────────────────────────────────────────────────────────────────────────────────────────────────╮
87 | │                                                                                                  │
88 | │  No tool calls have been made in this session.                                                   │
89 | │                                                                                                  │
90 | ╰──────────────────────────────────────────────────────────────────────────────────────────────────╯"
91 | `;
```

src/ui/components/shared/BaseSelectionList.test.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect, vi, beforeEach } from 'vitest';
8 | import { waitFor } from '@testing-library/react';
9 | import { renderWithProviders } from '../../../test-utils/render.js';
10 | import {
11 |   BaseSelectionList,
12 |   type BaseSelectionListProps,
13 |   type RenderItemContext,
14 | } from './BaseSelectionList.js';
15 | import { useSelectionList } from '../../hooks/useSelectionList.js';
16 | import { Text } from 'ink';
17 | import type { theme } from '../../semantic-colors.js';
18 | 
19 | vi.mock('../../hooks/useSelectionList.js');
20 | 
21 | const mockTheme = {
22 |   text: { primary: 'COLOR_PRIMARY', secondary: 'COLOR_SECONDARY' },
23 |   status: { success: 'COLOR_SUCCESS' },
24 | } as typeof theme;
25 | 
26 | vi.mock('../../semantic-colors.js', () => ({
27 |   theme: {
28 |     text: { primary: 'COLOR_PRIMARY', secondary: 'COLOR_SECONDARY' },
29 |     status: { success: 'COLOR_SUCCESS' },
30 |   },
31 | }));
32 | 
33 | describe('BaseSelectionList', () => {
34 |   const mockOnSelect = vi.fn();
35 |   const mockOnHighlight = vi.fn();
36 |   const mockRenderItem = vi.fn();
37 | 
38 |   const items = [
39 |     { value: 'A', label: 'Item A', key: 'A' },
40 |     { value: 'B', label: 'Item B', disabled: true, key: 'B' },
41 |     { value: 'C', label: 'Item C', key: 'C' },
42 |   ];
43 | 
44 |   // Helper to render the component with default props
45 |   const renderComponent = (
46 |     props: Partial<
47 |       BaseSelectionListProps<
48 |         string,
49 |         { value: string; label: string; disabled?: boolean; key: string }
50 |       >
51 |     > = {},
52 |     activeIndex: number = 0,
53 |   ) => {
54 |     vi.mocked(useSelectionList).mockReturnValue({
55 |       activeIndex,
56 |       setActiveIndex: vi.fn(),
57 |     });
58 | 
59 |     mockRenderItem.mockImplementation(
60 |       (
61 |         item: { value: string; label: string; disabled?: boolean; key: string },
62 |         context: RenderItemContext,
63 |       ) => <Text color={context.titleColor}>{item.label}</Text>,
64 |     );
65 | 
66 |     const defaultProps: BaseSelectionListProps<
67 |       string,
68 |       { value: string; label: string; disabled?: boolean; key: string }
69 |     > = {
70 |       items,
71 |       onSelect: mockOnSelect,
72 |       onHighlight: mockOnHighlight,
73 |       renderItem: mockRenderItem,
74 |       ...props,
75 |     };
76 | 
77 |     return renderWithProviders(<BaseSelectionList {...defaultProps} />);
78 |   };
79 | 
80 |   beforeEach(() => {
81 |     vi.clearAllMocks();
82 |   });
83 | 
84 |   describe('Rendering and Structure', () => {
85 |     it('should render all items using the renderItem prop', () => {
86 |       const { lastFrame } = renderComponent();
87 | 
88 |       expect(lastFrame()).toContain('Item A');
89 |       expect(lastFrame()).toContain('Item B');
90 |       expect(lastFrame()).toContain('Item C');
91 | 
92 |       expect(mockRenderItem).toHaveBeenCalledTimes(3);
93 |       expect(mockRenderItem).toHaveBeenCalledWith(items[0], expect.any(Object));
94 |     });
95 | 
96 |     it('should render the selection indicator (● or space) and layout', () => {
97 |       const { lastFrame } = renderComponent({}, 0);
98 |       const output = lastFrame();
99 | 
100 |       // Use regex to assert the structure: Indicator + Whitespace + Number + Label
101 |       expect(output).toMatch(/●\s+1\.\s+Item A/);
102 |       expect(output).toMatch(/\s+2\.\s+Item B/);
103 |       expect(output).toMatch(/\s+3\.\s+Item C/);
104 |     });
105 | 
106 |     it('should handle an empty list gracefully', () => {
107 |       const { lastFrame } = renderComponent({ items: [] });
108 |       expect(mockRenderItem).not.toHaveBeenCalled();
109 |       expect(lastFrame()).toBe('');
110 |     });
111 |   });
112 | 
113 |   describe('useSelectionList Integration', () => {
114 |     it('should pass props correctly to useSelectionList', () => {
115 |       const initialIndex = 1;
116 |       const isFocused = false;
117 |       const showNumbers = false;
118 | 
119 |       renderComponent({ initialIndex, isFocused, showNumbers });
120 | 
121 |       expect(useSelectionList).toHaveBeenCalledWith({
122 |         items,
123 |         initialIndex,
124 |         onSelect: mockOnSelect,
125 |         onHighlight: mockOnHighlight,
126 |         isFocused,
127 |         showNumbers,
128 |       });
129 |     });
130 | 
131 |     it('should use the activeIndex returned by the hook', () => {
132 |       renderComponent({}, 2); // Active index is C
133 | 
134 |       expect(mockRenderItem).toHaveBeenCalledWith(
135 |         items[0],
136 |         expect.objectContaining({ isSelected: false }),
137 |       );
138 |       expect(mockRenderItem).toHaveBeenCalledWith(
139 |         items[2],
140 |         expect.objectContaining({ isSelected: true }),
141 |       );
142 |     });
143 |   });
144 | 
145 |   describe('Styling and Colors', () => {
146 |     it('should apply success color to the selected item', () => {
147 |       renderComponent({}, 0); // Item A selected
148 | 
149 |       // Check renderItem context colors against the mocked theme
150 |       expect(mockRenderItem).toHaveBeenCalledWith(
151 |         items[0],
152 |         expect.objectContaining({
153 |           titleColor: mockTheme.status.success,
154 |           numberColor: mockTheme.status.success,
155 |           isSelected: true,
156 |         }),
157 |       );
158 |     });
159 | 
160 |     it('should apply primary color to unselected, enabled items', () => {
161 |       renderComponent({}, 0); // Item A selected, Item C unselected/enabled
162 | 
163 |       // Check renderItem context colors for Item C
164 |       expect(mockRenderItem).toHaveBeenCalledWith(
165 |         items[2],
166 |         expect.objectContaining({
167 |           titleColor: mockTheme.text.primary,
168 |           numberColor: mockTheme.text.primary,
169 |           isSelected: false,
170 |         }),
171 |       );
172 |     });
173 | 
174 |     it('should apply secondary color to disabled items (when not selected)', () => {
175 |       renderComponent({}, 0); // Item A selected, Item B disabled
176 | 
177 |       // Check renderItem context colors for Item B
178 |       expect(mockRenderItem).toHaveBeenCalledWith(
179 |         items[1],
180 |         expect.objectContaining({
181 |           titleColor: mockTheme.text.secondary,
182 |           numberColor: mockTheme.text.secondary,
183 |           isSelected: false,
184 |         }),
185 |       );
186 |     });
187 | 
188 |     it('should apply success color to disabled items if they are selected', () => {
189 |       // The component should visually reflect the selection even if the item is disabled.
190 |       renderComponent({}, 1); // Item B (disabled) selected
191 | 
192 |       // Check renderItem context colors for Item B
193 |       expect(mockRenderItem).toHaveBeenCalledWith(
194 |         items[1],
195 |         expect.objectContaining({
196 |           titleColor: mockTheme.status.success,
197 |           numberColor: mockTheme.status.success,
198 |           isSelected: true,
199 |         }),
200 |       );
201 |     });
202 |   });
203 | 
204 |   describe('Numbering (showNumbers)', () => {
205 |     it('should show numbers by default with correct formatting', () => {
206 |       const { lastFrame } = renderComponent();
207 |       const output = lastFrame();
208 | 
209 |       expect(output).toContain('1.');
210 |       expect(output).toContain('2.');
211 |       expect(output).toContain('3.');
212 |     });
213 | 
214 |     it('should hide numbers when showNumbers is false', () => {
215 |       const { lastFrame } = renderComponent({ showNumbers: false });
216 |       const output = lastFrame();
217 | 
218 |       expect(output).not.toContain('1.');
219 |       expect(output).not.toContain('2.');
220 |       expect(output).not.toContain('3.');
221 |     });
222 | 
223 |     it('should apply correct padding for alignment in long lists', () => {
224 |       const longList = Array.from({ length: 15 }, (_, i) => ({
225 |         value: `Item ${i + 1}`,
226 |         label: `Item ${i + 1}`,
227 |         key: `Item ${i + 1}`,
228 |       }));
229 | 
230 |       // We must increase maxItemsToShow (default 10) to see the 10th item and beyond
231 |       const { lastFrame } = renderComponent({
232 |         items: longList,
233 |         maxItemsToShow: 15,
234 |       });
235 |       const output = lastFrame();
236 | 
237 |       // Check formatting for single and double digits.
238 |       // The implementation uses padStart, resulting in " 1." and "10.".
239 |       expect(output).toContain(' 1.');
240 |       expect(output).toContain('10.');
241 |     });
242 | 
243 |     it('should apply secondary color to numbers if showNumbers is false (internal logic check)', () => {
244 |       renderComponent({ showNumbers: false }, 0);
245 | 
246 |       expect(mockRenderItem).toHaveBeenCalledWith(
247 |         items[0],
248 |         expect.objectContaining({
249 |           isSelected: true,
250 |           titleColor: mockTheme.status.success,
251 |           numberColor: mockTheme.text.secondary,
252 |         }),
253 |       );
254 |     });
255 |   });
256 | 
257 |   describe('Scrolling and Pagination (maxItemsToShow)', () => {
258 |     const longList = Array.from({ length: 10 }, (_, i) => ({
259 |       value: `Item ${i + 1}`,
260 |       label: `Item ${i + 1}`,
261 |       key: `Item ${i + 1}`,
262 |     }));
263 |     const MAX_ITEMS = 3;
264 | 
265 |     const renderScrollableList = (initialActiveIndex: number = 0) => {
266 |       // Define the props used for the initial render and subsequent rerenders
267 |       const componentProps: BaseSelectionListProps<
268 |         string,
269 |         { value: string; label: string; key: string }
270 |       > = {
271 |         items: longList,
272 |         maxItemsToShow: MAX_ITEMS,
273 |         onSelect: mockOnSelect,
274 |         onHighlight: mockOnHighlight,
275 |         renderItem: mockRenderItem,
276 |       };
277 | 
278 |       vi.mocked(useSelectionList).mockReturnValue({
279 |         activeIndex: initialActiveIndex,
280 |         setActiveIndex: vi.fn(),
281 |       });
282 | 
283 |       mockRenderItem.mockImplementation(
284 |         (item: (typeof longList)[0], context: RenderItemContext) => (
285 |           <Text color={context.titleColor}>{item.label}</Text>
286 |         ),
287 |       );
288 | 
289 |       const { rerender, lastFrame } = renderWithProviders(
290 |         <BaseSelectionList {...componentProps} />,
291 |       );
292 | 
293 |       // Function to simulate the activeIndex changing over time
294 |       const updateActiveIndex = async (newIndex: number) => {
295 |         vi.mocked(useSelectionList).mockReturnValue({
296 |           activeIndex: newIndex,
297 |           setActiveIndex: vi.fn(),
298 |         });
299 | 
300 |         rerender(<BaseSelectionList {...componentProps} />);
301 | 
302 |         await waitFor(() => {
303 |           expect(lastFrame()).toBeTruthy();
304 |         });
305 |       };
306 | 
307 |       return { updateActiveIndex, lastFrame };
308 |     };
309 | 
310 |     it('should only show maxItemsToShow items initially', () => {
311 |       const { lastFrame } = renderScrollableList(0);
312 |       const output = lastFrame();
313 | 
314 |       expect(output).toContain('Item 1');
315 |       expect(output).toContain('Item 3');
316 |       expect(output).not.toContain('Item 4');
317 |     });
318 | 
319 |     it('should scroll down when activeIndex moves beyond the visible window', async () => {
320 |       const { updateActiveIndex, lastFrame } = renderScrollableList(0);
321 | 
322 |       // Move to index 3 (Item 4). Should trigger scroll.
323 |       // New visible window should be Items 2, 3, 4 (scroll offset 1).
324 |       await updateActiveIndex(3);
325 | 
326 |       const output = lastFrame();
327 |       expect(output).not.toContain('Item 1');
328 |       expect(output).toContain('Item 2');
329 |       expect(output).toContain('Item 4');
330 |       expect(output).not.toContain('Item 5');
331 |     });
332 | 
333 |     it('should scroll up when activeIndex moves before the visible window', async () => {
334 |       const { updateActiveIndex, lastFrame } = renderScrollableList(0);
335 | 
336 |       await updateActiveIndex(4);
337 | 
338 |       let output = lastFrame();
339 |       expect(output).toContain('Item 3'); // Should see items 3, 4, 5
340 |       expect(output).toContain('Item 5');
341 |       expect(output).not.toContain('Item 2');
342 | 
343 |       // Now test scrolling up: move to index 1 (Item 2)
344 |       // This should trigger scroll up to show items 2, 3, 4
345 |       await updateActiveIndex(1);
346 | 
347 |       output = lastFrame();
348 |       expect(output).toContain('Item 2');
349 |       expect(output).toContain('Item 4');
350 |       expect(output).not.toContain('Item 5'); // Item 5 should no longer be visible
351 |     });
352 | 
353 |     it('should pin the scroll offset to the end if selection starts near the end', async () => {
354 |       // List length 10. Max items 3. Active index 9 (last item).
355 |       // Scroll offset should be 10 - 3 = 7.
[TRUNCATED]
```

src/ui/components/shared/BaseSelectionList.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type React from 'react';
8 | import { useEffect, useState } from 'react';
9 | import { Text, Box } from 'ink';
10 | import { theme } from '../../semantic-colors.js';
11 | import { useSelectionList } from '../../hooks/useSelectionList.js';
12 | 
13 | import type { SelectionListItem } from '../../hooks/useSelectionList.js';
14 | 
15 | export interface RenderItemContext {
16 |   isSelected: boolean;
17 |   titleColor: string;
18 |   numberColor: string;
19 | }
20 | 
21 | export interface BaseSelectionListProps<
22 |   T,
23 |   TItem extends SelectionListItem<T> = SelectionListItem<T>,
24 | > {
25 |   items: TItem[];
26 |   initialIndex?: number;
27 |   onSelect: (value: T) => void;
28 |   onHighlight?: (value: T) => void;
29 |   isFocused?: boolean;
30 |   showNumbers?: boolean;
31 |   showScrollArrows?: boolean;
32 |   maxItemsToShow?: number;
33 |   renderItem: (item: TItem, context: RenderItemContext) => React.ReactNode;
34 | }
35 | 
36 | /**
37 |  * Base component for selection lists that provides common UI structure
38 |  * and keyboard navigation logic via the useSelectionList hook.
39 |  *
40 |  * This component handles:
41 |  * - Radio button indicators
42 |  * - Item numbering
43 |  * - Scrolling for long lists
44 |  * - Color theming based on selection/disabled state
45 |  * - Keyboard navigation and numeric selection
46 |  *
47 |  * Specific components should use this as a base and provide
48 |  * their own renderItem implementation for custom content.
49 |  */
50 | export function BaseSelectionList<
51 |   T,
52 |   TItem extends SelectionListItem<T> = SelectionListItem<T>,
53 | >({
54 |   items,
55 |   initialIndex = 0,
56 |   onSelect,
57 |   onHighlight,
58 |   isFocused = true,
59 |   showNumbers = true,
60 |   showScrollArrows = false,
61 |   maxItemsToShow = 10,
62 |   renderItem,
63 | }: BaseSelectionListProps<T, TItem>): React.JSX.Element {
64 |   const { activeIndex } = useSelectionList({
65 |     items,
66 |     initialIndex,
67 |     onSelect,
68 |     onHighlight,
69 |     isFocused,
70 |     showNumbers,
71 |   });
72 | 
73 |   const [scrollOffset, setScrollOffset] = useState(0);
74 | 
75 |   // Handle scrolling for long lists
76 |   useEffect(() => {
77 |     const newScrollOffset = Math.max(
78 |       0,
79 |       Math.min(activeIndex - maxItemsToShow + 1, items.length - maxItemsToShow),
80 |     );
81 |     if (activeIndex < scrollOffset) {
82 |       setScrollOffset(activeIndex);
83 |     } else if (activeIndex >= scrollOffset + maxItemsToShow) {
84 |       setScrollOffset(newScrollOffset);
85 |     }
86 |   }, [activeIndex, items.length, scrollOffset, maxItemsToShow]);
87 | 
88 |   const visibleItems = items.slice(scrollOffset, scrollOffset + maxItemsToShow);
89 |   const numberColumnWidth = String(items.length).length;
90 | 
91 |   return (
92 |     <Box flexDirection="column">
93 |       {/* Use conditional coloring instead of conditional rendering */}
94 |       {showScrollArrows && (
95 |         <Text
96 |           color={scrollOffset > 0 ? theme.text.primary : theme.text.secondary}
97 |         >
98 |           ▲
99 |         </Text>
100 |       )}
101 | 
102 |       {visibleItems.map((item, index) => {
103 |         const itemIndex = scrollOffset + index;
104 |         const isSelected = activeIndex === itemIndex;
105 | 
106 |         // Determine colors based on selection and disabled state
107 |         let titleColor = theme.text.primary;
108 |         let numberColor = theme.text.primary;
109 | 
110 |         if (isSelected) {
111 |           titleColor = theme.status.success;
112 |           numberColor = theme.status.success;
113 |         } else if (item.disabled) {
114 |           titleColor = theme.text.secondary;
115 |           numberColor = theme.text.secondary;
116 |         }
117 | 
118 |         if (!isFocused && !item.disabled) {
119 |           numberColor = theme.text.secondary;
120 |         }
121 | 
122 |         if (!showNumbers) {
123 |           numberColor = theme.text.secondary;
124 |         }
125 | 
126 |         const itemNumberText = `${String(itemIndex + 1).padStart(
127 |           numberColumnWidth,
128 |         )}.`;
129 | 
130 |         return (
131 |           <Box key={item.key} alignItems="flex-start">
132 |             {/* Radio button indicator */}
133 |             <Box minWidth={2} flexShrink={0}>
134 |               <Text
135 |                 color={isSelected ? theme.status.success : theme.text.primary}
136 |                 aria-hidden
137 |               >
138 |                 {isSelected ? '●' : ' '}
139 |               </Text>
140 |             </Box>
141 | 
142 |             {/* Item number */}
143 |             {showNumbers && (
144 |               <Box
145 |                 marginRight={1}
146 |                 flexShrink={0}
147 |                 minWidth={itemNumberText.length}
148 |                 aria-state={{ checked: isSelected }}
149 |               >
150 |                 <Text color={numberColor}>{itemNumberText}</Text>
151 |               </Box>
152 |             )}
153 | 
154 |             {/* Custom content via render prop */}
155 |             <Box flexGrow={1}>
156 |               {renderItem(item, {
157 |                 isSelected,
158 |                 titleColor,
159 |                 numberColor,
160 |               })}
161 |             </Box>
162 |           </Box>
163 |         );
164 |       })}
165 | 
166 |       {showScrollArrows && (
167 |         <Text
168 |           color={
169 |             scrollOffset + maxItemsToShow < items.length
170 |               ? theme.text.primary
171 |               : theme.text.secondary
172 |           }
173 |         >
174 |           ▼
175 |         </Text>
176 |       )}
177 |     </Box>
178 |   );
179 | }
```

src/ui/components/shared/DescriptiveRadioButtonSelect.test.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect, vi, beforeEach } from 'vitest';
8 | import { renderWithProviders } from '../../../test-utils/render.js';
9 | import {
10 |   DescriptiveRadioButtonSelect,
11 |   type DescriptiveRadioSelectItem,
12 |   type DescriptiveRadioButtonSelectProps,
13 | } from './DescriptiveRadioButtonSelect.js';
14 | 
15 | vi.mock('./BaseSelectionList.js', async (importOriginal) => {
16 |   const actual =
17 |     await importOriginal<typeof import('./BaseSelectionList.js')>();
18 |   return {
19 |     ...actual,
20 |     BaseSelectionList: vi.fn(({ children, ...props }) => (
21 |       <actual.BaseSelectionList {...props}>{children}</actual.BaseSelectionList>
22 |     )),
23 |   };
24 | });
25 | 
26 | vi.mock('../../semantic-colors.js', () => ({
27 |   theme: {
28 |     text: {
29 |       primary: 'COLOR_PRIMARY',
30 |       secondary: 'COLOR_SECONDARY',
31 |     },
32 |     status: {
33 |       success: 'COLOR_SUCCESS',
34 |     },
35 |   },
36 | }));
37 | 
38 | describe('DescriptiveRadioButtonSelect', () => {
39 |   const mockOnSelect = vi.fn();
40 |   const mockOnHighlight = vi.fn();
41 | 
42 |   const ITEMS: Array<DescriptiveRadioSelectItem<string>> = [
43 |     {
44 |       title: 'Foo Title',
45 |       description: 'This is Foo.',
46 |       value: 'foo',
47 |       key: 'foo',
48 |     },
49 |     {
50 |       title: 'Bar Title',
51 |       description: 'This is Bar.',
52 |       value: 'bar',
53 |       key: 'bar',
54 |     },
55 |     {
56 |       title: 'Baz Title',
57 |       description: 'This is Baz.',
58 |       value: 'baz',
59 |       disabled: true,
60 |       key: 'baz',
61 |     },
62 |   ];
63 | 
64 |   const renderComponent = (
65 |     props: Partial<DescriptiveRadioButtonSelectProps<string>> = {},
66 |   ) => {
67 |     const defaultProps: DescriptiveRadioButtonSelectProps<string> = {
68 |       items: ITEMS,
69 |       onSelect: mockOnSelect,
70 |       ...props,
71 |     };
72 |     return renderWithProviders(
73 |       <DescriptiveRadioButtonSelect {...defaultProps} />,
74 |     );
75 |   };
76 | 
77 |   beforeEach(() => {
78 |     vi.clearAllMocks();
79 |   });
80 | 
81 |   it('should render correctly with default props', () => {
82 |     const { lastFrame } = renderComponent();
83 |     expect(lastFrame()).toMatchSnapshot();
84 |   });
85 | 
86 |   it('should render correctly with custom props', () => {
87 |     const { lastFrame } = renderComponent({
88 |       initialIndex: 1,
89 |       isFocused: false,
90 |       showScrollArrows: true,
91 |       maxItemsToShow: 5,
92 |       showNumbers: true,
93 |       onHighlight: mockOnHighlight,
94 |     });
95 |     expect(lastFrame()).toMatchSnapshot();
96 |   });
97 | });
```

src/ui/components/shared/DescriptiveRadioButtonSelect.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type React from 'react';
8 | import { Text, Box } from 'ink';
9 | import { theme } from '../../semantic-colors.js';
10 | import { BaseSelectionList } from './BaseSelectionList.js';
11 | import type { SelectionListItem } from '../../hooks/useSelectionList.js';
12 | 
13 | export interface DescriptiveRadioSelectItem<T> extends SelectionListItem<T> {
14 |   title: string;
15 |   description: string;
16 | }
17 | 
18 | export interface DescriptiveRadioButtonSelectProps<T> {
19 |   /** An array of items to display as descriptive radio options. */
20 |   items: Array<DescriptiveRadioSelectItem<T>>;
21 |   /** The initial index selected */
22 |   initialIndex?: number;
23 |   /** Function called when an item is selected. Receives the `value` of the selected item. */
24 |   onSelect: (value: T) => void;
25 |   /** Function called when an item is highlighted. Receives the `value` of the selected item. */
26 |   onHighlight?: (value: T) => void;
27 |   /** Whether this select input is currently focused and should respond to input. */
28 |   isFocused?: boolean;
29 |   /** Whether to show numbers next to items. */
30 |   showNumbers?: boolean;
31 |   /** Whether to show the scroll arrows. */
32 |   showScrollArrows?: boolean;
33 |   /** The maximum number of items to show at once. */
34 |   maxItemsToShow?: number;
35 | }
36 | 
37 | /**
38 |  * A radio button select component that displays items with title and description.
39 |  *
40 |  * @template T The type of the value associated with each descriptive radio item.
41 |  */
42 | export function DescriptiveRadioButtonSelect<T>({
43 |   items,
44 |   initialIndex = 0,
45 |   onSelect,
46 |   onHighlight,
47 |   isFocused = true,
48 |   showNumbers = false,
49 |   showScrollArrows = false,
50 |   maxItemsToShow = 10,
51 | }: DescriptiveRadioButtonSelectProps<T>): React.JSX.Element {
52 |   return (
53 |     <BaseSelectionList<T, DescriptiveRadioSelectItem<T>>
54 |       items={items}
55 |       initialIndex={initialIndex}
56 |       onSelect={onSelect}
57 |       onHighlight={onHighlight}
58 |       isFocused={isFocused}
59 |       showNumbers={showNumbers}
60 |       showScrollArrows={showScrollArrows}
61 |       maxItemsToShow={maxItemsToShow}
62 |       renderItem={(item, { titleColor }) => (
63 |         <Box flexDirection="column" key={item.key}>
64 |           <Text color={titleColor}>{item.title}</Text>
65 |           <Text color={theme.text.secondary}>{item.description}</Text>
66 |         </Box>
67 |       )}
68 |     />
69 |   );
70 | }
```

src/ui/components/shared/EnumSelector.test.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { renderWithProviders } from '../../../test-utils/render.js';
8 | import { EnumSelector } from './EnumSelector.js';
9 | import type { SettingEnumOption } from '../../../config/settingsSchema.js';
10 | import { describe, it, expect } from 'vitest';
11 | 
12 | const LANGUAGE_OPTIONS: readonly SettingEnumOption[] = [
13 |   { label: 'English', value: 'en' },
14 |   { label: '中文 (简体)', value: 'zh' },
15 |   { label: 'Español', value: 'es' },
16 |   { label: 'Français', value: 'fr' },
17 | ];
18 | 
19 | const NUMERIC_OPTIONS: readonly SettingEnumOption[] = [
20 |   { label: 'Low', value: 1 },
21 |   { label: 'Medium', value: 2 },
22 |   { label: 'High', value: 3 },
23 | ];
24 | 
25 | describe('<EnumSelector />', () => {
26 |   it('renders with string options and matches snapshot', () => {
27 |     const { lastFrame } = renderWithProviders(
28 |       <EnumSelector
29 |         options={LANGUAGE_OPTIONS}
30 |         currentValue="en"
31 |         isActive={true}
32 |         onValueChange={() => {}}
33 |       />,
34 |     );
35 |     expect(lastFrame()).toMatchSnapshot();
36 |   });
37 | 
38 |   it('renders with numeric options and matches snapshot', () => {
39 |     const { lastFrame } = renderWithProviders(
40 |       <EnumSelector
41 |         options={NUMERIC_OPTIONS}
42 |         currentValue={2}
43 |         isActive={true}
44 |         onValueChange={() => {}}
45 |       />,
46 |     );
47 |     expect(lastFrame()).toMatchSnapshot();
48 |   });
49 | 
50 |   it('renders inactive state and matches snapshot', () => {
51 |     const { lastFrame } = renderWithProviders(
52 |       <EnumSelector
53 |         options={LANGUAGE_OPTIONS}
54 |         currentValue="zh"
55 |         isActive={false}
56 |         onValueChange={() => {}}
57 |       />,
58 |     );
59 |     expect(lastFrame()).toMatchSnapshot();
60 |   });
61 | 
62 |   it('renders with single option and matches snapshot', () => {
63 |     const singleOption: readonly SettingEnumOption[] = [
64 |       { label: 'Only Option', value: 'only' },
65 |     ];
66 |     const { lastFrame } = renderWithProviders(
67 |       <EnumSelector
68 |         options={singleOption}
69 |         currentValue="only"
70 |         isActive={true}
71 |         onValueChange={() => {}}
72 |       />,
73 |     );
74 |     expect(lastFrame()).toMatchSnapshot();
75 |   });
76 | 
77 |   it('renders nothing when no options are provided', () => {
78 |     const { lastFrame } = renderWithProviders(
79 |       <EnumSelector
80 |         options={[]}
81 |         currentValue=""
82 |         isActive={true}
83 |         onValueChange={() => {}}
84 |       />,
85 |     );
86 |     expect(lastFrame()).toBe('');
87 |   });
88 | 
89 |   it('handles currentValue not found in options', () => {
90 |     const { lastFrame } = renderWithProviders(
91 |       <EnumSelector
92 |         options={LANGUAGE_OPTIONS}
93 |         currentValue="invalid"
94 |         isActive={true}
95 |         onValueChange={() => {}}
96 |       />,
97 |     );
98 |     // Should default to first option
99 |     expect(lastFrame()).toContain('English');
100 |   });
101 | 
102 |   it('updates when currentValue changes externally', () => {
103 |     const { rerender, lastFrame } = renderWithProviders(
104 |       <EnumSelector
105 |         options={LANGUAGE_OPTIONS}
106 |         currentValue="en"
107 |         isActive={true}
108 |         onValueChange={() => {}}
109 |       />,
110 |     );
111 |     expect(lastFrame()).toContain('English');
112 | 
113 |     rerender(
114 |       <EnumSelector
115 |         options={LANGUAGE_OPTIONS}
116 |         currentValue="zh"
117 |         isActive={true}
118 |         onValueChange={() => {}}
119 |       />,
120 |     );
121 |     expect(lastFrame()).toContain('中文 (简体)');
122 |   });
123 | 
124 |   it('shows navigation arrows when multiple options available', () => {
125 |     const { lastFrame } = renderWithProviders(
126 |       <EnumSelector
127 |         options={LANGUAGE_OPTIONS}
128 |         currentValue="en"
129 |         isActive={true}
130 |         onValueChange={() => {}}
131 |       />,
132 |     );
133 |     expect(lastFrame()).toContain('←');
134 |     expect(lastFrame()).toContain('→');
135 |   });
136 | 
137 |   it('hides navigation arrows when single option available', () => {
138 |     const singleOption: readonly SettingEnumOption[] = [
139 |       { label: 'Only Option', value: 'only' },
140 |     ];
141 |     const { lastFrame } = renderWithProviders(
142 |       <EnumSelector
143 |         options={singleOption}
144 |         currentValue="only"
145 |         isActive={true}
146 |         onValueChange={() => {}}
147 |       />,
148 |     );
149 |     expect(lastFrame()).not.toContain('←');
150 |     expect(lastFrame()).not.toContain('→');
151 |   });
152 | });
```

src/ui/components/shared/EnumSelector.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { useState, useEffect } from 'react';
8 | import type React from 'react';
9 | import { Box, Text } from 'ink';
10 | import { Colors } from '../../colors.js';
11 | import type { SettingEnumOption } from '../../../config/settingsSchema.js';
12 | 
13 | interface EnumSelectorProps {
14 |   options: readonly SettingEnumOption[];
15 |   currentValue: string | number;
16 |   isActive: boolean;
17 |   onValueChange: (value: string | number) => void;
18 | }
19 | 
20 | /**
21 |  * A left-right scrolling selector for enum values
22 |  */
23 | export function EnumSelector({
24 |   options,
25 |   currentValue,
26 |   isActive,
27 |   onValueChange: _onValueChange,
28 | }: EnumSelectorProps): React.JSX.Element {
29 |   const [currentIndex, setCurrentIndex] = useState(() => {
30 |     // Guard against empty options array
31 |     if (!options || options.length === 0) {
32 |       return 0;
33 |     }
34 |     const index = options.findIndex((option) => option.value === currentValue);
35 |     return index >= 0 ? index : 0;
36 |   });
37 | 
38 |   // Update index when currentValue changes externally
39 |   useEffect(() => {
40 |     // Guard against empty options array
41 |     if (!options || options.length === 0) {
42 |       return;
43 |     }
44 |     const index = options.findIndex((option) => option.value === currentValue);
45 |     // Always update index, defaulting to 0 if value not found
46 |     setCurrentIndex(index >= 0 ? index : 0);
47 |   }, [currentValue, options]);
48 | 
49 |   // Guard against empty options array
50 |   if (!options || options.length === 0) {
51 |     return <Box />;
52 |   }
53 | 
54 |   // Left/right navigation is handled by parent component
55 |   // This component is purely for display
56 |   // onValueChange is kept for interface compatibility but not used internally
57 | 
58 |   const currentOption = options[currentIndex] || options[0];
59 |   const canScrollLeft = options.length > 1;
60 |   const canScrollRight = options.length > 1;
61 | 
62 |   return (
63 |     <Box flexDirection="row" alignItems="center">
64 |       <Text
65 |         color={isActive && canScrollLeft ? Colors.AccentGreen : Colors.Gray}
66 |       >
67 |         {canScrollLeft ? '←' : ' '}
68 |       </Text>
69 |       <Text> </Text>
70 |       <Text
71 |         color={isActive ? Colors.AccentGreen : Colors.Foreground}
72 |         bold={isActive}
73 |       >
74 |         {currentOption.label}
75 |       </Text>
76 |       <Text> </Text>
77 |       <Text
78 |         color={isActive && canScrollRight ? Colors.AccentGreen : Colors.Gray}
79 |       >
80 |         {canScrollRight ? '→' : ' '}
81 |       </Text>
82 |     </Box>
83 |   );
84 | }
85 | 
86 | // Export the interface for external use
87 | export type { EnumSelectorProps };
```

src/ui/components/shared/MaxSizedBox.test.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { render } from 'ink-testing-library';
8 | import { OverflowProvider } from '../../contexts/OverflowContext.js';
9 | import { MaxSizedBox, setMaxSizedBoxDebugging } from './MaxSizedBox.js';
10 | import { Box, Text } from 'ink';
11 | import { describe, it, expect } from 'vitest';
12 | 
13 | describe('<MaxSizedBox />', () => {
14 |   // Make sure MaxSizedBox logs errors on invalid configurations.
15 |   // This is useful for debugging issues with the component.
16 |   // It should be set to false in production for performance and to avoid
17 |   // cluttering the console if there are ignorable issues.
18 |   setMaxSizedBoxDebugging(true);
19 | 
20 |   it('renders children without truncation when they fit', () => {
21 |     const { lastFrame } = render(
22 |       <OverflowProvider>
23 |         <MaxSizedBox maxWidth={80} maxHeight={10}>
24 |           <Box>
25 |             <Text>Hello, World!</Text>
26 |           </Box>
27 |         </MaxSizedBox>
28 |       </OverflowProvider>,
29 |     );
30 |     expect(lastFrame()).equals('Hello, World!');
31 |   });
32 | 
33 |   it('hides lines when content exceeds maxHeight', () => {
34 |     const { lastFrame } = render(
35 |       <OverflowProvider>
36 |         <MaxSizedBox maxWidth={80} maxHeight={2}>
37 |           <Box>
38 |             <Text>Line 1</Text>
39 |           </Box>
40 |           <Box>
41 |             <Text>Line 2</Text>
42 |           </Box>
43 |           <Box>
44 |             <Text>Line 3</Text>
45 |           </Box>
46 |         </MaxSizedBox>
47 |       </OverflowProvider>,
48 |     );
49 |     expect(lastFrame()).equals(`... first 2 lines hidden ...
50 | Line 3`);
51 |   });
52 | 
53 |   it('hides lines at the end when content exceeds maxHeight and overflowDirection is bottom', () => {
54 |     const { lastFrame } = render(
55 |       <OverflowProvider>
56 |         <MaxSizedBox maxWidth={80} maxHeight={2} overflowDirection="bottom">
57 |           <Box>
58 |             <Text>Line 1</Text>
59 |           </Box>
60 |           <Box>
61 |             <Text>Line 2</Text>
62 |           </Box>
63 |           <Box>
64 |             <Text>Line 3</Text>
65 |           </Box>
66 |         </MaxSizedBox>
67 |       </OverflowProvider>,
68 |     );
69 |     expect(lastFrame()).equals(`Line 1
70 | ... last 2 lines hidden ...`);
71 |   });
72 | 
73 |   it('wraps text that exceeds maxWidth', () => {
74 |     const { lastFrame } = render(
75 |       <OverflowProvider>
76 |         <MaxSizedBox maxWidth={10} maxHeight={5}>
77 |           <Box>
78 |             <Text wrap="wrap">This is a long line of text</Text>
79 |           </Box>
80 |         </MaxSizedBox>
81 |       </OverflowProvider>,
82 |     );
83 | 
84 |     expect(lastFrame()).equals(`This is a
85 | long line
86 | of text`);
87 |   });
88 | 
89 |   it('handles mixed wrapping and non-wrapping segments', () => {
90 |     const multilineText = `This part will wrap around.
91 | And has a line break.
92 |   Leading spaces preserved.`;
93 |     const { lastFrame } = render(
94 |       <OverflowProvider>
95 |         <MaxSizedBox maxWidth={20} maxHeight={20}>
96 |           <Box>
97 |             <Text>Example</Text>
98 |           </Box>
99 |           <Box>
100 |             <Text>No Wrap: </Text>
101 |             <Text wrap="wrap">{multilineText}</Text>
102 |           </Box>
103 |           <Box>
104 |             <Text>Longer No Wrap: </Text>
105 |             <Text wrap="wrap">This part will wrap around.</Text>
106 |           </Box>
107 |         </MaxSizedBox>
108 |       </OverflowProvider>,
109 |     );
110 | 
111 |     expect(lastFrame()).equals(
112 |       `Example
113 | No Wrap: This part
114 |          will wrap
115 |          around.
116 |          And has a
117 |          line break.
118 |            Leading
119 |          spaces
120 |          preserved.
121 | Longer No Wrap: This
122 |                 part
123 |                 will
124 |                 wrap
125 |                 arou
126 |                 nd.`,
127 |     );
128 |   });
129 | 
130 |   it('handles words longer than maxWidth by splitting them', () => {
131 |     const { lastFrame } = render(
132 |       <OverflowProvider>
133 |         <MaxSizedBox maxWidth={5} maxHeight={5}>
134 |           <Box>
135 |             <Text wrap="wrap">Supercalifragilisticexpialidocious</Text>
136 |           </Box>
137 |         </MaxSizedBox>
138 |       </OverflowProvider>,
139 |     );
140 | 
141 |     expect(lastFrame()).equals(`... …
142 | istic
143 | expia
144 | lidoc
145 | ious`);
146 |   });
147 | 
148 |   it('does not truncate when maxHeight is undefined', () => {
149 |     const { lastFrame } = render(
150 |       <OverflowProvider>
151 |         <MaxSizedBox maxWidth={80} maxHeight={undefined}>
152 |           <Box>
153 |             <Text>Line 1</Text>
154 |           </Box>
155 |           <Box>
156 |             <Text>Line 2</Text>
157 |           </Box>
158 |         </MaxSizedBox>
159 |       </OverflowProvider>,
160 |     );
161 |     expect(lastFrame()).equals(`Line 1
162 | Line 2`);
163 |   });
164 | 
165 |   it('shows plural "lines" when more than one line is hidden', () => {
166 |     const { lastFrame } = render(
167 |       <OverflowProvider>
168 |         <MaxSizedBox maxWidth={80} maxHeight={2}>
169 |           <Box>
170 |             <Text>Line 1</Text>
171 |           </Box>
172 |           <Box>
173 |             <Text>Line 2</Text>
174 |           </Box>
175 |           <Box>
176 |             <Text>Line 3</Text>
177 |           </Box>
178 |         </MaxSizedBox>
179 |       </OverflowProvider>,
180 |     );
181 |     expect(lastFrame()).equals(`... first 2 lines hidden ...
182 | Line 3`);
183 |   });
184 | 
185 |   it('shows plural "lines" when more than one line is hidden and overflowDirection is bottom', () => {
186 |     const { lastFrame } = render(
187 |       <OverflowProvider>
188 |         <MaxSizedBox maxWidth={80} maxHeight={2} overflowDirection="bottom">
189 |           <Box>
190 |             <Text>Line 1</Text>
191 |           </Box>
192 |           <Box>
193 |             <Text>Line 2</Text>
194 |           </Box>
195 |           <Box>
196 |             <Text>Line 3</Text>
197 |           </Box>
198 |         </MaxSizedBox>
199 |       </OverflowProvider>,
200 |     );
201 |     expect(lastFrame()).equals(`Line 1
202 | ... last 2 lines hidden ...`);
203 |   });
204 | 
205 |   it('renders an empty box for empty children', () => {
206 |     const { lastFrame } = render(
207 |       <OverflowProvider>
208 |         <MaxSizedBox maxWidth={80} maxHeight={10}></MaxSizedBox>
209 |       </OverflowProvider>,
210 |     );
211 |     // Expect an empty string or a box with nothing in it.
212 |     // Ink renders an empty box as an empty string.
213 |     expect(lastFrame()).equals('');
214 |   });
215 | 
216 |   it('wraps text with multi-byte unicode characters correctly', () => {
217 |     const { lastFrame } = render(
218 |       <OverflowProvider>
219 |         <MaxSizedBox maxWidth={5} maxHeight={5}>
220 |           <Box>
221 |             <Text wrap="wrap">你好世界</Text>
222 |           </Box>
223 |         </MaxSizedBox>
224 |       </OverflowProvider>,
225 |     );
226 | 
227 |     // "你好" has a visual width of 4. "世界" has a visual width of 4.
228 |     // With maxWidth=5, it should wrap after the second character.
229 |     expect(lastFrame()).equals(`你好
230 | 世界`);
231 |   });
232 | 
233 |   it('wraps text with multi-byte emoji characters correctly', () => {
234 |     const { lastFrame } = render(
235 |       <OverflowProvider>
236 |         <MaxSizedBox maxWidth={5} maxHeight={5}>
237 |           <Box>
238 |             <Text wrap="wrap">🐶🐶🐶🐶🐶</Text>
239 |           </Box>
240 |         </MaxSizedBox>
241 |       </OverflowProvider>,
242 |     );
243 | 
244 |     // Each "🐶" has a visual width of 2.
245 |     // With maxWidth=5, it should wrap every 2 emojis.
246 |     expect(lastFrame()).equals(`🐶🐶
247 | 🐶🐶
248 | 🐶`);
249 |   });
250 | 
251 |   it('falls back to an ellipsis when width is extremely small', () => {
252 |     const { lastFrame } = render(
253 |       <OverflowProvider>
254 |         <MaxSizedBox maxWidth={2} maxHeight={2}>
255 |           <Box>
256 |             <Text>No</Text>
257 |             <Text wrap="wrap">wrap</Text>
258 |           </Box>
259 |         </MaxSizedBox>
260 |       </OverflowProvider>,
261 |     );
262 | 
263 |     expect(lastFrame()).equals('N…');
264 |   });
265 | 
266 |   it('truncates long non-wrapping text with ellipsis', () => {
267 |     const { lastFrame } = render(
268 |       <OverflowProvider>
269 |         <MaxSizedBox maxWidth={3} maxHeight={2}>
270 |           <Box>
271 |             <Text>ABCDE</Text>
272 |             <Text wrap="wrap">wrap</Text>
273 |           </Box>
274 |         </MaxSizedBox>
275 |       </OverflowProvider>,
276 |     );
277 | 
278 |     expect(lastFrame()).equals('AB…');
279 |   });
280 | 
281 |   it('truncates non-wrapping text containing line breaks', () => {
282 |     const { lastFrame } = render(
283 |       <OverflowProvider>
284 |         <MaxSizedBox maxWidth={3} maxHeight={2}>
285 |           <Box>
286 |             <Text>{'A\nBCDE'}</Text>
287 |             <Text wrap="wrap">wrap</Text>
288 |           </Box>
289 |         </MaxSizedBox>
290 |       </OverflowProvider>,
291 |     );
292 | 
293 |     expect(lastFrame()).equals(`A\n…`);
294 |   });
295 | 
296 |   it('truncates emoji characters correctly with ellipsis', () => {
297 |     const { lastFrame } = render(
298 |       <OverflowProvider>
299 |         <MaxSizedBox maxWidth={3} maxHeight={2}>
300 |           <Box>
301 |             <Text>🐶🐶🐶</Text>
302 |             <Text wrap="wrap">wrap</Text>
303 |           </Box>
304 |         </MaxSizedBox>
305 |       </OverflowProvider>,
306 |     );
307 | 
308 |     expect(lastFrame()).equals(`🐶…`);
309 |   });
310 | 
311 |   it('shows ellipsis for multiple rows with long non-wrapping text', () => {
312 |     const { lastFrame } = render(
313 |       <OverflowProvider>
314 |         <MaxSizedBox maxWidth={3} maxHeight={3}>
315 |           <Box>
316 |             <Text>AAA</Text>
317 |             <Text wrap="wrap">first</Text>
318 |           </Box>
319 |           <Box>
320 |             <Text>BBB</Text>
321 |             <Text wrap="wrap">second</Text>
322 |           </Box>
323 |           <Box>
324 |             <Text>CCC</Text>
325 |             <Text wrap="wrap">third</Text>
326 |           </Box>
327 |         </MaxSizedBox>
328 |       </OverflowProvider>,
329 |     );
330 | 
331 |     expect(lastFrame()).equals(`AA…\nBB…\nCC…`);
332 |   });
333 | 
334 |   it('accounts for additionalHiddenLinesCount', () => {
335 |     const { lastFrame } = render(
336 |       <OverflowProvider>
337 |         <MaxSizedBox maxWidth={80} maxHeight={2} additionalHiddenLinesCount={5}>
338 |           <Box>
339 |             <Text>Line 1</Text>
340 |           </Box>
341 |           <Box>
342 |             <Text>Line 2</Text>
343 |           </Box>
344 |           <Box>
345 |             <Text>Line 3</Text>
346 |           </Box>
347 |         </MaxSizedBox>
348 |       </OverflowProvider>,
349 |     );
350 |     // 1 line is hidden by overflow, 5 are additionally hidden.
351 |     expect(lastFrame()).equals(`... first 7 lines hidden ...
352 | Line 3`);
353 |   });
354 | 
355 |   it('handles React.Fragment as a child', () => {
356 |     const { lastFrame } = render(
357 |       <OverflowProvider>
358 |         <MaxSizedBox maxWidth={80} maxHeight={10}>
359 |           <>
360 |             <Box>
361 |               <Text>Line 1 from Fragment</Text>
362 |             </Box>
363 |             <Box>
364 |               <Text>Line 2 from Fragment</Text>
365 |             </Box>
366 |           </>
367 |           <Box>
368 |             <Text>Line 3 direct child</Text>
369 |           </Box>
370 |         </MaxSizedBox>
371 |       </OverflowProvider>,
372 |     );
373 |     expect(lastFrame()).equals(`Line 1 from Fragment
374 | Line 2 from Fragment
375 | Line 3 direct child`);
376 |   });
377 | 
378 |   it('clips a long single text child from the top', () => {
379 |     const THIRTY_LINES = Array.from(
380 |       { length: 30 },
381 |       (_, i) => `Line ${i + 1}`,
382 |     ).join('\n');
383 | 
384 |     const { lastFrame } = render(
385 |       <OverflowProvider>
386 |         <MaxSizedBox maxWidth={80} maxHeight={10}>
387 |           <Box>
[TRUNCATED]
```

src/ui/components/shared/MaxSizedBox.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import React, { Fragment, useEffect, useId } from 'react';
8 | import { Box, Text } from 'ink';
9 | import stringWidth from 'string-width';
10 | import { theme } from '../../semantic-colors.js';
11 | import { toCodePoints } from '../../utils/textUtils.js';
12 | import { useOverflowActions } from '../../contexts/OverflowContext.js';
13 | 
14 | let enableDebugLog = false;
15 | 
16 | /**
17 |  * Minimum height for the MaxSizedBox component.
18 |  * This ensures there is room for at least one line of content as well as the
19 |  * message that content was truncated.
20 |  */
21 | export const MINIMUM_MAX_HEIGHT = 2;
22 | 
23 | export function setMaxSizedBoxDebugging(value: boolean) {
24 |   enableDebugLog = value;
25 | }
26 | 
27 | function debugReportError(message: string, element: React.ReactNode) {
28 |   if (!enableDebugLog) return;
29 | 
30 |   if (!React.isValidElement(element)) {
31 |     console.error(
32 |       message,
33 |       `Invalid element: '${String(element)}' typeof=${typeof element}`,
34 |     );
35 |     return;
36 |   }
37 | 
38 |   let sourceMessage = '<Unknown file>';
39 |   try {
40 |     const elementWithSource = element as {
41 |       _source?: { fileName?: string; lineNumber?: number };
42 |     };
43 |     const fileName = elementWithSource._source?.fileName;
44 |     const lineNumber = elementWithSource._source?.lineNumber;
45 |     sourceMessage = fileName ? `${fileName}:${lineNumber}` : '<Unknown file>';
46 |   } catch (error) {
47 |     console.error('Error while trying to get file name:', error);
48 |   }
49 | 
50 |   console.error(message, `${String(element.type)}. Source: ${sourceMessage}`);
51 | }
52 | interface MaxSizedBoxProps {
53 |   children?: React.ReactNode;
54 |   maxWidth?: number;
55 |   maxHeight: number | undefined;
56 |   overflowDirection?: 'top' | 'bottom';
57 |   additionalHiddenLinesCount?: number;
58 | }
59 | 
60 | /**
61 |  * A React component that constrains the size of its children and provides
62 |  * content-aware truncation when the content exceeds the specified `maxHeight`.
63 |  *
64 |  * `MaxSizedBox` requires a specific structure for its children to correctly
65 |  * measure and render the content:
66 |  *
67 |  * 1.  **Direct children must be `<Box>` elements.** Each `<Box>` represents a
68 |  *     single row of content.
69 |  * 2.  **Row `<Box>` elements must contain only `<Text>` elements.** These
70 |  *     `<Text>` elements can be nested and there are no restrictions to Text
71 |  *     element styling other than that non-wrapping text elements must be
72 |  *     before wrapping text elements.
73 |  *
74 |  * **Constraints:**
75 |  * - **Box Properties:** Custom properties on the child `<Box>` elements are
76 |  *   ignored. In debug mode, runtime checks will report errors for any
77 |  *   unsupported properties.
78 |  * - **Text Wrapping:** Within a single row, `<Text>` elements with no wrapping
79 |  *   (e.g., headers, labels) must appear before any `<Text>` elements that wrap.
80 |  * - **Element Types:** Runtime checks will warn if unsupported element types
81 |  *   are used as children.
82 |  *
83 |  * @example
84 |  * <MaxSizedBox maxWidth={80} maxHeight={10}>
85 |  *   <Box>
86 |  *     <Text>This is the first line.</Text>
87 |  *   </Box>
88 |  *   <Box>
89 |  *     <Text color="cyan" wrap="truncate">Non-wrapping Header: </Text>
90 |  *     <Text>This is the rest of the line which will wrap if it's too long.</Text>
91 |  *   </Box>
92 |  *   <Box>
93 |  *     <Text>
94 |  *       Line 3 with <Text color="yellow">nested styled text</Text> inside of it.
95 |  *     </Text>
96 |  *   </Box>
97 |  * </MaxSizedBox>
98 |  */
99 | export const MaxSizedBox: React.FC<MaxSizedBoxProps> = ({
100 |   children,
101 |   maxWidth,
102 |   maxHeight,
103 |   overflowDirection = 'top',
104 |   additionalHiddenLinesCount = 0,
105 | }) => {
106 |   const id = useId();
107 |   const { addOverflowingId, removeOverflowingId } = useOverflowActions() || {};
108 | 
109 |   const laidOutStyledText: StyledText[][] = [];
110 |   const targetMaxHeight = Math.max(
111 |     Math.round(maxHeight ?? Number.MAX_SAFE_INTEGER),
112 |     MINIMUM_MAX_HEIGHT,
113 |   );
114 | 
115 |   if (maxWidth === undefined) {
116 |     throw new Error('maxWidth must be defined when maxHeight is set.');
117 |   }
118 |   function visitRows(element: React.ReactNode) {
119 |     if (!React.isValidElement<{ children?: React.ReactNode }>(element)) {
120 |       return;
121 |     }
122 | 
123 |     if (element.type === Fragment) {
124 |       React.Children.forEach(element.props.children, visitRows);
125 |       return;
126 |     }
127 | 
128 |     if (element.type === Box) {
129 |       layoutInkElementAsStyledText(element, maxWidth!, laidOutStyledText);
130 |       return;
131 |     }
132 | 
133 |     debugReportError('MaxSizedBox children must be <Box> elements', element);
134 |   }
135 | 
136 |   React.Children.forEach(children, visitRows);
137 | 
138 |   const contentWillOverflow =
139 |     (targetMaxHeight !== undefined &&
140 |       laidOutStyledText.length > targetMaxHeight) ||
141 |     additionalHiddenLinesCount > 0;
142 |   const visibleContentHeight =
143 |     contentWillOverflow && targetMaxHeight !== undefined
144 |       ? targetMaxHeight - 1
145 |       : targetMaxHeight;
146 | 
147 |   const hiddenLinesCount =
148 |     visibleContentHeight !== undefined
149 |       ? Math.max(0, laidOutStyledText.length - visibleContentHeight)
150 |       : 0;
151 |   const totalHiddenLines = hiddenLinesCount + additionalHiddenLinesCount;
152 | 
153 |   useEffect(() => {
154 |     if (totalHiddenLines > 0) {
155 |       addOverflowingId?.(id);
156 |     } else {
157 |       removeOverflowingId?.(id);
158 |     }
159 | 
160 |     return () => {
161 |       removeOverflowingId?.(id);
162 |     };
163 |   }, [id, totalHiddenLines, addOverflowingId, removeOverflowingId]);
164 | 
165 |   const visibleStyledText =
166 |     hiddenLinesCount > 0
167 |       ? overflowDirection === 'top'
168 |         ? laidOutStyledText.slice(hiddenLinesCount, laidOutStyledText.length)
169 |         : laidOutStyledText.slice(0, visibleContentHeight)
170 |       : laidOutStyledText;
171 | 
172 |   const visibleLines = visibleStyledText.map((line, index) => (
173 |     <Box key={index}>
174 |       {line.length > 0 ? (
175 |         line.map((segment, segIndex) => (
176 |           <Text key={segIndex} {...segment.props}>
177 |             {segment.text}
178 |           </Text>
179 |         ))
180 |       ) : (
181 |         <Text> </Text>
182 |       )}
183 |     </Box>
184 |   ));
185 | 
186 |   return (
187 |     <Box flexDirection="column" width={maxWidth} flexShrink={0}>
188 |       {totalHiddenLines > 0 && overflowDirection === 'top' && (
189 |         <Text color={theme.text.secondary} wrap="truncate">
190 |           ... first {totalHiddenLines} line{totalHiddenLines === 1 ? '' : 's'}{' '}
191 |           hidden ...
192 |         </Text>
193 |       )}
194 |       {visibleLines}
195 |       {totalHiddenLines > 0 && overflowDirection === 'bottom' && (
196 |         <Text color={theme.text.secondary} wrap="truncate">
197 |           ... last {totalHiddenLines} line{totalHiddenLines === 1 ? '' : 's'}{' '}
198 |           hidden ...
199 |         </Text>
200 |       )}
201 |     </Box>
202 |   );
203 | };
204 | 
205 | // Define a type for styled text segments
206 | interface StyledText {
207 |   text: string;
208 |   props: Record<string, unknown>;
209 | }
210 | 
211 | /**
212 |  * Single row of content within the MaxSizedBox.
213 |  *
214 |  * A row can contain segments that are not wrapped, followed by segments that
215 |  * are. This is a minimal implementation that only supports the functionality
216 |  * needed today.
217 |  */
218 | interface Row {
219 |   noWrapSegments: StyledText[];
220 |   segments: StyledText[];
221 | }
222 | 
223 | /**
224 |  * Flattens the child elements of MaxSizedBox into an array of `Row` objects.
225 |  *
226 |  * This function expects a specific child structure to function correctly:
227 |  * 1. The top-level child of `MaxSizedBox` should be a single `<Box>`. This
228 |  *    outer box is primarily for structure and is not directly rendered.
229 |  * 2. Inside the outer `<Box>`, there should be one or more children. Each of
230 |  *    these children must be a `<Box>` that represents a row.
231 |  * 3. Inside each "row" `<Box>`, the children must be `<Text>` components.
232 |  *
233 |  * The structure should look like this:
234 |  * <MaxSizedBox>
235 |  *   <Box> // Row 1
236 |  *     <Text>...</Text>
237 |  *     <Text>...</Text>
238 |  *   </Box>
239 |  *   <Box> // Row 2
240 |  *     <Text>...</Text>
241 |  *   </Box>
242 |  * </MaxSizedBox>
243 |  *
244 |  * It is an error for a <Text> child without wrapping to appear after a
245 |  * <Text> child with wrapping within the same row Box.
246 |  *
247 |  * @param element The React node to flatten.
248 |  * @returns An array of `Row` objects.
249 |  */
250 | function visitBoxRow(element: React.ReactNode): Row {
251 |   if (
252 |     !React.isValidElement<{ children?: React.ReactNode }>(element) ||
253 |     element.type !== Box
254 |   ) {
255 |     debugReportError(
256 |       `All children of MaxSizedBox must be <Box> elements`,
257 |       element,
258 |     );
259 |     return {
260 |       noWrapSegments: [{ text: '<ERROR>', props: {} }],
261 |       segments: [],
262 |     };
263 |   }
264 | 
265 |   if (enableDebugLog) {
266 |     const boxProps = element.props as {
267 |       children?: React.ReactNode;
268 |       readonly flexDirection?:
269 |         | 'row'
270 |         | 'column'
271 |         | 'row-reverse'
272 |         | 'column-reverse';
273 |     };
274 |     // Ensure the Box has no props other than the default ones and key.
275 |     let maxExpectedProps = 4;
276 |     if (boxProps.children !== undefined) {
277 |       // Allow the key prop, which is automatically added by React.
278 |       maxExpectedProps += 1;
279 |     }
280 |     if (
281 |       boxProps.flexDirection !== undefined &&
282 |       boxProps.flexDirection !== 'row'
283 |     ) {
284 |       debugReportError(
285 |         'MaxSizedBox children must have flexDirection="row".',
286 |         element,
287 |       );
288 |     }
289 |     if (Object.keys(boxProps).length > maxExpectedProps) {
290 |       debugReportError(
291 |         `Boxes inside MaxSizedBox must not have additional props. ${Object.keys(
292 |           boxProps,
293 |         ).join(', ')}`,
294 |         element,
295 |       );
296 |     }
297 |   }
298 | 
299 |   const row: Row = {
300 |     noWrapSegments: [],
301 |     segments: [],
302 |   };
303 | 
304 |   let hasSeenWrapped = false;
305 | 
306 |   function visitRowChild(
307 |     element: React.ReactNode,
308 |     parentProps: Record<string, unknown> | undefined,
309 |   ) {
310 |     if (element === null) {
311 |       return;
312 |     }
313 |     if (typeof element === 'string' || typeof element === 'number') {
314 |       const text = String(element);
315 |       // Ignore empty strings as they don't need to be rendered.
316 |       if (!text) {
317 |         return;
318 |       }
319 | 
320 |       const segment: StyledText = { text, props: parentProps ?? {} };
321 | 
322 |       // Check the 'wrap' property from the merged props to decide the segment type.
323 |       if (parentProps === undefined || parentProps['wrap'] === 'wrap') {
324 |         hasSeenWrapped = true;
325 |         row.segments.push(segment);
326 |       } else {
327 |         if (!hasSeenWrapped) {
328 |           row.noWrapSegments.push(segment);
329 |         } else {
330 |           // put in the wrapped segment as the row is already stuck in wrapped mode.
331 |           row.segments.push(segment);
332 |           debugReportError(
333 |             'Text elements without wrapping cannot appear after elements with wrapping in the same row.',
334 |             element,
335 |           );
336 |         }
337 |       }
338 |       return;
339 |     }
340 | 
341 |     if (!React.isValidElement<{ children?: React.ReactNode }>(element)) {
342 |       debugReportError('Invalid element.', element);
343 |       return;
344 |     }
345 | 
346 |     if (element.type === Fragment) {
347 |       React.Children.forEach(element.props.children, (child) =>
348 |         visitRowChild(child, parentProps),
349 |       );
350 |       return;
351 |     }
352 | 
353 |     if (element.type !== Text) {
354 |       debugReportError(
[TRUNCATED]
```

src/ui/components/shared/RadioButtonSelect.test.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect, vi, beforeEach } from 'vitest';
8 | import { renderWithProviders } from '../../../test-utils/render.js';
9 | import type React from 'react';
10 | import {
11 |   RadioButtonSelect,
12 |   type RadioSelectItem,
13 |   type RadioButtonSelectProps,
14 | } from './RadioButtonSelect.js';
15 | import {
16 |   BaseSelectionList,
17 |   type BaseSelectionListProps,
18 |   type RenderItemContext,
19 | } from './BaseSelectionList.js';
20 | 
21 | vi.mock('./BaseSelectionList.js', () => ({
22 |   BaseSelectionList: vi.fn(() => null),
23 | }));
24 | 
25 | vi.mock('../../semantic-colors.js', () => ({
26 |   theme: {
27 |     text: { secondary: 'COLOR_SECONDARY' },
28 |   },
29 | }));
30 | 
31 | const MockedBaseSelectionList = vi.mocked(
32 |   BaseSelectionList,
33 | ) as unknown as ReturnType<typeof vi.fn>;
34 | 
35 | type RadioRenderItemFn = (
36 |   item: RadioSelectItem<string>,
37 |   context: RenderItemContext,
38 | ) => React.JSX.Element;
39 | const extractRenderItem = (): RadioRenderItemFn => {
40 |   const mockCalls = MockedBaseSelectionList.mock.calls;
41 | 
42 |   if (mockCalls.length === 0) {
43 |     throw new Error(
44 |       'BaseSelectionList was not called. Ensure RadioButtonSelect is rendered before calling extractRenderItem.',
45 |     );
46 |   }
47 | 
48 |   const props = mockCalls[0][0] as BaseSelectionListProps<
49 |     string,
50 |     RadioSelectItem<string>
51 |   >;
52 | 
53 |   if (typeof props.renderItem !== 'function') {
54 |     throw new Error('renderItem prop was not found on BaseSelectionList call.');
55 |   }
56 | 
57 |   return props.renderItem as RadioRenderItemFn;
58 | };
59 | 
60 | describe('RadioButtonSelect', () => {
61 |   const mockOnSelect = vi.fn();
62 |   const mockOnHighlight = vi.fn();
63 | 
64 |   const ITEMS: Array<RadioSelectItem<string>> = [
65 |     { label: 'Option 1', value: 'one', key: 'one' },
66 |     { label: 'Option 2', value: 'two', key: 'two' },
67 |     { label: 'Option 3', value: 'three', disabled: true, key: 'three' },
68 |   ];
69 | 
70 |   const renderComponent = (
71 |     props: Partial<RadioButtonSelectProps<string>> = {},
72 |   ) => {
73 |     const defaultProps: RadioButtonSelectProps<string> = {
74 |       items: ITEMS,
75 |       onSelect: mockOnSelect,
76 |       ...props,
77 |     };
78 |     return renderWithProviders(<RadioButtonSelect {...defaultProps} />);
79 |   };
80 | 
81 |   beforeEach(() => {
82 |     vi.clearAllMocks();
83 |   });
84 | 
85 |   describe('Prop forwarding to BaseSelectionList', () => {
86 |     it('should forward all props correctly when provided', () => {
87 |       const props = {
88 |         items: ITEMS,
89 |         initialIndex: 1,
90 |         onSelect: mockOnSelect,
91 |         onHighlight: mockOnHighlight,
92 |         isFocused: false,
93 |         showScrollArrows: true,
94 |         maxItemsToShow: 5,
95 |         showNumbers: false,
96 |       };
97 | 
98 |       renderComponent(props);
99 | 
100 |       expect(BaseSelectionList).toHaveBeenCalledTimes(1);
101 |       expect(BaseSelectionList).toHaveBeenCalledWith(
102 |         expect.objectContaining({
103 |           ...props,
104 |           renderItem: expect.any(Function),
105 |         }),
106 |         undefined,
107 |       );
108 |     });
109 | 
110 |     it('should use default props if not provided', () => {
111 |       renderComponent({
112 |         items: ITEMS,
113 |         onSelect: mockOnSelect,
114 |       });
115 | 
116 |       expect(BaseSelectionList).toHaveBeenCalledWith(
117 |         expect.objectContaining({
118 |           initialIndex: 0,
119 |           isFocused: true,
120 |           showScrollArrows: false,
121 |           maxItemsToShow: 10,
122 |           showNumbers: true,
123 |         }),
124 |         undefined,
125 |       );
126 |     });
127 |   });
128 | 
129 |   describe('renderItem implementation', () => {
130 |     let renderItem: RadioRenderItemFn;
131 |     const mockContext: RenderItemContext = {
132 |       isSelected: false,
133 |       titleColor: 'MOCK_TITLE_COLOR',
134 |       numberColor: 'MOCK_NUMBER_COLOR',
135 |     };
136 | 
137 |     beforeEach(() => {
138 |       renderComponent();
139 |       renderItem = extractRenderItem();
140 |     });
141 | 
142 |     it('should render the standard label display with correct color and truncation', () => {
143 |       const item = ITEMS[0];
144 | 
145 |       const result = renderItem(item, mockContext);
146 | 
147 |       expect(result?.props?.color).toBe(mockContext.titleColor);
148 |       expect(result?.props?.children).toBe('Option 1');
149 |       expect(result?.props?.wrap).toBe('truncate');
150 |     });
151 | 
152 |     it('should render the special theme display when theme props are present', () => {
153 |       const themeItem: RadioSelectItem<string> = {
154 |         label: 'Theme A (Light)',
155 |         value: 'a-light',
156 |         themeNameDisplay: 'Theme A',
157 |         themeTypeDisplay: '(Light)',
158 |         key: 'a-light',
159 |       };
160 | 
161 |       const result = renderItem(themeItem, mockContext);
162 | 
163 |       expect(result?.props?.color).toBe(mockContext.titleColor);
164 |       expect(result?.props?.wrap).toBe('truncate');
165 | 
166 |       const children = result?.props?.children;
167 | 
168 |       if (!Array.isArray(children) || children.length < 3) {
169 |         throw new Error(
170 |           'Expected children to be an array with at least 3 elements for theme display',
171 |         );
172 |       }
173 | 
174 |       expect(children[0]).toBe('Theme A');
175 |       expect(children[1]).toBe(' ');
176 | 
177 |       const nestedTextElement = children[2] as React.ReactElement<{
178 |         color?: string;
179 |         children?: React.ReactNode;
180 |       }>;
181 |       expect(nestedTextElement?.props?.color).toBe('COLOR_SECONDARY');
182 |       expect(nestedTextElement?.props?.children).toBe('(Light)');
183 |     });
184 | 
185 |     it('should fall back to standard display if only one theme prop is present', () => {
186 |       const partialThemeItem: RadioSelectItem<string> = {
187 |         label: 'Incomplete Theme',
188 |         value: 'incomplete',
189 |         themeNameDisplay: 'Only Name',
190 |         key: 'incomplete',
191 |       };
192 | 
193 |       const result = renderItem(partialThemeItem, mockContext);
194 | 
195 |       expect(result?.props?.children).toBe('Incomplete Theme');
196 |     });
197 |   });
198 | });
```

src/ui/components/shared/RadioButtonSelect.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type React from 'react';
8 | import { Text } from 'ink';
9 | import { theme } from '../../semantic-colors.js';
10 | import { BaseSelectionList } from './BaseSelectionList.js';
11 | import type { SelectionListItem } from '../../hooks/useSelectionList.js';
12 | 
13 | /**
14 |  * Represents a single option for the RadioButtonSelect.
15 |  * Requires a label for display and a value to be returned on selection.
16 |  */
17 | export interface RadioSelectItem<T> extends SelectionListItem<T> {
18 |   label: string;
19 |   themeNameDisplay?: string;
20 |   themeTypeDisplay?: string;
21 | }
22 | 
23 | /**
24 |  * Props for the RadioButtonSelect component.
25 |  * @template T The type of the value associated with each radio item.
26 |  */
27 | export interface RadioButtonSelectProps<T> {
28 |   /** An array of items to display as radio options. */
29 |   items: Array<RadioSelectItem<T>>;
30 |   /** The initial index selected */
31 |   initialIndex?: number;
32 |   /** Function called when an item is selected. Receives the `value` of the selected item. */
33 |   onSelect: (value: T) => void;
34 |   /** Function called when an item is highlighted. Receives the `value` of the selected item. */
35 |   onHighlight?: (value: T) => void;
36 |   /** Whether this select input is currently focused and should respond to input. */
37 |   isFocused?: boolean;
38 |   /** Whether to show the scroll arrows. */
39 |   showScrollArrows?: boolean;
40 |   /** The maximum number of items to show at once. */
41 |   maxItemsToShow?: number;
42 |   /** Whether to show numbers next to items. */
43 |   showNumbers?: boolean;
44 | }
45 | 
46 | /**
47 |  * A custom component that displays a list of items with radio buttons,
48 |  * supporting scrolling and keyboard navigation.
49 |  *
50 |  * @template T The type of the value associated with each radio item.
51 |  */
52 | export function RadioButtonSelect<T>({
53 |   items,
54 |   initialIndex = 0,
55 |   onSelect,
56 |   onHighlight,
57 |   isFocused = true,
58 |   showScrollArrows = false,
59 |   maxItemsToShow = 10,
60 |   showNumbers = true,
61 | }: RadioButtonSelectProps<T>): React.JSX.Element {
62 |   return (
63 |     <BaseSelectionList<T, RadioSelectItem<T>>
64 |       items={items}
65 |       initialIndex={initialIndex}
66 |       onSelect={onSelect}
67 |       onHighlight={onHighlight}
68 |       isFocused={isFocused}
69 |       showNumbers={showNumbers}
70 |       showScrollArrows={showScrollArrows}
71 |       maxItemsToShow={maxItemsToShow}
72 |       renderItem={(item, { titleColor }) => {
73 |         // Handle special theme display case for ThemeDialog compatibility
74 |         if (item.themeNameDisplay && item.themeTypeDisplay) {
75 |           return (
76 |             <Text color={titleColor} wrap="truncate" key={item.key}>
77 |               {item.themeNameDisplay}{' '}
78 |               <Text color={theme.text.secondary}>{item.themeTypeDisplay}</Text>
79 |             </Text>
80 |           );
81 |         }
82 |         // Regular label display
83 |         return (
84 |           <Text color={titleColor} wrap="truncate">
85 |             {item.label}
86 |           </Text>
87 |         );
88 |       }}
89 |     />
90 |   );
91 | }
```

src/ui/components/shared/ScopeSelector.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type React from 'react';
8 | import { Box, Text } from 'ink';
9 | import type { SettingScope } from '../../../config/settings.js';
10 | import { getScopeItems } from '../../../utils/dialogScopeUtils.js';
11 | import { RadioButtonSelect } from './RadioButtonSelect.js';
12 | 
13 | interface ScopeSelectorProps {
14 |   /** Callback function when a scope is selected */
15 |   onSelect: (scope: SettingScope) => void;
16 |   /** Callback function when a scope is highlighted */
17 |   onHighlight: (scope: SettingScope) => void;
18 |   /** Whether the component is focused */
19 |   isFocused: boolean;
20 |   /** The initial scope to select */
21 |   initialScope: SettingScope;
22 | }
23 | 
24 | export function ScopeSelector({
25 |   onSelect,
26 |   onHighlight,
27 |   isFocused,
28 |   initialScope,
29 | }: ScopeSelectorProps): React.JSX.Element {
30 |   const scopeItems = getScopeItems().map((item) => ({
31 |     ...item,
32 |     key: item.value,
33 |   }));
34 | 
35 |   const initialIndex = scopeItems.findIndex(
36 |     (item) => item.value === initialScope,
37 |   );
38 |   const safeInitialIndex = initialIndex >= 0 ? initialIndex : 0;
39 | 
40 |   return (
41 |     <Box flexDirection="column">
42 |       <Text bold={isFocused} wrap="truncate">
43 |         {isFocused ? '> ' : '  '}Apply To
44 |       </Text>
45 |       <RadioButtonSelect
46 |         items={scopeItems}
47 |         initialIndex={safeInitialIndex}
48 |         onSelect={onSelect}
49 |         onHighlight={onHighlight}
50 |         isFocused={isFocused}
51 |         showNumbers={isFocused}
52 |       />
53 |     </Box>
54 |   );
55 | }
```

src/ui/components/shared/text-buffer.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect, beforeEach } from 'vitest';
8 | import stripAnsi from 'strip-ansi';
9 | import { renderHook, act } from '@testing-library/react';
10 | import type {
11 |   Viewport,
12 |   TextBuffer,
13 |   TextBufferState,
14 |   TextBufferAction,
15 | } from './text-buffer.js';
16 | import {
17 |   useTextBuffer,
18 |   offsetToLogicalPos,
19 |   logicalPosToOffset,
20 |   textBufferReducer,
21 |   findWordEndInLine,
22 |   findNextWordStartInLine,
23 |   isWordCharStrict,
24 | } from './text-buffer.js';
25 | import { cpLen } from '../../utils/textUtils.js';
26 | 
27 | const initialState: TextBufferState = {
28 |   lines: [''],
29 |   cursorRow: 0,
30 |   cursorCol: 0,
31 |   preferredCol: null,
32 |   undoStack: [],
33 |   redoStack: [],
34 |   clipboard: null,
35 |   selectionAnchor: null,
36 | };
37 | 
38 | describe('textBufferReducer', () => {
39 |   it('should return the initial state if state is undefined', () => {
40 |     const action = { type: 'unknown_action' } as unknown as TextBufferAction;
41 |     const state = textBufferReducer(initialState, action);
42 |     expect(state).toHaveOnlyValidCharacters();
43 |     expect(state).toEqual(initialState);
44 |   });
45 | 
46 |   describe('set_text action', () => {
47 |     it('should set new text and move cursor to the end', () => {
48 |       const action: TextBufferAction = {
49 |         type: 'set_text',
50 |         payload: 'hello\nworld',
51 |       };
52 |       const state = textBufferReducer(initialState, action);
53 |       expect(state).toHaveOnlyValidCharacters();
54 |       expect(state.lines).toEqual(['hello', 'world']);
55 |       expect(state.cursorRow).toBe(1);
56 |       expect(state.cursorCol).toBe(5);
57 |       expect(state.undoStack.length).toBe(1);
58 |     });
59 | 
60 |     it('should not create an undo snapshot if pushToUndo is false', () => {
61 |       const action: TextBufferAction = {
62 |         type: 'set_text',
63 |         payload: 'no undo',
64 |         pushToUndo: false,
65 |       };
66 |       const state = textBufferReducer(initialState, action);
67 |       expect(state).toHaveOnlyValidCharacters();
68 |       expect(state.lines).toEqual(['no undo']);
69 |       expect(state.undoStack.length).toBe(0);
70 |     });
71 |   });
72 | 
73 |   describe('insert action', () => {
74 |     it('should insert a character', () => {
75 |       const action: TextBufferAction = { type: 'insert', payload: 'a' };
76 |       const state = textBufferReducer(initialState, action);
77 |       expect(state).toHaveOnlyValidCharacters();
78 |       expect(state.lines).toEqual(['a']);
79 |       expect(state.cursorCol).toBe(1);
80 |     });
81 | 
82 |     it('should insert a newline', () => {
83 |       const stateWithText = { ...initialState, lines: ['hello'] };
84 |       const action: TextBufferAction = { type: 'insert', payload: '\n' };
85 |       const state = textBufferReducer(stateWithText, action);
86 |       expect(state).toHaveOnlyValidCharacters();
87 |       expect(state.lines).toEqual(['', 'hello']);
88 |       expect(state.cursorRow).toBe(1);
89 |       expect(state.cursorCol).toBe(0);
90 |     });
91 |   });
92 | 
93 |   describe('backspace action', () => {
94 |     it('should remove a character', () => {
95 |       const stateWithText: TextBufferState = {
96 |         ...initialState,
97 |         lines: ['a'],
98 |         cursorRow: 0,
99 |         cursorCol: 1,
100 |       };
101 |       const action: TextBufferAction = { type: 'backspace' };
102 |       const state = textBufferReducer(stateWithText, action);
103 |       expect(state).toHaveOnlyValidCharacters();
104 |       expect(state.lines).toEqual(['']);
105 |       expect(state.cursorCol).toBe(0);
106 |     });
107 | 
108 |     it('should join lines if at the beginning of a line', () => {
109 |       const stateWithText: TextBufferState = {
110 |         ...initialState,
111 |         lines: ['hello', 'world'],
112 |         cursorRow: 1,
113 |         cursorCol: 0,
114 |       };
115 |       const action: TextBufferAction = { type: 'backspace' };
116 |       const state = textBufferReducer(stateWithText, action);
117 |       expect(state).toHaveOnlyValidCharacters();
118 |       expect(state.lines).toEqual(['helloworld']);
119 |       expect(state.cursorRow).toBe(0);
120 |       expect(state.cursorCol).toBe(5);
121 |     });
122 |   });
123 | 
124 |   describe('undo/redo actions', () => {
125 |     it('should undo and redo a change', () => {
126 |       // 1. Insert text
127 |       const insertAction: TextBufferAction = {
128 |         type: 'insert',
129 |         payload: 'test',
130 |       };
131 |       const stateAfterInsert = textBufferReducer(initialState, insertAction);
132 |       expect(stateAfterInsert).toHaveOnlyValidCharacters();
133 |       expect(stateAfterInsert.lines).toEqual(['test']);
134 |       expect(stateAfterInsert.undoStack.length).toBe(1);
135 | 
136 |       // 2. Undo
137 |       const undoAction: TextBufferAction = { type: 'undo' };
138 |       const stateAfterUndo = textBufferReducer(stateAfterInsert, undoAction);
139 |       expect(stateAfterUndo).toHaveOnlyValidCharacters();
140 |       expect(stateAfterUndo.lines).toEqual(['']);
141 |       expect(stateAfterUndo.undoStack.length).toBe(0);
142 |       expect(stateAfterUndo.redoStack.length).toBe(1);
143 | 
144 |       // 3. Redo
145 |       const redoAction: TextBufferAction = { type: 'redo' };
146 |       const stateAfterRedo = textBufferReducer(stateAfterUndo, redoAction);
147 |       expect(stateAfterRedo).toHaveOnlyValidCharacters();
148 |       expect(stateAfterRedo.lines).toEqual(['test']);
149 |       expect(stateAfterRedo.undoStack.length).toBe(1);
150 |       expect(stateAfterRedo.redoStack.length).toBe(0);
151 |     });
152 |   });
153 | 
154 |   describe('create_undo_snapshot action', () => {
155 |     it('should create a snapshot without changing state', () => {
156 |       const stateWithText: TextBufferState = {
157 |         ...initialState,
158 |         lines: ['hello'],
159 |         cursorRow: 0,
160 |         cursorCol: 5,
161 |       };
162 |       const action: TextBufferAction = { type: 'create_undo_snapshot' };
163 |       const state = textBufferReducer(stateWithText, action);
164 |       expect(state).toHaveOnlyValidCharacters();
165 | 
166 |       expect(state.lines).toEqual(['hello']);
167 |       expect(state.cursorRow).toBe(0);
168 |       expect(state.cursorCol).toBe(5);
169 |       expect(state.undoStack.length).toBe(1);
170 |       expect(state.undoStack[0].lines).toEqual(['hello']);
171 |       expect(state.undoStack[0].cursorRow).toBe(0);
172 |       expect(state.undoStack[0].cursorCol).toBe(5);
173 |     });
174 |   });
175 | 
176 |   describe('delete_word_left action', () => {
177 |     it('should delete a simple word', () => {
178 |       const stateWithText: TextBufferState = {
179 |         ...initialState,
180 |         lines: ['hello world'],
181 |         cursorRow: 0,
182 |         cursorCol: 11,
183 |       };
184 |       const action: TextBufferAction = { type: 'delete_word_left' };
185 |       const state = textBufferReducer(stateWithText, action);
186 |       expect(state.lines).toEqual(['hello ']);
187 |       expect(state.cursorCol).toBe(6);
188 |     });
189 | 
190 |     it('should delete a path segment', () => {
191 |       const stateWithText: TextBufferState = {
192 |         ...initialState,
193 |         lines: ['path/to/file'],
194 |         cursorRow: 0,
195 |         cursorCol: 12,
196 |       };
197 |       const action: TextBufferAction = { type: 'delete_word_left' };
198 |       const state = textBufferReducer(stateWithText, action);
199 |       expect(state.lines).toEqual(['path/to/']);
200 |       expect(state.cursorCol).toBe(8);
201 |     });
202 | 
203 |     it('should delete variable_name parts', () => {
204 |       const stateWithText: TextBufferState = {
205 |         ...initialState,
206 |         lines: ['variable_name'],
207 |         cursorRow: 0,
208 |         cursorCol: 13,
209 |       };
210 |       const action: TextBufferAction = { type: 'delete_word_left' };
211 |       const state = textBufferReducer(stateWithText, action);
212 |       expect(state.lines).toEqual(['variable_']);
213 |       expect(state.cursorCol).toBe(9);
214 |     });
215 | 
216 |     it('should act like backspace at the beginning of a line', () => {
217 |       const stateWithText: TextBufferState = {
218 |         ...initialState,
219 |         lines: ['hello', 'world'],
220 |         cursorRow: 1,
221 |         cursorCol: 0,
222 |       };
223 |       const action: TextBufferAction = { type: 'delete_word_left' };
224 |       const state = textBufferReducer(stateWithText, action);
225 |       expect(state.lines).toEqual(['helloworld']);
226 |       expect(state.cursorRow).toBe(0);
227 |       expect(state.cursorCol).toBe(5);
228 |     });
229 |   });
230 | 
231 |   describe('delete_word_right action', () => {
232 |     it('should delete a simple word', () => {
233 |       const stateWithText: TextBufferState = {
234 |         ...initialState,
235 |         lines: ['hello world'],
236 |         cursorRow: 0,
237 |         cursorCol: 0,
238 |       };
239 |       const action: TextBufferAction = { type: 'delete_word_right' };
240 |       const state = textBufferReducer(stateWithText, action);
241 |       expect(state.lines).toEqual(['world']);
242 |       expect(state.cursorCol).toBe(0);
243 |     });
244 | 
245 |     it('should delete a path segment', () => {
246 |       const stateWithText: TextBufferState = {
247 |         ...initialState,
248 |         lines: ['path/to/file'],
249 |         cursorRow: 0,
250 |         cursorCol: 0,
251 |       };
252 |       const action: TextBufferAction = { type: 'delete_word_right' };
253 |       let state = textBufferReducer(stateWithText, action);
254 |       expect(state.lines).toEqual(['/to/file']);
255 |       state = textBufferReducer(state, action);
256 |       expect(state.lines).toEqual(['to/file']);
257 |     });
258 | 
259 |     it('should delete variable_name parts', () => {
260 |       const stateWithText: TextBufferState = {
261 |         ...initialState,
262 |         lines: ['variable_name'],
263 |         cursorRow: 0,
264 |         cursorCol: 0,
265 |       };
266 |       const action: TextBufferAction = { type: 'delete_word_right' };
267 |       const state = textBufferReducer(stateWithText, action);
268 |       expect(state.lines).toEqual(['_name']);
269 |       expect(state.cursorCol).toBe(0);
270 |     });
271 | 
272 |     it('should act like delete at the end of a line', () => {
273 |       const stateWithText: TextBufferState = {
274 |         ...initialState,
275 |         lines: ['hello', 'world'],
276 |         cursorRow: 0,
277 |         cursorCol: 5,
278 |       };
279 |       const action: TextBufferAction = { type: 'delete_word_right' };
280 |       const state = textBufferReducer(stateWithText, action);
281 |       expect(state.lines).toEqual(['helloworld']);
282 |       expect(state.cursorRow).toBe(0);
283 |       expect(state.cursorCol).toBe(5);
284 |     });
285 |   });
286 | });
287 | 
288 | // Helper to get the state from the hook
289 | const getBufferState = (result: { current: TextBuffer }) => {
290 |   expect(result.current).toHaveOnlyValidCharacters();
291 |   return {
292 |     text: result.current.text,
293 |     lines: [...result.current.lines], // Clone for safety
294 |     cursor: [...result.current.cursor] as [number, number],
295 |     allVisualLines: [...result.current.allVisualLines],
296 |     viewportVisualLines: [...result.current.viewportVisualLines],
297 |     visualCursor: [...result.current.visualCursor] as [number, number],
298 |     visualScrollRow: result.current.visualScrollRow,
299 |     preferredCol: result.current.preferredCol,
300 |   };
301 | };
302 | 
303 | describe('useTextBuffer', () => {
304 |   let viewport: Viewport;
305 | 
306 |   beforeEach(() => {
307 |     viewport = { width: 10, height: 3 }; // Default viewport for tests
308 |   });
309 | 
310 |   describe('Initialization', () => {
311 |     it('should initialize with empty text and cursor at (0,0) by default', () => {
312 |       const { result } = renderHook(() =>
313 |         useTextBuffer({ viewport, isValidPath: () => false }),
314 |       );
315 |       const state = getBufferState(result);
316 |       expect(state.text).toBe('');
317 |       expect(state.lines).toEqual(['']);
318 |       expect(state.cursor).toEqual([0, 0]);
319 |       expect(state.allVisualLines).toEqual(['']);
320 |       expect(state.viewportVisualLines).toEqual(['']);
321 |       expect(state.visualCursor).toEqual([0, 0]);
322 |       expect(state.visualScrollRow).toBe(0);
323 |     });
324 | 
325 |     it('should initialize with provided initialText', () => {
326 |       const { result } = renderHook(() =>
327 |         useTextBuffer({
328 |           initialText: 'hello',
329 |           viewport,
330 |           isValidPath: () => false,
331 |         }),
332 |       );
333 |       const state = getBufferState(result);
334 |       expect(state.text).toBe('hello');
335 |       expect(state.lines).toEqual(['hello']);
336 |       expect(state.cursor).toEqual([0, 0]); // Default cursor if offset not given
337 |       expect(state.allVisualLines).toEqual(['hello']);
338 |       expect(state.viewportVisualLines).toEqual(['hello']);
339 |       expect(state.visualCursor).toEqual([0, 0]);
340 |     });
341 | 
342 |     it('should initialize with initialText and initialCursorOffset', () => {
343 |       const { result } = renderHook(() =>
344 |         useTextBuffer({
345 |           initialText: 'hello\nworld',
346 |           initialCursorOffset: 7, // Should be at 'o' in 'world'
347 |           viewport,
348 |           isValidPath: () => false,
349 |         }),
350 |       );
[TRUNCATED]
```

src/ui/components/shared/text-buffer.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { spawnSync } from 'node:child_process';
8 | import fs from 'node:fs';
9 | import os from 'node:os';
10 | import pathMod from 'node:path';
11 | import { useState, useCallback, useEffect, useMemo, useReducer } from 'react';
12 | import { unescapePath } from '@google/gemini-cli-core';
13 | import {
14 |   toCodePoints,
15 |   cpLen,
16 |   cpSlice,
17 |   stripUnsafeCharacters,
18 |   getCachedStringWidth,
19 | } from '../../utils/textUtils.js';
20 | import type { VimAction } from './vim-buffer-actions.js';
21 | import { handleVimAction } from './vim-buffer-actions.js';
22 | 
23 | export type Direction =
24 |   | 'left'
25 |   | 'right'
26 |   | 'up'
27 |   | 'down'
28 |   | 'wordLeft'
29 |   | 'wordRight'
30 |   | 'home'
31 |   | 'end';
32 | 
33 | // Simple helper for word‑wise ops.
34 | function isWordChar(ch: string | undefined): boolean {
35 |   if (ch === undefined) {
36 |     return false;
37 |   }
38 |   return !/[\s,.;!?]/.test(ch);
39 | }
40 | 
41 | // Helper functions for line-based word navigation
42 | export const isWordCharStrict = (char: string): boolean =>
43 |   /[\w\p{L}\p{N}]/u.test(char); // Matches a single character that is any Unicode letter, any Unicode number, or an underscore
44 | 
45 | export const isWhitespace = (char: string): boolean => /\s/.test(char);
46 | 
47 | // Check if a character is a combining mark (only diacritics for now)
48 | export const isCombiningMark = (char: string): boolean => /\p{M}/u.test(char);
49 | 
50 | // Check if a character should be considered part of a word (including combining marks)
51 | export const isWordCharWithCombining = (char: string): boolean =>
52 |   isWordCharStrict(char) || isCombiningMark(char);
53 | 
54 | // Get the script of a character (simplified for common scripts)
55 | export const getCharScript = (char: string): string => {
56 |   if (/[\p{Script=Latin}]/u.test(char)) return 'latin'; // All Latin script chars including diacritics
57 |   if (/[\p{Script=Han}]/u.test(char)) return 'han'; // Chinese
58 |   if (/[\p{Script=Arabic}]/u.test(char)) return 'arabic';
59 |   if (/[\p{Script=Hiragana}]/u.test(char)) return 'hiragana';
60 |   if (/[\p{Script=Katakana}]/u.test(char)) return 'katakana';
61 |   if (/[\p{Script=Cyrillic}]/u.test(char)) return 'cyrillic';
62 |   return 'other';
63 | };
64 | 
65 | // Check if two characters are from different scripts (indicating word boundary)
66 | export const isDifferentScript = (char1: string, char2: string): boolean => {
67 |   if (!isWordCharStrict(char1) || !isWordCharStrict(char2)) return false;
68 |   return getCharScript(char1) !== getCharScript(char2);
69 | };
70 | 
71 | // Find next word start within a line, starting from col
72 | export const findNextWordStartInLine = (
73 |   line: string,
74 |   col: number,
75 | ): number | null => {
76 |   const chars = toCodePoints(line);
77 |   let i = col;
78 | 
79 |   if (i >= chars.length) return null;
80 | 
81 |   const currentChar = chars[i];
82 | 
83 |   // Skip current word/sequence based on character type
84 |   if (isWordCharStrict(currentChar)) {
85 |     while (i < chars.length && isWordCharWithCombining(chars[i])) {
86 |       // Check for script boundary - if next character is from different script, stop here
87 |       if (
88 |         i + 1 < chars.length &&
89 |         isWordCharStrict(chars[i + 1]) &&
90 |         isDifferentScript(chars[i], chars[i + 1])
91 |       ) {
92 |         i++; // Include current character
93 |         break; // Stop at script boundary
94 |       }
95 |       i++;
96 |     }
97 |   } else if (!isWhitespace(currentChar)) {
98 |     while (
99 |       i < chars.length &&
100 |       !isWordCharStrict(chars[i]) &&
101 |       !isWhitespace(chars[i])
102 |     ) {
103 |       i++;
104 |     }
105 |   }
106 | 
107 |   // Skip whitespace
108 |   while (i < chars.length && isWhitespace(chars[i])) {
109 |     i++;
110 |   }
111 | 
112 |   return i < chars.length ? i : null;
113 | };
114 | 
115 | // Find previous word start within a line
116 | export const findPrevWordStartInLine = (
117 |   line: string,
118 |   col: number,
119 | ): number | null => {
120 |   const chars = toCodePoints(line);
121 |   let i = col;
122 | 
123 |   if (i <= 0) return null;
124 | 
125 |   i--;
126 | 
127 |   // Skip whitespace moving backwards
128 |   while (i >= 0 && isWhitespace(chars[i])) {
129 |     i--;
130 |   }
131 | 
132 |   if (i < 0) return null;
133 | 
134 |   if (isWordCharStrict(chars[i])) {
135 |     // We're in a word, move to its beginning
136 |     while (i >= 0 && isWordCharStrict(chars[i])) {
137 |       // Check for script boundary - if previous character is from different script, stop here
138 |       if (
139 |         i - 1 >= 0 &&
140 |         isWordCharStrict(chars[i - 1]) &&
141 |         isDifferentScript(chars[i], chars[i - 1])
142 |       ) {
143 |         return i; // Return current position at script boundary
144 |       }
145 |       i--;
146 |     }
147 |     return i + 1;
148 |   } else {
149 |     // We're in punctuation, move to its beginning
150 |     while (i >= 0 && !isWordCharStrict(chars[i]) && !isWhitespace(chars[i])) {
151 |       i--;
152 |     }
153 |     return i + 1;
154 |   }
155 | };
156 | 
157 | // Find word end within a line
158 | export const findWordEndInLine = (line: string, col: number): number | null => {
159 |   const chars = toCodePoints(line);
160 |   let i = col;
161 | 
162 |   // If we're already at the end of a word (including punctuation sequences), advance to next word
163 |   // This includes both regular word endings and script boundaries
164 |   const atEndOfWordChar =
165 |     i < chars.length &&
166 |     isWordCharWithCombining(chars[i]) &&
167 |     (i + 1 >= chars.length ||
168 |       !isWordCharWithCombining(chars[i + 1]) ||
169 |       (isWordCharStrict(chars[i]) &&
170 |         i + 1 < chars.length &&
171 |         isWordCharStrict(chars[i + 1]) &&
172 |         isDifferentScript(chars[i], chars[i + 1])));
173 | 
174 |   const atEndOfPunctuation =
175 |     i < chars.length &&
176 |     !isWordCharWithCombining(chars[i]) &&
177 |     !isWhitespace(chars[i]) &&
178 |     (i + 1 >= chars.length ||
179 |       isWhitespace(chars[i + 1]) ||
180 |       isWordCharWithCombining(chars[i + 1]));
181 | 
182 |   if (atEndOfWordChar || atEndOfPunctuation) {
183 |     // We're at the end of a word or punctuation sequence, move forward to find next word
184 |     i++;
185 |     // Skip whitespace to find next word or punctuation
186 |     while (i < chars.length && isWhitespace(chars[i])) {
187 |       i++;
188 |     }
189 |   }
190 | 
191 |   // If we're not on a word character, find the next word or punctuation sequence
192 |   if (i < chars.length && !isWordCharWithCombining(chars[i])) {
193 |     // Skip whitespace to find next word or punctuation
194 |     while (i < chars.length && isWhitespace(chars[i])) {
195 |       i++;
196 |     }
197 |   }
198 | 
199 |   // Move to end of current word (including combining marks, but stop at script boundaries)
200 |   let foundWord = false;
201 |   let lastBaseCharPos = -1;
202 | 
203 |   if (i < chars.length && isWordCharWithCombining(chars[i])) {
204 |     // Handle word characters
205 |     while (i < chars.length && isWordCharWithCombining(chars[i])) {
206 |       foundWord = true;
207 | 
208 |       // Track the position of the last base character (not combining mark)
209 |       if (isWordCharStrict(chars[i])) {
210 |         lastBaseCharPos = i;
211 |       }
212 | 
213 |       // Check if next character is from a different script (word boundary)
214 |       if (
215 |         i + 1 < chars.length &&
216 |         isWordCharStrict(chars[i + 1]) &&
217 |         isDifferentScript(chars[i], chars[i + 1])
218 |       ) {
219 |         i++; // Include current character
220 |         if (isWordCharStrict(chars[i - 1])) {
221 |           lastBaseCharPos = i - 1;
222 |         }
223 |         break; // Stop at script boundary
224 |       }
225 | 
226 |       i++;
227 |     }
228 |   } else if (i < chars.length && !isWhitespace(chars[i])) {
229 |     // Handle punctuation sequences (like ████)
230 |     while (
231 |       i < chars.length &&
232 |       !isWordCharStrict(chars[i]) &&
233 |       !isWhitespace(chars[i])
234 |     ) {
235 |       foundWord = true;
236 |       lastBaseCharPos = i;
237 |       i++;
238 |     }
239 |   }
240 | 
241 |   // Only return a position if we actually found a word
242 |   // Return the position of the last base character, not combining marks
243 |   if (foundWord && lastBaseCharPos >= col) {
244 |     return lastBaseCharPos;
245 |   }
246 | 
247 |   return null;
248 | };
249 | 
250 | // Find next word across lines
251 | export const findNextWordAcrossLines = (
252 |   lines: string[],
253 |   cursorRow: number,
254 |   cursorCol: number,
255 |   searchForWordStart: boolean,
256 | ): { row: number; col: number } | null => {
257 |   // First try current line
258 |   const currentLine = lines[cursorRow] || '';
259 |   const colInCurrentLine = searchForWordStart
260 |     ? findNextWordStartInLine(currentLine, cursorCol)
261 |     : findWordEndInLine(currentLine, cursorCol);
262 | 
263 |   if (colInCurrentLine !== null) {
264 |     return { row: cursorRow, col: colInCurrentLine };
265 |   }
266 | 
267 |   // Search subsequent lines
268 |   for (let row = cursorRow + 1; row < lines.length; row++) {
269 |     const line = lines[row] || '';
270 |     const chars = toCodePoints(line);
271 | 
272 |     // For empty lines, if we haven't found any words yet, return the empty line
273 |     if (chars.length === 0) {
274 |       // Check if there are any words in remaining lines
275 |       let hasWordsInLaterLines = false;
276 |       for (let laterRow = row + 1; laterRow < lines.length; laterRow++) {
277 |         const laterLine = lines[laterRow] || '';
278 |         const laterChars = toCodePoints(laterLine);
279 |         let firstNonWhitespace = 0;
280 |         while (
281 |           firstNonWhitespace < laterChars.length &&
282 |           isWhitespace(laterChars[firstNonWhitespace])
283 |         ) {
284 |           firstNonWhitespace++;
285 |         }
286 |         if (firstNonWhitespace < laterChars.length) {
287 |           hasWordsInLaterLines = true;
288 |           break;
289 |         }
290 |       }
291 | 
292 |       // If no words in later lines, return the empty line
293 |       if (!hasWordsInLaterLines) {
294 |         return { row, col: 0 };
295 |       }
296 |       continue;
297 |     }
298 | 
299 |     // Find first non-whitespace
300 |     let firstNonWhitespace = 0;
301 |     while (
302 |       firstNonWhitespace < chars.length &&
303 |       isWhitespace(chars[firstNonWhitespace])
304 |     ) {
305 |       firstNonWhitespace++;
306 |     }
307 | 
308 |     if (firstNonWhitespace < chars.length) {
309 |       if (searchForWordStart) {
310 |         return { row, col: firstNonWhitespace };
311 |       } else {
312 |         // For word end, find the end of the first word
313 |         const endCol = findWordEndInLine(line, firstNonWhitespace);
314 |         if (endCol !== null) {
315 |           return { row, col: endCol };
316 |         }
317 |       }
318 |     }
319 |   }
320 | 
321 |   return null;
322 | };
323 | 
324 | // Find previous word across lines
325 | export const findPrevWordAcrossLines = (
326 |   lines: string[],
327 |   cursorRow: number,
328 |   cursorCol: number,
329 | ): { row: number; col: number } | null => {
330 |   // First try current line
331 |   const currentLine = lines[cursorRow] || '';
332 |   const colInCurrentLine = findPrevWordStartInLine(currentLine, cursorCol);
333 | 
[TRUNCATED]
```

src/ui/components/shared/vim-buffer-actions.test.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { describe, it, expect } from 'vitest';
8 | import { handleVimAction } from './vim-buffer-actions.js';
9 | import type { TextBufferState } from './text-buffer.js';
10 | 
11 | // Helper to create test state
12 | const createTestState = (
13 |   lines: string[] = ['hello world'],
14 |   cursorRow = 0,
15 |   cursorCol = 0,
16 | ): TextBufferState => ({
17 |   lines,
18 |   cursorRow,
19 |   cursorCol,
20 |   preferredCol: null,
21 |   undoStack: [],
22 |   redoStack: [],
23 |   clipboard: null,
24 |   selectionAnchor: null,
25 |   viewportWidth: 80,
26 | });
27 | 
28 | describe('vim-buffer-actions', () => {
29 |   describe('Movement commands', () => {
30 |     describe('vim_move_left', () => {
31 |       it('should move cursor left by count', () => {
32 |         const state = createTestState(['hello world'], 0, 5);
33 |         const action = {
34 |           type: 'vim_move_left' as const,
35 |           payload: { count: 3 },
36 |         };
37 | 
38 |         const result = handleVimAction(state, action);
39 |         expect(result).toHaveOnlyValidCharacters();
40 |         expect(result.cursorCol).toBe(2);
41 |         expect(result.preferredCol).toBeNull();
42 |       });
43 | 
44 |       it('should not move past beginning of line', () => {
45 |         const state = createTestState(['hello'], 0, 2);
46 |         const action = {
47 |           type: 'vim_move_left' as const,
48 |           payload: { count: 5 },
49 |         };
50 | 
51 |         const result = handleVimAction(state, action);
52 |         expect(result).toHaveOnlyValidCharacters();
53 |         expect(result.cursorCol).toBe(0);
54 |       });
55 | 
56 |       it('should wrap to previous line when at beginning', () => {
57 |         const state = createTestState(['line1', 'line2'], 1, 0);
58 |         const action = {
59 |           type: 'vim_move_left' as const,
60 |           payload: { count: 1 },
61 |         };
62 | 
63 |         const result = handleVimAction(state, action);
64 |         expect(result).toHaveOnlyValidCharacters();
65 |         expect(result.cursorRow).toBe(0);
66 |         expect(result.cursorCol).toBe(4); // On last character '1' of 'line1'
67 |       });
68 | 
69 |       it('should handle multiple line wrapping', () => {
70 |         const state = createTestState(['abc', 'def', 'ghi'], 2, 0);
71 |         const action = {
72 |           type: 'vim_move_left' as const,
73 |           payload: { count: 5 },
74 |         };
75 | 
76 |         const result = handleVimAction(state, action);
77 |         expect(result).toHaveOnlyValidCharacters();
78 |         expect(result.cursorRow).toBe(0);
79 |         expect(result.cursorCol).toBe(1); // On 'b' after 5 left movements
80 |       });
81 | 
82 |       it('should correctly handle h/l movement between lines', () => {
83 |         // Start at end of first line at 'd' (position 10)
84 |         let state = createTestState(['hello world', 'foo bar'], 0, 10);
85 | 
86 |         // Move right - should go to beginning of next line
87 |         state = handleVimAction(state, {
88 |           type: 'vim_move_right' as const,
89 |           payload: { count: 1 },
90 |         });
91 |         expect(state).toHaveOnlyValidCharacters();
92 |         expect(state.cursorRow).toBe(1);
93 |         expect(state.cursorCol).toBe(0); // Should be on 'f'
94 | 
95 |         // Move left - should go back to end of previous line on 'd'
96 |         state = handleVimAction(state, {
97 |           type: 'vim_move_left' as const,
98 |           payload: { count: 1 },
99 |         });
100 |         expect(state).toHaveOnlyValidCharacters();
101 |         expect(state.cursorRow).toBe(0);
102 |         expect(state.cursorCol).toBe(10); // Should be on 'd', not past it
103 |       });
104 |     });
105 | 
106 |     describe('vim_move_right', () => {
107 |       it('should move cursor right by count', () => {
108 |         const state = createTestState(['hello world'], 0, 2);
109 |         const action = {
110 |           type: 'vim_move_right' as const,
111 |           payload: { count: 3 },
112 |         };
113 | 
114 |         const result = handleVimAction(state, action);
115 |         expect(result).toHaveOnlyValidCharacters();
116 |         expect(result.cursorCol).toBe(5);
117 |       });
118 | 
119 |       it('should not move past last character of line', () => {
120 |         const state = createTestState(['hello'], 0, 3);
121 |         const action = {
122 |           type: 'vim_move_right' as const,
123 |           payload: { count: 5 },
124 |         };
125 | 
126 |         const result = handleVimAction(state, action);
127 |         expect(result).toHaveOnlyValidCharacters();
128 |         expect(result.cursorCol).toBe(4); // Last character of 'hello'
129 |       });
130 | 
131 |       it('should wrap to next line when at end', () => {
132 |         const state = createTestState(['line1', 'line2'], 0, 4); // At end of 'line1'
133 |         const action = {
134 |           type: 'vim_move_right' as const,
135 |           payload: { count: 1 },
136 |         };
137 | 
138 |         const result = handleVimAction(state, action);
139 |         expect(result).toHaveOnlyValidCharacters();
140 |         expect(result.cursorRow).toBe(1);
141 |         expect(result.cursorCol).toBe(0);
142 |       });
143 | 
144 |       it('should skip over combining marks to avoid cursor disappearing', () => {
145 |         // Test case for combining character cursor disappearing bug
146 |         // "café test" where é is represented as e + combining acute accent
147 |         const state = createTestState(['cafe\u0301 test'], 0, 2); // Start at 'f'
148 |         const action = {
149 |           type: 'vim_move_right' as const,
150 |           payload: { count: 1 },
151 |         };
152 | 
153 |         const result = handleVimAction(state, action);
154 |         expect(result).toHaveOnlyValidCharacters();
155 |         expect(result.cursorCol).toBe(3); // Should be on 'e' of 'café'
156 | 
157 |         // Move right again - should skip combining mark and land on space
158 |         const result2 = handleVimAction(result, action);
159 |         expect(result2).toHaveOnlyValidCharacters();
160 |         expect(result2.cursorCol).toBe(5); // Should be on space after 'café'
161 |       });
162 |     });
163 | 
164 |     describe('vim_move_up', () => {
165 |       it('should move cursor up by count', () => {
166 |         const state = createTestState(['line1', 'line2', 'line3'], 2, 3);
167 |         const action = { type: 'vim_move_up' as const, payload: { count: 2 } };
168 | 
169 |         const result = handleVimAction(state, action);
170 |         expect(result).toHaveOnlyValidCharacters();
171 |         expect(result.cursorRow).toBe(0);
172 |         expect(result.cursorCol).toBe(3);
173 |       });
174 | 
175 |       it('should not move past first line', () => {
176 |         const state = createTestState(['line1', 'line2'], 1, 3);
177 |         const action = { type: 'vim_move_up' as const, payload: { count: 5 } };
178 | 
179 |         const result = handleVimAction(state, action);
180 |         expect(result).toHaveOnlyValidCharacters();
181 |         expect(result.cursorRow).toBe(0);
182 |       });
183 | 
184 |       it('should adjust column for shorter lines', () => {
185 |         const state = createTestState(['short', 'very long line'], 1, 10);
186 |         const action = { type: 'vim_move_up' as const, payload: { count: 1 } };
187 | 
188 |         const result = handleVimAction(state, action);
189 |         expect(result).toHaveOnlyValidCharacters();
190 |         expect(result.cursorRow).toBe(0);
191 |         expect(result.cursorCol).toBe(4); // Last character 't' of 'short', not past it
192 |       });
193 |     });
194 | 
195 |     describe('vim_move_down', () => {
196 |       it('should move cursor down by count', () => {
197 |         const state = createTestState(['line1', 'line2', 'line3'], 0, 2);
198 |         const action = {
199 |           type: 'vim_move_down' as const,
200 |           payload: { count: 2 },
201 |         };
202 | 
203 |         const result = handleVimAction(state, action);
204 |         expect(result).toHaveOnlyValidCharacters();
205 |         expect(result.cursorRow).toBe(2);
206 |         expect(result.cursorCol).toBe(2);
207 |       });
208 | 
209 |       it('should not move past last line', () => {
210 |         const state = createTestState(['line1', 'line2'], 0, 2);
211 |         const action = {
212 |           type: 'vim_move_down' as const,
213 |           payload: { count: 5 },
214 |         };
215 | 
216 |         const result = handleVimAction(state, action);
217 |         expect(result).toHaveOnlyValidCharacters();
218 |         expect(result.cursorRow).toBe(1);
219 |       });
220 |     });
221 | 
222 |     describe('vim_move_word_forward', () => {
223 |       it('should move to start of next word', () => {
224 |         const state = createTestState(['hello world test'], 0, 0);
225 |         const action = {
226 |           type: 'vim_move_word_forward' as const,
227 |           payload: { count: 1 },
228 |         };
229 | 
230 |         const result = handleVimAction(state, action);
231 |         expect(result).toHaveOnlyValidCharacters();
232 |         expect(result.cursorCol).toBe(6); // Start of 'world'
233 |       });
234 | 
235 |       it('should handle multiple words', () => {
236 |         const state = createTestState(['hello world test'], 0, 0);
237 |         const action = {
238 |           type: 'vim_move_word_forward' as const,
239 |           payload: { count: 2 },
240 |         };
241 | 
242 |         const result = handleVimAction(state, action);
243 |         expect(result).toHaveOnlyValidCharacters();
244 |         expect(result.cursorCol).toBe(12); // Start of 'test'
245 |       });
246 | 
247 |       it('should handle punctuation correctly', () => {
248 |         const state = createTestState(['hello, world!'], 0, 0);
249 |         const action = {
250 |           type: 'vim_move_word_forward' as const,
251 |           payload: { count: 1 },
252 |         };
253 | 
254 |         const result = handleVimAction(state, action);
255 |         expect(result).toHaveOnlyValidCharacters();
256 |         expect(result.cursorCol).toBe(5); // Start of ','
257 |       });
258 | 
259 |       it('should move across empty lines when starting from within a word', () => {
260 |         // Testing the exact scenario: cursor on 'w' of 'hello world', w should move to next line
261 |         const state = createTestState(['hello world', ''], 0, 6); // At 'w' of 'world'
262 |         const action = {
263 |           type: 'vim_move_word_forward' as const,
264 |           payload: { count: 1 },
265 |         };
266 | 
267 |         const result = handleVimAction(state, action);
268 |         expect(result).toHaveOnlyValidCharacters();
269 |         expect(result.cursorRow).toBe(1); // Should move to empty line
270 |         expect(result.cursorCol).toBe(0); // Beginning of empty line
271 |       });
272 |     });
273 | 
274 |     describe('vim_move_word_backward', () => {
275 |       it('should move to start of previous word', () => {
276 |         const state = createTestState(['hello world test'], 0, 12);
277 |         const action = {
278 |           type: 'vim_move_word_backward' as const,
279 |           payload: { count: 1 },
280 |         };
281 | 
282 |         const result = handleVimAction(state, action);
283 |         expect(result).toHaveOnlyValidCharacters();
284 |         expect(result.cursorCol).toBe(6); // Start of 'world'
285 |       });
286 | 
287 |       it('should handle multiple words', () => {
288 |         const state = createTestState(['hello world test'], 0, 12);
289 |         const action = {
290 |           type: 'vim_move_word_backward' as const,
291 |           payload: { count: 2 },
292 |         };
293 | 
294 |         const result = handleVimAction(state, action);
295 |         expect(result).toHaveOnlyValidCharacters();
296 |         expect(result.cursorCol).toBe(0); // Start of 'hello'
297 |       });
298 |     });
299 | 
300 |     describe('vim_move_word_end', () => {
301 |       it('should move to end of current word', () => {
302 |         const state = createTestState(['hello world'], 0, 0);
303 |         const action = {
304 |           type: 'vim_move_word_end' as const,
305 |           payload: { count: 1 },
306 |         };
307 | 
308 |         const result = handleVimAction(state, action);
309 |         expect(result).toHaveOnlyValidCharacters();
310 |         expect(result.cursorCol).toBe(4); // End of 'hello'
311 |       });
312 | 
313 |       it('should move to end of next word if already at word end', () => {
[TRUNCATED]
```

src/ui/components/shared/vim-buffer-actions.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type { TextBufferState, TextBufferAction } from './text-buffer.js';
8 | import {
9 |   getLineRangeOffsets,
10 |   getPositionFromOffsets,
11 |   replaceRangeInternal,
12 |   pushUndo,
13 |   isWordCharStrict,
14 |   isWordCharWithCombining,
15 |   isCombiningMark,
16 |   findNextWordAcrossLines,
17 |   findPrevWordAcrossLines,
18 |   findWordEndInLine,
19 | } from './text-buffer.js';
20 | import { cpLen, toCodePoints } from '../../utils/textUtils.js';
21 | import { assumeExhaustive } from '../../../utils/checks.js';
22 | 
23 | // Check if we're at the end of a base word (on the last base character)
24 | // Returns true if current position has a base character followed only by combining marks until non-word
25 | function isAtEndOfBaseWord(lineCodePoints: string[], col: number): boolean {
26 |   if (!isWordCharStrict(lineCodePoints[col])) return false;
27 | 
28 |   // Look ahead to see if we have only combining marks followed by non-word
29 |   let i = col + 1;
30 | 
31 |   // Skip any combining marks
32 |   while (i < lineCodePoints.length && isCombiningMark(lineCodePoints[i])) {
33 |     i++;
34 |   }
35 | 
36 |   // If we hit end of line or non-word character, we were at end of base word
37 |   return i >= lineCodePoints.length || !isWordCharStrict(lineCodePoints[i]);
38 | }
39 | 
40 | export type VimAction = Extract<
41 |   TextBufferAction,
42 |   | { type: 'vim_delete_word_forward' }
43 |   | { type: 'vim_delete_word_backward' }
44 |   | { type: 'vim_delete_word_end' }
45 |   | { type: 'vim_change_word_forward' }
46 |   | { type: 'vim_change_word_backward' }
47 |   | { type: 'vim_change_word_end' }
48 |   | { type: 'vim_delete_line' }
49 |   | { type: 'vim_change_line' }
50 |   | { type: 'vim_delete_to_end_of_line' }
51 |   | { type: 'vim_change_to_end_of_line' }
52 |   | { type: 'vim_change_movement' }
53 |   | { type: 'vim_move_left' }
54 |   | { type: 'vim_move_right' }
55 |   | { type: 'vim_move_up' }
56 |   | { type: 'vim_move_down' }
57 |   | { type: 'vim_move_word_forward' }
58 |   | { type: 'vim_move_word_backward' }
59 |   | { type: 'vim_move_word_end' }
60 |   | { type: 'vim_delete_char' }
61 |   | { type: 'vim_insert_at_cursor' }
62 |   | { type: 'vim_append_at_cursor' }
63 |   | { type: 'vim_open_line_below' }
64 |   | { type: 'vim_open_line_above' }
65 |   | { type: 'vim_append_at_line_end' }
66 |   | { type: 'vim_insert_at_line_start' }
67 |   | { type: 'vim_move_to_line_start' }
68 |   | { type: 'vim_move_to_line_end' }
69 |   | { type: 'vim_move_to_first_nonwhitespace' }
70 |   | { type: 'vim_move_to_first_line' }
71 |   | { type: 'vim_move_to_last_line' }
72 |   | { type: 'vim_move_to_line' }
73 |   | { type: 'vim_escape_insert_mode' }
74 | >;
75 | 
76 | export function handleVimAction(
77 |   state: TextBufferState,
78 |   action: VimAction,
79 | ): TextBufferState {
80 |   const { lines, cursorRow, cursorCol } = state;
81 | 
82 |   switch (action.type) {
83 |     case 'vim_delete_word_forward':
84 |     case 'vim_change_word_forward': {
85 |       const { count } = action.payload;
86 |       let endRow = cursorRow;
87 |       let endCol = cursorCol;
88 | 
89 |       for (let i = 0; i < count; i++) {
90 |         const nextWord = findNextWordAcrossLines(lines, endRow, endCol, true);
91 |         if (nextWord) {
92 |           endRow = nextWord.row;
93 |           endCol = nextWord.col;
94 |         } else {
95 |           // No more words, delete/change to end of current word or line
96 |           const currentLine = lines[endRow] || '';
97 |           const wordEnd = findWordEndInLine(currentLine, endCol);
98 |           if (wordEnd !== null) {
99 |             endCol = wordEnd + 1; // Include the character at word end
100 |           } else {
101 |             endCol = cpLen(currentLine);
102 |           }
103 |           break;
104 |         }
105 |       }
106 | 
107 |       if (endRow !== cursorRow || endCol !== cursorCol) {
108 |         const nextState = pushUndo(state);
109 |         return replaceRangeInternal(
110 |           nextState,
111 |           cursorRow,
112 |           cursorCol,
113 |           endRow,
114 |           endCol,
115 |           '',
116 |         );
117 |       }
118 |       return state;
119 |     }
120 | 
121 |     case 'vim_delete_word_backward':
122 |     case 'vim_change_word_backward': {
123 |       const { count } = action.payload;
124 |       let startRow = cursorRow;
125 |       let startCol = cursorCol;
126 | 
127 |       for (let i = 0; i < count; i++) {
128 |         const prevWord = findPrevWordAcrossLines(lines, startRow, startCol);
129 |         if (prevWord) {
130 |           startRow = prevWord.row;
131 |           startCol = prevWord.col;
132 |         } else {
133 |           break;
134 |         }
135 |       }
136 | 
137 |       if (startRow !== cursorRow || startCol !== cursorCol) {
138 |         const nextState = pushUndo(state);
139 |         return replaceRangeInternal(
140 |           nextState,
141 |           startRow,
142 |           startCol,
143 |           cursorRow,
144 |           cursorCol,
145 |           '',
146 |         );
147 |       }
148 |       return state;
149 |     }
150 | 
151 |     case 'vim_delete_word_end':
152 |     case 'vim_change_word_end': {
153 |       const { count } = action.payload;
154 |       let row = cursorRow;
155 |       let col = cursorCol;
156 |       let endRow = cursorRow;
157 |       let endCol = cursorCol;
158 | 
159 |       for (let i = 0; i < count; i++) {
160 |         const wordEnd = findNextWordAcrossLines(lines, row, col, false);
161 |         if (wordEnd) {
162 |           endRow = wordEnd.row;
163 |           endCol = wordEnd.col + 1; // Include the character at word end
164 |           // For next iteration, move to start of next word
165 |           if (i < count - 1) {
166 |             const nextWord = findNextWordAcrossLines(
167 |               lines,
168 |               wordEnd.row,
169 |               wordEnd.col + 1,
170 |               true,
171 |             );
172 |             if (nextWord) {
173 |               row = nextWord.row;
174 |               col = nextWord.col;
175 |             } else {
176 |               break; // No more words
177 |             }
178 |           }
179 |         } else {
180 |           break;
181 |         }
182 |       }
183 | 
184 |       // Ensure we don't go past the end of the last line
185 |       if (endRow < lines.length) {
186 |         const lineLen = cpLen(lines[endRow] || '');
187 |         endCol = Math.min(endCol, lineLen);
188 |       }
189 | 
190 |       if (endRow !== cursorRow || endCol !== cursorCol) {
191 |         const nextState = pushUndo(state);
192 |         return replaceRangeInternal(
193 |           nextState,
194 |           cursorRow,
195 |           cursorCol,
196 |           endRow,
197 |           endCol,
198 |           '',
199 |         );
200 |       }
201 |       return state;
202 |     }
203 | 
204 |     case 'vim_delete_line': {
205 |       const { count } = action.payload;
206 |       if (lines.length === 0) return state;
207 | 
208 |       const linesToDelete = Math.min(count, lines.length - cursorRow);
209 |       const totalLines = lines.length;
210 | 
211 |       if (totalLines === 1 || linesToDelete >= totalLines) {
212 |         // If there's only one line, or we're deleting all remaining lines,
213 |         // clear the content but keep one empty line (text editors should never be completely empty)
214 |         const nextState = pushUndo(state);
215 |         return {
216 |           ...nextState,
217 |           lines: [''],
218 |           cursorRow: 0,
219 |           cursorCol: 0,
220 |           preferredCol: null,
221 |         };
222 |       }
223 | 
224 |       const nextState = pushUndo(state);
225 |       const newLines = [...nextState.lines];
226 |       newLines.splice(cursorRow, linesToDelete);
227 | 
228 |       // Adjust cursor position
229 |       const newCursorRow = Math.min(cursorRow, newLines.length - 1);
230 |       const newCursorCol = 0; // Vim places cursor at beginning of line after dd
231 | 
232 |       return {
233 |         ...nextState,
234 |         lines: newLines,
235 |         cursorRow: newCursorRow,
236 |         cursorCol: newCursorCol,
237 |         preferredCol: null,
238 |       };
239 |     }
240 | 
241 |     case 'vim_change_line': {
242 |       const { count } = action.payload;
243 |       if (lines.length === 0) return state;
244 | 
245 |       const linesToChange = Math.min(count, lines.length - cursorRow);
246 |       const nextState = pushUndo(state);
247 | 
248 |       const { startOffset, endOffset } = getLineRangeOffsets(
249 |         cursorRow,
250 |         linesToChange,
251 |         nextState.lines,
252 |       );
253 |       const { startRow, startCol, endRow, endCol } = getPositionFromOffsets(
254 |         startOffset,
255 |         endOffset,
256 |         nextState.lines,
257 |       );
258 |       return replaceRangeInternal(
259 |         nextState,
260 |         startRow,
261 |         startCol,
262 |         endRow,
263 |         endCol,
264 |         '',
265 |       );
266 |     }
267 | 
268 |     case 'vim_delete_to_end_of_line':
269 |     case 'vim_change_to_end_of_line': {
270 |       const currentLine = lines[cursorRow] || '';
271 |       if (cursorCol < cpLen(currentLine)) {
272 |         const nextState = pushUndo(state);
273 |         return replaceRangeInternal(
274 |           nextState,
275 |           cursorRow,
276 |           cursorCol,
277 |           cursorRow,
278 |           cpLen(currentLine),
279 |           '',
280 |         );
281 |       }
282 |       return state;
283 |     }
284 | 
285 |     case 'vim_change_movement': {
286 |       const { movement, count } = action.payload;
287 |       const totalLines = lines.length;
288 | 
289 |       switch (movement) {
290 |         case 'h': {
291 |           // Left
292 |           // Change N characters to the left
293 |           const startCol = Math.max(0, cursorCol - count);
294 |           return replaceRangeInternal(
295 |             pushUndo(state),
296 |             cursorRow,
297 |             startCol,
298 |             cursorRow,
299 |             cursorCol,
300 |             '',
301 |           );
302 |         }
303 | 
304 |         case 'j': {
305 |           // Down
306 |           const linesToChange = Math.min(count, totalLines - cursorRow);
307 |           if (linesToChange > 0) {
308 |             if (totalLines === 1) {
309 |               const currentLine = state.lines[0] || '';
310 |               return replaceRangeInternal(
311 |                 pushUndo(state),
312 |                 0,
313 |                 0,
314 |                 0,
315 |                 cpLen(currentLine),
316 |                 '',
317 |               );
318 |             } else {
319 |               const nextState = pushUndo(state);
320 |               const { startOffset, endOffset } = getLineRangeOffsets(
321 |                 cursorRow,
322 |                 linesToChange,
323 |                 nextState.lines,
324 |               );
325 |               const { startRow, startCol, endRow, endCol } =
326 |                 getPositionFromOffsets(startOffset, endOffset, nextState.lines);
327 |               return replaceRangeInternal(
328 |                 nextState,
329 |                 startRow,
330 |                 startCol,
331 |                 endRow,
332 |                 endCol,
333 |                 '',
334 |               );
335 |             }
336 |           }
337 |           return state;
338 |         }
339 | 
340 |         case 'k': {
341 |           // Up
342 |           const upLines = Math.min(count, cursorRow + 1);
343 |           if (upLines > 0) {
344 |             if (state.lines.length === 1) {
345 |               const currentLine = state.lines[0] || '';
346 |               return replaceRangeInternal(
347 |                 pushUndo(state),
348 |                 0,
349 |                 0,
350 |                 0,
351 |                 cpLen(currentLine),
352 |                 '',
353 |               );
354 |             } else {
355 |               const startRow = Math.max(0, cursorRow - count + 1);
356 |               const linesToChange = cursorRow - startRow + 1;
357 |               const nextState = pushUndo(state);
358 |               const { startOffset, endOffset } = getLineRangeOffsets(
359 |                 startRow,
360 |                 linesToChange,
361 |                 nextState.lines,
362 |               );
363 |               const {
364 |                 startRow: newStartRow,
365 |                 startCol,
366 |                 endRow,
367 |                 endCol,
368 |               } = getPositionFromOffsets(
369 |                 startOffset,
370 |                 endOffset,
371 |                 nextState.lines,
372 |               );
373 |               const resultState = replaceRangeInternal(
374 |                 nextState,
375 |                 newStartRow,
376 |                 startCol,
377 |                 endRow,
378 |                 endCol,
379 |                 '',
380 |               );
[TRUNCATED]
```

src/ui/components/views/ChatList.test.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { render } from 'ink-testing-library';
8 | import { describe, it, expect } from 'vitest';
9 | import { ChatList } from './ChatList.js';
10 | import type { ChatDetail } from '../../types.js';
11 | 
12 | const mockChats: ChatDetail[] = [
13 |   {
14 |     name: 'chat-1',
15 |     mtime: '2025-10-02T10:00:00.000Z',
16 |   },
17 |   {
18 |     name: 'another-chat',
19 |     mtime: '2025-10-01T12:30:00.000Z',
20 |   },
21 | ];
22 | 
23 | describe('<ChatList />', () => {
24 |   it('renders correctly with a list of chats', () => {
25 |     const { lastFrame } = render(<ChatList chats={mockChats} />);
26 |     expect(lastFrame()).toMatchSnapshot();
27 |   });
28 | 
29 |   it('renders correctly with no chats', () => {
30 |     const { lastFrame } = render(<ChatList chats={[]} />);
31 |     expect(lastFrame()).toContain('No saved conversation checkpoints found.');
32 |     expect(lastFrame()).toMatchSnapshot();
33 |   });
34 | 
35 |   it('handles invalid date formats gracefully', () => {
36 |     const mockChatsWithInvalidDate: ChatDetail[] = [
37 |       {
38 |         name: 'bad-date-chat',
39 |         mtime: 'an-invalid-date-string',
40 |       },
41 |     ];
42 |     const { lastFrame } = render(<ChatList chats={mockChatsWithInvalidDate} />);
43 |     expect(lastFrame()).toContain('(Invalid Date)');
44 |     expect(lastFrame()).toMatchSnapshot();
45 |   });
46 | });
```

src/ui/components/views/ChatList.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type React from 'react';
8 | import { Box, Text } from 'ink';
9 | import { theme } from '../../semantic-colors.js';
10 | import type { ChatDetail } from '../../types.js';
11 | 
12 | interface ChatListProps {
13 |   chats: readonly ChatDetail[];
14 | }
15 | 
16 | export const ChatList: React.FC<ChatListProps> = ({ chats }) => {
17 |   if (chats.length === 0) {
18 |     return <Text>No saved conversation checkpoints found.</Text>;
19 |   }
20 | 
21 |   return (
22 |     <Box flexDirection="column">
23 |       <Text>List of saved conversations:</Text>
24 |       <Box height={1} />
25 |       {chats.map((chat) => {
26 |         const isoString = chat.mtime;
27 |         const match = isoString.match(
28 |           /(\d{4}-\d{2}-\d{2})T(\d{2}:\d{2}:\d{2})/,
29 |         );
30 |         const formattedDate = match
31 |           ? `${match[1]} ${match[2]}`
32 |           : 'Invalid Date';
33 |         return (
34 |           <Box key={chat.name} flexDirection="row">
35 |             <Text>
36 |               {'  '}- <Text color={theme.text.accent}>{chat.name}</Text>{' '}
37 |               <Text color={theme.text.secondary}>({formattedDate})</Text>
38 |             </Text>
39 |           </Box>
40 |         );
41 |       })}
42 |       <Box height={1} />
43 |       <Text color={theme.text.secondary}>Note: Newest last, oldest first</Text>
44 |     </Box>
45 |   );
46 | };
```

src/ui/components/views/ExtensionsList.test.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { render } from 'ink-testing-library';
8 | import { vi } from 'vitest';
9 | import { useUIState } from '../../contexts/UIStateContext.js';
10 | import { ExtensionUpdateState } from '../../state/extensions.js';
11 | import { ExtensionsList } from './ExtensionsList.js';
12 | import { createMockCommandContext } from '../../../test-utils/mockCommandContext.js';
13 | 
14 | vi.mock('../../contexts/UIStateContext.js');
15 | 
16 | const mockUseUIState = vi.mocked(useUIState);
17 | 
18 | const mockExtensions = [
19 |   { name: 'ext-one', version: '1.0.0', isActive: true },
20 |   { name: 'ext-two', version: '2.1.0', isActive: true },
21 |   { name: 'ext-disabled', version: '3.0.0', isActive: false },
22 | ];
23 | 
24 | describe('<ExtensionsList />', () => {
25 |   beforeEach(() => {
26 |     vi.resetAllMocks();
27 |   });
28 | 
29 |   const mockUIState = (
30 |     extensions: unknown[],
31 |     extensionsUpdateState: Map<string, ExtensionUpdateState>,
32 |     disabledExtensions: string[] = [],
33 |   ) => {
34 |     mockUseUIState.mockReturnValue({
35 |       commandContext: createMockCommandContext({
36 |         services: {
37 |           config: {
38 |             getExtensions: () => extensions,
39 |           },
40 |           settings: {
41 |             merged: {
42 |               extensions: {
43 |                 disabled: disabledExtensions,
44 |               },
45 |             },
46 |           },
47 |         },
48 |       }),
49 |       extensionsUpdateState,
50 |       // Add other required properties from UIState if needed by the component
51 |     } as never);
52 |   };
53 | 
54 |   it('should render "No extensions installed." if there are no extensions', () => {
55 |     mockUIState([], new Map());
56 |     const { lastFrame } = render(<ExtensionsList />);
57 |     expect(lastFrame()).toContain('No extensions installed.');
58 |   });
59 | 
60 |   it('should render a list of extensions with their version and status', () => {
61 |     mockUIState(mockExtensions, new Map(), ['ext-disabled']);
62 |     const { lastFrame } = render(<ExtensionsList />);
63 |     const output = lastFrame();
64 |     expect(output).toContain('ext-one (v1.0.0) - active');
65 |     expect(output).toContain('ext-two (v2.1.0) - active');
66 |     expect(output).toContain('ext-disabled (v3.0.0) - disabled');
67 |   });
68 | 
69 |   it('should display "unknown state" if an extension has no update state', () => {
70 |     mockUIState([mockExtensions[0]], new Map());
71 |     const { lastFrame } = render(<ExtensionsList />);
72 |     expect(lastFrame()).toContain('(unknown state)');
73 |   });
74 | 
75 |   const stateTestCases = [
76 |     {
77 |       state: ExtensionUpdateState.CHECKING_FOR_UPDATES,
78 |       expectedText: '(checking for updates)',
79 |     },
80 |     {
81 |       state: ExtensionUpdateState.UPDATING,
82 |       expectedText: '(updating)',
83 |     },
84 |     {
85 |       state: ExtensionUpdateState.UPDATE_AVAILABLE,
86 |       expectedText: '(update available)',
87 |     },
88 |     {
89 |       state: ExtensionUpdateState.UPDATED_NEEDS_RESTART,
90 |       expectedText: '(updated, needs restart)',
91 |     },
92 |     {
93 |       state: ExtensionUpdateState.ERROR,
94 |       expectedText: '(error)',
95 |     },
96 |     {
97 |       state: ExtensionUpdateState.UP_TO_DATE,
98 |       expectedText: '(up to date)',
99 |     },
100 |   ];
101 | 
102 |   for (const { state, expectedText } of stateTestCases) {
103 |     it(`should correctly display the state: ${state}`, () => {
104 |       const updateState = new Map([[mockExtensions[0].name, state]]);
105 |       mockUIState([mockExtensions[0]], updateState);
106 |       const { lastFrame } = render(<ExtensionsList />);
107 |       expect(lastFrame()).toContain(expectedText);
108 |     });
109 |   }
110 | });
```

src/ui/components/views/ExtensionsList.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { Box, Text } from 'ink';
8 | import { useUIState } from '../../contexts/UIStateContext.js';
9 | import { ExtensionUpdateState } from '../../state/extensions.js';
10 | 
11 | export const ExtensionsList = () => {
12 |   const { commandContext, extensionsUpdateState } = useUIState();
13 |   const allExtensions = commandContext.services.config!.getExtensions();
14 |   const settings = commandContext.services.settings;
15 |   const disabledExtensions = settings.merged.extensions?.disabled ?? [];
16 | 
17 |   if (allExtensions.length === 0) {
18 |     return <Text>No extensions installed.</Text>;
19 |   }
20 | 
21 |   return (
22 |     <Box flexDirection="column" marginTop={1} marginBottom={1}>
23 |       <Text>Installed extensions:</Text>
24 |       <Box flexDirection="column" paddingLeft={2}>
25 |         {allExtensions.map((ext) => {
26 |           const state = extensionsUpdateState.get(ext.name);
27 |           const isActive = !disabledExtensions.includes(ext.name);
28 |           const activeString = isActive ? 'active' : 'disabled';
29 | 
30 |           let stateColor = 'gray';
31 |           const stateText = state || 'unknown state';
32 | 
33 |           switch (state) {
34 |             case ExtensionUpdateState.CHECKING_FOR_UPDATES:
35 |             case ExtensionUpdateState.UPDATING:
36 |               stateColor = 'cyan';
37 |               break;
38 |             case ExtensionUpdateState.UPDATE_AVAILABLE:
39 |             case ExtensionUpdateState.UPDATED_NEEDS_RESTART:
40 |               stateColor = 'yellow';
41 |               break;
42 |             case ExtensionUpdateState.ERROR:
43 |               stateColor = 'red';
44 |               break;
45 |             case ExtensionUpdateState.UP_TO_DATE:
46 |             case ExtensionUpdateState.NOT_UPDATABLE:
47 |               stateColor = 'green';
48 |               break;
49 |             default:
50 |               console.error(`Unhandled ExtensionUpdateState ${state}`);
51 |               break;
52 |           }
53 | 
54 |           return (
55 |             <Box key={ext.name}>
56 |               <Text>
57 |                 <Text color="cyan">{`${ext.name} (v${ext.version})`}</Text>
58 |                 {` - ${activeString}`}
59 |                 {<Text color={stateColor}>{` (${stateText})`}</Text>}
60 |               </Text>
61 |             </Box>
62 |           );
63 |         })}
64 |       </Box>
65 |     </Box>
66 |   );
67 | };
```

src/ui/components/views/McpStatus.test.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { render } from 'ink-testing-library';
8 | import { describe, it, expect, vi } from 'vitest';
9 | import { McpStatus } from './McpStatus.js';
10 | import { MCPServerStatus } from '@google/gemini-cli-core';
11 | import { MessageType } from '../../types.js';
12 | 
13 | describe('McpStatus', () => {
14 |   const baseProps = {
15 |     type: MessageType.MCP_STATUS,
16 |     servers: {
17 |       'server-1': {
18 |         url: 'http://localhost:8080',
19 |         name: 'server-1',
20 |         description: 'A test server',
21 |       },
22 |     },
23 |     tools: [
24 |       {
25 |         serverName: 'server-1',
26 |         name: 'tool-1',
27 |         description: 'A test tool',
28 |         schema: {
29 |           parameters: {
30 |             type: 'object',
31 |             properties: {
32 |               param1: { type: 'string' },
33 |             },
34 |           },
35 |         },
36 |       },
37 |     ],
38 |     prompts: [],
39 |     blockedServers: [],
40 |     serverStatus: () => MCPServerStatus.CONNECTED,
41 |     authStatus: {},
42 |     discoveryInProgress: false,
43 |     connectingServers: [],
44 |     showDescriptions: true,
45 |     showSchema: false,
46 |     showTips: false,
47 |   };
48 | 
49 |   it('renders correctly with a connected server', () => {
50 |     const { lastFrame } = render(<McpStatus {...baseProps} />);
51 |     expect(lastFrame()).toMatchSnapshot();
52 |   });
53 | 
54 |   it('renders correctly with authenticated OAuth status', () => {
55 |     const { lastFrame } = render(
56 |       <McpStatus {...baseProps} authStatus={{ 'server-1': 'authenticated' }} />,
57 |     );
58 |     expect(lastFrame()).toMatchSnapshot();
59 |   });
60 | 
61 |   it('renders correctly with expired OAuth status', () => {
62 |     const { lastFrame } = render(
63 |       <McpStatus {...baseProps} authStatus={{ 'server-1': 'expired' }} />,
64 |     );
65 |     expect(lastFrame()).toMatchSnapshot();
66 |   });
67 | 
68 |   it('renders correctly with unauthenticated OAuth status', () => {
69 |     const { lastFrame } = render(
70 |       <McpStatus
71 |         {...baseProps}
72 |         authStatus={{ 'server-1': 'unauthenticated' }}
73 |       />,
74 |     );
75 |     expect(lastFrame()).toMatchSnapshot();
76 |   });
77 | 
78 |   it('renders correctly with a disconnected server', async () => {
79 |     vi.spyOn(
80 |       await import('@google/gemini-cli-core'),
81 |       'getMCPServerStatus',
82 |     ).mockReturnValue(MCPServerStatus.DISCONNECTED);
83 |     const { lastFrame } = render(<McpStatus {...baseProps} />);
84 |     expect(lastFrame()).toMatchSnapshot();
85 |   });
86 | 
87 |   it('renders correctly when discovery is in progress', () => {
88 |     const { lastFrame } = render(
89 |       <McpStatus {...baseProps} discoveryInProgress={true} />,
90 |     );
91 |     expect(lastFrame()).toMatchSnapshot();
92 |   });
93 | 
94 |   it('renders correctly with schema enabled', () => {
95 |     const { lastFrame } = render(
96 |       <McpStatus {...baseProps} showSchema={true} />,
97 |     );
98 |     expect(lastFrame()).toMatchSnapshot();
99 |   });
100 | 
101 |   it('renders correctly with parametersJsonSchema', () => {
102 |     const { lastFrame } = render(
103 |       <McpStatus
104 |         {...baseProps}
105 |         tools={[
106 |           {
107 |             serverName: 'server-1',
108 |             name: 'tool-1',
109 |             description: 'A test tool',
110 |             schema: {
111 |               parametersJsonSchema: {
112 |                 type: 'object',
113 |                 properties: {
114 |                   param1: { type: 'string' },
115 |                 },
116 |               },
117 |             },
118 |           },
119 |         ]}
120 |         showSchema={true}
121 |       />,
122 |     );
123 |     expect(lastFrame()).toMatchSnapshot();
124 |   });
125 | 
126 |   it('renders correctly with tips enabled', () => {
127 |     const { lastFrame } = render(<McpStatus {...baseProps} showTips={true} />);
128 |     expect(lastFrame()).toMatchSnapshot();
129 |   });
130 | 
131 |   it('renders correctly with prompts', () => {
132 |     const { lastFrame } = render(
133 |       <McpStatus
134 |         {...baseProps}
135 |         prompts={[
136 |           {
137 |             serverName: 'server-1',
138 |             name: 'prompt-1',
139 |             description: 'A test prompt',
140 |           },
141 |         ]}
142 |       />,
143 |     );
144 |     expect(lastFrame()).toMatchSnapshot();
145 |   });
146 | 
147 |   it('renders correctly with a blocked server', () => {
148 |     const { lastFrame } = render(
149 |       <McpStatus
150 |         {...baseProps}
151 |         blockedServers={[{ name: 'server-1', extensionName: 'test-extension' }]}
152 |       />,
153 |     );
154 |     expect(lastFrame()).toMatchSnapshot();
155 |   });
156 | 
157 |   it('renders correctly with a connecting server', () => {
158 |     const { lastFrame } = render(
159 |       <McpStatus {...baseProps} connectingServers={['server-1']} />,
160 |     );
161 |     expect(lastFrame()).toMatchSnapshot();
162 |   });
163 | });
```

src/ui/components/views/McpStatus.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type { MCPServerConfig } from '@google/gemini-cli-core';
8 | import { MCPServerStatus } from '@google/gemini-cli-core';
9 | import { Box, Text } from 'ink';
10 | import type React from 'react';
11 | import { theme } from '../../semantic-colors.js';
12 | import type {
13 |   HistoryItemMcpStatus,
14 |   JsonMcpPrompt,
15 |   JsonMcpTool,
16 | } from '../../types.js';
17 | 
18 | interface McpStatusProps {
19 |   servers: Record<string, MCPServerConfig>;
20 |   tools: JsonMcpTool[];
21 |   prompts: JsonMcpPrompt[];
22 |   blockedServers: Array<{ name: string; extensionName: string }>;
23 |   serverStatus: (serverName: string) => MCPServerStatus;
24 |   authStatus: HistoryItemMcpStatus['authStatus'];
25 |   discoveryInProgress: boolean;
26 |   connectingServers: string[];
27 |   showDescriptions: boolean;
28 |   showSchema: boolean;
29 |   showTips: boolean;
30 | }
31 | 
32 | export const McpStatus: React.FC<McpStatusProps> = ({
33 |   servers,
34 |   tools,
35 |   prompts,
36 |   blockedServers,
37 |   serverStatus,
38 |   authStatus,
39 |   discoveryInProgress,
40 |   connectingServers,
41 |   showDescriptions,
42 |   showSchema,
43 |   showTips,
44 | }) => {
45 |   const serverNames = Object.keys(servers);
46 | 
47 |   if (serverNames.length === 0 && blockedServers.length === 0) {
48 |     return (
49 |       <Box flexDirection="column">
50 |         <Text>No MCP servers configured.</Text>
51 |         <Text>
52 |           Please view MCP documentation in your browser:{' '}
53 |           <Text color={theme.text.link}>
54 |             https://goo.gle/gemini-cli-docs-mcp
55 |           </Text>{' '}
56 |           or use the cli /docs command
57 |         </Text>
58 |       </Box>
59 |     );
60 |   }
61 | 
62 |   return (
63 |     <Box flexDirection="column">
64 |       {discoveryInProgress && (
65 |         <Box flexDirection="column" marginBottom={1}>
66 |           <Text color={theme.status.warning}>
67 |             ⏳ MCP servers are starting up ({connectingServers.length}{' '}
68 |             initializing)...
69 |           </Text>
70 |           <Text color={theme.text.primary}>
71 |             Note: First startup may take longer. Tool availability will update
72 |             automatically.
73 |           </Text>
74 |         </Box>
75 |       )}
76 | 
77 |       <Text bold>Configured MCP servers:</Text>
78 |       <Box height={1} />
79 | 
80 |       {serverNames.map((serverName) => {
81 |         const server = servers[serverName];
82 |         const serverTools = tools.filter(
83 |           (tool) => tool.serverName === serverName,
84 |         );
85 |         const serverPrompts = prompts.filter(
86 |           (prompt) => prompt.serverName === serverName,
87 |         );
88 |         const originalStatus = serverStatus(serverName);
89 |         const hasCachedItems =
90 |           serverTools.length > 0 || serverPrompts.length > 0;
91 |         const status =
92 |           originalStatus === MCPServerStatus.DISCONNECTED && hasCachedItems
93 |             ? MCPServerStatus.CONNECTED
94 |             : originalStatus;
95 | 
96 |         let statusIndicator = '';
97 |         let statusText = '';
98 |         let statusColor = theme.text.primary;
99 | 
100 |         switch (status) {
101 |           case MCPServerStatus.CONNECTED:
102 |             statusIndicator = '🟢';
103 |             statusText = 'Ready';
104 |             statusColor = theme.status.success;
105 |             break;
106 |           case MCPServerStatus.CONNECTING:
107 |             statusIndicator = '🔄';
108 |             statusText = 'Starting... (first startup may take longer)';
109 |             statusColor = theme.status.warning;
110 |             break;
111 |           case MCPServerStatus.DISCONNECTED:
112 |           default:
113 |             statusIndicator = '🔴';
114 |             statusText = 'Disconnected';
115 |             statusColor = theme.status.error;
116 |             break;
117 |         }
118 | 
119 |         let serverDisplayName = serverName;
120 |         if (server.extensionName) {
121 |           serverDisplayName += ` (from ${server.extensionName})`;
122 |         }
123 | 
124 |         const toolCount = serverTools.length;
125 |         const promptCount = serverPrompts.length;
126 |         const parts = [];
127 |         if (toolCount > 0) {
128 |           parts.push(`${toolCount} ${toolCount === 1 ? 'tool' : 'tools'}`);
129 |         }
130 |         if (promptCount > 0) {
131 |           parts.push(
132 |             `${promptCount} ${promptCount === 1 ? 'prompt' : 'prompts'}`,
133 |           );
134 |         }
135 | 
136 |         const serverAuthStatus = authStatus[serverName];
137 |         let authStatusNode: React.ReactNode = null;
138 |         if (serverAuthStatus === 'authenticated') {
139 |           authStatusNode = <Text> (OAuth)</Text>;
140 |         } else if (serverAuthStatus === 'expired') {
141 |           authStatusNode = (
142 |             <Text color={theme.status.error}> (OAuth expired)</Text>
143 |           );
144 |         } else if (serverAuthStatus === 'unauthenticated') {
145 |           authStatusNode = (
146 |             <Text color={theme.status.warning}> (OAuth not authenticated)</Text>
147 |           );
148 |         }
149 | 
150 |         return (
151 |           <Box key={serverName} flexDirection="column" marginBottom={1}>
152 |             <Box>
153 |               <Text color={statusColor}>{statusIndicator} </Text>
154 |               <Text bold>{serverDisplayName}</Text>
155 |               <Text>
156 |                 {' - '}
157 |                 {statusText}
158 |                 {status === MCPServerStatus.CONNECTED &&
159 |                   parts.length > 0 &&
160 |                   ` (${parts.join(', ')})`}
161 |               </Text>
162 |               {authStatusNode}
163 |             </Box>
164 |             {status === MCPServerStatus.CONNECTING && (
165 |               <Text> (tools and prompts will appear when ready)</Text>
166 |             )}
167 |             {status === MCPServerStatus.DISCONNECTED && toolCount > 0 && (
168 |               <Text> ({toolCount} tools cached)</Text>
169 |             )}
170 | 
171 |             {showDescriptions && server?.description && (
172 |               <Text color={theme.text.secondary}>
173 |                 {server.description.trim()}
174 |               </Text>
175 |             )}
176 | 
177 |             {serverTools.length > 0 && (
178 |               <Box flexDirection="column" marginLeft={2}>
179 |                 <Text color={theme.text.primary}>Tools:</Text>
180 |                 {serverTools.map((tool) => {
181 |                   const schemaContent =
182 |                     showSchema &&
183 |                     tool.schema &&
184 |                     (tool.schema.parametersJsonSchema || tool.schema.parameters)
185 |                       ? JSON.stringify(
186 |                           tool.schema.parametersJsonSchema ??
187 |                             tool.schema.parameters,
188 |                           null,
189 |                           2,
190 |                         )
191 |                       : null;
192 | 
193 |                   return (
194 |                     <Box key={tool.name} flexDirection="column">
195 |                       <Text>
196 |                         - <Text color={theme.text.primary}>{tool.name}</Text>
197 |                       </Text>
198 |                       {showDescriptions && tool.description && (
199 |                         <Box marginLeft={2}>
200 |                           <Text color={theme.text.secondary}>
201 |                             {tool.description.trim()}
202 |                           </Text>
203 |                         </Box>
204 |                       )}
205 |                       {schemaContent && (
206 |                         <Box flexDirection="column" marginLeft={4}>
207 |                           <Text color={theme.text.secondary}>Parameters:</Text>
208 |                           <Text color={theme.text.secondary}>
209 |                             {schemaContent}
210 |                           </Text>
211 |                         </Box>
212 |                       )}
213 |                     </Box>
214 |                   );
215 |                 })}
216 |               </Box>
217 |             )}
218 | 
219 |             {serverPrompts.length > 0 && (
220 |               <Box flexDirection="column" marginLeft={2}>
221 |                 <Text color={theme.text.primary}>Prompts:</Text>
222 |                 {serverPrompts.map((prompt) => (
223 |                   <Box key={prompt.name} flexDirection="column">
224 |                     <Text>
225 |                       - <Text color={theme.text.primary}>{prompt.name}</Text>
226 |                     </Text>
227 |                     {showDescriptions && prompt.description && (
228 |                       <Box marginLeft={2}>
229 |                         <Text color={theme.text.primary}>
230 |                           {prompt.description.trim()}
231 |                         </Text>
232 |                       </Box>
233 |                     )}
234 |                   </Box>
235 |                 ))}
236 |               </Box>
237 |             )}
238 |           </Box>
239 |         );
240 |       })}
241 | 
242 |       {blockedServers.map((server) => (
243 |         <Box key={server.name} marginBottom={1}>
244 |           <Text color={theme.status.error}>🔴 </Text>
245 |           <Text bold>
246 |             {server.name}
247 |             {server.extensionName ? ` (from ${server.extensionName})` : ''}
248 |           </Text>
249 |           <Text> - Blocked</Text>
250 |         </Box>
251 |       ))}
252 | 
253 |       {showTips && (
254 |         <Box flexDirection="column" marginTop={1}>
255 |           <Text color={theme.text.accent}>💡 Tips:</Text>
256 |           <Text>
257 |             {'  '}- Use <Text color={theme.text.accent}>/mcp desc</Text> to show
258 |             server and tool descriptions
259 |           </Text>
260 |           <Text>
261 |             {'  '}- Use <Text color={theme.text.accent}>/mcp schema</Text> to
262 |             show tool parameter schemas
263 |           </Text>
264 |           <Text>
265 |             {'  '}- Use <Text color={theme.text.accent}>/mcp nodesc</Text> to
266 |             hide descriptions
267 |           </Text>
268 |           <Text>
269 |             {'  '}- Use{' '}
270 |             <Text color={theme.text.accent}>/mcp auth &lt;server-name&gt;</Text>{' '}
271 |             to authenticate with OAuth-enabled servers
272 |           </Text>
273 |           <Text>
274 |             {'  '}- Press <Text color={theme.text.accent}>Ctrl+T</Text> to
275 |             toggle tool descriptions on/off
276 |           </Text>
277 |         </Box>
278 |       )}
279 |     </Box>
280 |   );
281 | };
```

src/ui/components/views/ToolsList.test.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { render } from 'ink-testing-library';
8 | import { describe, it, expect } from 'vitest';
9 | import { ToolsList } from './ToolsList.js';
10 | import { type ToolDefinition } from '../../types.js';
11 | 
12 | const mockTools: ToolDefinition[] = [
13 |   {
14 |     name: 'test-tool-one',
15 |     displayName: 'Test Tool One',
16 |     description: 'This is the first test tool.',
17 |   },
18 |   {
19 |     name: 'test-tool-two',
20 |     displayName: 'Test Tool Two',
21 |     description: `This is the second test tool.
22 |   1. Tool descriptions support markdown formatting.
23 |   2. **note** use this tool wisely and be sure to consider how this tool interacts with word wrap.
24 |   3. **important** this tool is awesome.`,
25 |   },
26 |   {
27 |     name: 'test-tool-three',
28 |     displayName: 'Test Tool Three',
29 |     description: 'This is the third test tool.',
30 |   },
31 | ];
32 | 
33 | describe('<ToolsList />', () => {
34 |   it('renders correctly with descriptions', () => {
35 |     const { lastFrame } = render(
36 |       <ToolsList
37 |         tools={mockTools}
38 |         showDescriptions={true}
39 |         terminalWidth={40}
40 |       />,
41 |     );
42 |     expect(lastFrame()).toMatchSnapshot();
43 |   });
44 | 
45 |   it('renders correctly without descriptions', () => {
46 |     const { lastFrame } = render(
47 |       <ToolsList
48 |         tools={mockTools}
49 |         showDescriptions={false}
50 |         terminalWidth={40}
51 |       />,
52 |     );
53 |     expect(lastFrame()).toMatchSnapshot();
54 |   });
55 | 
56 |   it('renders correctly with no tools', () => {
57 |     const { lastFrame } = render(
58 |       <ToolsList tools={[]} showDescriptions={true} terminalWidth={40} />,
59 |     );
60 |     expect(lastFrame()).toMatchSnapshot();
61 |   });
62 | });
```

src/ui/components/views/ToolsList.tsx
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import type React from 'react';
8 | import { Box, Text } from 'ink';
9 | import { theme } from '../../semantic-colors.js';
10 | import { type ToolDefinition } from '../../types.js';
11 | import { MarkdownDisplay } from '../../utils/MarkdownDisplay.js';
12 | 
13 | interface ToolsListProps {
14 |   tools: readonly ToolDefinition[];
15 |   showDescriptions: boolean;
16 |   terminalWidth: number;
17 | }
18 | 
19 | export const ToolsList: React.FC<ToolsListProps> = ({
20 |   tools,
21 |   showDescriptions,
22 |   terminalWidth,
23 | }) => (
24 |   <Box flexDirection="column" marginBottom={1}>
25 |     <Text bold color={theme.text.primary}>
26 |       Available Gemini CLI tools:
27 |     </Text>
28 |     <Box height={1} />
29 |     {tools.length > 0 ? (
30 |       tools.map((tool) => (
31 |         <Box key={tool.name} flexDirection="row">
32 |           <Text color={theme.text.primary}>{'  '}- </Text>
33 |           <Box flexDirection="column">
34 |             <Text bold color={theme.text.accent}>
35 |               {tool.displayName}
36 |               {showDescriptions ? ` (${tool.name})` : ''}
37 |             </Text>
38 |             {showDescriptions && tool.description && (
39 |               <MarkdownDisplay
40 |                 terminalWidth={terminalWidth}
41 |                 text={tool.description}
42 |                 isPending={false}
43 |               />
44 |             )}
45 |           </Box>
46 |         </Box>
47 |       ))
48 |     ) : (
49 |       <Text color={theme.text.primary}> No tools available</Text>
50 |     )}
51 |   </Box>
52 | );
```

src/ui/utils/__snapshots__/MarkdownDisplay.test.tsx.snap
```
1 | // Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html
2 | 
3 | exports[`<MarkdownDisplay /> > renders a simple paragraph 1`] = `"Hello, world."`;
4 | 
5 | exports[`<MarkdownDisplay /> > renders nothing for empty text 1`] = `""`;
6 | 
7 | exports[`<MarkdownDisplay /> > with 'Unix' line endings > correctly parses a mix of markdown elements 1`] = `
8 | "Main Title
9 | 
10 | Here is a paragraph.
11 | 
12 |  - List item 1
13 |  - List item 2
14 | 
15 |  1 some code
16 | 
17 | Another paragraph.
18 | "
19 | `;
20 | 
21 | exports[`<MarkdownDisplay /> > with 'Unix' line endings > handles a table at the end of the input 1`] = `
22 | "Some text before.
23 | | A | B |
24 | |---|
25 | | 1 | 2 |"
26 | `;
27 | 
28 | exports[`<MarkdownDisplay /> > with 'Unix' line endings > handles unclosed (pending) code blocks 1`] = `" 1 let y = 2;"`;
29 | 
30 | exports[`<MarkdownDisplay /> > with 'Unix' line endings > hides line numbers in code blocks when showLineNumbers is false 1`] = `" const x = 1;"`;
31 | 
32 | exports[`<MarkdownDisplay /> > with 'Unix' line endings > inserts a single space between paragraphs 1`] = `
33 | "Paragraph 1.
34 | 
35 | Paragraph 2."
36 | `;
37 | 
38 | exports[`<MarkdownDisplay /> > with 'Unix' line endings > renders a fenced code block with a language 1`] = `
39 | " 1 const x = 1;
40 |  2 console.log(x);"
41 | `;
42 | 
43 | exports[`<MarkdownDisplay /> > with 'Unix' line endings > renders a fenced code block without a language 1`] = `" 1 plain text"`;
44 | 
45 | exports[`<MarkdownDisplay /> > with 'Unix' line endings > renders headers with correct levels 1`] = `
46 | "Header 1
47 | Header 2
48 | Header 3
49 | Header 4
50 | "
51 | `;
52 | 
53 | exports[`<MarkdownDisplay /> > with 'Unix' line endings > renders horizontal rules 1`] = `
54 | "Hello
55 | ---
56 | World
57 | ---
58 | Test
59 | "
60 | `;
61 | 
62 | exports[`<MarkdownDisplay /> > with 'Unix' line endings > renders nested unordered lists 1`] = `
63 | " * Level 1
64 |    * Level 2
65 |      * Level 3
66 | "
67 | `;
68 | 
69 | exports[`<MarkdownDisplay /> > with 'Unix' line endings > renders ordered lists 1`] = `
70 | " 1. First item
71 |  2. Second item
72 | "
73 | `;
74 | 
75 | exports[`<MarkdownDisplay /> > with 'Unix' line endings > renders tables correctly 1`] = `
76 | "
77 | ┌──────────┬──────────┐
78 | │ Header 1 │ Header 2 │
79 | ├──────────┼──────────┤
80 | │ Cell 1   │ Cell 2   │
81 | │ Cell 3   │ Cell 4   │
82 | └──────────┴──────────┘
83 | "
84 | `;
85 | 
86 | exports[`<MarkdownDisplay /> > with 'Unix' line endings > renders unordered lists with different markers 1`] = `
87 | " - item A
88 |  * item B
89 |  + item C
90 | "
91 | `;
92 | 
93 | exports[`<MarkdownDisplay /> > with 'Unix' line endings > shows line numbers in code blocks by default 1`] = `" 1 const x = 1;"`;
94 | 
95 | exports[`<MarkdownDisplay /> > with 'Windows' line endings > correctly parses a mix of markdown elements 1`] = `
96 | "Main Title
97 | 
98 | Here is a paragraph.
99 | 
100 |  - List item 1
101 |  - List item 2
102 | 
103 |  1 some code
104 | 
105 | Another paragraph.
106 | "
107 | `;
108 | 
109 | exports[`<MarkdownDisplay /> > with 'Windows' line endings > handles a table at the end of the input 1`] = `
110 | "Some text before.
111 | | A | B |
112 | |---|
113 | | 1 | 2 |"
114 | `;
115 | 
116 | exports[`<MarkdownDisplay /> > with 'Windows' line endings > handles unclosed (pending) code blocks 1`] = `" 1 let y = 2;"`;
117 | 
118 | exports[`<MarkdownDisplay /> > with 'Windows' line endings > hides line numbers in code blocks when showLineNumbers is false 1`] = `" const x = 1;"`;
119 | 
120 | exports[`<MarkdownDisplay /> > with 'Windows' line endings > inserts a single space between paragraphs 1`] = `
121 | "Paragraph 1.
122 | 
123 | Paragraph 2."
124 | `;
125 | 
126 | exports[`<MarkdownDisplay /> > with 'Windows' line endings > renders a fenced code block with a language 1`] = `
127 | " 1 const x = 1;
128 |  2 console.log(x);"
129 | `;
130 | 
131 | exports[`<MarkdownDisplay /> > with 'Windows' line endings > renders a fenced code block without a language 1`] = `" 1 plain text"`;
132 | 
133 | exports[`<MarkdownDisplay /> > with 'Windows' line endings > renders headers with correct levels 1`] = `
134 | "Header 1
135 | Header 2
136 | Header 3
137 | Header 4
138 | "
139 | `;
140 | 
141 | exports[`<MarkdownDisplay /> > with 'Windows' line endings > renders horizontal rules 1`] = `
142 | "Hello
143 | ---
144 | World
145 | ---
146 | Test
147 | "
148 | `;
149 | 
150 | exports[`<MarkdownDisplay /> > with 'Windows' line endings > renders nested unordered lists 1`] = `
151 | " * Level 1
152 |    * Level 2
153 |      * Level 3
154 | "
155 | `;
156 | 
157 | exports[`<MarkdownDisplay /> > with 'Windows' line endings > renders ordered lists 1`] = `
158 | " 1. First item
159 |  2. Second item
160 | "
161 | `;
162 | 
163 | exports[`<MarkdownDisplay /> > with 'Windows' line endings > renders tables correctly 1`] = `
164 | "
165 | ┌──────────┬──────────┐
166 | │ Header 1 │ Header 2 │
167 | ├──────────┼──────────┤
168 | │ Cell 1   │ Cell 2   │
169 | │ Cell 3   │ Cell 4   │
170 | └──────────┴──────────┘
171 | "
172 | `;
173 | 
174 | exports[`<MarkdownDisplay /> > with 'Windows' line endings > renders unordered lists with different markers 1`] = `
175 | " - item A
176 |  * item B
177 |  + item C
178 | "
179 | `;
180 | 
181 | exports[`<MarkdownDisplay /> > with 'Windows' line endings > shows line numbers in code blocks by default 1`] = `" 1 const x = 1;"`;
```

src/ui/components/messages/__snapshots__/ToolGroupMessage.test.tsx.snap
```
1 | // Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html
2 | 
3 | exports[`<ToolGroupMessage /> > Border Color Logic > uses gray border when all tools are successful and no shell commands 1`] = `
4 | "╭──────────────────────────────────────────────────────────────────────────────╮
5 | │MockTool[tool-123]: ✓ test-tool - A tool for testing (medium)                 │
6 | │                                                                              │
7 | │MockTool[tool-2]: ✓ another-tool - A tool for testing (medium)                │
8 | ╰──────────────────────────────────────────────────────────────────────────────╯"
9 | `;
10 | 
11 | exports[`<ToolGroupMessage /> > Border Color Logic > uses yellow border for shell commands even when successful 1`] = `
12 | "╭──────────────────────────────────────────────────────────────────────────────╮
13 | │MockTool[tool-123]: ✓ run_shell_command - A tool for testing (medium)         │
14 | ╰──────────────────────────────────────────────────────────────────────────────╯"
15 | `;
16 | 
17 | exports[`<ToolGroupMessage /> > Border Color Logic > uses yellow border when tools are pending 1`] = `
18 | "╭──────────────────────────────────────────────────────────────────────────────╮
19 | │MockTool[tool-123]: o test-tool - A tool for testing (medium)                 │
20 | ╰──────────────────────────────────────────────────────────────────────────────╯"
21 | `;
22 | 
23 | exports[`<ToolGroupMessage /> > Confirmation Handling > shows confirmation dialog for first confirming tool only 1`] = `
24 | "╭──────────────────────────────────────────────────────────────────────────────╮
25 | │MockTool[tool-1]: ? first-confirm - A tool for testing (high)                 │
26 | │MockConfirmation: Confirm first tool                                          │
27 | │                                                                              │
28 | │MockTool[tool-2]: ? second-confirm - A tool for testing (low)                 │
29 | ╰──────────────────────────────────────────────────────────────────────────────╯"
30 | `;
31 | 
32 | exports[`<ToolGroupMessage /> > Golden Snapshots > renders empty tool calls array 1`] = `
33 | "╭──────────────────────────────────────────────────────────────────────────────╮
34 | ╰──────────────────────────────────────────────────────────────────────────────╯"
35 | `;
36 | 
37 | exports[`<ToolGroupMessage /> > Golden Snapshots > renders mixed tool calls including shell command 1`] = `
38 | "╭──────────────────────────────────────────────────────────────────────────────╮
39 | │MockTool[tool-1]: ✓ read_file - Read a file (medium)                          │
40 | │                                                                              │
41 | │MockTool[tool-2]: ⊷ run_shell_command - Run command (medium)                  │
42 | │                                                                              │
43 | │MockTool[tool-3]: o write_file - Write to file (medium)                       │
44 | ╰──────────────────────────────────────────────────────────────────────────────╯"
45 | `;
46 | 
47 | exports[`<ToolGroupMessage /> > Golden Snapshots > renders multiple tool calls with different statuses 1`] = `
48 | "╭──────────────────────────────────────────────────────────────────────────────╮
49 | │MockTool[tool-1]: ✓ successful-tool - This tool succeeded (medium)            │
50 | │                                                                              │
51 | │MockTool[tool-2]: o pending-tool - This tool is pending (medium)              │
52 | │                                                                              │
53 | │MockTool[tool-3]: x error-tool - This tool failed (medium)                    │
54 | ╰──────────────────────────────────────────────────────────────────────────────╯"
55 | `;
56 | 
57 | exports[`<ToolGroupMessage /> > Golden Snapshots > renders shell command with yellow border 1`] = `
58 | "╭──────────────────────────────────────────────────────────────────────────────╮
59 | │MockTool[shell-1]: ✓ run_shell_command - Execute shell command (medium)       │
60 | ╰──────────────────────────────────────────────────────────────────────────────╯"
61 | `;
62 | 
63 | exports[`<ToolGroupMessage /> > Golden Snapshots > renders single successful tool call 1`] = `
64 | "╭──────────────────────────────────────────────────────────────────────────────╮
65 | │MockTool[tool-123]: ✓ test-tool - A tool for testing (medium)                 │
66 | ╰──────────────────────────────────────────────────────────────────────────────╯"
67 | `;
68 | 
69 | exports[`<ToolGroupMessage /> > Golden Snapshots > renders tool call awaiting confirmation 1`] = `
70 | "╭──────────────────────────────────────────────────────────────────────────────╮
71 | │MockTool[tool-confirm]: ? confirmation-tool - This tool needs confirmation    │
72 | │(high)                                                                        │
73 | │MockConfirmation: Are you sure you want to proceed?                           │
74 | ╰──────────────────────────────────────────────────────────────────────────────╯"
75 | `;
76 | 
77 | exports[`<ToolGroupMessage /> > Golden Snapshots > renders when not focused 1`] = `
78 | "╭──────────────────────────────────────────────────────────────────────────────╮
79 | │MockTool[tool-123]: ✓ test-tool - A tool for testing (medium)                 │
80 | ╰──────────────────────────────────────────────────────────────────────────────╯"
81 | `;
82 | 
83 | exports[`<ToolGroupMessage /> > Golden Snapshots > renders with limited terminal height 1`] = `
84 | "╭──────────────────────────────────────────────────────────────────────────────╮
85 | │MockTool[tool-1]: ✓ tool-with-result - Tool with output (medium)              │
86 | │                                                                              │
87 | │MockTool[tool-2]: ✓ another-tool - Another tool (medium)                      │
88 | ╰──────────────────────────────────────────────────────────────────────────────╯"
89 | `;
90 | 
91 | exports[`<ToolGroupMessage /> > Golden Snapshots > renders with narrow terminal width 1`] = `
92 | "╭──────────────────────────────────────╮
93 | │MockTool[tool-123]: ✓                 │
94 | │very-long-tool-name-that-might-wrap - │
95 | │This is a very long description that  │
96 | │might cause wrapping issues (medium)  │
97 | ╰──────────────────────────────────────╯"
98 | `;
99 | 
100 | exports[`<ToolGroupMessage /> > Height Calculation > calculates available height correctly with multiple tools with results 1`] = `
101 | "╭──────────────────────────────────────────────────────────────────────────────╮
102 | │MockTool[tool-1]: ✓ test-tool - A tool for testing (medium)                   │
103 | │                                                                              │
104 | │MockTool[tool-2]: ✓ test-tool - A tool for testing (medium)                   │
105 | │                                                                              │
106 | │MockTool[tool-3]: ✓ test-tool - A tool for testing (medium)                   │
107 | ╰──────────────────────────────────────────────────────────────────────────────╯"
108 | `;
```

src/commands/extensions/examples/context/GEMINI.md
```
1 | # Ink Library Screen Reader Guidance
2 | 
3 | When building custom components, it's important to keep accessibility in mind.
4 | While Ink provides the building blocks, ensuring your components are accessible
5 | will make your CLIs usable by a wider audience.
6 | 
7 | ## General Principles
8 | 
9 | Provide screen reader-friendly output: Use the useIsScreenReaderEnabled hook to
10 | detect if a screen reader is active. You can then render a more descriptive
11 | output for screen reader users. Leverage ARIA props: For components that have a
12 | specific role (e.g., a checkbox or a button), use the aria-role, aria-state, and
13 | aria-label props on <Box> and <Text> to provide semantic meaning to screen
14 | readers.
```

src/commands/extensions/examples/context/gemini-extension.json
```
1 | {
2 |   "name": "context-example",
3 |   "version": "1.0.0"
4 | }
```

src/commands/extensions/examples/custom-commands/gemini-extension.json
```
1 | {
2 |   "name": "custom-commands",
3 |   "version": "1.0.0"
4 | }
```

src/commands/extensions/examples/exclude-tools/gemini-extension.json
```
1 | {
2 |   "name": "excludeTools",
3 |   "version": "1.0.0",
4 |   "excludeTools": ["run_shell_command(rm -rf)"]
5 | }
```

src/commands/extensions/examples/mcp-server/example.ts
```
1 | /**
2 |  * @license
3 |  * Copyright 2025 Google LLC
4 |  * SPDX-License-Identifier: Apache-2.0
5 |  */
6 | 
7 | import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
8 | import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
9 | import { z } from 'zod';
10 | 
11 | const server = new McpServer({
12 |   name: 'prompt-server',
13 |   version: '1.0.0',
14 | });
15 | 
16 | server.registerTool(
17 |   'fetch_posts',
18 |   {
19 |     description: 'Fetches a list of posts from a public API.',
20 |     inputSchema: z.object({}).shape,
21 |   },
22 |   async () => {
23 |     const apiResponse = await fetch(
24 |       'https://jsonplaceholder.typicode.com/posts',
25 |     );
26 |     const posts = await apiResponse.json();
27 |     const response = { posts: posts.slice(0, 5) };
28 |     return {
29 |       content: [
30 |         {
31 |           type: 'text',
32 |           text: JSON.stringify(response),
33 |         },
34 |       ],
35 |     };
36 |   },
37 | );
38 | 
39 | server.registerPrompt(
40 |   'poem-writer',
41 |   {
42 |     title: 'Poem Writer',
43 |     description: 'Write a nice haiku',
44 |     argsSchema: { title: z.string(), mood: z.string().optional() },
45 |   },
46 |   ({ title, mood }) => ({
47 |     messages: [
48 |       {
49 |         role: 'user',
50 |         content: {
51 |           type: 'text',
52 |           text: `Write a haiku${mood ? ` with the mood ${mood}` : ''} called ${title}. Note that a haiku is 5 syllables followed by 7 syllables followed by 5 syllables `,
53 |         },
54 |       },
55 |     ],
56 |   }),
57 | );
58 | 
59 | const transport = new StdioServerTransport();
60 | await server.connect(transport);
```

src/commands/extensions/examples/mcp-server/gemini-extension.json
```
1 | {
2 |   "name": "mcp-server-example",
3 |   "version": "1.0.0",
4 |   "mcpServers": {
5 |     "nodeServer": {
6 |       "command": "node",
7 |       "args": ["${extensionPath}${/}dist${/}example.js"],
8 |       "cwd": "${extensionPath}"
9 |     }
10 |   }
11 | }
```

src/commands/extensions/examples/mcp-server/package.json
```
1 | {
2 |   "name": "mcp-server-example",
3 |   "version": "1.0.0",
4 |   "description": "Example MCP Server for Gemini CLI Extension",
5 |   "type": "module",
6 |   "main": "example.js",
7 |   "scripts": {
8 |     "build": "tsc"
9 |   },
10 |   "devDependencies": {
11 |     "typescript": "~5.4.5",
12 |     "@types/node": "^20.11.25"
13 |   },
14 |   "dependencies": {
15 |     "@modelcontextprotocol/sdk": "^1.11.0",
16 |     "zod": "^3.22.4"
17 |   }
18 | }
```

src/commands/extensions/examples/mcp-server/tsconfig.json
```
1 | {
2 |   "compilerOptions": {
3 |     "target": "ES2022",
4 |     "module": "NodeNext",
5 |     "moduleResolution": "NodeNext",
6 |     "strict": true,
7 |     "esModuleInterop": true,
8 |     "skipLibCheck": true,
9 |     "forceConsistentCasingInFileNames": true,
10 |     "outDir": "./dist"
11 |   },
12 |   "include": ["example.ts"]
13 | }
```

src/ui/components/views/__snapshots__/ChatList.test.tsx.snap
```
1 | // Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html
2 | 
3 | exports[`<ChatList /> > handles invalid date formats gracefully 1`] = `
4 | "List of saved conversations:
5 | 
6 |   - bad-date-chat (Invalid Date)
7 | 
8 | Note: Newest last, oldest first"
9 | `;
10 | 
11 | exports[`<ChatList /> > renders correctly with a list of chats 1`] = `
12 | "List of saved conversations:
13 | 
14 |   - chat-1 (2025-10-02 10:00:00)
15 |   - another-chat (2025-10-01 12:30:00)
16 | 
17 | Note: Newest last, oldest first"
18 | `;
19 | 
20 | exports[`<ChatList /> > renders correctly with no chats 1`] = `"No saved conversation checkpoints found."`;
```

src/ui/components/views/__snapshots__/McpStatus.test.tsx.snap
```
1 | // Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html
2 | 
3 | exports[`McpStatus > renders correctly when discovery is in progress 1`] = `
4 | "⏳ MCP servers are starting up (0 initializing)...
5 | Note: First startup may take longer. Tool availability will update automatically.
6 | 
7 | Configured MCP servers:
8 | 
9 | 🟢 server-1 - Ready (1 tool)
10 | A test server
11 |   Tools:
12 |   - tool-1
13 |     A test tool
14 | "
15 | `;
16 | 
17 | exports[`McpStatus > renders correctly with a blocked server 1`] = `
18 | "Configured MCP servers:
19 | 
20 | 🟢 server-1 - Ready (1 tool)
21 | A test server
22 |   Tools:
23 |   - tool-1
24 |     A test tool
25 | 
26 | 🔴 server-1 (from test-extension) - Blocked
27 | "
28 | `;
29 | 
30 | exports[`McpStatus > renders correctly with a connected server 1`] = `
31 | "Configured MCP servers:
32 | 
33 | 🟢 server-1 - Ready (1 tool)
34 | A test server
35 |   Tools:
36 |   - tool-1
37 |     A test tool
38 | "
39 | `;
40 | 
41 | exports[`McpStatus > renders correctly with a connecting server 1`] = `
42 | "Configured MCP servers:
43 | 
44 | 🟢 server-1 - Ready (1 tool)
45 | A test server
46 |   Tools:
47 |   - tool-1
48 |     A test tool
49 | "
50 | `;
51 | 
52 | exports[`McpStatus > renders correctly with a disconnected server 1`] = `
53 | "Configured MCP servers:
54 | 
55 | 🟢 server-1 - Ready (1 tool)
56 | A test server
57 |   Tools:
58 |   - tool-1
59 |     A test tool
60 | "
61 | `;
62 | 
63 | exports[`McpStatus > renders correctly with authenticated OAuth status 1`] = `
64 | "Configured MCP servers:
65 | 
66 | 🟢 server-1 - Ready (1 tool) (OAuth)
67 | A test server
68 |   Tools:
69 |   - tool-1
70 |     A test tool
71 | "
72 | `;
73 | 
74 | exports[`McpStatus > renders correctly with expired OAuth status 1`] = `
75 | "Configured MCP servers:
76 | 
77 | 🟢 server-1 - Ready (1 tool) (OAuth expired)
78 | A test server
79 |   Tools:
80 |   - tool-1
81 |     A test tool
82 | "
83 | `;
84 | 
85 | exports[`McpStatus > renders correctly with parametersJsonSchema 1`] = `
86 | "Configured MCP servers:
87 | 
88 | 🟢 server-1 - Ready (1 tool)
89 | A test server
90 |   Tools:
91 |   - tool-1
92 |     A test tool
93 |       Parameters:
94 |       {
95 |         "type": "object",
96 |         "properties": {
97 |           "param1": {
98 |             "type": "string"
99 |           }
100 |         }
101 |       }
102 | "
103 | `;
104 | 
105 | exports[`McpStatus > renders correctly with prompts 1`] = `
106 | "Configured MCP servers:
107 | 
108 | 🟢 server-1 - Ready (1 tool, 1 prompt)
109 | A test server
110 |   Tools:
111 |   - tool-1
112 |     A test tool
113 |   Prompts:
114 |   - prompt-1
115 |     A test prompt
116 | "
117 | `;
118 | 
119 | exports[`McpStatus > renders correctly with schema enabled 1`] = `
120 | "Configured MCP servers:
121 | 
122 | 🟢 server-1 - Ready (1 tool)
123 | A test server
124 |   Tools:
125 |   - tool-1
126 |     A test tool
127 |       Parameters:
128 |       {
129 |         "type": "object",
130 |         "properties": {
131 |           "param1": {
132 |             "type": "string"
133 |           }
134 |         }
135 |       }
136 | "
137 | `;
138 | 
139 | exports[`McpStatus > renders correctly with tips enabled 1`] = `
140 | "Configured MCP servers:
141 | 
142 | 🟢 server-1 - Ready (1 tool)
143 | A test server
144 |   Tools:
145 |   - tool-1
146 |     A test tool
147 | 
148 | 
149 | 💡 Tips:
150 |   - Use /mcp desc to show server and tool descriptions
151 |   - Use /mcp schema to show tool parameter schemas
152 |   - Use /mcp nodesc to hide descriptions
153 |   - Use /mcp auth <server-name> to authenticate with OAuth-enabled servers
154 |   - Press Ctrl+T to toggle tool descriptions on/off"
155 | `;
156 | 
157 | exports[`McpStatus > renders correctly with unauthenticated OAuth status 1`] = `
158 | "Configured MCP servers:
159 | 
160 | 🟢 server-1 - Ready (1 tool) (OAuth not authenticated)
161 | A test server
162 |   Tools:
163 |   - tool-1
164 |     A test tool
165 | "
166 | `;
```

src/ui/components/views/__snapshots__/ToolsList.test.tsx.snap
```
1 | // Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html
2 | 
3 | exports[`<ToolsList /> > renders correctly with descriptions 1`] = `
4 | "Available Gemini CLI tools:
5 | 
6 |   - Test Tool One (test-tool-one)
7 |     This is the first test tool.
8 |   - Test Tool Two (test-tool-two)
9 |     This is the second test tool.
10 |        1. Tool descriptions support markdown formatting.
11 |        2. note use this tool wisely and be sure to consider how this tool interacts with word wrap.
12 |        3. important this tool is awesome.
13 |   - Test Tool Three (test-tool-three)
14 |     This is the third test tool.
15 | "
16 | `;
17 | 
18 | exports[`<ToolsList /> > renders correctly with no tools 1`] = `
19 | "Available Gemini CLI tools:
20 | 
21 |  No tools available
22 | "
23 | `;
24 | 
25 | exports[`<ToolsList /> > renders correctly without descriptions 1`] = `
26 | "Available Gemini CLI tools:
27 | 
28 |   - Test Tool One
29 |   - Test Tool Two
30 |   - Test Tool Three
31 | "
32 | `;
```

src/ui/components/shared/__snapshots__/DescriptiveRadioButtonSelect.test.tsx.snap
```
1 | // Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html
2 | 
3 | exports[`DescriptiveRadioButtonSelect > should render correctly with custom props 1`] = `
4 | "▲
5 |   1. Foo Title
6 |      This is Foo.
7 | ● 2. Bar Title
8 |      This is Bar.
9 |   3. Baz Title
10 |      This is Baz.
11 | ▼"
12 | `;
13 | 
14 | exports[`DescriptiveRadioButtonSelect > should render correctly with default props 1`] = `
15 | "● Foo Title
16 |   This is Foo.
17 |   Bar Title
18 |   This is Bar.
19 |   Baz Title
20 |   This is Baz."
21 | `;
```

src/ui/components/shared/__snapshots__/EnumSelector.test.tsx.snap
```
1 | // Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html
2 | 
3 | exports[`<EnumSelector /> > renders inactive state and matches snapshot 1`] = `"← 中文 (简体) →"`;
4 | 
5 | exports[`<EnumSelector /> > renders with numeric options and matches snapshot 1`] = `"← Medium →"`;
6 | 
7 | exports[`<EnumSelector /> > renders with single option and matches snapshot 1`] = `"  Only Option"`;
8 | 
9 | exports[`<EnumSelector /> > renders with string options and matches snapshot 1`] = `"← English →"`;
```

src/commands/extensions/examples/custom-commands/commands/fs/grep-code.toml
```
1 | prompt = """
2 | Please summarize the findings for the pattern `{{args}}`.
3 | 
4 | Search Results:
5 | !{grep -r {{args}} .}
6 | """
```
